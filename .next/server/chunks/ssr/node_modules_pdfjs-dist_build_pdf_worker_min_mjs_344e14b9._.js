module.exports = {

"[project]/node_modules/pdfjs-dist/build/pdf.worker.min.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */ __turbopack_context__.s({
    "WorkerMessageHandler": (()=>Qg)
});
var e1 = {
    d: (t, i)=>{
        for(var a in i)e1.o(i, a) && !e1.o(t, a) && Object.defineProperty(t, a, {
            enumerable: !0,
            get: i[a]
        });
    },
    o: (e1, t)=>Object.prototype.hasOwnProperty.call(e1, t)
}, __webpack_exports__ = globalThis.pdfjsWorker = {};
e1.d(__webpack_exports__, {
    WorkerMessageHandler: ()=>WorkerMessageHandler
});
const t = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type), i = [
    1,
    0,
    0,
    1,
    0,
    0
], a = [
    .001,
    0,
    0,
    .001,
    0,
    0
], s = 1.35, r = .35, n = .25925925925925924, g = 1, o = 2, c = 4, C = 8, h = 16, l = 64, Q = 128, E = 256, u = "pdfjs_internal_editor_", d = 3, f = 9, p = 13, m = 15, y = {
    PRINT: 4,
    MODIFY_CONTENTS: 8,
    COPY: 16,
    MODIFY_ANNOTATIONS: 32,
    FILL_INTERACTIVE_FORMS: 256,
    COPY_FOR_ACCESSIBILITY: 512,
    ASSEMBLE: 1024,
    PRINT_HIGH_QUALITY: 2048
}, w = 0, D = 4, b = 1, F = 2, S = 3, k = 1, R = 2, N = 3, G = 4, M = 5, U = 6, x = 7, L = 8, H = 9, J = 10, Y = 11, v = 12, K = 13, T = 14, q = 15, O = 16, W = 17, j = 20, X = "Group", Z = "R", V = 1, z = 2, _ = 4, $ = 16, AA = 32, eA = 128, tA = 512, iA = 1, aA = 2, sA = 4096, rA = 8192, nA = 32768, gA = 65536, oA = 131072, IA = 1048576, cA = 2097152, CA = 8388608, hA = 16777216, lA = 1, BA = 2, QA = 3, EA = 4, uA = 5, dA = {
    E: "Mouse Enter",
    X: "Mouse Exit",
    D: "Mouse Down",
    U: "Mouse Up",
    Fo: "Focus",
    Bl: "Blur",
    PO: "PageOpen",
    PC: "PageClose",
    PV: "PageVisible",
    PI: "PageInvisible",
    K: "Keystroke",
    F: "Format",
    V: "Validate",
    C: "Calculate"
}, fA = {
    WC: "WillClose",
    WS: "WillSave",
    DS: "DidSave",
    WP: "WillPrint",
    DP: "DidPrint"
}, pA = {
    O: "PageOpen",
    C: "PageClose"
}, mA = 1, yA = 5, wA = 1, DA = 2, bA = 3, FA = 4, SA = 5, kA = 6, RA = 7, NA = 8, GA = 9, MA = 10, UA = 11, xA = 12, LA = 13, HA = 14, JA = 15, YA = 16, vA = 17, KA = 18, TA = 19, qA = 20, OA = 21, PA = 22, WA = 23, jA = 24, XA = 25, ZA = 26, VA = 27, zA = 28, _A = 29, $A = 30, Ae = 31, ee = 32, te = 33, ie = 34, ae = 35, se = 36, re = 37, ne = 38, ge = 39, oe = 40, Ie = 41, ce = 42, Ce = 43, he = 44, le = 45, Be = 46, Qe = 47, Ee = 48, ue = 49, de = 50, fe = 51, pe = 52, me = 53, ye = 54, we = 55, De = 56, be = 57, Fe = 58, Se = 59, ke = 60, Re = 61, Ne = 62, Ge = 63, Me = 64, Ue = 65, xe = 66, Le = 67, He = 68, Je = 69, Ye = 70, ve = 71, Ke = 72, Te = 73, qe = 74, Oe = 75, Pe = 76, We = 77, je = 80, Xe = 81, Ze = 83, Ve = 84, ze = 85, _e = 86, $e = 87, At = 88, et = 89, tt = 90, it = 91, at = 92, st = 93, rt = 1, nt = 2;
let gt = mA;
function getVerbosityLevel() {
    return gt;
}
function info(e1) {
    gt >= yA && console.log(`Info: ${e1}`);
}
function warn(e1) {
    gt >= mA && console.log(`Warning: ${e1}`);
}
function unreachable(e1) {
    throw new Error(e1);
}
function assert(e1, t) {
    e1 || unreachable(t);
}
function createValidAbsoluteUrl(e1, t = null, i = null) {
    if (!e1) return null;
    try {
        if (i && "string" == typeof e1) {
            if (i.addDefaultProtocol && e1.startsWith("www.")) {
                const t = e1.match(/\./g);
                t?.length >= 2 && (e1 = `http://${e1}`);
            }
            if (i.tryConvertEncoding) try {
                e1 = stringToUTF8String(e1);
            } catch  {}
        }
        const a = t ? new URL(e1, t) : new URL(e1);
        if (function _isValidProtocol(e1) {
            switch(e1?.protocol){
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                    return !0;
                default:
                    return !1;
            }
        }(a)) return a;
    } catch  {}
    return null;
}
function shadow(e1, t, i, a = !1) {
    Object.defineProperty(e1, t, {
        value: i,
        enumerable: !a,
        configurable: !0,
        writable: !1
    });
    return i;
}
const ot = function BaseExceptionClosure() {
    function BaseException(e1, t) {
        this.message = e1;
        this.name = t;
    }
    BaseException.prototype = new Error;
    BaseException.constructor = BaseException;
    return BaseException;
}();
class PasswordException extends ot {
    constructor(e1, t){
        super(e1, "PasswordException");
        this.code = t;
    }
}
class UnknownErrorException extends ot {
    constructor(e1, t){
        super(e1, "UnknownErrorException");
        this.details = t;
    }
}
class InvalidPDFException extends ot {
    constructor(e1){
        super(e1, "InvalidPDFException");
    }
}
class MissingPDFException extends ot {
    constructor(e1){
        super(e1, "MissingPDFException");
    }
}
class UnexpectedResponseException extends ot {
    constructor(e1, t){
        super(e1, "UnexpectedResponseException");
        this.status = t;
    }
}
class FormatError extends ot {
    constructor(e1){
        super(e1, "FormatError");
    }
}
class AbortException extends ot {
    constructor(e1){
        super(e1, "AbortException");
    }
}
function bytesToString(e1) {
    "object" == typeof e1 && void 0 !== e1?.length || unreachable("Invalid argument for bytesToString");
    const t = e1.length, i = 8192;
    if (t < i) return String.fromCharCode.apply(null, e1);
    const a = [];
    for(let s = 0; s < t; s += i){
        const r = Math.min(s + i, t), n = e1.subarray(s, r);
        a.push(String.fromCharCode.apply(null, n));
    }
    return a.join("");
}
function stringToBytes(e1) {
    "string" != typeof e1 && unreachable("Invalid argument for stringToBytes");
    const t = e1.length, i = new Uint8Array(t);
    for(let a = 0; a < t; ++a)i[a] = 255 & e1.charCodeAt(a);
    return i;
}
function string32(e1) {
    return String.fromCharCode(e1 >> 24 & 255, e1 >> 16 & 255, e1 >> 8 & 255, 255 & e1);
}
function objectSize(e1) {
    return Object.keys(e1).length;
}
class FeatureTest {
    static get isLittleEndian() {
        return shadow(this, "isLittleEndian", function isLittleEndian() {
            const e1 = new Uint8Array(4);
            e1[0] = 1;
            return 1 === new Uint32Array(e1.buffer, 0, 1)[0];
        }());
    }
    static get isEvalSupported() {
        return shadow(this, "isEvalSupported", function isEvalSupported() {
            try {
                new Function("");
                return !0;
            } catch  {
                return !1;
            }
        }());
    }
    static get isOffscreenCanvasSupported() {
        return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
    }
    static get isImageDecoderSupported() {
        return shadow(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
    }
    static get platform() {
        return "undefined" != typeof navigator && "string" == typeof navigator?.platform ? shadow(this, "platform", {
            isMac: navigator.platform.includes("Mac"),
            isWindows: navigator.platform.includes("Win"),
            isFirefox: "string" == typeof navigator?.userAgent && navigator.userAgent.includes("Firefox")
        }) : shadow(this, "platform", {
            isMac: !1,
            isWindows: !1,
            isFirefox: !1
        });
    }
    static get isCSSRoundSupported() {
        return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
    }
}
const It = Array.from(Array(256).keys(), (e1)=>e1.toString(16).padStart(2, "0"));
class Util {
    static makeHexColor(e1, t, i) {
        return `#${It[e1]}${It[t]}${It[i]}`;
    }
    static scaleMinMax(e1, t) {
        let i;
        if (e1[0]) {
            if (e1[0] < 0) {
                i = t[0];
                t[0] = t[2];
                t[2] = i;
            }
            t[0] *= e1[0];
            t[2] *= e1[0];
            if (e1[3] < 0) {
                i = t[1];
                t[1] = t[3];
                t[3] = i;
            }
            t[1] *= e1[3];
            t[3] *= e1[3];
        } else {
            i = t[0];
            t[0] = t[1];
            t[1] = i;
            i = t[2];
            t[2] = t[3];
            t[3] = i;
            if (e1[1] < 0) {
                i = t[1];
                t[1] = t[3];
                t[3] = i;
            }
            t[1] *= e1[1];
            t[3] *= e1[1];
            if (e1[2] < 0) {
                i = t[0];
                t[0] = t[2];
                t[2] = i;
            }
            t[0] *= e1[2];
            t[2] *= e1[2];
        }
        t[0] += e1[4];
        t[1] += e1[5];
        t[2] += e1[4];
        t[3] += e1[5];
    }
    static transform(e1, t) {
        return [
            e1[0] * t[0] + e1[2] * t[1],
            e1[1] * t[0] + e1[3] * t[1],
            e1[0] * t[2] + e1[2] * t[3],
            e1[1] * t[2] + e1[3] * t[3],
            e1[0] * t[4] + e1[2] * t[5] + e1[4],
            e1[1] * t[4] + e1[3] * t[5] + e1[5]
        ];
    }
    static applyTransform(e1, t) {
        return [
            e1[0] * t[0] + e1[1] * t[2] + t[4],
            e1[0] * t[1] + e1[1] * t[3] + t[5]
        ];
    }
    static applyInverseTransform(e1, t) {
        const i = t[0] * t[3] - t[1] * t[2];
        return [
            (e1[0] * t[3] - e1[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / i,
            (-e1[0] * t[1] + e1[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / i
        ];
    }
    static getAxialAlignedBoundingBox(e1, t) {
        const i = this.applyTransform(e1, t), a = this.applyTransform(e1.slice(2, 4), t), s = this.applyTransform([
            e1[0],
            e1[3]
        ], t), r = this.applyTransform([
            e1[2],
            e1[1]
        ], t);
        return [
            Math.min(i[0], a[0], s[0], r[0]),
            Math.min(i[1], a[1], s[1], r[1]),
            Math.max(i[0], a[0], s[0], r[0]),
            Math.max(i[1], a[1], s[1], r[1])
        ];
    }
    static inverseTransform(e1) {
        const t = e1[0] * e1[3] - e1[1] * e1[2];
        return [
            e1[3] / t,
            -e1[1] / t,
            -e1[2] / t,
            e1[0] / t,
            (e1[2] * e1[5] - e1[4] * e1[3]) / t,
            (e1[4] * e1[1] - e1[5] * e1[0]) / t
        ];
    }
    static singularValueDecompose2dScale(e1) {
        const t = [
            e1[0],
            e1[2],
            e1[1],
            e1[3]
        ], i = e1[0] * t[0] + e1[1] * t[2], a = e1[0] * t[1] + e1[1] * t[3], s = e1[2] * t[0] + e1[3] * t[2], r = e1[2] * t[1] + e1[3] * t[3], n = (i + r) / 2, g = Math.sqrt((i + r) ** 2 - 4 * (i * r - s * a)) / 2, o = n + g || 1, c = n - g || 1;
        return [
            Math.sqrt(o),
            Math.sqrt(c)
        ];
    }
    static normalizeRect(e1) {
        const t = e1.slice(0);
        if (e1[0] > e1[2]) {
            t[0] = e1[2];
            t[2] = e1[0];
        }
        if (e1[1] > e1[3]) {
            t[1] = e1[3];
            t[3] = e1[1];
        }
        return t;
    }
    static intersect(e1, t) {
        const i = Math.max(Math.min(e1[0], e1[2]), Math.min(t[0], t[2])), a = Math.min(Math.max(e1[0], e1[2]), Math.max(t[0], t[2]));
        if (i > a) return null;
        const s = Math.max(Math.min(e1[1], e1[3]), Math.min(t[1], t[3])), r = Math.min(Math.max(e1[1], e1[3]), Math.max(t[1], t[3]));
        return s > r ? null : [
            i,
            s,
            a,
            r
        ];
    }
    static #A(e1, t, i, a, s, r, n, g, o, c) {
        if (o <= 0 || o >= 1) return;
        const C = 1 - o, h = o * o, l = h * o, Q = C * (C * (C * e1 + 3 * o * t) + 3 * h * i) + l * a, E = C * (C * (C * s + 3 * o * r) + 3 * h * n) + l * g;
        c[0] = Math.min(c[0], Q);
        c[1] = Math.min(c[1], E);
        c[2] = Math.max(c[2], Q);
        c[3] = Math.max(c[3], E);
    }
    static #e(e1, t, i, a, s, r, n, g, o, c, C, h) {
        if (Math.abs(o) < 1e-12) {
            Math.abs(c) >= 1e-12 && this.#A(e1, t, i, a, s, r, n, g, -C / c, h);
            return;
        }
        const l = c ** 2 - 4 * C * o;
        if (l < 0) return;
        const Q = Math.sqrt(l), E = 2 * o;
        this.#A(e1, t, i, a, s, r, n, g, (-c + Q) / E, h);
        this.#A(e1, t, i, a, s, r, n, g, (-c - Q) / E, h);
    }
    static bezierBoundingBox(e1, t, i, a, s, r, n, g, o) {
        if (o) {
            o[0] = Math.min(o[0], e1, n);
            o[1] = Math.min(o[1], t, g);
            o[2] = Math.max(o[2], e1, n);
            o[3] = Math.max(o[3], t, g);
        } else o = [
            Math.min(e1, n),
            Math.min(t, g),
            Math.max(e1, n),
            Math.max(t, g)
        ];
        this.#e(e1, i, s, n, t, a, r, g, 3 * (3 * (i - s) - e1 + n), 6 * (e1 - 2 * i + s), 3 * (i - e1), o);
        this.#e(e1, i, s, n, t, a, r, g, 3 * (3 * (a - r) - t + g), 6 * (t - 2 * a + r), 3 * (a - t), o);
        return o;
    }
}
const ct = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    728,
    711,
    710,
    729,
    733,
    731,
    730,
    732,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8226,
    8224,
    8225,
    8230,
    8212,
    8211,
    402,
    8260,
    8249,
    8250,
    8722,
    8240,
    8222,
    8220,
    8221,
    8216,
    8217,
    8218,
    8482,
    64257,
    64258,
    321,
    338,
    352,
    376,
    381,
    305,
    322,
    339,
    353,
    382,
    0,
    8364
];
function stringToPDFString(e1) {
    if (e1[0] >= "Ã¯") {
        let t;
        if ("Ã¾" === e1[0] && "Ã¿" === e1[1]) {
            t = "utf-16be";
            e1.length % 2 == 1 && (e1 = e1.slice(0, -1));
        } else if ("Ã¿" === e1[0] && "Ã¾" === e1[1]) {
            t = "utf-16le";
            e1.length % 2 == 1 && (e1 = e1.slice(0, -1));
        } else "Ã¯" === e1[0] && "Â»" === e1[1] && "Â¿" === e1[2] && (t = "utf-8");
        if (t) try {
            const i = new TextDecoder(t, {
                fatal: !0
            }), a = stringToBytes(e1), s = i.decode(a);
            return s.includes("") ? s.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "") : s;
        } catch (e1) {
            warn(`stringToPDFString: "${e1}".`);
        }
    }
    const t = [];
    for(let i = 0, a = e1.length; i < a; i++){
        const s = e1.charCodeAt(i);
        if (27 === s) {
            for(; ++i < a && 27 !== e1.charCodeAt(i););
            continue;
        }
        const r = ct[s];
        t.push(r ? String.fromCharCode(r) : e1.charAt(i));
    }
    return t.join("");
}
function stringToUTF8String(e1) {
    return decodeURIComponent(escape(e1));
}
function utf8StringToString(e1) {
    return unescape(encodeURIComponent(e1));
}
function isArrayEqual(e1, t) {
    if (e1.length !== t.length) return !1;
    for(let i = 0, a = e1.length; i < a; i++)if (e1[i] !== t[i]) return !1;
    return !0;
}
function getModificationDate(e1 = new Date) {
    return [
        e1.getUTCFullYear().toString(),
        (e1.getUTCMonth() + 1).toString().padStart(2, "0"),
        e1.getUTCDate().toString().padStart(2, "0"),
        e1.getUTCHours().toString().padStart(2, "0"),
        e1.getUTCMinutes().toString().padStart(2, "0"),
        e1.getUTCSeconds().toString().padStart(2, "0")
    ].join("");
}
let Ct = null, ht = null;
function toHexUtil(e1) {
    return Uint8Array.prototype.toHex ? e1.toHex() : Array.from(e1, (e1)=>It[e1]).join("");
}
"function" != typeof Promise.try && (Promise.try = function(e1, ...t) {
    return new Promise((i)=>{
        i(e1(...t));
    });
});
const lt = Symbol("CIRCULAR_REF"), Bt = Symbol("EOF");
let Qt = Object.create(null), Et = Object.create(null), ut = Object.create(null);
class Name {
    constructor(e1){
        this.name = e1;
    }
    static get(e1) {
        return Et[e1] ||= new Name(e1);
    }
}
class Cmd {
    constructor(e1){
        this.cmd = e1;
    }
    static get(e1) {
        return Qt[e1] ||= new Cmd(e1);
    }
}
const dt = function nonSerializableClosure() {
    return dt;
};
class Dict {
    constructor(e1 = null){
        this._map = new Map;
        this.xref = e1;
        this.objId = null;
        this.suppressEncryption = !1;
        this.__nonSerializable__ = dt;
    }
    assignXref(e1) {
        this.xref = e1;
    }
    get size() {
        return this._map.size;
    }
    get(e1, t, i) {
        let a = this._map.get(e1);
        if (void 0 === a && void 0 !== t) {
            a = this._map.get(t);
            void 0 === a && void 0 !== i && (a = this._map.get(i));
        }
        return a instanceof Ref && this.xref ? this.xref.fetch(a, this.suppressEncryption) : a;
    }
    async getAsync(e1, t, i) {
        let a = this._map.get(e1);
        if (void 0 === a && void 0 !== t) {
            a = this._map.get(t);
            void 0 === a && void 0 !== i && (a = this._map.get(i));
        }
        return a instanceof Ref && this.xref ? this.xref.fetchAsync(a, this.suppressEncryption) : a;
    }
    getArray(e1, t, i) {
        let a = this._map.get(e1);
        if (void 0 === a && void 0 !== t) {
            a = this._map.get(t);
            void 0 === a && void 0 !== i && (a = this._map.get(i));
        }
        a instanceof Ref && this.xref && (a = this.xref.fetch(a, this.suppressEncryption));
        if (Array.isArray(a)) {
            a = a.slice();
            for(let e1 = 0, t = a.length; e1 < t; e1++)a[e1] instanceof Ref && this.xref && (a[e1] = this.xref.fetch(a[e1], this.suppressEncryption));
        }
        return a;
    }
    getRaw(e1) {
        return this._map.get(e1);
    }
    getKeys() {
        return [
            ...this._map.keys()
        ];
    }
    getRawValues() {
        return [
            ...this._map.values()
        ];
    }
    set(e1, t) {
        this._map.set(e1, t);
    }
    has(e1) {
        return this._map.has(e1);
    }
    *[Symbol.iterator]() {
        for (const [e1, t] of this._map)yield [
            e1,
            t instanceof Ref && this.xref ? this.xref.fetch(t, this.suppressEncryption) : t
        ];
    }
    static get empty() {
        const e1 = new Dict(null);
        e1.set = (e1, t)=>{
            unreachable("Should not call `set` on the empty dictionary.");
        };
        return shadow(this, "empty", e1);
    }
    static merge({ xref: e1, dictArray: t, mergeSubDicts: i = !1 }) {
        const a = new Dict(e1), s = new Map;
        for (const e1 of t)if (e1 instanceof Dict) for (const [t, a] of e1._map){
            let e1 = s.get(t);
            if (void 0 === e1) {
                e1 = [];
                s.set(t, e1);
            } else if (!(i && a instanceof Dict)) continue;
            e1.push(a);
        }
        for (const [t, i] of s){
            if (1 === i.length || !(i[0] instanceof Dict)) {
                a._map.set(t, i[0]);
                continue;
            }
            const s = new Dict(e1);
            for (const e1 of i)for (const [t, i] of e1._map)s._map.has(t) || s._map.set(t, i);
            s.size > 0 && a._map.set(t, s);
        }
        s.clear();
        return a.size > 0 ? a : Dict.empty;
    }
    clone() {
        const e1 = new Dict(this.xref);
        for (const t of this.getKeys())e1.set(t, this.getRaw(t));
        return e1;
    }
    delete(e1) {
        delete this._map[e1];
    }
}
class Ref {
    constructor(e1, t){
        this.num = e1;
        this.gen = t;
    }
    toString() {
        return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
    }
    static fromString(e1) {
        const t = ut[e1];
        if (t) return t;
        const i = /^(\d+)R(\d*)$/.exec(e1);
        return i && "0" !== i[1] ? ut[e1] = new Ref(parseInt(i[1]), i[2] ? parseInt(i[2]) : 0) : null;
    }
    static get(e1, t) {
        const i = 0 === t ? `${e1}R` : `${e1}R${t}`;
        return ut[i] ||= new Ref(e1, t);
    }
}
class RefSet {
    constructor(e1 = null){
        this._set = new Set(e1?._set);
    }
    has(e1) {
        return this._set.has(e1.toString());
    }
    put(e1) {
        this._set.add(e1.toString());
    }
    remove(e1) {
        this._set.delete(e1.toString());
    }
    [Symbol.iterator]() {
        return this._set.values();
    }
    clear() {
        this._set.clear();
    }
}
class RefSetCache {
    constructor(){
        this._map = new Map;
    }
    get size() {
        return this._map.size;
    }
    get(e1) {
        return this._map.get(e1.toString());
    }
    has(e1) {
        return this._map.has(e1.toString());
    }
    put(e1, t) {
        this._map.set(e1.toString(), t);
    }
    putAlias(e1, t) {
        this._map.set(e1.toString(), this.get(t));
    }
    [Symbol.iterator]() {
        return this._map.values();
    }
    clear() {
        this._map.clear();
    }
    *values() {
        yield* this._map.values();
    }
    *items() {
        for (const [e1, t] of this._map)yield [
            Ref.fromString(e1),
            t
        ];
    }
}
function isName(e1, t) {
    return e1 instanceof Name && (void 0 === t || e1.name === t);
}
function isCmd(e1, t) {
    return e1 instanceof Cmd && (void 0 === t || e1.cmd === t);
}
function isDict(e1, t) {
    return e1 instanceof Dict && (void 0 === t || isName(e1.get("Type"), t));
}
function isRefsEqual(e1, t) {
    return e1.num === t.num && e1.gen === t.gen;
}
class BaseStream {
    get length() {
        unreachable("Abstract getter `length` accessed");
    }
    get isEmpty() {
        unreachable("Abstract getter `isEmpty` accessed");
    }
    get isDataLoaded() {
        return shadow(this, "isDataLoaded", !0);
    }
    getByte() {
        unreachable("Abstract method `getByte` called");
    }
    getBytes(e1) {
        unreachable("Abstract method `getBytes` called");
    }
    async getImageData(e1, t) {
        return this.getBytes(e1, t);
    }
    async asyncGetBytes() {
        unreachable("Abstract method `asyncGetBytes` called");
    }
    get isAsync() {
        return !1;
    }
    get canAsyncDecodeImageFromBuffer() {
        return !1;
    }
    async getTransferableImage() {
        return null;
    }
    peekByte() {
        const e1 = this.getByte();
        -1 !== e1 && this.pos--;
        return e1;
    }
    peekBytes(e1) {
        const t = this.getBytes(e1);
        this.pos -= t.length;
        return t;
    }
    getUint16() {
        const e1 = this.getByte(), t = this.getByte();
        return -1 === e1 || -1 === t ? -1 : (e1 << 8) + t;
    }
    getInt32() {
        return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
    }
    getByteRange(e1, t) {
        unreachable("Abstract method `getByteRange` called");
    }
    getString(e1) {
        return bytesToString(this.getBytes(e1));
    }
    skip(e1) {
        this.pos += e1 || 1;
    }
    reset() {
        unreachable("Abstract method `reset` called");
    }
    moveStart() {
        unreachable("Abstract method `moveStart` called");
    }
    makeSubStream(e1, t, i = null) {
        unreachable("Abstract method `makeSubStream` called");
    }
    getBaseStreams() {
        return null;
    }
}
const ft = /^[1-9]\.\d$/, pt = 2 ** 31 - 1;
function getLookupTableFactory(e1) {
    let t;
    return function() {
        if (e1) {
            t = Object.create(null);
            e1(t);
            e1 = null;
        }
        return t;
    };
}
class MissingDataException extends ot {
    constructor(e1, t){
        super(`Missing data [${e1}, ${t})`, "MissingDataException");
        this.begin = e1;
        this.end = t;
    }
}
class ParserEOFException extends ot {
    constructor(e1){
        super(e1, "ParserEOFException");
    }
}
class XRefEntryException extends ot {
    constructor(e1){
        super(e1, "XRefEntryException");
    }
}
class XRefParseException extends ot {
    constructor(e1){
        super(e1, "XRefParseException");
    }
}
function arrayBuffersToBytes(e1) {
    const t = e1.length;
    if (0 === t) return new Uint8Array(0);
    if (1 === t) return new Uint8Array(e1[0]);
    let i = 0;
    for(let a = 0; a < t; a++)i += e1[a].byteLength;
    const a = new Uint8Array(i);
    let s = 0;
    for(let i = 0; i < t; i++){
        const t = new Uint8Array(e1[i]);
        a.set(t, s);
        s += t.byteLength;
    }
    return a;
}
function getInheritableProperty({ dict: e1, key: t, getArray: i = !1, stopWhenFound: a = !0 }) {
    let s;
    const r = new RefSet;
    for(; e1 instanceof Dict && (!e1.objId || !r.has(e1.objId));){
        e1.objId && r.put(e1.objId);
        const n = i ? e1.getArray(t) : e1.get(t);
        if (void 0 !== n) {
            if (a) return n;
            (s ||= []).push(n);
        }
        e1 = e1.get("Parent");
    }
    return s;
}
const mt = [
    "",
    "C",
    "CC",
    "CCC",
    "CD",
    "D",
    "DC",
    "DCC",
    "DCCC",
    "CM",
    "",
    "X",
    "XX",
    "XXX",
    "XL",
    "L",
    "LX",
    "LXX",
    "LXXX",
    "XC",
    "",
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX"
];
function toRomanNumerals(e1, t = !1) {
    assert(Number.isInteger(e1) && e1 > 0, "The number should be a positive integer.");
    const i = "M".repeat(e1 / 1e3 | 0) + mt[e1 % 1e3 / 100 | 0] + mt[10 + (e1 % 100 / 10 | 0)] + mt[20 + e1 % 10];
    return t ? i.toLowerCase() : i;
}
function log2(e1) {
    return e1 > 0 ? Math.ceil(Math.log2(e1)) : 0;
}
function readInt8(e1, t) {
    return e1[t] << 24 >> 24;
}
function readUint16(e1, t) {
    return e1[t] << 8 | e1[t + 1];
}
function readUint32(e1, t) {
    return (e1[t] << 24 | e1[t + 1] << 16 | e1[t + 2] << 8 | e1[t + 3]) >>> 0;
}
function isWhiteSpace(e1) {
    return 32 === e1 || 9 === e1 || 13 === e1 || 10 === e1;
}
function isNumberArray(e1, t) {
    return Array.isArray(e1) ? (null === t || e1.length === t) && e1.every((e1)=>"number" == typeof e1) : ArrayBuffer.isView(e1) && (0 === e1.length || "number" == typeof e1[0]) && (null === t || e1.length === t);
}
function lookupMatrix(e1, t) {
    return isNumberArray(e1, 6) ? e1 : t;
}
function lookupRect(e1, t) {
    return isNumberArray(e1, 4) ? e1 : t;
}
function lookupNormalRect(e1, t) {
    return isNumberArray(e1, 4) ? Util.normalizeRect(e1) : t;
}
function parseXFAPath(e1) {
    const t = /(.+)\[(\d+)\]$/;
    return e1.split(".").map((e1)=>{
        const i = e1.match(t);
        return i ? {
            name: i[1],
            pos: parseInt(i[2], 10)
        } : {
            name: e1,
            pos: 0
        };
    });
}
function escapePDFName(e1) {
    const t = [];
    let i = 0;
    for(let a = 0, s = e1.length; a < s; a++){
        const s = e1.charCodeAt(a);
        if (s < 33 || s > 126 || 35 === s || 40 === s || 41 === s || 60 === s || 62 === s || 91 === s || 93 === s || 123 === s || 125 === s || 47 === s || 37 === s) {
            i < a && t.push(e1.substring(i, a));
            t.push(`#${s.toString(16)}`);
            i = a + 1;
        }
    }
    if (0 === t.length) return e1;
    i < e1.length && t.push(e1.substring(i, e1.length));
    return t.join("");
}
function escapeString(e1) {
    return e1.replaceAll(/([()\\\n\r])/g, (e1)=>"\n" === e1 ? "\\n" : "\r" === e1 ? "\\r" : `\\${e1}`);
}
function _collectJS(e1, t, i, a) {
    if (!e1) return;
    let s = null;
    if (e1 instanceof Ref) {
        if (a.has(e1)) return;
        s = e1;
        a.put(s);
        e1 = t.fetch(e1);
    }
    if (Array.isArray(e1)) for (const s of e1)_collectJS(s, t, i, a);
    else if (e1 instanceof Dict) {
        if (isName(e1.get("S"), "JavaScript")) {
            const t = e1.get("JS");
            let a;
            t instanceof BaseStream ? a = t.getString() : "string" == typeof t && (a = t);
            a &&= stringToPDFString(a).replaceAll("\0", "");
            a && i.push(a);
        }
        _collectJS(e1.getRaw("Next"), t, i, a);
    }
    s && a.remove(s);
}
function collectActions(e1, t, i) {
    const a = Object.create(null), s = getInheritableProperty({
        dict: t,
        key: "AA",
        stopWhenFound: !1
    });
    if (s) for(let t = s.length - 1; t >= 0; t--){
        const r = s[t];
        if (r instanceof Dict) for (const t of r.getKeys()){
            const s = i[t];
            if (!s) continue;
            const n = [];
            _collectJS(r.getRaw(t), e1, n, new RefSet);
            n.length > 0 && (a[s] = n);
        }
    }
    if (t.has("A")) {
        const i = [];
        _collectJS(t.get("A"), e1, i, new RefSet);
        i.length > 0 && (a.Action = i);
    }
    return objectSize(a) > 0 ? a : null;
}
const yt = {
    60: "&lt;",
    62: "&gt;",
    38: "&amp;",
    34: "&quot;",
    39: "&apos;"
};
function* codePointIter(e1) {
    for(let t = 0, i = e1.length; t < i; t++){
        const i = e1.codePointAt(t);
        i > 55295 && (i < 57344 || i > 65533) && t++;
        yield i;
    }
}
function encodeToXmlString(e1) {
    const t = [];
    let i = 0;
    for(let a = 0, s = e1.length; a < s; a++){
        const s = e1.codePointAt(a);
        if (32 <= s && s <= 126) {
            const r = yt[s];
            if (r) {
                i < a && t.push(e1.substring(i, a));
                t.push(r);
                i = a + 1;
            }
        } else {
            i < a && t.push(e1.substring(i, a));
            t.push(`&#x${s.toString(16).toUpperCase()};`);
            s > 55295 && (s < 57344 || s > 65533) && a++;
            i = a + 1;
        }
    }
    if (0 === t.length) return e1;
    i < e1.length && t.push(e1.substring(i, e1.length));
    return t.join("");
}
function validateFontName(e1, t = !1) {
    const i = /^("|').*("|')$/.exec(e1);
    if (i && i[1] === i[2]) {
        if (new RegExp(`[^\\\\]${i[1]}`).test(e1.slice(1, -1))) {
            t && warn(`FontFamily contains unescaped ${i[1]}: ${e1}.`);
            return !1;
        }
    } else for (const i of e1.split(/[ \t]+/))if (/^(\d|(-(\d|-)))/.test(i) || !/^[\w-\\]+$/.test(i)) {
        t && warn(`FontFamily contains invalid <custom-ident>: ${e1}.`);
        return !1;
    }
    return !0;
}
function validateCSSFont(e1) {
    const t = new Set([
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900",
        "1000",
        "normal",
        "bold",
        "bolder",
        "lighter"
    ]), { fontFamily: i, fontWeight: a, italicAngle: s } = e1;
    if (!validateFontName(i, !0)) return !1;
    const r = a ? a.toString() : "";
    e1.fontWeight = t.has(r) ? r : "400";
    const n = parseFloat(s);
    e1.italicAngle = isNaN(n) || n < -90 || n > 90 ? "14" : s.toString();
    return !0;
}
function recoverJsURL(e1) {
    const t = new RegExp("^\\s*(" + [
        "app.launchURL",
        "window.open",
        "xfa.host.gotoURL"
    ].join("|").replaceAll(".", "\\.") + ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))", "i").exec(e1);
    return t?.[2] ? {
        url: t[2],
        newWindow: "app.launchURL" === t[1] && "true" === t[3]
    } : null;
}
function numberToString(e1) {
    if (Number.isInteger(e1)) return e1.toString();
    const t = Math.round(100 * e1);
    return t % 100 == 0 ? (t / 100).toString() : t % 10 == 0 ? e1.toFixed(1) : e1.toFixed(2);
}
function getNewAnnotationsMap(e1) {
    if (!e1) return null;
    const t = new Map;
    for (const [i, a] of e1){
        if (!i.startsWith(u)) continue;
        let e1 = t.get(a.pageIndex);
        if (!e1) {
            e1 = [];
            t.set(a.pageIndex, e1);
        }
        e1.push(a);
    }
    return t.size > 0 ? t : null;
}
function stringToAsciiOrUTF16BE(e1) {
    return function isAscii(e1) {
        return /^[\x00-\x7F]*$/.test(e1);
    }(e1) ? e1 : stringToUTF16String(e1, !0);
}
function stringToUTF16HexString(e1) {
    const t = [];
    for(let i = 0, a = e1.length; i < a; i++){
        const a = e1.charCodeAt(i);
        t.push(It[a >> 8 & 255], It[255 & a]);
    }
    return t.join("");
}
function stringToUTF16String(e1, t = !1) {
    const i = [];
    t && i.push("Ã¾Ã¿");
    for(let t = 0, a = e1.length; t < a; t++){
        const a = e1.charCodeAt(t);
        i.push(String.fromCharCode(a >> 8 & 255), String.fromCharCode(255 & a));
    }
    return i.join("");
}
function getRotationMatrix(e1, t, i) {
    switch(e1){
        case 90:
            return [
                0,
                1,
                -1,
                0,
                t,
                0
            ];
        case 180:
            return [
                -1,
                0,
                0,
                -1,
                t,
                i
            ];
        case 270:
            return [
                0,
                -1,
                1,
                0,
                0,
                i
            ];
        default:
            throw new Error("Invalid rotation");
    }
}
function getSizeInBytes(e1) {
    return Math.ceil(Math.ceil(Math.log2(1 + e1)) / 8);
}
class Stream extends BaseStream {
    constructor(e1, t, i, a){
        super();
        this.bytes = e1 instanceof Uint8Array ? e1 : new Uint8Array(e1);
        this.start = t || 0;
        this.pos = this.start;
        this.end = t + i || this.bytes.length;
        this.dict = a;
    }
    get length() {
        return this.end - this.start;
    }
    get isEmpty() {
        return 0 === this.length;
    }
    getByte() {
        return this.pos >= this.end ? -1 : this.bytes[this.pos++];
    }
    getBytes(e1) {
        const t = this.bytes, i = this.pos, a = this.end;
        if (!e1) return t.subarray(i, a);
        let s = i + e1;
        s > a && (s = a);
        this.pos = s;
        return t.subarray(i, s);
    }
    getByteRange(e1, t) {
        e1 < 0 && (e1 = 0);
        t > this.end && (t = this.end);
        return this.bytes.subarray(e1, t);
    }
    reset() {
        this.pos = this.start;
    }
    moveStart() {
        this.start = this.pos;
    }
    makeSubStream(e1, t, i = null) {
        return new Stream(this.bytes.buffer, e1, t, i);
    }
}
class StringStream extends Stream {
    constructor(e1){
        super(stringToBytes(e1));
    }
}
class NullStream extends Stream {
    constructor(){
        super(new Uint8Array(0));
    }
}
class ChunkedStream extends Stream {
    constructor(e1, t, i){
        super(new Uint8Array(e1), 0, e1, null);
        this.chunkSize = t;
        this._loadedChunks = new Set;
        this.numChunks = Math.ceil(e1 / t);
        this.manager = i;
        this.progressiveDataLength = 0;
        this.lastSuccessfulEnsureByteChunk = -1;
    }
    getMissingChunks() {
        const e1 = [];
        for(let t = 0, i = this.numChunks; t < i; ++t)this._loadedChunks.has(t) || e1.push(t);
        return e1;
    }
    get numChunksLoaded() {
        return this._loadedChunks.size;
    }
    get isDataLoaded() {
        return this.numChunksLoaded === this.numChunks;
    }
    onReceiveData(e1, t) {
        const i = this.chunkSize;
        if (e1 % i != 0) throw new Error(`Bad begin offset: ${e1}`);
        const a = e1 + t.byteLength;
        if (a % i != 0 && a !== this.bytes.length) throw new Error(`Bad end offset: ${a}`);
        this.bytes.set(new Uint8Array(t), e1);
        const s = Math.floor(e1 / i), r = Math.floor((a - 1) / i) + 1;
        for(let e1 = s; e1 < r; ++e1)this._loadedChunks.add(e1);
    }
    onReceiveProgressiveData(e1) {
        let t = this.progressiveDataLength;
        const i = Math.floor(t / this.chunkSize);
        this.bytes.set(new Uint8Array(e1), t);
        t += e1.byteLength;
        this.progressiveDataLength = t;
        const a = t >= this.end ? this.numChunks : Math.floor(t / this.chunkSize);
        for(let e1 = i; e1 < a; ++e1)this._loadedChunks.add(e1);
    }
    ensureByte(e1) {
        if (e1 < this.progressiveDataLength) return;
        const t = Math.floor(e1 / this.chunkSize);
        if (!(t > this.numChunks) && t !== this.lastSuccessfulEnsureByteChunk) {
            if (!this._loadedChunks.has(t)) throw new MissingDataException(e1, e1 + 1);
            this.lastSuccessfulEnsureByteChunk = t;
        }
    }
    ensureRange(e1, t) {
        if (e1 >= t) return;
        if (t <= this.progressiveDataLength) return;
        const i = Math.floor(e1 / this.chunkSize);
        if (i > this.numChunks) return;
        const a = Math.min(Math.floor((t - 1) / this.chunkSize) + 1, this.numChunks);
        for(let s = i; s < a; ++s)if (!this._loadedChunks.has(s)) throw new MissingDataException(e1, t);
    }
    nextEmptyChunk(e1) {
        const t = this.numChunks;
        for(let i = 0; i < t; ++i){
            const a = (e1 + i) % t;
            if (!this._loadedChunks.has(a)) return a;
        }
        return null;
    }
    hasChunk(e1) {
        return this._loadedChunks.has(e1);
    }
    getByte() {
        const e1 = this.pos;
        if (e1 >= this.end) return -1;
        e1 >= this.progressiveDataLength && this.ensureByte(e1);
        return this.bytes[this.pos++];
    }
    getBytes(e1) {
        const t = this.bytes, i = this.pos, a = this.end;
        if (!e1) {
            a > this.progressiveDataLength && this.ensureRange(i, a);
            return t.subarray(i, a);
        }
        let s = i + e1;
        s > a && (s = a);
        s > this.progressiveDataLength && this.ensureRange(i, s);
        this.pos = s;
        return t.subarray(i, s);
    }
    getByteRange(e1, t) {
        e1 < 0 && (e1 = 0);
        t > this.end && (t = this.end);
        t > this.progressiveDataLength && this.ensureRange(e1, t);
        return this.bytes.subarray(e1, t);
    }
    makeSubStream(e1, t, i = null) {
        t ? e1 + t > this.progressiveDataLength && this.ensureRange(e1, e1 + t) : e1 >= this.progressiveDataLength && this.ensureByte(e1);
        function ChunkedStreamSubstream() {}
        ChunkedStreamSubstream.prototype = Object.create(this);
        ChunkedStreamSubstream.prototype.getMissingChunks = function() {
            const e1 = this.chunkSize, t = Math.floor(this.start / e1), i = Math.floor((this.end - 1) / e1) + 1, a = [];
            for(let e1 = t; e1 < i; ++e1)this._loadedChunks.has(e1) || a.push(e1);
            return a;
        };
        Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
            get () {
                return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
            },
            configurable: !0
        });
        const a = new ChunkedStreamSubstream;
        a.pos = a.start = e1;
        a.end = e1 + t || this.end;
        a.dict = i;
        return a;
    }
    getBaseStreams() {
        return [
            this
        ];
    }
}
class ChunkedStreamManager {
    constructor(e1, t){
        this.length = t.length;
        this.chunkSize = t.rangeChunkSize;
        this.stream = new ChunkedStream(this.length, this.chunkSize, this);
        this.pdfNetworkStream = e1;
        this.disableAutoFetch = t.disableAutoFetch;
        this.msgHandler = t.msgHandler;
        this.currRequestId = 0;
        this._chunksNeededByRequest = new Map;
        this._requestsByChunk = new Map;
        this._promisesByRequest = new Map;
        this.progressiveDataLength = 0;
        this.aborted = !1;
        this._loadedStreamCapability = Promise.withResolvers();
    }
    sendRequest(e1, t) {
        const i = this.pdfNetworkStream.getRangeReader(e1, t);
        i.isStreamingSupported || (i.onProgress = this.onProgress.bind(this));
        let a = [], s = 0;
        return new Promise((e1, t)=>{
            const readChunk = ({ value: r, done: n })=>{
                try {
                    if (n) {
                        const t = arrayBuffersToBytes(a);
                        a = null;
                        e1(t);
                        return;
                    }
                    s += r.byteLength;
                    i.isStreamingSupported && this.onProgress({
                        loaded: s
                    });
                    a.push(r);
                    i.read().then(readChunk, t);
                } catch (e1) {
                    t(e1);
                }
            };
            i.read().then(readChunk, t);
        }).then((t)=>{
            this.aborted || this.onReceiveData({
                chunk: t,
                begin: e1
            });
        });
    }
    requestAllChunks(e1 = !1) {
        if (!e1) {
            const e1 = this.stream.getMissingChunks();
            this._requestChunks(e1);
        }
        return this._loadedStreamCapability.promise;
    }
    _requestChunks(e1) {
        const t = this.currRequestId++, i = new Set;
        this._chunksNeededByRequest.set(t, i);
        for (const t of e1)this.stream.hasChunk(t) || i.add(t);
        if (0 === i.size) return Promise.resolve();
        const a = Promise.withResolvers();
        this._promisesByRequest.set(t, a);
        const s = [];
        for (const e1 of i){
            let i = this._requestsByChunk.get(e1);
            if (!i) {
                i = [];
                this._requestsByChunk.set(e1, i);
                s.push(e1);
            }
            i.push(t);
        }
        if (s.length > 0) {
            const e1 = this.groupChunks(s);
            for (const t of e1){
                const e1 = t.beginChunk * this.chunkSize, i = Math.min(t.endChunk * this.chunkSize, this.length);
                this.sendRequest(e1, i).catch(a.reject);
            }
        }
        return a.promise.catch((e1)=>{
            if (!this.aborted) throw e1;
        });
    }
    getStream() {
        return this.stream;
    }
    requestRange(e1, t) {
        t = Math.min(t, this.length);
        const i = this.getBeginChunk(e1), a = this.getEndChunk(t), s = [];
        for(let e1 = i; e1 < a; ++e1)s.push(e1);
        return this._requestChunks(s);
    }
    requestRanges(e1 = []) {
        const t = [];
        for (const i of e1){
            const e1 = this.getBeginChunk(i.begin), a = this.getEndChunk(i.end);
            for(let i = e1; i < a; ++i)t.includes(i) || t.push(i);
        }
        t.sort(function(e1, t) {
            return e1 - t;
        });
        return this._requestChunks(t);
    }
    groupChunks(e1) {
        const t = [];
        let i = -1, a = -1;
        for(let s = 0, r = e1.length; s < r; ++s){
            const r = e1[s];
            i < 0 && (i = r);
            if (a >= 0 && a + 1 !== r) {
                t.push({
                    beginChunk: i,
                    endChunk: a + 1
                });
                i = r;
            }
            s + 1 === e1.length && t.push({
                beginChunk: i,
                endChunk: r + 1
            });
            a = r;
        }
        return t;
    }
    onProgress(e1) {
        this.msgHandler.send("DocProgress", {
            loaded: this.stream.numChunksLoaded * this.chunkSize + e1.loaded,
            total: this.length
        });
    }
    onReceiveData(e1) {
        const t = e1.chunk, i = void 0 === e1.begin, a = i ? this.progressiveDataLength : e1.begin, s = a + t.byteLength, r = Math.floor(a / this.chunkSize), n = s < this.length ? Math.floor(s / this.chunkSize) : Math.ceil(s / this.chunkSize);
        if (i) {
            this.stream.onReceiveProgressiveData(t);
            this.progressiveDataLength = s;
        } else this.stream.onReceiveData(a, t);
        this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
        const g = [];
        for(let e1 = r; e1 < n; ++e1){
            const t = this._requestsByChunk.get(e1);
            if (t) {
                this._requestsByChunk.delete(e1);
                for (const i of t){
                    const t = this._chunksNeededByRequest.get(i);
                    t.has(e1) && t.delete(e1);
                    t.size > 0 || g.push(i);
                }
            }
        }
        if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
            let e1;
            if (1 === this.stream.numChunksLoaded) {
                const t = this.stream.numChunks - 1;
                this.stream.hasChunk(t) || (e1 = t);
            } else e1 = this.stream.nextEmptyChunk(n);
            Number.isInteger(e1) && this._requestChunks([
                e1
            ]);
        }
        for (const e1 of g){
            const t = this._promisesByRequest.get(e1);
            this._promisesByRequest.delete(e1);
            t.resolve();
        }
        this.msgHandler.send("DocProgress", {
            loaded: this.stream.numChunksLoaded * this.chunkSize,
            total: this.length
        });
    }
    onError(e1) {
        this._loadedStreamCapability.reject(e1);
    }
    getBeginChunk(e1) {
        return Math.floor(e1 / this.chunkSize);
    }
    getEndChunk(e1) {
        return Math.floor((e1 - 1) / this.chunkSize) + 1;
    }
    abort(e1) {
        this.aborted = !0;
        this.pdfNetworkStream?.cancelAllRequests(e1);
        for (const t of this._promisesByRequest.values())t.reject(e1);
    }
}
class ColorSpace {
    constructor(e1, t){
        this.name = e1;
        this.numComps = t;
    }
    getRgb(e1, t) {
        const i = new Uint8ClampedArray(3);
        this.getRgbItem(e1, t, i, 0);
        return i;
    }
    getRgbItem(e1, t, i, a) {
        unreachable("Should not call ColorSpace.getRgbItem");
    }
    getRgbBuffer(e1, t, i, a, s, r, n) {
        unreachable("Should not call ColorSpace.getRgbBuffer");
    }
    getOutputLength(e1, t) {
        unreachable("Should not call ColorSpace.getOutputLength");
    }
    isPassthrough(e1) {
        return !1;
    }
    isDefaultDecode(e1, t) {
        return ColorSpace.isDefaultDecode(e1, this.numComps);
    }
    fillRgb(e1, t, i, a, s, r, n, g, o) {
        const c = t * i;
        let C = null;
        const h = 1 << n, l = i !== s || t !== a;
        if (this.isPassthrough(n)) C = g;
        else if (1 === this.numComps && c > h && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
            const t = n <= 8 ? new Uint8Array(h) : new Uint16Array(h);
            for(let e1 = 0; e1 < h; e1++)t[e1] = e1;
            const i = new Uint8ClampedArray(3 * h);
            this.getRgbBuffer(t, 0, h, i, 0, n, 0);
            if (l) {
                C = new Uint8Array(3 * c);
                let e1 = 0;
                for(let t = 0; t < c; ++t){
                    const a = 3 * g[t];
                    C[e1++] = i[a];
                    C[e1++] = i[a + 1];
                    C[e1++] = i[a + 2];
                }
            } else {
                let t = 0;
                for(let a = 0; a < c; ++a){
                    const s = 3 * g[a];
                    e1[t++] = i[s];
                    e1[t++] = i[s + 1];
                    e1[t++] = i[s + 2];
                    t += o;
                }
            }
        } else if (l) {
            C = new Uint8ClampedArray(3 * c);
            this.getRgbBuffer(g, 0, c, C, 0, n, 0);
        } else this.getRgbBuffer(g, 0, a * r, e1, 0, n, o);
        if (C) if (l) !function resizeRgbImage(e1, t, i, a, s, r, n) {
            n = 1 !== n ? 0 : n;
            const g = i / s, o = a / r;
            let c, C = 0;
            const h = new Uint16Array(s), l = 3 * i;
            for(let e1 = 0; e1 < s; e1++)h[e1] = 3 * Math.floor(e1 * g);
            for(let i = 0; i < r; i++){
                const a = Math.floor(i * o) * l;
                for(let i = 0; i < s; i++){
                    c = a + h[i];
                    t[C++] = e1[c++];
                    t[C++] = e1[c++];
                    t[C++] = e1[c++];
                    C += n;
                }
            }
        }(C, e1, t, i, a, s, o);
        else {
            let t = 0, i = 0;
            for(let s = 0, n = a * r; s < n; s++){
                e1[t++] = C[i++];
                e1[t++] = C[i++];
                e1[t++] = C[i++];
                t += o;
            }
        }
    }
    get usesZeroToOneRange() {
        return shadow(this, "usesZeroToOneRange", !0);
    }
    static _cache(e1, t, i, a) {
        if (!i) throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
        if (!a) throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
        let s, r;
        if (e1 instanceof Ref) {
            r = e1;
            e1 = t.fetch(e1);
        }
        e1 instanceof Name && (s = e1.name);
        (s || r) && i.set(s, r, a);
    }
    static getCached(e1, t, i) {
        if (!i) throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
        if (e1 instanceof Ref) {
            const a = i.getByRef(e1);
            if (a) return a;
            try {
                e1 = t.fetch(e1);
            } catch (e1) {
                if (e1 instanceof MissingDataException) throw e1;
            }
        }
        if (e1 instanceof Name) {
            const t = i.getByName(e1.name);
            if (t) return t;
        }
        return null;
    }
    static async parseAsync({ cs: e1, xref: t, resources: i = null, pdfFunctionFactory: a, localColorSpaceCache: s }) {
        const r = this._parse(e1, t, i, a);
        this._cache(e1, t, s, r);
        return r;
    }
    static parse({ cs: e1, xref: t, resources: i = null, pdfFunctionFactory: a, localColorSpaceCache: s }) {
        const r = this.getCached(e1, t, s);
        if (r) return r;
        const n = this._parse(e1, t, i, a);
        this._cache(e1, t, s, n);
        return n;
    }
    static _parse(e1, t, i = null, a) {
        if ((e1 = t.fetchIfRef(e1)) instanceof Name) switch(e1.name){
            case "G":
            case "DeviceGray":
                return this.singletons.gray;
            case "RGB":
            case "DeviceRGB":
                return this.singletons.rgb;
            case "DeviceRGBA":
                return this.singletons.rgba;
            case "CMYK":
            case "DeviceCMYK":
                return this.singletons.cmyk;
            case "Pattern":
                return new PatternCS(null);
            default:
                if (i instanceof Dict) {
                    const s = i.get("ColorSpace");
                    if (s instanceof Dict) {
                        const r = s.get(e1.name);
                        if (r) {
                            if (r instanceof Name) return this._parse(r, t, i, a);
                            e1 = r;
                            break;
                        }
                    }
                }
                warn(`Unrecognized ColorSpace: ${e1.name}`);
                return this.singletons.gray;
        }
        if (Array.isArray(e1)) {
            const s = t.fetchIfRef(e1[0]).name;
            let r, n, g, o, c, C;
            switch(s){
                case "G":
                case "DeviceGray":
                    return this.singletons.gray;
                case "RGB":
                case "DeviceRGB":
                    return this.singletons.rgb;
                case "CMYK":
                case "DeviceCMYK":
                    return this.singletons.cmyk;
                case "CalGray":
                    r = t.fetchIfRef(e1[1]);
                    o = r.getArray("WhitePoint");
                    c = r.getArray("BlackPoint");
                    C = r.get("Gamma");
                    return new CalGrayCS(o, c, C);
                case "CalRGB":
                    r = t.fetchIfRef(e1[1]);
                    o = r.getArray("WhitePoint");
                    c = r.getArray("BlackPoint");
                    C = r.getArray("Gamma");
                    const h = r.getArray("Matrix");
                    return new CalRGBCS(o, c, C, h);
                case "ICCBased":
                    const l = t.fetchIfRef(e1[1]).dict;
                    n = l.get("N");
                    const Q = l.get("Alternate");
                    if (Q) {
                        const e1 = this._parse(Q, t, i, a);
                        if (e1.numComps === n) return e1;
                        warn("ICCBased color space: Ignoring incorrect /Alternate entry.");
                    }
                    if (1 === n) return this.singletons.gray;
                    if (3 === n) return this.singletons.rgb;
                    if (4 === n) return this.singletons.cmyk;
                    break;
                case "Pattern":
                    g = e1[1] || null;
                    g && (g = this._parse(g, t, i, a));
                    return new PatternCS(g);
                case "I":
                case "Indexed":
                    g = this._parse(e1[1], t, i, a);
                    const E = Math.max(0, Math.min(t.fetchIfRef(e1[2]), 255)), u = t.fetchIfRef(e1[3]);
                    return new IndexedCS(g, E, u);
                case "Separation":
                case "DeviceN":
                    const d = t.fetchIfRef(e1[1]);
                    n = Array.isArray(d) ? d.length : 1;
                    g = this._parse(e1[2], t, i, a);
                    const f = a.create(e1[3]);
                    return new AlternateCS(n, g, f);
                case "Lab":
                    r = t.fetchIfRef(e1[1]);
                    o = r.getArray("WhitePoint");
                    c = r.getArray("BlackPoint");
                    const p = r.getArray("Range");
                    return new LabCS(o, c, p);
                default:
                    warn(`Unimplemented ColorSpace object: ${s}`);
                    return this.singletons.gray;
            }
        }
        warn(`Unrecognized ColorSpace object: ${e1}`);
        return this.singletons.gray;
    }
    static isDefaultDecode(e1, t) {
        if (!Array.isArray(e1)) return !0;
        if (2 * t !== e1.length) {
            warn("The decode map is not the correct length");
            return !0;
        }
        for(let t = 0, i = e1.length; t < i; t += 2)if (0 !== e1[t] || 1 !== e1[t + 1]) return !1;
        return !0;
    }
    static get singletons() {
        return shadow(this, "singletons", {
            get gray () {
                return shadow(this, "gray", new DeviceGrayCS);
            },
            get rgb () {
                return shadow(this, "rgb", new DeviceRgbCS);
            },
            get rgba () {
                return shadow(this, "rgba", new DeviceRgbaCS);
            },
            get cmyk () {
                return shadow(this, "cmyk", new DeviceCmykCS);
            }
        });
    }
}
class AlternateCS extends ColorSpace {
    constructor(e1, t, i){
        super("Alternate", e1);
        this.base = t;
        this.tintFn = i;
        this.tmpBuf = new Float32Array(t.numComps);
    }
    getRgbItem(e1, t, i, a) {
        const s = this.tmpBuf;
        this.tintFn(e1, t, s, 0);
        this.base.getRgbItem(s, 0, i, a);
    }
    getRgbBuffer(e1, t, i, a, s, r, n) {
        const g = this.tintFn, o = this.base, c = 1 / ((1 << r) - 1), C = o.numComps, h = o.usesZeroToOneRange, l = (o.isPassthrough(8) || !h) && 0 === n;
        let Q = l ? s : 0;
        const E = l ? a : new Uint8ClampedArray(C * i), u = this.numComps, d = new Float32Array(u), f = new Float32Array(C);
        let p, m;
        for(p = 0; p < i; p++){
            for(m = 0; m < u; m++)d[m] = e1[t++] * c;
            g(d, 0, f, 0);
            if (h) for(m = 0; m < C; m++)E[Q++] = 255 * f[m];
            else {
                o.getRgbItem(f, 0, E, Q);
                Q += C;
            }
        }
        l || o.getRgbBuffer(E, 0, i, a, s, 8, n);
    }
    getOutputLength(e1, t) {
        return this.base.getOutputLength(e1 * this.base.numComps / this.numComps, t);
    }
}
class PatternCS extends ColorSpace {
    constructor(e1){
        super("Pattern", null);
        this.base = e1;
    }
    isDefaultDecode(e1, t) {
        unreachable("Should not call PatternCS.isDefaultDecode");
    }
}
class IndexedCS extends ColorSpace {
    constructor(e1, t, i){
        super("Indexed", 1);
        this.base = e1;
        const a = e1.numComps * (t + 1);
        this.lookup = new Uint8Array(a);
        if (i instanceof BaseStream) {
            const e1 = i.getBytes(a);
            this.lookup.set(e1);
        } else {
            if ("string" != typeof i) throw new FormatError(`IndexedCS - unrecognized lookup table: ${i}`);
            for(let e1 = 0; e1 < a; ++e1)this.lookup[e1] = 255 & i.charCodeAt(e1);
        }
    }
    getRgbItem(e1, t, i, a) {
        const s = this.base.numComps, r = e1[t] * s;
        this.base.getRgbBuffer(this.lookup, r, 1, i, a, 8, 0);
    }
    getRgbBuffer(e1, t, i, a, s, r, n) {
        const g = this.base, o = g.numComps, c = g.getOutputLength(o, n), C = this.lookup;
        for(let r = 0; r < i; ++r){
            const i = e1[t++] * o;
            g.getRgbBuffer(C, i, 1, a, s, 8, n);
            s += c;
        }
    }
    getOutputLength(e1, t) {
        return this.base.getOutputLength(e1 * this.base.numComps, t);
    }
    isDefaultDecode(e1, t) {
        if (!Array.isArray(e1)) return !0;
        if (2 !== e1.length) {
            warn("Decode map length is not correct");
            return !0;
        }
        if (!Number.isInteger(t) || t < 1) {
            warn("Bits per component is not correct");
            return !0;
        }
        return 0 === e1[0] && e1[1] === (1 << t) - 1;
    }
}
class DeviceGrayCS extends ColorSpace {
    constructor(){
        super("DeviceGray", 1);
    }
    getRgbItem(e1, t, i, a) {
        const s = 255 * e1[t];
        i[a] = i[a + 1] = i[a + 2] = s;
    }
    getRgbBuffer(e1, t, i, a, s, r, n) {
        const g = 255 / ((1 << r) - 1);
        let o = t, c = s;
        for(let t = 0; t < i; ++t){
            const t = g * e1[o++];
            a[c++] = t;
            a[c++] = t;
            a[c++] = t;
            c += n;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t);
    }
}
class DeviceRgbCS extends ColorSpace {
    constructor(){
        super("DeviceRGB", 3);
    }
    getRgbItem(e1, t, i, a) {
        i[a] = 255 * e1[t];
        i[a + 1] = 255 * e1[t + 1];
        i[a + 2] = 255 * e1[t + 2];
    }
    getRgbBuffer(e1, t, i, a, s, r, n) {
        if (8 === r && 0 === n) {
            a.set(e1.subarray(t, t + 3 * i), s);
            return;
        }
        const g = 255 / ((1 << r) - 1);
        let o = t, c = s;
        for(let t = 0; t < i; ++t){
            a[c++] = g * e1[o++];
            a[c++] = g * e1[o++];
            a[c++] = g * e1[o++];
            c += n;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t) / 3 | 0;
    }
    isPassthrough(e1) {
        return 8 === e1;
    }
}
class DeviceRgbaCS extends ColorSpace {
    constructor(){
        super("DeviceRGBA", 4);
    }
    getOutputLength(e1, t) {
        return 4 * e1;
    }
    isPassthrough(e1) {
        return 8 === e1;
    }
    fillRgb(e1, t, i, a, s, r, n, g, o) {
        i !== s || t !== a ? function resizeRgbaImage(e1, t, i, a, s, r, n) {
            const g = i / s, o = a / r;
            let c = 0;
            const C = new Uint16Array(s);
            if (1 === n) {
                for(let e1 = 0; e1 < s; e1++)C[e1] = Math.floor(e1 * g);
                const a = new Uint32Array(e1.buffer), n = new Uint32Array(t.buffer), h = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
                for(let e1 = 0; e1 < r; e1++){
                    const t = a.subarray(Math.floor(e1 * o) * i);
                    for(let e1 = 0; e1 < s; e1++)n[c++] |= t[C[e1]] & h;
                }
            } else {
                const a = 4, n = i * a;
                for(let e1 = 0; e1 < s; e1++)C[e1] = Math.floor(e1 * g) * a;
                for(let i = 0; i < r; i++){
                    const a = e1.subarray(Math.floor(i * o) * n);
                    for(let e1 = 0; e1 < s; e1++){
                        const i = C[e1];
                        t[c++] = a[i];
                        t[c++] = a[i + 1];
                        t[c++] = a[i + 2];
                    }
                }
            }
        }(g, e1, t, i, a, s, o) : function copyRgbaImage(e1, t, i) {
            if (1 === i) {
                const i = new Uint32Array(e1.buffer), a = new Uint32Array(t.buffer), s = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
                for(let e1 = 0, t = i.length; e1 < t; e1++)a[e1] |= i[e1] & s;
            } else {
                let i = 0;
                for(let a = 0, s = e1.length; a < s; a += 4){
                    t[i++] = e1[a];
                    t[i++] = e1[a + 1];
                    t[i++] = e1[a + 2];
                }
            }
        }(g, e1, o);
    }
}
class DeviceCmykCS extends ColorSpace {
    constructor(){
        super("DeviceCMYK", 4);
    }
    #t(e1, t, i, a, s) {
        const r = e1[t] * i, n = e1[t + 1] * i, g = e1[t + 2] * i, o = e1[t + 3] * i;
        a[s] = 255 + r * (-4.387332384609988 * r + 54.48615194189176 * n + 18.82290502165302 * g + 212.25662451639585 * o - 285.2331026137004) + n * (1.7149763477362134 * n - 5.6096736904047315 * g + -17.873870861415444 * o - 5.497006427196366) + g * (-2.5217340131683033 * g - 21.248923337353073 * o + 17.5119270841813) + o * (-21.86122147463605 * o - 189.48180835922747);
        a[s + 1] = 255 + r * (8.841041422036149 * r + 60.118027045597366 * n + 6.871425592049007 * g + 31.159100130055922 * o - 79.2970844816548) + n * (-15.310361306967817 * n + 17.575251261109482 * g + 131.35250912493976 * o - 190.9453302588951) + g * (4.444339102852739 * g + 9.8632861493405 * o - 24.86741582555878) + o * (-20.737325471181034 * o - 187.80453709719578);
        a[s + 2] = 255 + r * (.8842522430003296 * r + 8.078677503112928 * n + 30.89978309703729 * g - .23883238689178934 * o - 14.183576799673286) + n * (10.49593273432072 * n + 63.02378494754052 * g + 50.606957656360734 * o - 112.23884253719248) + g * (.03296041114873217 * g + 115.60384449646641 * o - 193.58209356861505) + o * (-22.33816807309886 * o - 180.12613974708367);
    }
    getRgbItem(e1, t, i, a) {
        this.#t(e1, t, 1, i, a);
    }
    getRgbBuffer(e1, t, i, a, s, r, n) {
        const g = 1 / ((1 << r) - 1);
        for(let r = 0; r < i; r++){
            this.#t(e1, t, g, a, s);
            t += 4;
            s += 3 + n;
        }
    }
    getOutputLength(e1, t) {
        return e1 / 4 * (3 + t) | 0;
    }
}
class CalGrayCS extends ColorSpace {
    constructor(e1, t, i){
        super("CalGray", 1);
        if (!e1) throw new FormatError("WhitePoint missing - required for color space CalGray");
        [this.XW, this.YW, this.ZW] = e1;
        [this.XB, this.YB, this.ZB] = t || [
            0,
            0,
            0
        ];
        this.G = i || 1;
        if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
            info(`Invalid BlackPoint for ${this.name}, falling back to default.`);
            this.XB = this.YB = this.ZB = 0;
        }
        0 === this.XB && 0 === this.YB && 0 === this.ZB || warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
        if (this.G < 1) {
            info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
            this.G = 1;
        }
    }
    #t(e1, t, i, a, s) {
        const r = (e1[t] * s) ** this.G, n = this.YW * r, g = Math.max(295.8 * n ** .3333333333333333 - 40.8, 0);
        i[a] = g;
        i[a + 1] = g;
        i[a + 2] = g;
    }
    getRgbItem(e1, t, i, a) {
        this.#t(e1, t, i, a, 1);
    }
    getRgbBuffer(e1, t, i, a, s, r, n) {
        const g = 1 / ((1 << r) - 1);
        for(let r = 0; r < i; ++r){
            this.#t(e1, t, a, s, g);
            t += 1;
            s += 3 + n;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t);
    }
}
class CalRGBCS extends ColorSpace {
    static #i = new Float32Array([
        .8951,
        .2664,
        -.1614,
        -.7502,
        1.7135,
        .0367,
        .0389,
        -.0685,
        1.0296
    ]);
    static #a = new Float32Array([
        .9869929,
        -.1470543,
        .1599627,
        .4323053,
        .5183603,
        .0492912,
        -.0085287,
        .0400428,
        .9684867
    ]);
    static #s = new Float32Array([
        3.2404542,
        -1.5371385,
        -.4985314,
        -.969266,
        1.8760108,
        .041556,
        .0556434,
        -.2040259,
        1.0572252
    ]);
    static #r = new Float32Array([
        1,
        1,
        1
    ]);
    static #n = new Float32Array(3);
    static #g = new Float32Array(3);
    static #o = new Float32Array(3);
    static #I = (24 / 116) ** 3 / 8;
    constructor(e1, t, i, a){
        super("CalRGB", 3);
        if (!e1) throw new FormatError("WhitePoint missing - required for color space CalRGB");
        const [s, r, n] = this.whitePoint = e1, [g, o, c] = this.blackPoint = t || new Float32Array(3);
        [this.GR, this.GG, this.GB] = i || new Float32Array([
            1,
            1,
            1
        ]);
        [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = a || new Float32Array([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]);
        if (s < 0 || n < 0 || 1 !== r) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        if (g < 0 || o < 0 || c < 0) {
            info(`Invalid BlackPoint for ${this.name} [${g}, ${o}, ${c}], falling back to default.`);
            this.blackPoint = new Float32Array(3);
        }
        if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
            info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
            this.GR = this.GG = this.GB = 1;
        }
    }
    #c(e1, t, i) {
        i[0] = e1[0] * t[0] + e1[1] * t[1] + e1[2] * t[2];
        i[1] = e1[3] * t[0] + e1[4] * t[1] + e1[5] * t[2];
        i[2] = e1[6] * t[0] + e1[7] * t[1] + e1[8] * t[2];
    }
    #C(e1, t, i) {
        i[0] = 1 * t[0] / e1[0];
        i[1] = 1 * t[1] / e1[1];
        i[2] = 1 * t[2] / e1[2];
    }
    #h(e1, t, i) {
        i[0] = .95047 * t[0] / e1[0];
        i[1] = 1 * t[1] / e1[1];
        i[2] = 1.08883 * t[2] / e1[2];
    }
    #l(e1) {
        return e1 <= .0031308 ? this.#B(0, 1, 12.92 * e1) : e1 >= .99554525 ? 1 : this.#B(0, 1, 1.055 * e1 ** (1 / 2.4) - .055);
    }
    #B(e1, t, i) {
        return Math.max(e1, Math.min(t, i));
    }
    #Q(e1) {
        return e1 < 0 ? -this.#Q(-e1) : e1 > 8 ? ((e1 + 16) / 116) ** 3 : e1 * CalRGBCS.#I;
    }
    #E(e1, t, i) {
        if (0 === e1[0] && 0 === e1[1] && 0 === e1[2]) {
            i[0] = t[0];
            i[1] = t[1];
            i[2] = t[2];
            return;
        }
        const a = this.#Q(0), s = (1 - a) / (1 - this.#Q(e1[0])), r = 1 - s, n = (1 - a) / (1 - this.#Q(e1[1])), g = 1 - n, o = (1 - a) / (1 - this.#Q(e1[2])), c = 1 - o;
        i[0] = t[0] * s + r;
        i[1] = t[1] * n + g;
        i[2] = t[2] * o + c;
    }
    #u(e1, t, i) {
        if (1 === e1[0] && 1 === e1[2]) {
            i[0] = t[0];
            i[1] = t[1];
            i[2] = t[2];
            return;
        }
        const a = i;
        this.#c(CalRGBCS.#i, t, a);
        const s = CalRGBCS.#n;
        this.#C(e1, a, s);
        this.#c(CalRGBCS.#a, s, i);
    }
    #d(e1, t, i) {
        const a = i;
        this.#c(CalRGBCS.#i, t, a);
        const s = CalRGBCS.#n;
        this.#h(e1, a, s);
        this.#c(CalRGBCS.#a, s, i);
    }
    #t(e1, t, i, a, s) {
        const r = this.#B(0, 1, e1[t] * s), n = this.#B(0, 1, e1[t + 1] * s), g = this.#B(0, 1, e1[t + 2] * s), o = 1 === r ? 1 : r ** this.GR, c = 1 === n ? 1 : n ** this.GG, C = 1 === g ? 1 : g ** this.GB, h = this.MXA * o + this.MXB * c + this.MXC * C, l = this.MYA * o + this.MYB * c + this.MYC * C, Q = this.MZA * o + this.MZB * c + this.MZC * C, E = CalRGBCS.#g;
        E[0] = h;
        E[1] = l;
        E[2] = Q;
        const u = CalRGBCS.#o;
        this.#u(this.whitePoint, E, u);
        const d = CalRGBCS.#g;
        this.#E(this.blackPoint, u, d);
        const f = CalRGBCS.#o;
        this.#d(CalRGBCS.#r, d, f);
        const p = CalRGBCS.#g;
        this.#c(CalRGBCS.#s, f, p);
        i[a] = 255 * this.#l(p[0]);
        i[a + 1] = 255 * this.#l(p[1]);
        i[a + 2] = 255 * this.#l(p[2]);
    }
    getRgbItem(e1, t, i, a) {
        this.#t(e1, t, i, a, 1);
    }
    getRgbBuffer(e1, t, i, a, s, r, n) {
        const g = 1 / ((1 << r) - 1);
        for(let r = 0; r < i; ++r){
            this.#t(e1, t, a, s, g);
            t += 3;
            s += 3 + n;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t) / 3 | 0;
    }
}
class LabCS extends ColorSpace {
    constructor(e1, t, i){
        super("Lab", 3);
        if (!e1) throw new FormatError("WhitePoint missing - required for color space Lab");
        [this.XW, this.YW, this.ZW] = e1;
        [this.amin, this.amax, this.bmin, this.bmax] = i || [
            -100,
            100,
            -100,
            100
        ];
        [this.XB, this.YB, this.ZB] = t || [
            0,
            0,
            0
        ];
        if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError("Invalid WhitePoint components, no fallback available");
        if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
            info("Invalid BlackPoint, falling back to default");
            this.XB = this.YB = this.ZB = 0;
        }
        if (this.amin > this.amax || this.bmin > this.bmax) {
            info("Invalid Range, falling back to defaults");
            this.amin = -100;
            this.amax = 100;
            this.bmin = -100;
            this.bmax = 100;
        }
    }
    #f(e1) {
        return e1 >= 6 / 29 ? e1 ** 3 : 108 / 841 * (e1 - 4 / 29);
    }
    #p(e1, t, i, a) {
        return i + e1 * (a - i) / t;
    }
    #t(e1, t, i, a, s) {
        let r = e1[t], n = e1[t + 1], g = e1[t + 2];
        if (!1 !== i) {
            r = this.#p(r, i, 0, 100);
            n = this.#p(n, i, this.amin, this.amax);
            g = this.#p(g, i, this.bmin, this.bmax);
        }
        n > this.amax ? n = this.amax : n < this.amin && (n = this.amin);
        g > this.bmax ? g = this.bmax : g < this.bmin && (g = this.bmin);
        const o = (r + 16) / 116, c = o + n / 500, C = o - g / 200, h = this.XW * this.#f(c), l = this.YW * this.#f(o), Q = this.ZW * this.#f(C);
        let E, u, d;
        if (this.ZW < 1) {
            E = 3.1339 * h + -1.617 * l + -.4906 * Q;
            u = -.9785 * h + 1.916 * l + .0333 * Q;
            d = .072 * h + -.229 * l + 1.4057 * Q;
        } else {
            E = 3.2406 * h + -1.5372 * l + -.4986 * Q;
            u = -.9689 * h + 1.8758 * l + .0415 * Q;
            d = .0557 * h + -.204 * l + 1.057 * Q;
        }
        a[s] = 255 * Math.sqrt(E);
        a[s + 1] = 255 * Math.sqrt(u);
        a[s + 2] = 255 * Math.sqrt(d);
    }
    getRgbItem(e1, t, i, a) {
        this.#t(e1, t, !1, i, a);
    }
    getRgbBuffer(e1, t, i, a, s, r, n) {
        const g = (1 << r) - 1;
        for(let r = 0; r < i; r++){
            this.#t(e1, t, g, a, s);
            t += 3;
            s += 3 + n;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t) / 3 | 0;
    }
    isDefaultDecode(e1, t) {
        return !0;
    }
    get usesZeroToOneRange() {
        return shadow(this, "usesZeroToOneRange", !1);
    }
}
function hexToInt(e1, t) {
    let i = 0;
    for(let a = 0; a <= t; a++)i = i << 8 | e1[a];
    return i >>> 0;
}
function hexToStr(e1, t) {
    return 1 === t ? String.fromCharCode(e1[0], e1[1]) : 3 === t ? String.fromCharCode(e1[0], e1[1], e1[2], e1[3]) : String.fromCharCode(...e1.subarray(0, t + 1));
}
function addHex(e1, t, i) {
    let a = 0;
    for(let s = i; s >= 0; s--){
        a += e1[s] + t[s];
        e1[s] = 255 & a;
        a >>= 8;
    }
}
function incHex(e1, t) {
    let i = 1;
    for(let a = t; a >= 0 && i > 0; a--){
        i += e1[a];
        e1[a] = 255 & i;
        i >>= 8;
    }
}
const wt = 16;
class BinaryCMapStream {
    constructor(e1){
        this.buffer = e1;
        this.pos = 0;
        this.end = e1.length;
        this.tmpBuf = new Uint8Array(19);
    }
    readByte() {
        return this.pos >= this.end ? -1 : this.buffer[this.pos++];
    }
    readNumber() {
        let e1, t = 0;
        do {
            const i = this.readByte();
            if (i < 0) throw new FormatError("unexpected EOF in bcmap");
            e1 = !(128 & i);
            t = t << 7 | 127 & i;
        }while (!e1)
        return t;
    }
    readSigned() {
        const e1 = this.readNumber();
        return 1 & e1 ? ~(e1 >>> 1) : e1 >>> 1;
    }
    readHex(e1, t) {
        e1.set(this.buffer.subarray(this.pos, this.pos + t + 1));
        this.pos += t + 1;
    }
    readHexNumber(e1, t) {
        let i;
        const a = this.tmpBuf;
        let s = 0;
        do {
            const e1 = this.readByte();
            if (e1 < 0) throw new FormatError("unexpected EOF in bcmap");
            i = !(128 & e1);
            a[s++] = 127 & e1;
        }while (!i)
        let r = t, n = 0, g = 0;
        for(; r >= 0;){
            for(; g < 8 && a.length > 0;){
                n |= a[--s] << g;
                g += 7;
            }
            e1[r] = 255 & n;
            r--;
            n >>= 8;
            g -= 8;
        }
    }
    readHexSigned(e1, t) {
        this.readHexNumber(e1, t);
        const i = 1 & e1[t] ? 255 : 0;
        let a = 0;
        for(let s = 0; s <= t; s++){
            a = (1 & a) << 8 | e1[s];
            e1[s] = a >> 1 ^ i;
        }
    }
    readString() {
        const e1 = this.readNumber(), t = new Array(e1);
        for(let i = 0; i < e1; i++)t[i] = this.readNumber();
        return String.fromCharCode(...t);
    }
}
class BinaryCMapReader {
    async process(e1, t, i) {
        const a = new BinaryCMapStream(e1), s = a.readByte();
        t.vertical = !!(1 & s);
        let r = null;
        const n = new Uint8Array(wt), g = new Uint8Array(wt), o = new Uint8Array(wt), c = new Uint8Array(wt), C = new Uint8Array(wt);
        let h, l;
        for(; (l = a.readByte()) >= 0;){
            const e1 = l >> 5;
            if (7 === e1) {
                switch(31 & l){
                    case 0:
                        a.readString();
                        break;
                    case 1:
                        r = a.readString();
                }
                continue;
            }
            const i = !!(16 & l), s = 15 & l;
            if (s + 1 > wt) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
            const Q = 1, E = a.readNumber();
            switch(e1){
                case 0:
                    a.readHex(n, s);
                    a.readHexNumber(g, s);
                    addHex(g, n, s);
                    t.addCodespaceRange(s + 1, hexToInt(n, s), hexToInt(g, s));
                    for(let e1 = 1; e1 < E; e1++){
                        incHex(g, s);
                        a.readHexNumber(n, s);
                        addHex(n, g, s);
                        a.readHexNumber(g, s);
                        addHex(g, n, s);
                        t.addCodespaceRange(s + 1, hexToInt(n, s), hexToInt(g, s));
                    }
                    break;
                case 1:
                    a.readHex(n, s);
                    a.readHexNumber(g, s);
                    addHex(g, n, s);
                    a.readNumber();
                    for(let e1 = 1; e1 < E; e1++){
                        incHex(g, s);
                        a.readHexNumber(n, s);
                        addHex(n, g, s);
                        a.readHexNumber(g, s);
                        addHex(g, n, s);
                        a.readNumber();
                    }
                    break;
                case 2:
                    a.readHex(o, s);
                    h = a.readNumber();
                    t.mapOne(hexToInt(o, s), h);
                    for(let e1 = 1; e1 < E; e1++){
                        incHex(o, s);
                        if (!i) {
                            a.readHexNumber(C, s);
                            addHex(o, C, s);
                        }
                        h = a.readSigned() + (h + 1);
                        t.mapOne(hexToInt(o, s), h);
                    }
                    break;
                case 3:
                    a.readHex(n, s);
                    a.readHexNumber(g, s);
                    addHex(g, n, s);
                    h = a.readNumber();
                    t.mapCidRange(hexToInt(n, s), hexToInt(g, s), h);
                    for(let e1 = 1; e1 < E; e1++){
                        incHex(g, s);
                        if (i) n.set(g);
                        else {
                            a.readHexNumber(n, s);
                            addHex(n, g, s);
                        }
                        a.readHexNumber(g, s);
                        addHex(g, n, s);
                        h = a.readNumber();
                        t.mapCidRange(hexToInt(n, s), hexToInt(g, s), h);
                    }
                    break;
                case 4:
                    a.readHex(o, Q);
                    a.readHex(c, s);
                    t.mapOne(hexToInt(o, Q), hexToStr(c, s));
                    for(let e1 = 1; e1 < E; e1++){
                        incHex(o, Q);
                        if (!i) {
                            a.readHexNumber(C, Q);
                            addHex(o, C, Q);
                        }
                        incHex(c, s);
                        a.readHexSigned(C, s);
                        addHex(c, C, s);
                        t.mapOne(hexToInt(o, Q), hexToStr(c, s));
                    }
                    break;
                case 5:
                    a.readHex(n, Q);
                    a.readHexNumber(g, Q);
                    addHex(g, n, Q);
                    a.readHex(c, s);
                    t.mapBfRange(hexToInt(n, Q), hexToInt(g, Q), hexToStr(c, s));
                    for(let e1 = 1; e1 < E; e1++){
                        incHex(g, Q);
                        if (i) n.set(g);
                        else {
                            a.readHexNumber(n, Q);
                            addHex(n, g, Q);
                        }
                        a.readHexNumber(g, Q);
                        addHex(g, n, Q);
                        a.readHex(c, s);
                        t.mapBfRange(hexToInt(n, Q), hexToInt(g, Q), hexToStr(c, s));
                    }
                    break;
                default:
                    throw new Error(`BinaryCMapReader.process - unknown type: ${e1}`);
            }
        }
        return r ? i(r) : t;
    }
}
const Dt = new Uint8Array(0);
class DecodeStream extends BaseStream {
    constructor(e1){
        super();
        this._rawMinBufferLength = e1 || 0;
        this.pos = 0;
        this.bufferLength = 0;
        this.eof = !1;
        this.buffer = Dt;
        this.minBufferLength = 512;
        if (e1) for(; this.minBufferLength < e1;)this.minBufferLength *= 2;
    }
    get isEmpty() {
        for(; !this.eof && 0 === this.bufferLength;)this.readBlock();
        return 0 === this.bufferLength;
    }
    ensureBuffer(e1) {
        const t = this.buffer;
        if (e1 <= t.byteLength) return t;
        let i = this.minBufferLength;
        for(; i < e1;)i *= 2;
        const a = new Uint8Array(i);
        a.set(t);
        return this.buffer = a;
    }
    getByte() {
        const e1 = this.pos;
        for(; this.bufferLength <= e1;){
            if (this.eof) return -1;
            this.readBlock();
        }
        return this.buffer[this.pos++];
    }
    getBytes(e1, t = null) {
        const i = this.pos;
        let a;
        if (e1) {
            this.ensureBuffer(i + e1);
            a = i + e1;
            for(; !this.eof && this.bufferLength < a;)this.readBlock(t);
            const s = this.bufferLength;
            a > s && (a = s);
        } else {
            for(; !this.eof;)this.readBlock(t);
            a = this.bufferLength;
        }
        this.pos = a;
        return this.buffer.subarray(i, a);
    }
    async getImageData(e1, t = null) {
        if (!this.canAsyncDecodeImageFromBuffer) return this.getBytes(e1, t);
        const i = await this.stream.asyncGetBytes();
        return this.decodeImage(i, t);
    }
    reset() {
        this.pos = 0;
    }
    makeSubStream(e1, t, i = null) {
        if (void 0 === t) for(; !this.eof;)this.readBlock();
        else {
            const i = e1 + t;
            for(; this.bufferLength <= i && !this.eof;)this.readBlock();
        }
        return new Stream(this.buffer, e1, t, i);
    }
    getBaseStreams() {
        return this.str ? this.str.getBaseStreams() : null;
    }
}
class StreamsSequenceStream extends DecodeStream {
    constructor(e1, t = null){
        e1 = e1.filter((e1)=>e1 instanceof BaseStream);
        let i = 0;
        for (const t of e1)i += t instanceof DecodeStream ? t._rawMinBufferLength : t.length;
        super(i);
        this.streams = e1;
        this._onError = t;
    }
    readBlock() {
        const e1 = this.streams;
        if (0 === e1.length) {
            this.eof = !0;
            return;
        }
        const t = e1.shift();
        let i;
        try {
            i = t.getBytes();
        } catch (e1) {
            if (this._onError) {
                this._onError(e1, t.dict?.objId);
                return;
            }
            throw e1;
        }
        const a = this.bufferLength, s = a + i.length;
        this.ensureBuffer(s).set(i, a);
        this.bufferLength = s;
    }
    getBaseStreams() {
        const e1 = [];
        for (const t of this.streams){
            const i = t.getBaseStreams();
            i && e1.push(...i);
        }
        return e1.length > 0 ? e1 : null;
    }
}
class Ascii85Stream extends DecodeStream {
    constructor(e1, t){
        t && (t *= .8);
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        this.input = new Uint8Array(5);
    }
    readBlock() {
        const e1 = this.str;
        let t = e1.getByte();
        for(; isWhiteSpace(t);)t = e1.getByte();
        if (-1 === t || 126 === t) {
            this.eof = !0;
            return;
        }
        const i = this.bufferLength;
        let a, s;
        if (122 === t) {
            a = this.ensureBuffer(i + 4);
            for(s = 0; s < 4; ++s)a[i + s] = 0;
            this.bufferLength += 4;
        } else {
            const r = this.input;
            r[0] = t;
            for(s = 1; s < 5; ++s){
                t = e1.getByte();
                for(; isWhiteSpace(t);)t = e1.getByte();
                r[s] = t;
                if (-1 === t || 126 === t) break;
            }
            a = this.ensureBuffer(i + s - 1);
            this.bufferLength += s - 1;
            if (s < 5) {
                for(; s < 5; ++s)r[s] = 117;
                this.eof = !0;
            }
            let n = 0;
            for(s = 0; s < 5; ++s)n = 85 * n + (r[s] - 33);
            for(s = 3; s >= 0; --s){
                a[i + s] = 255 & n;
                n >>= 8;
            }
        }
    }
}
class AsciiHexStream extends DecodeStream {
    constructor(e1, t){
        t && (t *= .5);
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        this.firstDigit = -1;
    }
    readBlock() {
        const e1 = this.str.getBytes(8e3);
        if (!e1.length) {
            this.eof = !0;
            return;
        }
        const t = e1.length + 1 >> 1, i = this.ensureBuffer(this.bufferLength + t);
        let a = this.bufferLength, s = this.firstDigit;
        for (const t of e1){
            let e1;
            if (t >= 48 && t <= 57) e1 = 15 & t;
            else {
                if (!(t >= 65 && t <= 70 || t >= 97 && t <= 102)) {
                    if (62 === t) {
                        this.eof = !0;
                        break;
                    }
                    continue;
                }
                e1 = 9 + (15 & t);
            }
            if (s < 0) s = e1;
            else {
                i[a++] = s << 4 | e1;
                s = -1;
            }
        }
        if (s >= 0 && this.eof) {
            i[a++] = s << 4;
            s = -1;
        }
        this.firstDigit = s;
        this.bufferLength = a;
    }
}
const bt = -1, Ft = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        7,
        8
    ],
    [
        7,
        7
    ],
    [
        6,
        6
    ],
    [
        6,
        6
    ],
    [
        6,
        5
    ],
    [
        6,
        5
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ]
], St = [
    [
        -1,
        -1
    ],
    [
        12,
        -2
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        12,
        1984
    ],
    [
        12,
        2048
    ],
    [
        12,
        2112
    ],
    [
        12,
        2176
    ],
    [
        12,
        2240
    ],
    [
        12,
        2304
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        12,
        2368
    ],
    [
        12,
        2432
    ],
    [
        12,
        2496
    ],
    [
        12,
        2560
    ]
], kt = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        8,
        29
    ],
    [
        8,
        29
    ],
    [
        8,
        30
    ],
    [
        8,
        30
    ],
    [
        8,
        45
    ],
    [
        8,
        45
    ],
    [
        8,
        46
    ],
    [
        8,
        46
    ],
    [
        7,
        22
    ],
    [
        7,
        22
    ],
    [
        7,
        22
    ],
    [
        7,
        22
    ],
    [
        7,
        23
    ],
    [
        7,
        23
    ],
    [
        7,
        23
    ],
    [
        7,
        23
    ],
    [
        8,
        47
    ],
    [
        8,
        47
    ],
    [
        8,
        48
    ],
    [
        8,
        48
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        7,
        20
    ],
    [
        7,
        20
    ],
    [
        7,
        20
    ],
    [
        7,
        20
    ],
    [
        8,
        33
    ],
    [
        8,
        33
    ],
    [
        8,
        34
    ],
    [
        8,
        34
    ],
    [
        8,
        35
    ],
    [
        8,
        35
    ],
    [
        8,
        36
    ],
    [
        8,
        36
    ],
    [
        8,
        37
    ],
    [
        8,
        37
    ],
    [
        8,
        38
    ],
    [
        8,
        38
    ],
    [
        7,
        19
    ],
    [
        7,
        19
    ],
    [
        7,
        19
    ],
    [
        7,
        19
    ],
    [
        8,
        31
    ],
    [
        8,
        31
    ],
    [
        8,
        32
    ],
    [
        8,
        32
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        8,
        53
    ],
    [
        8,
        53
    ],
    [
        8,
        54
    ],
    [
        8,
        54
    ],
    [
        7,
        26
    ],
    [
        7,
        26
    ],
    [
        7,
        26
    ],
    [
        7,
        26
    ],
    [
        8,
        39
    ],
    [
        8,
        39
    ],
    [
        8,
        40
    ],
    [
        8,
        40
    ],
    [
        8,
        41
    ],
    [
        8,
        41
    ],
    [
        8,
        42
    ],
    [
        8,
        42
    ],
    [
        8,
        43
    ],
    [
        8,
        43
    ],
    [
        8,
        44
    ],
    [
        8,
        44
    ],
    [
        7,
        21
    ],
    [
        7,
        21
    ],
    [
        7,
        21
    ],
    [
        7,
        21
    ],
    [
        7,
        28
    ],
    [
        7,
        28
    ],
    [
        7,
        28
    ],
    [
        7,
        28
    ],
    [
        8,
        61
    ],
    [
        8,
        61
    ],
    [
        8,
        62
    ],
    [
        8,
        62
    ],
    [
        8,
        63
    ],
    [
        8,
        63
    ],
    [
        8,
        0
    ],
    [
        8,
        0
    ],
    [
        8,
        320
    ],
    [
        8,
        320
    ],
    [
        8,
        384
    ],
    [
        8,
        384
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        7,
        27
    ],
    [
        7,
        27
    ],
    [
        7,
        27
    ],
    [
        7,
        27
    ],
    [
        8,
        59
    ],
    [
        8,
        59
    ],
    [
        8,
        60
    ],
    [
        8,
        60
    ],
    [
        9,
        1472
    ],
    [
        9,
        1536
    ],
    [
        9,
        1600
    ],
    [
        9,
        1728
    ],
    [
        7,
        18
    ],
    [
        7,
        18
    ],
    [
        7,
        18
    ],
    [
        7,
        18
    ],
    [
        7,
        24
    ],
    [
        7,
        24
    ],
    [
        7,
        24
    ],
    [
        7,
        24
    ],
    [
        8,
        49
    ],
    [
        8,
        49
    ],
    [
        8,
        50
    ],
    [
        8,
        50
    ],
    [
        8,
        51
    ],
    [
        8,
        51
    ],
    [
        8,
        52
    ],
    [
        8,
        52
    ],
    [
        7,
        25
    ],
    [
        7,
        25
    ],
    [
        7,
        25
    ],
    [
        7,
        25
    ],
    [
        8,
        55
    ],
    [
        8,
        55
    ],
    [
        8,
        56
    ],
    [
        8,
        56
    ],
    [
        8,
        57
    ],
    [
        8,
        57
    ],
    [
        8,
        58
    ],
    [
        8,
        58
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        8,
        448
    ],
    [
        8,
        448
    ],
    [
        8,
        512
    ],
    [
        8,
        512
    ],
    [
        9,
        704
    ],
    [
        9,
        768
    ],
    [
        8,
        640
    ],
    [
        8,
        640
    ],
    [
        8,
        576
    ],
    [
        8,
        576
    ],
    [
        9,
        832
    ],
    [
        9,
        896
    ],
    [
        9,
        960
    ],
    [
        9,
        1024
    ],
    [
        9,
        1088
    ],
    [
        9,
        1152
    ],
    [
        9,
        1216
    ],
    [
        9,
        1280
    ],
    [
        9,
        1344
    ],
    [
        9,
        1408
    ],
    [
        7,
        256
    ],
    [
        7,
        256
    ],
    [
        7,
        256
    ],
    [
        7,
        256
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ]
], Rt = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        12,
        -2
    ],
    [
        12,
        -2
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        12,
        1984
    ],
    [
        12,
        1984
    ],
    [
        12,
        2048
    ],
    [
        12,
        2048
    ],
    [
        12,
        2112
    ],
    [
        12,
        2112
    ],
    [
        12,
        2176
    ],
    [
        12,
        2176
    ],
    [
        12,
        2240
    ],
    [
        12,
        2240
    ],
    [
        12,
        2304
    ],
    [
        12,
        2304
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        12,
        2368
    ],
    [
        12,
        2368
    ],
    [
        12,
        2432
    ],
    [
        12,
        2432
    ],
    [
        12,
        2496
    ],
    [
        12,
        2496
    ],
    [
        12,
        2560
    ],
    [
        12,
        2560
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        12,
        52
    ],
    [
        12,
        52
    ],
    [
        13,
        640
    ],
    [
        13,
        704
    ],
    [
        13,
        768
    ],
    [
        13,
        832
    ],
    [
        12,
        55
    ],
    [
        12,
        55
    ],
    [
        12,
        56
    ],
    [
        12,
        56
    ],
    [
        13,
        1280
    ],
    [
        13,
        1344
    ],
    [
        13,
        1408
    ],
    [
        13,
        1472
    ],
    [
        12,
        59
    ],
    [
        12,
        59
    ],
    [
        12,
        60
    ],
    [
        12,
        60
    ],
    [
        13,
        1536
    ],
    [
        13,
        1600
    ],
    [
        11,
        24
    ],
    [
        11,
        24
    ],
    [
        11,
        24
    ],
    [
        11,
        24
    ],
    [
        11,
        25
    ],
    [
        11,
        25
    ],
    [
        11,
        25
    ],
    [
        11,
        25
    ],
    [
        13,
        1664
    ],
    [
        13,
        1728
    ],
    [
        12,
        320
    ],
    [
        12,
        320
    ],
    [
        12,
        384
    ],
    [
        12,
        384
    ],
    [
        12,
        448
    ],
    [
        12,
        448
    ],
    [
        13,
        512
    ],
    [
        13,
        576
    ],
    [
        12,
        53
    ],
    [
        12,
        53
    ],
    [
        12,
        54
    ],
    [
        12,
        54
    ],
    [
        13,
        896
    ],
    [
        13,
        960
    ],
    [
        13,
        1024
    ],
    [
        13,
        1088
    ],
    [
        13,
        1152
    ],
    [
        13,
        1216
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ]
], Nt = [
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        11,
        23
    ],
    [
        11,
        23
    ],
    [
        12,
        50
    ],
    [
        12,
        51
    ],
    [
        12,
        44
    ],
    [
        12,
        45
    ],
    [
        12,
        46
    ],
    [
        12,
        47
    ],
    [
        12,
        57
    ],
    [
        12,
        58
    ],
    [
        12,
        61
    ],
    [
        12,
        256
    ],
    [
        10,
        16
    ],
    [
        10,
        16
    ],
    [
        10,
        16
    ],
    [
        10,
        16
    ],
    [
        10,
        17
    ],
    [
        10,
        17
    ],
    [
        10,
        17
    ],
    [
        10,
        17
    ],
    [
        12,
        48
    ],
    [
        12,
        49
    ],
    [
        12,
        62
    ],
    [
        12,
        63
    ],
    [
        12,
        30
    ],
    [
        12,
        31
    ],
    [
        12,
        32
    ],
    [
        12,
        33
    ],
    [
        12,
        40
    ],
    [
        12,
        41
    ],
    [
        11,
        22
    ],
    [
        11,
        22
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        12,
        128
    ],
    [
        12,
        192
    ],
    [
        12,
        26
    ],
    [
        12,
        27
    ],
    [
        12,
        28
    ],
    [
        12,
        29
    ],
    [
        11,
        19
    ],
    [
        11,
        19
    ],
    [
        11,
        20
    ],
    [
        11,
        20
    ],
    [
        12,
        34
    ],
    [
        12,
        35
    ],
    [
        12,
        36
    ],
    [
        12,
        37
    ],
    [
        12,
        38
    ],
    [
        12,
        39
    ],
    [
        11,
        21
    ],
    [
        11,
        21
    ],
    [
        12,
        42
    ],
    [
        12,
        43
    ],
    [
        10,
        0
    ],
    [
        10,
        0
    ],
    [
        10,
        0
    ],
    [
        10,
        0
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ]
], Gt = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        6,
        9
    ],
    [
        6,
        8
    ],
    [
        5,
        7
    ],
    [
        5,
        7
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ]
];
class CCITTFaxDecoder {
    constructor(e1, t = {}){
        if ("function" != typeof e1?.next) throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
        this.source = e1;
        this.eof = !1;
        this.encoding = t.K || 0;
        this.eoline = t.EndOfLine || !1;
        this.byteAlign = t.EncodedByteAlign || !1;
        this.columns = t.Columns || 1728;
        this.rows = t.Rows || 0;
        this.eoblock = t.EndOfBlock ?? !0;
        this.black = t.BlackIs1 || !1;
        this.codingLine = new Uint32Array(this.columns + 1);
        this.refLine = new Uint32Array(this.columns + 2);
        this.codingLine[0] = this.columns;
        this.codingPos = 0;
        this.row = 0;
        this.nextLine2D = this.encoding < 0;
        this.inputBits = 0;
        this.inputBuf = 0;
        this.outputBits = 0;
        this.rowsDone = !1;
        let i;
        for(; 0 === (i = this._lookBits(12));)this._eatBits(1);
        1 === i && this._eatBits(12);
        if (this.encoding > 0) {
            this.nextLine2D = !this._lookBits(1);
            this._eatBits(1);
        }
    }
    readNextChar() {
        if (this.eof) return -1;
        const e1 = this.refLine, t = this.codingLine, i = this.columns;
        let a, s, r, n, g;
        if (0 === this.outputBits) {
            this.rowsDone && (this.eof = !0);
            if (this.eof) return -1;
            this.err = !1;
            let r, g, o;
            if (this.nextLine2D) {
                for(n = 0; t[n] < i; ++n)e1[n] = t[n];
                e1[n++] = i;
                e1[n] = i;
                t[0] = 0;
                this.codingPos = 0;
                a = 0;
                s = 0;
                for(; t[this.codingPos] < i;){
                    r = this._getTwoDimCode();
                    switch(r){
                        case 0:
                            this._addPixels(e1[a + 1], s);
                            e1[a + 1] < i && (a += 2);
                            break;
                        case 1:
                            r = g = 0;
                            if (s) {
                                do {
                                    r += o = this._getBlackCode();
                                }while (o >= 64)
                                do {
                                    g += o = this._getWhiteCode();
                                }while (o >= 64)
                            } else {
                                do {
                                    r += o = this._getWhiteCode();
                                }while (o >= 64)
                                do {
                                    g += o = this._getBlackCode();
                                }while (o >= 64)
                            }
                            this._addPixels(t[this.codingPos] + r, s);
                            t[this.codingPos] < i && this._addPixels(t[this.codingPos] + g, 1 ^ s);
                            for(; e1[a] <= t[this.codingPos] && e1[a] < i;)a += 2;
                            break;
                        case 7:
                            this._addPixels(e1[a] + 3, s);
                            s ^= 1;
                            if (t[this.codingPos] < i) {
                                ++a;
                                for(; e1[a] <= t[this.codingPos] && e1[a] < i;)a += 2;
                            }
                            break;
                        case 5:
                            this._addPixels(e1[a] + 2, s);
                            s ^= 1;
                            if (t[this.codingPos] < i) {
                                ++a;
                                for(; e1[a] <= t[this.codingPos] && e1[a] < i;)a += 2;
                            }
                            break;
                        case 3:
                            this._addPixels(e1[a] + 1, s);
                            s ^= 1;
                            if (t[this.codingPos] < i) {
                                ++a;
                                for(; e1[a] <= t[this.codingPos] && e1[a] < i;)a += 2;
                            }
                            break;
                        case 2:
                            this._addPixels(e1[a], s);
                            s ^= 1;
                            if (t[this.codingPos] < i) {
                                ++a;
                                for(; e1[a] <= t[this.codingPos] && e1[a] < i;)a += 2;
                            }
                            break;
                        case 8:
                            this._addPixelsNeg(e1[a] - 3, s);
                            s ^= 1;
                            if (t[this.codingPos] < i) {
                                a > 0 ? --a : ++a;
                                for(; e1[a] <= t[this.codingPos] && e1[a] < i;)a += 2;
                            }
                            break;
                        case 6:
                            this._addPixelsNeg(e1[a] - 2, s);
                            s ^= 1;
                            if (t[this.codingPos] < i) {
                                a > 0 ? --a : ++a;
                                for(; e1[a] <= t[this.codingPos] && e1[a] < i;)a += 2;
                            }
                            break;
                        case 4:
                            this._addPixelsNeg(e1[a] - 1, s);
                            s ^= 1;
                            if (t[this.codingPos] < i) {
                                a > 0 ? --a : ++a;
                                for(; e1[a] <= t[this.codingPos] && e1[a] < i;)a += 2;
                            }
                            break;
                        case bt:
                            this._addPixels(i, 0);
                            this.eof = !0;
                            break;
                        default:
                            info("bad 2d code");
                            this._addPixels(i, 0);
                            this.err = !0;
                    }
                }
            } else {
                t[0] = 0;
                this.codingPos = 0;
                s = 0;
                for(; t[this.codingPos] < i;){
                    r = 0;
                    if (s) do {
                        r += o = this._getBlackCode();
                    }while (o >= 64)
                    else do {
                        r += o = this._getWhiteCode();
                    }while (o >= 64)
                    this._addPixels(t[this.codingPos] + r, s);
                    s ^= 1;
                }
            }
            let c = !1;
            this.byteAlign && (this.inputBits &= -8);
            if (this.eoblock || this.row !== this.rows - 1) {
                r = this._lookBits(12);
                if (this.eoline) for(; r !== bt && 1 !== r;){
                    this._eatBits(1);
                    r = this._lookBits(12);
                }
                else for(; 0 === r;){
                    this._eatBits(1);
                    r = this._lookBits(12);
                }
                if (1 === r) {
                    this._eatBits(12);
                    c = !0;
                } else r === bt && (this.eof = !0);
            } else this.rowsDone = !0;
            if (!this.eof && this.encoding > 0 && !this.rowsDone) {
                this.nextLine2D = !this._lookBits(1);
                this._eatBits(1);
            }
            if (this.eoblock && c && this.byteAlign) {
                r = this._lookBits(12);
                if (1 === r) {
                    this._eatBits(12);
                    if (this.encoding > 0) {
                        this._lookBits(1);
                        this._eatBits(1);
                    }
                    if (this.encoding >= 0) for(n = 0; n < 4; ++n){
                        r = this._lookBits(12);
                        1 !== r && info("bad rtc code: " + r);
                        this._eatBits(12);
                        if (this.encoding > 0) {
                            this._lookBits(1);
                            this._eatBits(1);
                        }
                    }
                    this.eof = !0;
                }
            } else if (this.err && this.eoline) {
                for(;;){
                    r = this._lookBits(13);
                    if (r === bt) {
                        this.eof = !0;
                        return -1;
                    }
                    if (r >> 1 == 1) break;
                    this._eatBits(1);
                }
                this._eatBits(12);
                if (this.encoding > 0) {
                    this._eatBits(1);
                    this.nextLine2D = !(1 & r);
                }
            }
            this.outputBits = t[0] > 0 ? t[this.codingPos = 0] : t[this.codingPos = 1];
            this.row++;
        }
        if (this.outputBits >= 8) {
            g = 1 & this.codingPos ? 0 : 255;
            this.outputBits -= 8;
            if (0 === this.outputBits && t[this.codingPos] < i) {
                this.codingPos++;
                this.outputBits = t[this.codingPos] - t[this.codingPos - 1];
            }
        } else {
            r = 8;
            g = 0;
            do {
                if ("number" != typeof this.outputBits) throw new FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                if (this.outputBits > r) {
                    g <<= r;
                    1 & this.codingPos || (g |= 255 >> 8 - r);
                    this.outputBits -= r;
                    r = 0;
                } else {
                    g <<= this.outputBits;
                    1 & this.codingPos || (g |= 255 >> 8 - this.outputBits);
                    r -= this.outputBits;
                    this.outputBits = 0;
                    if (t[this.codingPos] < i) {
                        this.codingPos++;
                        this.outputBits = t[this.codingPos] - t[this.codingPos - 1];
                    } else if (r > 0) {
                        g <<= r;
                        r = 0;
                    }
                }
            }while (r)
        }
        this.black && (g ^= 255);
        return g;
    }
    _addPixels(e1, t) {
        const i = this.codingLine;
        let a = this.codingPos;
        if (e1 > i[a]) {
            if (e1 > this.columns) {
                info("row is wrong length");
                this.err = !0;
                e1 = this.columns;
            }
            1 & a ^ t && ++a;
            i[a] = e1;
        }
        this.codingPos = a;
    }
    _addPixelsNeg(e1, t) {
        const i = this.codingLine;
        let a = this.codingPos;
        if (e1 > i[a]) {
            if (e1 > this.columns) {
                info("row is wrong length");
                this.err = !0;
                e1 = this.columns;
            }
            1 & a ^ t && ++a;
            i[a] = e1;
        } else if (e1 < i[a]) {
            if (e1 < 0) {
                info("invalid code");
                this.err = !0;
                e1 = 0;
            }
            for(; a > 0 && e1 < i[a - 1];)--a;
            i[a] = e1;
        }
        this.codingPos = a;
    }
    _findTableCode(e1, t, i, a) {
        const s = a || 0;
        for(let a = e1; a <= t; ++a){
            let e1 = this._lookBits(a);
            if (e1 === bt) return [
                !0,
                1,
                !1
            ];
            a < t && (e1 <<= t - a);
            if (!s || e1 >= s) {
                const t = i[e1 - s];
                if (t[0] === a) {
                    this._eatBits(a);
                    return [
                        !0,
                        t[1],
                        !0
                    ];
                }
            }
        }
        return [
            !1,
            0,
            !1
        ];
    }
    _getTwoDimCode() {
        let e1, t = 0;
        if (this.eoblock) {
            t = this._lookBits(7);
            e1 = Ft[t];
            if (e1?.[0] > 0) {
                this._eatBits(e1[0]);
                return e1[1];
            }
        } else {
            const e1 = this._findTableCode(1, 7, Ft);
            if (e1[0] && e1[2]) return e1[1];
        }
        info("Bad two dim code");
        return bt;
    }
    _getWhiteCode() {
        let e1, t = 0;
        if (this.eoblock) {
            t = this._lookBits(12);
            if (t === bt) return 1;
            e1 = t >> 5 ? kt[t >> 3] : St[t];
            if (e1[0] > 0) {
                this._eatBits(e1[0]);
                return e1[1];
            }
        } else {
            let e1 = this._findTableCode(1, 9, kt);
            if (e1[0]) return e1[1];
            e1 = this._findTableCode(11, 12, St);
            if (e1[0]) return e1[1];
        }
        info("bad white code");
        this._eatBits(1);
        return 1;
    }
    _getBlackCode() {
        let e1, t;
        if (this.eoblock) {
            e1 = this._lookBits(13);
            if (e1 === bt) return 1;
            t = e1 >> 7 ? !(e1 >> 9) && e1 >> 7 ? Nt[(e1 >> 1) - 64] : Gt[e1 >> 7] : Rt[e1];
            if (t[0] > 0) {
                this._eatBits(t[0]);
                return t[1];
            }
        } else {
            let e1 = this._findTableCode(2, 6, Gt);
            if (e1[0]) return e1[1];
            e1 = this._findTableCode(7, 12, Nt, 64);
            if (e1[0]) return e1[1];
            e1 = this._findTableCode(10, 13, Rt);
            if (e1[0]) return e1[1];
        }
        info("bad black code");
        this._eatBits(1);
        return 1;
    }
    _lookBits(e1) {
        let t;
        for(; this.inputBits < e1;){
            if (-1 === (t = this.source.next())) return 0 === this.inputBits ? bt : this.inputBuf << e1 - this.inputBits & 65535 >> 16 - e1;
            this.inputBuf = this.inputBuf << 8 | t;
            this.inputBits += 8;
        }
        return this.inputBuf >> this.inputBits - e1 & 65535 >> 16 - e1;
    }
    _eatBits(e1) {
        (this.inputBits -= e1) < 0 && (this.inputBits = 0);
    }
}
class CCITTFaxStream extends DecodeStream {
    constructor(e1, t, i){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        i instanceof Dict || (i = Dict.empty);
        const a = {
            next: ()=>e1.getByte()
        };
        this.ccittFaxDecoder = new CCITTFaxDecoder(a, {
            K: i.get("K"),
            EndOfLine: i.get("EndOfLine"),
            EncodedByteAlign: i.get("EncodedByteAlign"),
            Columns: i.get("Columns"),
            Rows: i.get("Rows"),
            EndOfBlock: i.get("EndOfBlock"),
            BlackIs1: i.get("BlackIs1")
        });
    }
    readBlock() {
        for(; !this.eof;){
            const e1 = this.ccittFaxDecoder.readNextChar();
            if (-1 === e1) {
                this.eof = !0;
                return;
            }
            this.ensureBuffer(this.bufferLength + 1);
            this.buffer[this.bufferLength++] = e1;
        }
    }
}
const Mt = new Int32Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]), Ut = new Int32Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    65547,
    65549,
    65551,
    65553,
    131091,
    131095,
    131099,
    131103,
    196643,
    196651,
    196659,
    196667,
    262211,
    262227,
    262243,
    262259,
    327811,
    327843,
    327875,
    327907,
    258,
    258,
    258
]), xt = new Int32Array([
    1,
    2,
    3,
    4,
    65541,
    65543,
    131081,
    131085,
    196625,
    196633,
    262177,
    262193,
    327745,
    327777,
    393345,
    393409,
    459009,
    459137,
    524801,
    525057,
    590849,
    591361,
    657409,
    658433,
    724993,
    727041,
    794625,
    798721,
    868353,
    876545
]), Lt = [
    new Int32Array([
        459008,
        524368,
        524304,
        524568,
        459024,
        524400,
        524336,
        590016,
        459016,
        524384,
        524320,
        589984,
        524288,
        524416,
        524352,
        590048,
        459012,
        524376,
        524312,
        589968,
        459028,
        524408,
        524344,
        590032,
        459020,
        524392,
        524328,
        59e4,
        524296,
        524424,
        524360,
        590064,
        459010,
        524372,
        524308,
        524572,
        459026,
        524404,
        524340,
        590024,
        459018,
        524388,
        524324,
        589992,
        524292,
        524420,
        524356,
        590056,
        459014,
        524380,
        524316,
        589976,
        459030,
        524412,
        524348,
        590040,
        459022,
        524396,
        524332,
        590008,
        524300,
        524428,
        524364,
        590072,
        459009,
        524370,
        524306,
        524570,
        459025,
        524402,
        524338,
        590020,
        459017,
        524386,
        524322,
        589988,
        524290,
        524418,
        524354,
        590052,
        459013,
        524378,
        524314,
        589972,
        459029,
        524410,
        524346,
        590036,
        459021,
        524394,
        524330,
        590004,
        524298,
        524426,
        524362,
        590068,
        459011,
        524374,
        524310,
        524574,
        459027,
        524406,
        524342,
        590028,
        459019,
        524390,
        524326,
        589996,
        524294,
        524422,
        524358,
        590060,
        459015,
        524382,
        524318,
        589980,
        459031,
        524414,
        524350,
        590044,
        459023,
        524398,
        524334,
        590012,
        524302,
        524430,
        524366,
        590076,
        459008,
        524369,
        524305,
        524569,
        459024,
        524401,
        524337,
        590018,
        459016,
        524385,
        524321,
        589986,
        524289,
        524417,
        524353,
        590050,
        459012,
        524377,
        524313,
        589970,
        459028,
        524409,
        524345,
        590034,
        459020,
        524393,
        524329,
        590002,
        524297,
        524425,
        524361,
        590066,
        459010,
        524373,
        524309,
        524573,
        459026,
        524405,
        524341,
        590026,
        459018,
        524389,
        524325,
        589994,
        524293,
        524421,
        524357,
        590058,
        459014,
        524381,
        524317,
        589978,
        459030,
        524413,
        524349,
        590042,
        459022,
        524397,
        524333,
        590010,
        524301,
        524429,
        524365,
        590074,
        459009,
        524371,
        524307,
        524571,
        459025,
        524403,
        524339,
        590022,
        459017,
        524387,
        524323,
        589990,
        524291,
        524419,
        524355,
        590054,
        459013,
        524379,
        524315,
        589974,
        459029,
        524411,
        524347,
        590038,
        459021,
        524395,
        524331,
        590006,
        524299,
        524427,
        524363,
        590070,
        459011,
        524375,
        524311,
        524575,
        459027,
        524407,
        524343,
        590030,
        459019,
        524391,
        524327,
        589998,
        524295,
        524423,
        524359,
        590062,
        459015,
        524383,
        524319,
        589982,
        459031,
        524415,
        524351,
        590046,
        459023,
        524399,
        524335,
        590014,
        524303,
        524431,
        524367,
        590078,
        459008,
        524368,
        524304,
        524568,
        459024,
        524400,
        524336,
        590017,
        459016,
        524384,
        524320,
        589985,
        524288,
        524416,
        524352,
        590049,
        459012,
        524376,
        524312,
        589969,
        459028,
        524408,
        524344,
        590033,
        459020,
        524392,
        524328,
        590001,
        524296,
        524424,
        524360,
        590065,
        459010,
        524372,
        524308,
        524572,
        459026,
        524404,
        524340,
        590025,
        459018,
        524388,
        524324,
        589993,
        524292,
        524420,
        524356,
        590057,
        459014,
        524380,
        524316,
        589977,
        459030,
        524412,
        524348,
        590041,
        459022,
        524396,
        524332,
        590009,
        524300,
        524428,
        524364,
        590073,
        459009,
        524370,
        524306,
        524570,
        459025,
        524402,
        524338,
        590021,
        459017,
        524386,
        524322,
        589989,
        524290,
        524418,
        524354,
        590053,
        459013,
        524378,
        524314,
        589973,
        459029,
        524410,
        524346,
        590037,
        459021,
        524394,
        524330,
        590005,
        524298,
        524426,
        524362,
        590069,
        459011,
        524374,
        524310,
        524574,
        459027,
        524406,
        524342,
        590029,
        459019,
        524390,
        524326,
        589997,
        524294,
        524422,
        524358,
        590061,
        459015,
        524382,
        524318,
        589981,
        459031,
        524414,
        524350,
        590045,
        459023,
        524398,
        524334,
        590013,
        524302,
        524430,
        524366,
        590077,
        459008,
        524369,
        524305,
        524569,
        459024,
        524401,
        524337,
        590019,
        459016,
        524385,
        524321,
        589987,
        524289,
        524417,
        524353,
        590051,
        459012,
        524377,
        524313,
        589971,
        459028,
        524409,
        524345,
        590035,
        459020,
        524393,
        524329,
        590003,
        524297,
        524425,
        524361,
        590067,
        459010,
        524373,
        524309,
        524573,
        459026,
        524405,
        524341,
        590027,
        459018,
        524389,
        524325,
        589995,
        524293,
        524421,
        524357,
        590059,
        459014,
        524381,
        524317,
        589979,
        459030,
        524413,
        524349,
        590043,
        459022,
        524397,
        524333,
        590011,
        524301,
        524429,
        524365,
        590075,
        459009,
        524371,
        524307,
        524571,
        459025,
        524403,
        524339,
        590023,
        459017,
        524387,
        524323,
        589991,
        524291,
        524419,
        524355,
        590055,
        459013,
        524379,
        524315,
        589975,
        459029,
        524411,
        524347,
        590039,
        459021,
        524395,
        524331,
        590007,
        524299,
        524427,
        524363,
        590071,
        459011,
        524375,
        524311,
        524575,
        459027,
        524407,
        524343,
        590031,
        459019,
        524391,
        524327,
        589999,
        524295,
        524423,
        524359,
        590063,
        459015,
        524383,
        524319,
        589983,
        459031,
        524415,
        524351,
        590047,
        459023,
        524399,
        524335,
        590015,
        524303,
        524431,
        524367,
        590079
    ]),
    9
], Ht = [
    new Int32Array([
        327680,
        327696,
        327688,
        327704,
        327684,
        327700,
        327692,
        327708,
        327682,
        327698,
        327690,
        327706,
        327686,
        327702,
        327694,
        0,
        327681,
        327697,
        327689,
        327705,
        327685,
        327701,
        327693,
        327709,
        327683,
        327699,
        327691,
        327707,
        327687,
        327703,
        327695,
        0
    ]),
    5
];
class FlateStream extends DecodeStream {
    constructor(e1, t){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        const i = e1.getByte(), a = e1.getByte();
        if (-1 === i || -1 === a) throw new FormatError(`Invalid header in flate stream: ${i}, ${a}`);
        if (8 != (15 & i)) throw new FormatError(`Unknown compression method in flate stream: ${i}, ${a}`);
        if (((i << 8) + a) % 31 != 0) throw new FormatError(`Bad FCHECK in flate stream: ${i}, ${a}`);
        if (32 & a) throw new FormatError(`FDICT bit set in flate stream: ${i}, ${a}`);
        this.codeSize = 0;
        this.codeBuf = 0;
    }
    async getImageData(e1, t) {
        const i = await this.asyncGetBytes();
        return i?.subarray(0, e1) || this.getBytes(e1);
    }
    async asyncGetBytes() {
        this.str.reset();
        const e1 = this.str.getBytes();
        try {
            const { readable: t, writable: i } = new DecompressionStream("deflate"), a = i.getWriter();
            await a.ready;
            a.write(e1).then(async ()=>{
                await a.ready;
                await a.close();
            }).catch(()=>{});
            const s = [];
            let r = 0;
            for await (const e1 of t){
                s.push(e1);
                r += e1.byteLength;
            }
            const n = new Uint8Array(r);
            let g = 0;
            for (const e1 of s){
                n.set(e1, g);
                g += e1.byteLength;
            }
            return n;
        } catch  {
            this.str = new Stream(e1, 2, e1.length, this.str.dict);
            this.reset();
            return null;
        }
    }
    get isAsync() {
        return !0;
    }
    getBits(e1) {
        const t = this.str;
        let i, a = this.codeSize, s = this.codeBuf;
        for(; a < e1;){
            if (-1 === (i = t.getByte())) throw new FormatError("Bad encoding in flate stream");
            s |= i << a;
            a += 8;
        }
        i = s & (1 << e1) - 1;
        this.codeBuf = s >> e1;
        this.codeSize = a -= e1;
        return i;
    }
    getCode(e1) {
        const t = this.str, i = e1[0], a = e1[1];
        let s, r = this.codeSize, n = this.codeBuf;
        for(; r < a && -1 !== (s = t.getByte());){
            n |= s << r;
            r += 8;
        }
        const g = i[n & (1 << a) - 1], o = g >> 16, c = 65535 & g;
        if (o < 1 || r < o) throw new FormatError("Bad encoding in flate stream");
        this.codeBuf = n >> o;
        this.codeSize = r - o;
        return c;
    }
    generateHuffmanTable(e1) {
        const t = e1.length;
        let i, a = 0;
        for(i = 0; i < t; ++i)e1[i] > a && (a = e1[i]);
        const s = 1 << a, r = new Int32Array(s);
        for(let n = 1, g = 0, o = 2; n <= a; ++n, g <<= 1, o <<= 1)for(let a = 0; a < t; ++a)if (e1[a] === n) {
            let e1 = 0, t = g;
            for(i = 0; i < n; ++i){
                e1 = e1 << 1 | 1 & t;
                t >>= 1;
            }
            for(i = e1; i < s; i += o)r[i] = n << 16 | a;
            ++g;
        }
        return [
            r,
            a
        ];
    }
    #m(e1) {
        info(e1);
        this.eof = !0;
    }
    readBlock() {
        let e1, t, i;
        const a = this.str;
        try {
            t = this.getBits(3);
        } catch (e1) {
            this.#m(e1.message);
            return;
        }
        1 & t && (this.eof = !0);
        t >>= 1;
        if (0 === t) {
            let t;
            if (-1 === (t = a.getByte())) {
                this.#m("Bad block header in flate stream");
                return;
            }
            let i = t;
            if (-1 === (t = a.getByte())) {
                this.#m("Bad block header in flate stream");
                return;
            }
            i |= t << 8;
            if (-1 === (t = a.getByte())) {
                this.#m("Bad block header in flate stream");
                return;
            }
            let s = t;
            if (-1 === (t = a.getByte())) {
                this.#m("Bad block header in flate stream");
                return;
            }
            s |= t << 8;
            if (s !== (65535 & ~i) && (0 !== i || 0 !== s)) throw new FormatError("Bad uncompressed block length in flate stream");
            this.codeBuf = 0;
            this.codeSize = 0;
            const r = this.bufferLength, n = r + i;
            e1 = this.ensureBuffer(n);
            this.bufferLength = n;
            if (0 === i) -1 === a.peekByte() && (this.eof = !0);
            else {
                const t = a.getBytes(i);
                e1.set(t, r);
                t.length < i && (this.eof = !0);
            }
            return;
        }
        let s, r;
        if (1 === t) {
            s = Lt;
            r = Ht;
        } else {
            if (2 !== t) throw new FormatError("Unknown block type in flate stream");
            {
                const e1 = this.getBits(5) + 257, t = this.getBits(5) + 1, a = this.getBits(4) + 4, n = new Uint8Array(Mt.length);
                let g;
                for(g = 0; g < a; ++g)n[Mt[g]] = this.getBits(3);
                const o = this.generateHuffmanTable(n);
                i = 0;
                g = 0;
                const c = e1 + t, C = new Uint8Array(c);
                let h, l, Q;
                for(; g < c;){
                    const e1 = this.getCode(o);
                    if (16 === e1) {
                        h = 2;
                        l = 3;
                        Q = i;
                    } else if (17 === e1) {
                        h = 3;
                        l = 3;
                        Q = i = 0;
                    } else {
                        if (18 !== e1) {
                            C[g++] = i = e1;
                            continue;
                        }
                        h = 7;
                        l = 11;
                        Q = i = 0;
                    }
                    let t = this.getBits(h) + l;
                    for(; t-- > 0;)C[g++] = Q;
                }
                s = this.generateHuffmanTable(C.subarray(0, e1));
                r = this.generateHuffmanTable(C.subarray(e1, c));
            }
        }
        e1 = this.buffer;
        let n = e1 ? e1.length : 0, g = this.bufferLength;
        for(;;){
            let t = this.getCode(s);
            if (t < 256) {
                if (g + 1 >= n) {
                    e1 = this.ensureBuffer(g + 1);
                    n = e1.length;
                }
                e1[g++] = t;
                continue;
            }
            if (256 === t) {
                this.bufferLength = g;
                return;
            }
            t -= 257;
            t = Ut[t];
            let a = t >> 16;
            a > 0 && (a = this.getBits(a));
            i = (65535 & t) + a;
            t = this.getCode(r);
            t = xt[t];
            a = t >> 16;
            a > 0 && (a = this.getBits(a));
            const o = (65535 & t) + a;
            if (g + i >= n) {
                e1 = this.ensureBuffer(g + i);
                n = e1.length;
            }
            for(let t = 0; t < i; ++t, ++g)e1[g] = e1[g - o];
        }
    }
}
const Jt = [
    {
        qe: 22017,
        nmps: 1,
        nlps: 1,
        switchFlag: 1
    },
    {
        qe: 13313,
        nmps: 2,
        nlps: 6,
        switchFlag: 0
    },
    {
        qe: 6145,
        nmps: 3,
        nlps: 9,
        switchFlag: 0
    },
    {
        qe: 2753,
        nmps: 4,
        nlps: 12,
        switchFlag: 0
    },
    {
        qe: 1313,
        nmps: 5,
        nlps: 29,
        switchFlag: 0
    },
    {
        qe: 545,
        nmps: 38,
        nlps: 33,
        switchFlag: 0
    },
    {
        qe: 22017,
        nmps: 7,
        nlps: 6,
        switchFlag: 1
    },
    {
        qe: 21505,
        nmps: 8,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 18433,
        nmps: 9,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 14337,
        nmps: 10,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 12289,
        nmps: 11,
        nlps: 17,
        switchFlag: 0
    },
    {
        qe: 9217,
        nmps: 12,
        nlps: 18,
        switchFlag: 0
    },
    {
        qe: 7169,
        nmps: 13,
        nlps: 20,
        switchFlag: 0
    },
    {
        qe: 5633,
        nmps: 29,
        nlps: 21,
        switchFlag: 0
    },
    {
        qe: 22017,
        nmps: 15,
        nlps: 14,
        switchFlag: 1
    },
    {
        qe: 21505,
        nmps: 16,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 20737,
        nmps: 17,
        nlps: 15,
        switchFlag: 0
    },
    {
        qe: 18433,
        nmps: 18,
        nlps: 16,
        switchFlag: 0
    },
    {
        qe: 14337,
        nmps: 19,
        nlps: 17,
        switchFlag: 0
    },
    {
        qe: 13313,
        nmps: 20,
        nlps: 18,
        switchFlag: 0
    },
    {
        qe: 12289,
        nmps: 21,
        nlps: 19,
        switchFlag: 0
    },
    {
        qe: 10241,
        nmps: 22,
        nlps: 19,
        switchFlag: 0
    },
    {
        qe: 9217,
        nmps: 23,
        nlps: 20,
        switchFlag: 0
    },
    {
        qe: 8705,
        nmps: 24,
        nlps: 21,
        switchFlag: 0
    },
    {
        qe: 7169,
        nmps: 25,
        nlps: 22,
        switchFlag: 0
    },
    {
        qe: 6145,
        nmps: 26,
        nlps: 23,
        switchFlag: 0
    },
    {
        qe: 5633,
        nmps: 27,
        nlps: 24,
        switchFlag: 0
    },
    {
        qe: 5121,
        nmps: 28,
        nlps: 25,
        switchFlag: 0
    },
    {
        qe: 4609,
        nmps: 29,
        nlps: 26,
        switchFlag: 0
    },
    {
        qe: 4353,
        nmps: 30,
        nlps: 27,
        switchFlag: 0
    },
    {
        qe: 2753,
        nmps: 31,
        nlps: 28,
        switchFlag: 0
    },
    {
        qe: 2497,
        nmps: 32,
        nlps: 29,
        switchFlag: 0
    },
    {
        qe: 2209,
        nmps: 33,
        nlps: 30,
        switchFlag: 0
    },
    {
        qe: 1313,
        nmps: 34,
        nlps: 31,
        switchFlag: 0
    },
    {
        qe: 1089,
        nmps: 35,
        nlps: 32,
        switchFlag: 0
    },
    {
        qe: 673,
        nmps: 36,
        nlps: 33,
        switchFlag: 0
    },
    {
        qe: 545,
        nmps: 37,
        nlps: 34,
        switchFlag: 0
    },
    {
        qe: 321,
        nmps: 38,
        nlps: 35,
        switchFlag: 0
    },
    {
        qe: 273,
        nmps: 39,
        nlps: 36,
        switchFlag: 0
    },
    {
        qe: 133,
        nmps: 40,
        nlps: 37,
        switchFlag: 0
    },
    {
        qe: 73,
        nmps: 41,
        nlps: 38,
        switchFlag: 0
    },
    {
        qe: 37,
        nmps: 42,
        nlps: 39,
        switchFlag: 0
    },
    {
        qe: 21,
        nmps: 43,
        nlps: 40,
        switchFlag: 0
    },
    {
        qe: 9,
        nmps: 44,
        nlps: 41,
        switchFlag: 0
    },
    {
        qe: 5,
        nmps: 45,
        nlps: 42,
        switchFlag: 0
    },
    {
        qe: 1,
        nmps: 45,
        nlps: 43,
        switchFlag: 0
    },
    {
        qe: 22017,
        nmps: 46,
        nlps: 46,
        switchFlag: 0
    }
];
class ArithmeticDecoder {
    constructor(e1, t, i){
        this.data = e1;
        this.bp = t;
        this.dataEnd = i;
        this.chigh = e1[t];
        this.clow = 0;
        this.byteIn();
        this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
        this.clow = this.clow << 7 & 65535;
        this.ct -= 7;
        this.a = 32768;
    }
    byteIn() {
        const e1 = this.data;
        let t = this.bp;
        if (255 === e1[t]) if (e1[t + 1] > 143) {
            this.clow += 65280;
            this.ct = 8;
        } else {
            t++;
            this.clow += e1[t] << 9;
            this.ct = 7;
            this.bp = t;
        }
        else {
            t++;
            this.clow += t < this.dataEnd ? e1[t] << 8 : 65280;
            this.ct = 8;
            this.bp = t;
        }
        if (this.clow > 65535) {
            this.chigh += this.clow >> 16;
            this.clow &= 65535;
        }
    }
    readBit(e1, t) {
        let i = e1[t] >> 1, a = 1 & e1[t];
        const s = Jt[i], r = s.qe;
        let n, g = this.a - r;
        if (this.chigh < r) if (g < r) {
            g = r;
            n = a;
            i = s.nmps;
        } else {
            g = r;
            n = 1 ^ a;
            1 === s.switchFlag && (a = n);
            i = s.nlps;
        }
        else {
            this.chigh -= r;
            if (32768 & g) {
                this.a = g;
                return a;
            }
            if (g < r) {
                n = 1 ^ a;
                1 === s.switchFlag && (a = n);
                i = s.nlps;
            } else {
                n = a;
                i = s.nmps;
            }
        }
        do {
            0 === this.ct && this.byteIn();
            g <<= 1;
            this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
            this.clow = this.clow << 1 & 65535;
            this.ct--;
        }while (!(32768 & g))
        this.a = g;
        e1[t] = i << 1 | a;
        return n;
    }
}
class Jbig2Error extends ot {
    constructor(e1){
        super(e1, "Jbig2Error");
    }
}
class ContextCache {
    getContexts(e1) {
        return e1 in this ? this[e1] : this[e1] = new Int8Array(65536);
    }
}
class DecodingContext {
    constructor(e1, t, i){
        this.data = e1;
        this.start = t;
        this.end = i;
    }
    get decoder() {
        return shadow(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
    }
    get contextCache() {
        return shadow(this, "contextCache", new ContextCache);
    }
}
function decodeInteger(e1, t, i) {
    const a = e1.getContexts(t);
    let s = 1;
    function readBits(e1) {
        let t = 0;
        for(let r = 0; r < e1; r++){
            const e1 = i.readBit(a, s);
            s = s < 256 ? s << 1 | e1 : 511 & (s << 1 | e1) | 256;
            t = t << 1 | e1;
        }
        return t >>> 0;
    }
    const r = readBits(1), n = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
    let g;
    0 === r ? g = n : n > 0 && (g = -n);
    return g >= -2147483648 && g <= pt ? g : null;
}
function decodeIAID(e1, t, i) {
    const a = e1.getContexts("IAID");
    let s = 1;
    for(let e1 = 0; e1 < i; e1++){
        s = s << 1 | t.readBit(a, s);
    }
    return i < 31 ? s & (1 << i) - 1 : 2147483647 & s;
}
const Yt = [
    "SymbolDictionary",
    null,
    null,
    null,
    "IntermediateTextRegion",
    null,
    "ImmediateTextRegion",
    "ImmediateLosslessTextRegion",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "PatternDictionary",
    null,
    null,
    null,
    "IntermediateHalftoneRegion",
    null,
    "ImmediateHalftoneRegion",
    "ImmediateLosslessHalftoneRegion",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "IntermediateGenericRegion",
    null,
    "ImmediateGenericRegion",
    "ImmediateLosslessGenericRegion",
    "IntermediateGenericRefinementRegion",
    null,
    "ImmediateGenericRefinementRegion",
    "ImmediateLosslessGenericRefinementRegion",
    null,
    null,
    null,
    null,
    "PageInformation",
    "EndOfPage",
    "EndOfStripe",
    "EndOfFile",
    "Profiles",
    "Tables",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "Extension"
], vt = [
    [
        {
            x: -1,
            y: -2
        },
        {
            x: 0,
            y: -2
        },
        {
            x: 1,
            y: -2
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: 2,
            y: -1
        },
        {
            x: -4,
            y: 0
        },
        {
            x: -3,
            y: 0
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ],
    [
        {
            x: -1,
            y: -2
        },
        {
            x: 0,
            y: -2
        },
        {
            x: 1,
            y: -2
        },
        {
            x: 2,
            y: -2
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: 2,
            y: -1
        },
        {
            x: -3,
            y: 0
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ],
    [
        {
            x: -1,
            y: -2
        },
        {
            x: 0,
            y: -2
        },
        {
            x: 1,
            y: -2
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ],
    [
        {
            x: -3,
            y: -1
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: -4,
            y: 0
        },
        {
            x: -3,
            y: 0
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ]
], Kt = [
    {
        coding: [
            {
                x: 0,
                y: -1
            },
            {
                x: 1,
                y: -1
            },
            {
                x: -1,
                y: 0
            }
        ],
        reference: [
            {
                x: 0,
                y: -1
            },
            {
                x: 1,
                y: -1
            },
            {
                x: -1,
                y: 0
            },
            {
                x: 0,
                y: 0
            },
            {
                x: 1,
                y: 0
            },
            {
                x: -1,
                y: 1
            },
            {
                x: 0,
                y: 1
            },
            {
                x: 1,
                y: 1
            }
        ]
    },
    {
        coding: [
            {
                x: -1,
                y: -1
            },
            {
                x: 0,
                y: -1
            },
            {
                x: 1,
                y: -1
            },
            {
                x: -1,
                y: 0
            }
        ],
        reference: [
            {
                x: 0,
                y: -1
            },
            {
                x: -1,
                y: 0
            },
            {
                x: 0,
                y: 0
            },
            {
                x: 1,
                y: 0
            },
            {
                x: 0,
                y: 1
            },
            {
                x: 1,
                y: 1
            }
        ]
    }
], Tt = [
    39717,
    1941,
    229,
    405
], qt = [
    32,
    8
];
function decodeBitmap(e1, t, i, a, s, r, n, g) {
    if (e1) {
        return decodeMMRBitmap(new Reader(g.data, g.start, g.end), t, i, !1);
    }
    if (0 === a && !r && !s && 4 === n.length && 3 === n[0].x && -1 === n[0].y && -3 === n[1].x && -1 === n[1].y && 2 === n[2].x && -2 === n[2].y && -2 === n[3].x && -2 === n[3].y) return function decodeBitmapTemplate0(e1, t, i) {
        const a = i.decoder, s = i.contextCache.getContexts("GB"), r = [];
        let n, g, o, c, C, h, l;
        for(g = 0; g < t; g++){
            C = r[g] = new Uint8Array(e1);
            h = g < 1 ? C : r[g - 1];
            l = g < 2 ? C : r[g - 2];
            n = l[0] << 13 | l[1] << 12 | l[2] << 11 | h[0] << 7 | h[1] << 6 | h[2] << 5 | h[3] << 4;
            for(o = 0; o < e1; o++){
                C[o] = c = a.readBit(s, n);
                n = (31735 & n) << 1 | (o + 3 < e1 ? l[o + 3] << 11 : 0) | (o + 4 < e1 ? h[o + 4] << 4 : 0) | c;
            }
        }
        return r;
    }(t, i, g);
    const o = !!r, c = vt[a].concat(n);
    c.sort(function(e1, t) {
        return e1.y - t.y || e1.x - t.x;
    });
    const C = c.length, h = new Int8Array(C), l = new Int8Array(C), Q = [];
    let E, u, d = 0, f = 0, p = 0, m = 0;
    for(u = 0; u < C; u++){
        h[u] = c[u].x;
        l[u] = c[u].y;
        f = Math.min(f, c[u].x);
        p = Math.max(p, c[u].x);
        m = Math.min(m, c[u].y);
        u < C - 1 && c[u].y === c[u + 1].y && c[u].x === c[u + 1].x - 1 ? d |= 1 << C - 1 - u : Q.push(u);
    }
    const y = Q.length, w = new Int8Array(y), D = new Int8Array(y), b = new Uint16Array(y);
    for(E = 0; E < y; E++){
        u = Q[E];
        w[E] = c[u].x;
        D[E] = c[u].y;
        b[E] = 1 << C - 1 - u;
    }
    const F = -f, S = -m, k = t - p, R = Tt[a];
    let N = new Uint8Array(t);
    const G = [], M = g.decoder, U = g.contextCache.getContexts("GB");
    let x, L, H, J, Y, v = 0, K = 0;
    for(let e1 = 0; e1 < i; e1++){
        if (s) {
            v ^= M.readBit(U, R);
            if (v) {
                G.push(N);
                continue;
            }
        }
        N = new Uint8Array(N);
        G.push(N);
        for(x = 0; x < t; x++){
            if (o && r[e1][x]) {
                N[x] = 0;
                continue;
            }
            if (x >= F && x < k && e1 >= S) {
                K = K << 1 & d;
                for(u = 0; u < y; u++){
                    L = e1 + D[u];
                    H = x + w[u];
                    J = G[L][H];
                    if (J) {
                        J = b[u];
                        K |= J;
                    }
                }
            } else {
                K = 0;
                Y = C - 1;
                for(u = 0; u < C; u++, Y--){
                    H = x + h[u];
                    if (H >= 0 && H < t) {
                        L = e1 + l[u];
                        if (L >= 0) {
                            J = G[L][H];
                            J && (K |= J << Y);
                        }
                    }
                }
            }
            const i = M.readBit(U, K);
            N[x] = i;
        }
    }
    return G;
}
function decodeRefinement(e1, t, i, a, s, r, n, g, o) {
    let c = Kt[i].coding;
    0 === i && (c = c.concat([
        g[0]
    ]));
    const C = c.length, h = new Int32Array(C), l = new Int32Array(C);
    let Q;
    for(Q = 0; Q < C; Q++){
        h[Q] = c[Q].x;
        l[Q] = c[Q].y;
    }
    let E = Kt[i].reference;
    0 === i && (E = E.concat([
        g[1]
    ]));
    const u = E.length, d = new Int32Array(u), f = new Int32Array(u);
    for(Q = 0; Q < u; Q++){
        d[Q] = E[Q].x;
        f[Q] = E[Q].y;
    }
    const p = a[0].length, m = a.length, y = qt[i], w = [], D = o.decoder, b = o.contextCache.getContexts("GR");
    let F = 0;
    for(let i = 0; i < t; i++){
        if (n) {
            F ^= D.readBit(b, y);
            if (F) throw new Jbig2Error("prediction is not supported");
        }
        const t = new Uint8Array(e1);
        w.push(t);
        for(let n = 0; n < e1; n++){
            let g, o, c = 0;
            for(Q = 0; Q < C; Q++){
                g = i + l[Q];
                o = n + h[Q];
                g < 0 || o < 0 || o >= e1 ? c <<= 1 : c = c << 1 | w[g][o];
            }
            for(Q = 0; Q < u; Q++){
                g = i + f[Q] - r;
                o = n + d[Q] - s;
                g < 0 || g >= m || o < 0 || o >= p ? c <<= 1 : c = c << 1 | a[g][o];
            }
            const E = D.readBit(b, c);
            t[n] = E;
        }
    }
    return w;
}
function decodeTextRegion(e1, t, i, a, s, r, n, g, o, c, C, h, l, Q, E, u, d, f, p) {
    if (e1 && t) throw new Jbig2Error("refinement with Huffman is not supported");
    const m = [];
    let y, w;
    for(y = 0; y < a; y++){
        w = new Uint8Array(i);
        if (s) for(let e1 = 0; e1 < i; e1++)w[e1] = s;
        m.push(w);
    }
    const D = d.decoder, b = d.contextCache;
    let F = e1 ? -Q.tableDeltaT.decode(p) : -decodeInteger(b, "IADT", D), S = 0;
    y = 0;
    for(; y < r;){
        F += e1 ? Q.tableDeltaT.decode(p) : decodeInteger(b, "IADT", D);
        S += e1 ? Q.tableFirstS.decode(p) : decodeInteger(b, "IAFS", D);
        let a = S;
        for(;;){
            let s = 0;
            n > 1 && (s = e1 ? p.readBits(f) : decodeInteger(b, "IAIT", D));
            const r = n * F + s, S = e1 ? Q.symbolIDTable.decode(p) : decodeIAID(b, D, o), k = t && (e1 ? p.readBit() : decodeInteger(b, "IARI", D));
            let R = g[S], N = R[0].length, G = R.length;
            if (k) {
                const e1 = decodeInteger(b, "IARDW", D), t = decodeInteger(b, "IARDH", D);
                N += e1;
                G += t;
                R = decodeRefinement(N, G, E, R, (e1 >> 1) + decodeInteger(b, "IARDX", D), (t >> 1) + decodeInteger(b, "IARDY", D), !1, u, d);
            }
            let M = 0;
            c ? 1 & h ? M = G - 1 : a += G - 1 : h > 1 ? a += N - 1 : M = N - 1;
            const U = r - (1 & h ? 0 : G - 1), x = a - (2 & h ? N - 1 : 0);
            let L, H, J;
            if (c) for(L = 0; L < G; L++){
                w = m[x + L];
                if (!w) continue;
                J = R[L];
                const e1 = Math.min(i - U, N);
                switch(l){
                    case 0:
                        for(H = 0; H < e1; H++)w[U + H] |= J[H];
                        break;
                    case 2:
                        for(H = 0; H < e1; H++)w[U + H] ^= J[H];
                        break;
                    default:
                        throw new Jbig2Error(`operator ${l} is not supported`);
                }
            }
            else for(H = 0; H < G; H++){
                w = m[U + H];
                if (w) {
                    J = R[H];
                    switch(l){
                        case 0:
                            for(L = 0; L < N; L++)w[x + L] |= J[L];
                            break;
                        case 2:
                            for(L = 0; L < N; L++)w[x + L] ^= J[L];
                            break;
                        default:
                            throw new Jbig2Error(`operator ${l} is not supported`);
                    }
                }
            }
            y++;
            const Y = e1 ? Q.tableDeltaS.decode(p) : decodeInteger(b, "IADS", D);
            if (null === Y) break;
            a += M + Y + C;
        }
    }
    return m;
}
function readSegmentHeader(e1, t) {
    const i = {};
    i.number = readUint32(e1, t);
    const a = e1[t + 4], s = 63 & a;
    if (!Yt[s]) throw new Jbig2Error("invalid segment type: " + s);
    i.type = s;
    i.typeName = Yt[s];
    i.deferredNonRetain = !!(128 & a);
    const r = !!(64 & a), n = e1[t + 5];
    let g = n >> 5 & 7;
    const o = [
        31 & n
    ];
    let c = t + 6;
    if (7 === n) {
        g = 536870911 & readUint32(e1, c - 1);
        c += 3;
        let t = g + 7 >> 3;
        o[0] = e1[c++];
        for(; --t > 0;)o.push(e1[c++]);
    } else if (5 === n || 6 === n) throw new Jbig2Error("invalid referred-to flags");
    i.retainBits = o;
    let C = 4;
    i.number <= 256 ? C = 1 : i.number <= 65536 && (C = 2);
    const h = [];
    let l, Q;
    for(l = 0; l < g; l++){
        let t;
        t = 1 === C ? e1[c] : 2 === C ? readUint16(e1, c) : readUint32(e1, c);
        h.push(t);
        c += C;
    }
    i.referredTo = h;
    if (r) {
        i.pageAssociation = readUint32(e1, c);
        c += 4;
    } else i.pageAssociation = e1[c++];
    i.length = readUint32(e1, c);
    c += 4;
    if (4294967295 === i.length) {
        if (38 !== s) throw new Jbig2Error("invalid unknown segment length");
        {
            const t = readRegionSegmentInformation(e1, c), a = !!(1 & e1[c + Ot]), s = 6, r = new Uint8Array(s);
            if (!a) {
                r[0] = 255;
                r[1] = 172;
            }
            r[2] = t.height >>> 24 & 255;
            r[3] = t.height >> 16 & 255;
            r[4] = t.height >> 8 & 255;
            r[5] = 255 & t.height;
            for(l = c, Q = e1.length; l < Q; l++){
                let t = 0;
                for(; t < s && r[t] === e1[l + t];)t++;
                if (t === s) {
                    i.length = l + s;
                    break;
                }
            }
            if (4294967295 === i.length) throw new Jbig2Error("segment end was not found");
        }
    }
    i.headerEnd = c;
    return i;
}
function readSegments(e1, t, i, a) {
    const s = [];
    let r = i;
    for(; r < a;){
        const i = readSegmentHeader(t, r);
        r = i.headerEnd;
        const a = {
            header: i,
            data: t
        };
        if (!e1.randomAccess) {
            a.start = r;
            r += i.length;
            a.end = r;
        }
        s.push(a);
        if (51 === i.type) break;
    }
    if (e1.randomAccess) for(let e1 = 0, t = s.length; e1 < t; e1++){
        s[e1].start = r;
        r += s[e1].header.length;
        s[e1].end = r;
    }
    return s;
}
function readRegionSegmentInformation(e1, t) {
    return {
        width: readUint32(e1, t),
        height: readUint32(e1, t + 4),
        x: readUint32(e1, t + 8),
        y: readUint32(e1, t + 12),
        combinationOperator: 7 & e1[t + 16]
    };
}
const Ot = 17;
function processSegment(e1, t) {
    const i = e1.header, a = e1.data, s = e1.end;
    let r, n, g, o, c = e1.start;
    switch(i.type){
        case 0:
            const e2 = {}, t1 = readUint16(a, c);
            e2.huffman = !!(1 & t1);
            e2.refinement = !!(2 & t1);
            e2.huffmanDHSelector = t1 >> 2 & 3;
            e2.huffmanDWSelector = t1 >> 4 & 3;
            e2.bitmapSizeSelector = t1 >> 6 & 1;
            e2.aggregationInstancesSelector = t1 >> 7 & 1;
            e2.bitmapCodingContextUsed = !!(256 & t1);
            e2.bitmapCodingContextRetained = !!(512 & t1);
            e2.template = t1 >> 10 & 3;
            e2.refinementTemplate = t1 >> 12 & 1;
            c += 2;
            if (!e2.huffman) {
                o = 0 === e2.template ? 4 : 1;
                n = [];
                for(g = 0; g < o; g++){
                    n.push({
                        x: readInt8(a, c),
                        y: readInt8(a, c + 1)
                    });
                    c += 2;
                }
                e2.at = n;
            }
            if (e2.refinement && !e2.refinementTemplate) {
                n = [];
                for(g = 0; g < 2; g++){
                    n.push({
                        x: readInt8(a, c),
                        y: readInt8(a, c + 1)
                    });
                    c += 2;
                }
                e2.refinementAt = n;
            }
            e2.numberOfExportedSymbols = readUint32(a, c);
            c += 4;
            e2.numberOfNewSymbols = readUint32(a, c);
            c += 4;
            r = [
                e2,
                i.number,
                i.referredTo,
                a,
                c,
                s
            ];
            break;
        case 6:
        case 7:
            const C = {};
            C.info = readRegionSegmentInformation(a, c);
            c += Ot;
            const h = readUint16(a, c);
            c += 2;
            C.huffman = !!(1 & h);
            C.refinement = !!(2 & h);
            C.logStripSize = h >> 2 & 3;
            C.stripSize = 1 << C.logStripSize;
            C.referenceCorner = h >> 4 & 3;
            C.transposed = !!(64 & h);
            C.combinationOperator = h >> 7 & 3;
            C.defaultPixelValue = h >> 9 & 1;
            C.dsOffset = h << 17 >> 27;
            C.refinementTemplate = h >> 15 & 1;
            if (C.huffman) {
                const e1 = readUint16(a, c);
                c += 2;
                C.huffmanFS = 3 & e1;
                C.huffmanDS = e1 >> 2 & 3;
                C.huffmanDT = e1 >> 4 & 3;
                C.huffmanRefinementDW = e1 >> 6 & 3;
                C.huffmanRefinementDH = e1 >> 8 & 3;
                C.huffmanRefinementDX = e1 >> 10 & 3;
                C.huffmanRefinementDY = e1 >> 12 & 3;
                C.huffmanRefinementSizeSelector = !!(16384 & e1);
            }
            if (C.refinement && !C.refinementTemplate) {
                n = [];
                for(g = 0; g < 2; g++){
                    n.push({
                        x: readInt8(a, c),
                        y: readInt8(a, c + 1)
                    });
                    c += 2;
                }
                C.refinementAt = n;
            }
            C.numberOfSymbolInstances = readUint32(a, c);
            c += 4;
            r = [
                C,
                i.referredTo,
                a,
                c,
                s
            ];
            break;
        case 16:
            const l = {}, Q = a[c++];
            l.mmr = !!(1 & Q);
            l.template = Q >> 1 & 3;
            l.patternWidth = a[c++];
            l.patternHeight = a[c++];
            l.maxPatternIndex = readUint32(a, c);
            c += 4;
            r = [
                l,
                i.number,
                a,
                c,
                s
            ];
            break;
        case 22:
        case 23:
            const E = {};
            E.info = readRegionSegmentInformation(a, c);
            c += Ot;
            const u = a[c++];
            E.mmr = !!(1 & u);
            E.template = u >> 1 & 3;
            E.enableSkip = !!(8 & u);
            E.combinationOperator = u >> 4 & 7;
            E.defaultPixelValue = u >> 7 & 1;
            E.gridWidth = readUint32(a, c);
            c += 4;
            E.gridHeight = readUint32(a, c);
            c += 4;
            E.gridOffsetX = 4294967295 & readUint32(a, c);
            c += 4;
            E.gridOffsetY = 4294967295 & readUint32(a, c);
            c += 4;
            E.gridVectorX = readUint16(a, c);
            c += 2;
            E.gridVectorY = readUint16(a, c);
            c += 2;
            r = [
                E,
                i.referredTo,
                a,
                c,
                s
            ];
            break;
        case 38:
        case 39:
            const d = {};
            d.info = readRegionSegmentInformation(a, c);
            c += Ot;
            const f = a[c++];
            d.mmr = !!(1 & f);
            d.template = f >> 1 & 3;
            d.prediction = !!(8 & f);
            if (!d.mmr) {
                o = 0 === d.template ? 4 : 1;
                n = [];
                for(g = 0; g < o; g++){
                    n.push({
                        x: readInt8(a, c),
                        y: readInt8(a, c + 1)
                    });
                    c += 2;
                }
                d.at = n;
            }
            r = [
                d,
                a,
                c,
                s
            ];
            break;
        case 48:
            const p = {
                width: readUint32(a, c),
                height: readUint32(a, c + 4),
                resolutionX: readUint32(a, c + 8),
                resolutionY: readUint32(a, c + 12)
            };
            4294967295 === p.height && delete p.height;
            const m = a[c + 16];
            readUint16(a, c + 17);
            p.lossless = !!(1 & m);
            p.refinement = !!(2 & m);
            p.defaultPixelValue = m >> 2 & 1;
            p.combinationOperator = m >> 3 & 3;
            p.requiresBuffer = !!(32 & m);
            p.combinationOperatorOverride = !!(64 & m);
            r = [
                p
            ];
            break;
        case 49:
        case 50:
        case 51:
        case 62:
            break;
        case 53:
            r = [
                i.number,
                a,
                c,
                s
            ];
            break;
        default:
            throw new Jbig2Error(`segment type ${i.typeName}(${i.type}) is not implemented`);
    }
    const C1 = "on" + i.typeName;
    C1 in t && t[C1].apply(t, r);
}
function processSegments(e1, t) {
    for(let i = 0, a = e1.length; i < a; i++)processSegment(e1[i], t);
}
class SimpleSegmentVisitor {
    onPageInformation(e1) {
        this.currentPageInfo = e1;
        const t = e1.width + 7 >> 3, i = new Uint8ClampedArray(t * e1.height);
        e1.defaultPixelValue && i.fill(255);
        this.buffer = i;
    }
    drawBitmap(e1, t) {
        const i = this.currentPageInfo, a = e1.width, s = e1.height, r = i.width + 7 >> 3, n = i.combinationOperatorOverride ? e1.combinationOperator : i.combinationOperator, g = this.buffer, o = 128 >> (7 & e1.x);
        let c, C, h, l, Q = e1.y * r + (e1.x >> 3);
        switch(n){
            case 0:
                for(c = 0; c < s; c++){
                    h = o;
                    l = Q;
                    for(C = 0; C < a; C++){
                        t[c][C] && (g[l] |= h);
                        h >>= 1;
                        if (!h) {
                            h = 128;
                            l++;
                        }
                    }
                    Q += r;
                }
                break;
            case 2:
                for(c = 0; c < s; c++){
                    h = o;
                    l = Q;
                    for(C = 0; C < a; C++){
                        t[c][C] && (g[l] ^= h);
                        h >>= 1;
                        if (!h) {
                            h = 128;
                            l++;
                        }
                    }
                    Q += r;
                }
                break;
            default:
                throw new Jbig2Error(`operator ${n} is not supported`);
        }
    }
    onImmediateGenericRegion(e1, t, i, a) {
        const s = e1.info, r = new DecodingContext(t, i, a), n = decodeBitmap(e1.mmr, s.width, s.height, e1.template, e1.prediction, null, e1.at, r);
        this.drawBitmap(s, n);
    }
    onImmediateLosslessGenericRegion() {
        this.onImmediateGenericRegion(...arguments);
    }
    onSymbolDictionary(e1, t, i, a, s, r) {
        let n, g;
        if (e1.huffman) {
            n = function getSymbolDictionaryHuffmanTables(e1, t, i) {
                let a, s, r, n, g = 0;
                switch(e1.huffmanDHSelector){
                    case 0:
                    case 1:
                        a = getStandardTable(e1.huffmanDHSelector + 4);
                        break;
                    case 3:
                        a = getCustomHuffmanTable(g, t, i);
                        g++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman DH selector");
                }
                switch(e1.huffmanDWSelector){
                    case 0:
                    case 1:
                        s = getStandardTable(e1.huffmanDWSelector + 2);
                        break;
                    case 3:
                        s = getCustomHuffmanTable(g, t, i);
                        g++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman DW selector");
                }
                if (e1.bitmapSizeSelector) {
                    r = getCustomHuffmanTable(g, t, i);
                    g++;
                } else r = getStandardTable(1);
                n = e1.aggregationInstancesSelector ? getCustomHuffmanTable(g, t, i) : getStandardTable(1);
                return {
                    tableDeltaHeight: a,
                    tableDeltaWidth: s,
                    tableBitmapSize: r,
                    tableAggregateInstances: n
                };
            }(e1, i, this.customTables);
            g = new Reader(a, s, r);
        }
        let o = this.symbols;
        o || (this.symbols = o = {});
        const c = [];
        for (const e1 of i){
            const t = o[e1];
            t && c.push(...t);
        }
        const C = new DecodingContext(a, s, r);
        o[t] = function decodeSymbolDictionary(e1, t, i, a, s, r, n, g, o, c, C, h) {
            if (e1 && t) throw new Jbig2Error("symbol refinement with Huffman is not supported");
            const l = [];
            let Q = 0, E = log2(i.length + a);
            const u = C.decoder, d = C.contextCache;
            let f, p;
            if (e1) {
                f = getStandardTable(1);
                p = [];
                E = Math.max(E, 1);
            }
            for(; l.length < a;){
                Q += e1 ? r.tableDeltaHeight.decode(h) : decodeInteger(d, "IADH", u);
                let a = 0, s = 0;
                const f = e1 ? p.length : 0;
                for(;;){
                    const f = e1 ? r.tableDeltaWidth.decode(h) : decodeInteger(d, "IADW", u);
                    if (null === f) break;
                    a += f;
                    s += a;
                    let m;
                    if (t) {
                        const s = decodeInteger(d, "IAAI", u);
                        if (s > 1) m = decodeTextRegion(e1, t, a, Q, 0, s, 1, i.concat(l), E, 0, 0, 1, 0, r, o, c, C, 0, h);
                        else {
                            const e1 = decodeIAID(d, u, E), t = decodeInteger(d, "IARDX", u), s = decodeInteger(d, "IARDY", u);
                            m = decodeRefinement(a, Q, o, e1 < i.length ? i[e1] : l[e1 - i.length], t, s, !1, c, C);
                        }
                        l.push(m);
                    } else if (e1) p.push(a);
                    else {
                        m = decodeBitmap(!1, a, Q, n, !1, null, g, C);
                        l.push(m);
                    }
                }
                if (e1 && !t) {
                    const e1 = r.tableBitmapSize.decode(h);
                    h.byteAlign();
                    let t;
                    if (0 === e1) t = readUncompressedBitmap(h, s, Q);
                    else {
                        const i = h.end, a = h.position + e1;
                        h.end = a;
                        t = decodeMMRBitmap(h, s, Q, !1);
                        h.end = i;
                        h.position = a;
                    }
                    const i = p.length;
                    if (f === i - 1) l.push(t);
                    else {
                        let e1, a, s, r, n, g = 0;
                        for(e1 = f; e1 < i; e1++){
                            r = p[e1];
                            s = g + r;
                            n = [];
                            for(a = 0; a < Q; a++)n.push(t[a].subarray(g, s));
                            l.push(n);
                            g = s;
                        }
                    }
                }
            }
            const m = [], y = [];
            let w, D, b = !1;
            const F = i.length + a;
            for(; y.length < F;){
                let t = e1 ? f.decode(h) : decodeInteger(d, "IAEX", u);
                for(; t--;)y.push(b);
                b = !b;
            }
            for(w = 0, D = i.length; w < D; w++)y[w] && m.push(i[w]);
            for(let e1 = 0; e1 < a; w++, e1++)y[w] && m.push(l[e1]);
            return m;
        }(e1.huffman, e1.refinement, c, e1.numberOfNewSymbols, e1.numberOfExportedSymbols, n, e1.template, e1.at, e1.refinementTemplate, e1.refinementAt, C, g);
    }
    onImmediateTextRegion(e1, t, i, a, s) {
        const r = e1.info;
        let n, g;
        const o = this.symbols, c = [];
        for (const e1 of t){
            const t = o[e1];
            t && c.push(...t);
        }
        const C = log2(c.length);
        if (e1.huffman) {
            g = new Reader(i, a, s);
            n = function getTextRegionHuffmanTables(e1, t, i, a, s) {
                const r = [];
                for(let e1 = 0; e1 <= 34; e1++){
                    const t = s.readBits(4);
                    r.push(new HuffmanLine([
                        e1,
                        t,
                        0,
                        0
                    ]));
                }
                const n = new HuffmanTable(r, !1);
                r.length = 0;
                for(let e1 = 0; e1 < a;){
                    const t = n.decode(s);
                    if (t >= 32) {
                        let i, a, n;
                        switch(t){
                            case 32:
                                if (0 === e1) throw new Jbig2Error("no previous value in symbol ID table");
                                a = s.readBits(2) + 3;
                                i = r[e1 - 1].prefixLength;
                                break;
                            case 33:
                                a = s.readBits(3) + 3;
                                i = 0;
                                break;
                            case 34:
                                a = s.readBits(7) + 11;
                                i = 0;
                                break;
                            default:
                                throw new Jbig2Error("invalid code length in symbol ID table");
                        }
                        for(n = 0; n < a; n++){
                            r.push(new HuffmanLine([
                                e1,
                                i,
                                0,
                                0
                            ]));
                            e1++;
                        }
                    } else {
                        r.push(new HuffmanLine([
                            e1,
                            t,
                            0,
                            0
                        ]));
                        e1++;
                    }
                }
                s.byteAlign();
                const g = new HuffmanTable(r, !1);
                let o, c, C, h = 0;
                switch(e1.huffmanFS){
                    case 0:
                    case 1:
                        o = getStandardTable(e1.huffmanFS + 6);
                        break;
                    case 3:
                        o = getCustomHuffmanTable(h, t, i);
                        h++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman FS selector");
                }
                switch(e1.huffmanDS){
                    case 0:
                    case 1:
                    case 2:
                        c = getStandardTable(e1.huffmanDS + 8);
                        break;
                    case 3:
                        c = getCustomHuffmanTable(h, t, i);
                        h++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman DS selector");
                }
                switch(e1.huffmanDT){
                    case 0:
                    case 1:
                    case 2:
                        C = getStandardTable(e1.huffmanDT + 11);
                        break;
                    case 3:
                        C = getCustomHuffmanTable(h, t, i);
                        h++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman DT selector");
                }
                if (e1.refinement) throw new Jbig2Error("refinement with Huffman is not supported");
                return {
                    symbolIDTable: g,
                    tableFirstS: o,
                    tableDeltaS: c,
                    tableDeltaT: C
                };
            }(e1, t, this.customTables, c.length, g);
        }
        const h = new DecodingContext(i, a, s), l = decodeTextRegion(e1.huffman, e1.refinement, r.width, r.height, e1.defaultPixelValue, e1.numberOfSymbolInstances, e1.stripSize, c, C, e1.transposed, e1.dsOffset, e1.referenceCorner, e1.combinationOperator, n, e1.refinementTemplate, e1.refinementAt, h, e1.logStripSize, g);
        this.drawBitmap(r, l);
    }
    onImmediateLosslessTextRegion() {
        this.onImmediateTextRegion(...arguments);
    }
    onPatternDictionary(e1, t, i, a, s) {
        let r = this.patterns;
        r || (this.patterns = r = {});
        const n = new DecodingContext(i, a, s);
        r[t] = function decodePatternDictionary(e1, t, i, a, s, r) {
            const n = [];
            if (!e1) {
                n.push({
                    x: -t,
                    y: 0
                });
                0 === s && n.push({
                    x: -3,
                    y: -1
                }, {
                    x: 2,
                    y: -2
                }, {
                    x: -2,
                    y: -2
                });
            }
            const g = decodeBitmap(e1, (a + 1) * t, i, s, !1, null, n, r), o = [];
            for(let e1 = 0; e1 <= a; e1++){
                const a = [], s = t * e1, r = s + t;
                for(let e1 = 0; e1 < i; e1++)a.push(g[e1].subarray(s, r));
                o.push(a);
            }
            return o;
        }(e1.mmr, e1.patternWidth, e1.patternHeight, e1.maxPatternIndex, e1.template, n);
    }
    onImmediateHalftoneRegion(e1, t, i, a, s) {
        const r = this.patterns[t[0]], n = e1.info, g = new DecodingContext(i, a, s), o = function decodeHalftoneRegion(e1, t, i, a, s, r, n, g, o, c, C, h, l, Q, E) {
            if (n) throw new Jbig2Error("skip is not supported");
            if (0 !== g) throw new Jbig2Error(`operator "${g}" is not supported in halftone region`);
            const u = [];
            let d, f, p;
            for(d = 0; d < s; d++){
                p = new Uint8Array(a);
                if (r) for(f = 0; f < a; f++)p[f] = r;
                u.push(p);
            }
            const m = t.length, y = t[0], w = y[0].length, D = y.length, b = log2(m), F = [];
            if (!e1) {
                F.push({
                    x: i <= 1 ? 3 : 2,
                    y: -1
                });
                0 === i && F.push({
                    x: -3,
                    y: -1
                }, {
                    x: 2,
                    y: -2
                }, {
                    x: -2,
                    y: -2
                });
            }
            const S = [];
            let k, R, N, G, M, U, x, L, H, J, Y;
            e1 && (k = new Reader(E.data, E.start, E.end));
            for(d = b - 1; d >= 0; d--){
                R = e1 ? decodeMMRBitmap(k, o, c, !0) : decodeBitmap(!1, o, c, i, !1, null, F, E);
                S[d] = R;
            }
            for(N = 0; N < c; N++)for(G = 0; G < o; G++){
                M = 0;
                U = 0;
                for(f = b - 1; f >= 0; f--){
                    M ^= S[f][N][G];
                    U |= M << f;
                }
                x = t[U];
                L = C + N * Q + G * l >> 8;
                H = h + N * l - G * Q >> 8;
                if (L >= 0 && L + w <= a && H >= 0 && H + D <= s) for(d = 0; d < D; d++){
                    Y = u[H + d];
                    J = x[d];
                    for(f = 0; f < w; f++)Y[L + f] |= J[f];
                }
                else {
                    let e1, t;
                    for(d = 0; d < D; d++){
                        t = H + d;
                        if (!(t < 0 || t >= s)) {
                            Y = u[t];
                            J = x[d];
                            for(f = 0; f < w; f++){
                                e1 = L + f;
                                e1 >= 0 && e1 < a && (Y[e1] |= J[f]);
                            }
                        }
                    }
                }
            }
            return u;
        }(e1.mmr, r, e1.template, n.width, n.height, e1.defaultPixelValue, e1.enableSkip, e1.combinationOperator, e1.gridWidth, e1.gridHeight, e1.gridOffsetX, e1.gridOffsetY, e1.gridVectorX, e1.gridVectorY, g);
        this.drawBitmap(n, o);
    }
    onImmediateLosslessHalftoneRegion() {
        this.onImmediateHalftoneRegion(...arguments);
    }
    onTables(e1, t, i, a) {
        let s = this.customTables;
        s || (this.customTables = s = {});
        s[e1] = function decodeTablesSegment(e1, t, i) {
            const a = e1[t], s = 4294967295 & readUint32(e1, t + 1), r = 4294967295 & readUint32(e1, t + 5), n = new Reader(e1, t + 9, i), g = 1 + (a >> 1 & 7), o = 1 + (a >> 4 & 7), c = [];
            let C, h, l = s;
            do {
                C = n.readBits(g);
                h = n.readBits(o);
                c.push(new HuffmanLine([
                    l,
                    C,
                    h,
                    0
                ]));
                l += 1 << h;
            }while (l < r)
            C = n.readBits(g);
            c.push(new HuffmanLine([
                s - 1,
                C,
                32,
                0,
                "lower"
            ]));
            C = n.readBits(g);
            c.push(new HuffmanLine([
                r,
                C,
                32,
                0
            ]));
            if (1 & a) {
                C = n.readBits(g);
                c.push(new HuffmanLine([
                    C,
                    0
                ]));
            }
            return new HuffmanTable(c, !1);
        }(t, i, a);
    }
}
class HuffmanLine {
    constructor(e1){
        if (2 === e1.length) {
            this.isOOB = !0;
            this.rangeLow = 0;
            this.prefixLength = e1[0];
            this.rangeLength = 0;
            this.prefixCode = e1[1];
            this.isLowerRange = !1;
        } else {
            this.isOOB = !1;
            this.rangeLow = e1[0];
            this.prefixLength = e1[1];
            this.rangeLength = e1[2];
            this.prefixCode = e1[3];
            this.isLowerRange = "lower" === e1[4];
        }
    }
}
class HuffmanTreeNode {
    constructor(e1){
        this.children = [];
        if (e1) {
            this.isLeaf = !0;
            this.rangeLength = e1.rangeLength;
            this.rangeLow = e1.rangeLow;
            this.isLowerRange = e1.isLowerRange;
            this.isOOB = e1.isOOB;
        } else this.isLeaf = !1;
    }
    buildTree(e1, t) {
        const i = e1.prefixCode >> t & 1;
        if (t <= 0) this.children[i] = new HuffmanTreeNode(e1);
        else {
            let a = this.children[i];
            a || (this.children[i] = a = new HuffmanTreeNode(null));
            a.buildTree(e1, t - 1);
        }
    }
    decodeNode(e1) {
        if (this.isLeaf) {
            if (this.isOOB) return null;
            const t = e1.readBits(this.rangeLength);
            return this.rangeLow + (this.isLowerRange ? -t : t);
        }
        const t = this.children[e1.readBit()];
        if (!t) throw new Jbig2Error("invalid Huffman data");
        return t.decodeNode(e1);
    }
}
class HuffmanTable {
    constructor(e1, t){
        t || this.assignPrefixCodes(e1);
        this.rootNode = new HuffmanTreeNode(null);
        for(let t = 0, i = e1.length; t < i; t++){
            const i = e1[t];
            i.prefixLength > 0 && this.rootNode.buildTree(i, i.prefixLength - 1);
        }
    }
    decode(e1) {
        return this.rootNode.decodeNode(e1);
    }
    assignPrefixCodes(e1) {
        const t = e1.length;
        let i = 0;
        for(let a = 0; a < t; a++)i = Math.max(i, e1[a].prefixLength);
        const a = new Uint32Array(i + 1);
        for(let i = 0; i < t; i++)a[e1[i].prefixLength]++;
        let s, r, n, g = 1, o = 0;
        a[0] = 0;
        for(; g <= i;){
            o = o + a[g - 1] << 1;
            s = o;
            r = 0;
            for(; r < t;){
                n = e1[r];
                if (n.prefixLength === g) {
                    n.prefixCode = s;
                    s++;
                }
                r++;
            }
            g++;
        }
    }
}
const Pt = {};
function getStandardTable(e1) {
    let t, i = Pt[e1];
    if (i) return i;
    switch(e1){
        case 1:
            t = [
                [
                    0,
                    1,
                    4,
                    0
                ],
                [
                    16,
                    2,
                    8,
                    2
                ],
                [
                    272,
                    3,
                    16,
                    6
                ],
                [
                    65808,
                    3,
                    32,
                    7
                ]
            ];
            break;
        case 2:
            t = [
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    0,
                    2
                ],
                [
                    2,
                    3,
                    0,
                    6
                ],
                [
                    3,
                    4,
                    3,
                    14
                ],
                [
                    11,
                    5,
                    6,
                    30
                ],
                [
                    75,
                    6,
                    32,
                    62
                ],
                [
                    6,
                    63
                ]
            ];
            break;
        case 3:
            t = [
                [
                    -256,
                    8,
                    8,
                    254
                ],
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    0,
                    2
                ],
                [
                    2,
                    3,
                    0,
                    6
                ],
                [
                    3,
                    4,
                    3,
                    14
                ],
                [
                    11,
                    5,
                    6,
                    30
                ],
                [
                    -257,
                    8,
                    32,
                    255,
                    "lower"
                ],
                [
                    75,
                    7,
                    32,
                    126
                ],
                [
                    6,
                    62
                ]
            ];
            break;
        case 4:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    0,
                    2
                ],
                [
                    3,
                    3,
                    0,
                    6
                ],
                [
                    4,
                    4,
                    3,
                    14
                ],
                [
                    12,
                    5,
                    6,
                    30
                ],
                [
                    76,
                    5,
                    32,
                    31
                ]
            ];
            break;
        case 5:
            t = [
                [
                    -255,
                    7,
                    8,
                    126
                ],
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    0,
                    2
                ],
                [
                    3,
                    3,
                    0,
                    6
                ],
                [
                    4,
                    4,
                    3,
                    14
                ],
                [
                    12,
                    5,
                    6,
                    30
                ],
                [
                    -256,
                    7,
                    32,
                    127,
                    "lower"
                ],
                [
                    76,
                    6,
                    32,
                    62
                ]
            ];
            break;
        case 6:
            t = [
                [
                    -2048,
                    5,
                    10,
                    28
                ],
                [
                    -1024,
                    4,
                    9,
                    8
                ],
                [
                    -512,
                    4,
                    8,
                    9
                ],
                [
                    -256,
                    4,
                    7,
                    10
                ],
                [
                    -128,
                    5,
                    6,
                    29
                ],
                [
                    -64,
                    5,
                    5,
                    30
                ],
                [
                    -32,
                    4,
                    5,
                    11
                ],
                [
                    0,
                    2,
                    7,
                    0
                ],
                [
                    128,
                    3,
                    7,
                    2
                ],
                [
                    256,
                    3,
                    8,
                    3
                ],
                [
                    512,
                    4,
                    9,
                    12
                ],
                [
                    1024,
                    4,
                    10,
                    13
                ],
                [
                    -2049,
                    6,
                    32,
                    62,
                    "lower"
                ],
                [
                    2048,
                    6,
                    32,
                    63
                ]
            ];
            break;
        case 7:
            t = [
                [
                    -1024,
                    4,
                    9,
                    8
                ],
                [
                    -512,
                    3,
                    8,
                    0
                ],
                [
                    -256,
                    4,
                    7,
                    9
                ],
                [
                    -128,
                    5,
                    6,
                    26
                ],
                [
                    -64,
                    5,
                    5,
                    27
                ],
                [
                    -32,
                    4,
                    5,
                    10
                ],
                [
                    0,
                    4,
                    5,
                    11
                ],
                [
                    32,
                    5,
                    5,
                    28
                ],
                [
                    64,
                    5,
                    6,
                    29
                ],
                [
                    128,
                    4,
                    7,
                    12
                ],
                [
                    256,
                    3,
                    8,
                    1
                ],
                [
                    512,
                    3,
                    9,
                    2
                ],
                [
                    1024,
                    3,
                    10,
                    3
                ],
                [
                    -1025,
                    5,
                    32,
                    30,
                    "lower"
                ],
                [
                    2048,
                    5,
                    32,
                    31
                ]
            ];
            break;
        case 8:
            t = [
                [
                    -15,
                    8,
                    3,
                    252
                ],
                [
                    -7,
                    9,
                    1,
                    508
                ],
                [
                    -5,
                    8,
                    1,
                    253
                ],
                [
                    -3,
                    9,
                    0,
                    509
                ],
                [
                    -2,
                    7,
                    0,
                    124
                ],
                [
                    -1,
                    4,
                    0,
                    10
                ],
                [
                    0,
                    2,
                    1,
                    0
                ],
                [
                    2,
                    5,
                    0,
                    26
                ],
                [
                    3,
                    6,
                    0,
                    58
                ],
                [
                    4,
                    3,
                    4,
                    4
                ],
                [
                    20,
                    6,
                    1,
                    59
                ],
                [
                    22,
                    4,
                    4,
                    11
                ],
                [
                    38,
                    4,
                    5,
                    12
                ],
                [
                    70,
                    5,
                    6,
                    27
                ],
                [
                    134,
                    5,
                    7,
                    28
                ],
                [
                    262,
                    6,
                    7,
                    60
                ],
                [
                    390,
                    7,
                    8,
                    125
                ],
                [
                    646,
                    6,
                    10,
                    61
                ],
                [
                    -16,
                    9,
                    32,
                    510,
                    "lower"
                ],
                [
                    1670,
                    9,
                    32,
                    511
                ],
                [
                    2,
                    1
                ]
            ];
            break;
        case 9:
            t = [
                [
                    -31,
                    8,
                    4,
                    252
                ],
                [
                    -15,
                    9,
                    2,
                    508
                ],
                [
                    -11,
                    8,
                    2,
                    253
                ],
                [
                    -7,
                    9,
                    1,
                    509
                ],
                [
                    -5,
                    7,
                    1,
                    124
                ],
                [
                    -3,
                    4,
                    1,
                    10
                ],
                [
                    -1,
                    3,
                    1,
                    2
                ],
                [
                    1,
                    3,
                    1,
                    3
                ],
                [
                    3,
                    5,
                    1,
                    26
                ],
                [
                    5,
                    6,
                    1,
                    58
                ],
                [
                    7,
                    3,
                    5,
                    4
                ],
                [
                    39,
                    6,
                    2,
                    59
                ],
                [
                    43,
                    4,
                    5,
                    11
                ],
                [
                    75,
                    4,
                    6,
                    12
                ],
                [
                    139,
                    5,
                    7,
                    27
                ],
                [
                    267,
                    5,
                    8,
                    28
                ],
                [
                    523,
                    6,
                    8,
                    60
                ],
                [
                    779,
                    7,
                    9,
                    125
                ],
                [
                    1291,
                    6,
                    11,
                    61
                ],
                [
                    -32,
                    9,
                    32,
                    510,
                    "lower"
                ],
                [
                    3339,
                    9,
                    32,
                    511
                ],
                [
                    2,
                    0
                ]
            ];
            break;
        case 10:
            t = [
                [
                    -21,
                    7,
                    4,
                    122
                ],
                [
                    -5,
                    8,
                    0,
                    252
                ],
                [
                    -4,
                    7,
                    0,
                    123
                ],
                [
                    -3,
                    5,
                    0,
                    24
                ],
                [
                    -2,
                    2,
                    2,
                    0
                ],
                [
                    2,
                    5,
                    0,
                    25
                ],
                [
                    3,
                    6,
                    0,
                    54
                ],
                [
                    4,
                    7,
                    0,
                    124
                ],
                [
                    5,
                    8,
                    0,
                    253
                ],
                [
                    6,
                    2,
                    6,
                    1
                ],
                [
                    70,
                    5,
                    5,
                    26
                ],
                [
                    102,
                    6,
                    5,
                    55
                ],
                [
                    134,
                    6,
                    6,
                    56
                ],
                [
                    198,
                    6,
                    7,
                    57
                ],
                [
                    326,
                    6,
                    8,
                    58
                ],
                [
                    582,
                    6,
                    9,
                    59
                ],
                [
                    1094,
                    6,
                    10,
                    60
                ],
                [
                    2118,
                    7,
                    11,
                    125
                ],
                [
                    -22,
                    8,
                    32,
                    254,
                    "lower"
                ],
                [
                    4166,
                    8,
                    32,
                    255
                ],
                [
                    2,
                    2
                ]
            ];
            break;
        case 11:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    1,
                    2
                ],
                [
                    4,
                    4,
                    0,
                    12
                ],
                [
                    5,
                    4,
                    1,
                    13
                ],
                [
                    7,
                    5,
                    1,
                    28
                ],
                [
                    9,
                    5,
                    2,
                    29
                ],
                [
                    13,
                    6,
                    2,
                    60
                ],
                [
                    17,
                    7,
                    2,
                    122
                ],
                [
                    21,
                    7,
                    3,
                    123
                ],
                [
                    29,
                    7,
                    4,
                    124
                ],
                [
                    45,
                    7,
                    5,
                    125
                ],
                [
                    77,
                    7,
                    6,
                    126
                ],
                [
                    141,
                    7,
                    32,
                    127
                ]
            ];
            break;
        case 12:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    0,
                    2
                ],
                [
                    3,
                    3,
                    1,
                    6
                ],
                [
                    5,
                    5,
                    0,
                    28
                ],
                [
                    6,
                    5,
                    1,
                    29
                ],
                [
                    8,
                    6,
                    1,
                    60
                ],
                [
                    10,
                    7,
                    0,
                    122
                ],
                [
                    11,
                    7,
                    1,
                    123
                ],
                [
                    13,
                    7,
                    2,
                    124
                ],
                [
                    17,
                    7,
                    3,
                    125
                ],
                [
                    25,
                    7,
                    4,
                    126
                ],
                [
                    41,
                    8,
                    5,
                    254
                ],
                [
                    73,
                    8,
                    32,
                    255
                ]
            ];
            break;
        case 13:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    3,
                    0,
                    4
                ],
                [
                    3,
                    4,
                    0,
                    12
                ],
                [
                    4,
                    5,
                    0,
                    28
                ],
                [
                    5,
                    4,
                    1,
                    13
                ],
                [
                    7,
                    3,
                    3,
                    5
                ],
                [
                    15,
                    6,
                    1,
                    58
                ],
                [
                    17,
                    6,
                    2,
                    59
                ],
                [
                    21,
                    6,
                    3,
                    60
                ],
                [
                    29,
                    6,
                    4,
                    61
                ],
                [
                    45,
                    6,
                    5,
                    62
                ],
                [
                    77,
                    7,
                    6,
                    126
                ],
                [
                    141,
                    7,
                    32,
                    127
                ]
            ];
            break;
        case 14:
            t = [
                [
                    -2,
                    3,
                    0,
                    4
                ],
                [
                    -1,
                    3,
                    0,
                    5
                ],
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    3,
                    0,
                    6
                ],
                [
                    2,
                    3,
                    0,
                    7
                ]
            ];
            break;
        case 15:
            t = [
                [
                    -24,
                    7,
                    4,
                    124
                ],
                [
                    -8,
                    6,
                    2,
                    60
                ],
                [
                    -4,
                    5,
                    1,
                    28
                ],
                [
                    -2,
                    4,
                    0,
                    12
                ],
                [
                    -1,
                    3,
                    0,
                    4
                ],
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    3,
                    0,
                    5
                ],
                [
                    2,
                    4,
                    0,
                    13
                ],
                [
                    3,
                    5,
                    1,
                    29
                ],
                [
                    5,
                    6,
                    2,
                    61
                ],
                [
                    9,
                    7,
                    4,
                    125
                ],
                [
                    -25,
                    7,
                    32,
                    126,
                    "lower"
                ],
                [
                    25,
                    7,
                    32,
                    127
                ]
            ];
            break;
        default:
            throw new Jbig2Error(`standard table B.${e1} does not exist`);
    }
    for(let e1 = 0, i = t.length; e1 < i; e1++)t[e1] = new HuffmanLine(t[e1]);
    i = new HuffmanTable(t, !0);
    Pt[e1] = i;
    return i;
}
class Reader {
    constructor(e1, t, i){
        this.data = e1;
        this.start = t;
        this.end = i;
        this.position = t;
        this.shift = -1;
        this.currentByte = 0;
    }
    readBit() {
        if (this.shift < 0) {
            if (this.position >= this.end) throw new Jbig2Error("end of data while reading bit");
            this.currentByte = this.data[this.position++];
            this.shift = 7;
        }
        const e1 = this.currentByte >> this.shift & 1;
        this.shift--;
        return e1;
    }
    readBits(e1) {
        let t, i = 0;
        for(t = e1 - 1; t >= 0; t--)i |= this.readBit() << t;
        return i;
    }
    byteAlign() {
        this.shift = -1;
    }
    next() {
        return this.position >= this.end ? -1 : this.data[this.position++];
    }
}
function getCustomHuffmanTable(e1, t, i) {
    let a = 0;
    for(let s = 0, r = t.length; s < r; s++){
        const r = i[t[s]];
        if (r) {
            if (e1 === a) return r;
            a++;
        }
    }
    throw new Jbig2Error("can't find custom Huffman table");
}
function readUncompressedBitmap(e1, t, i) {
    const a = [];
    for(let s = 0; s < i; s++){
        const i = new Uint8Array(t);
        a.push(i);
        for(let a = 0; a < t; a++)i[a] = e1.readBit();
        e1.byteAlign();
    }
    return a;
}
function decodeMMRBitmap(e1, t, i, a) {
    const s = new CCITTFaxDecoder(e1, {
        K: -1,
        Columns: t,
        Rows: i,
        BlackIs1: !0,
        EndOfBlock: a
    }), r = [];
    let n, g = !1;
    for(let e1 = 0; e1 < i; e1++){
        const e1 = new Uint8Array(t);
        r.push(e1);
        let i = -1;
        for(let a = 0; a < t; a++){
            if (i < 0) {
                n = s.readNextChar();
                if (-1 === n) {
                    n = 0;
                    g = !0;
                }
                i = 7;
            }
            e1[a] = n >> i & 1;
            i--;
        }
    }
    if (a && !g) {
        const e1 = 5;
        for(let t = 0; t < e1 && -1 !== s.readNextChar(); t++);
    }
    return r;
}
class Jbig2Image {
    parseChunks(e1) {
        return function parseJbig2Chunks(e1) {
            const t = new SimpleSegmentVisitor;
            for(let i = 0, a = e1.length; i < a; i++){
                const a = e1[i];
                processSegments(readSegments({}, a.data, a.start, a.end), t);
            }
            return t.buffer;
        }(e1);
    }
    parse(e1) {
        throw new Error("Not implemented: Jbig2Image.parse");
    }
}
class Jbig2Stream extends DecodeStream {
    constructor(e1, t, i){
        super(t);
        this.stream = e1;
        this.dict = e1.dict;
        this.maybeLength = t;
        this.params = i;
    }
    get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e1) {}
    readBlock() {
        this.decodeImage();
    }
    decodeImage(e1) {
        if (this.eof) return this.buffer;
        e1 ||= this.bytes;
        const t = new Jbig2Image, i = [];
        if (this.params instanceof Dict) {
            const e1 = this.params.get("JBIG2Globals");
            if (e1 instanceof BaseStream) {
                const t = e1.getBytes();
                i.push({
                    data: t,
                    start: 0,
                    end: t.length
                });
            }
        }
        i.push({
            data: e1,
            start: 0,
            end: e1.length
        });
        const a = t.parseChunks(i), s = a.length;
        for(let e1 = 0; e1 < s; e1++)a[e1] ^= 255;
        this.buffer = a;
        this.bufferLength = s;
        this.eof = !0;
        return this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
    }
}
function convertToRGBA(e1) {
    switch(e1.kind){
        case b:
            return convertBlackAndWhiteToRGBA(e1);
        case F:
            return function convertRGBToRGBA({ src: e1, srcPos: t = 0, dest: i, destPos: a = 0, width: s, height: r }) {
                let n = 0;
                const g = s * r * 3, o = g >> 2, c = new Uint32Array(e1.buffer, t, o);
                if (FeatureTest.isLittleEndian) {
                    for(; n < o - 2; n += 3, a += 4){
                        const e1 = c[n], t = c[n + 1], s = c[n + 2];
                        i[a] = 4278190080 | e1;
                        i[a + 1] = e1 >>> 24 | t << 8 | 4278190080;
                        i[a + 2] = t >>> 16 | s << 16 | 4278190080;
                        i[a + 3] = s >>> 8 | 4278190080;
                    }
                    for(let s = 4 * n, r = t + g; s < r; s += 3)i[a++] = e1[s] | e1[s + 1] << 8 | e1[s + 2] << 16 | 4278190080;
                } else {
                    for(; n < o - 2; n += 3, a += 4){
                        const e1 = c[n], t = c[n + 1], s = c[n + 2];
                        i[a] = 255 | e1;
                        i[a + 1] = e1 << 24 | t >>> 8 | 255;
                        i[a + 2] = t << 16 | s >>> 16 | 255;
                        i[a + 3] = s << 8 | 255;
                    }
                    for(let s = 4 * n, r = t + g; s < r; s += 3)i[a++] = e1[s] << 24 | e1[s + 1] << 16 | e1[s + 2] << 8 | 255;
                }
                return {
                    srcPos: t + g,
                    destPos: a
                };
            }(e1);
    }
    return null;
}
function convertBlackAndWhiteToRGBA({ src: e1, srcPos: t = 0, dest: i, width: a, height: s, nonBlackColor: r = 4294967295, inverseDecode: n = !1 }) {
    const g = FeatureTest.isLittleEndian ? 4278190080 : 255, [o, c] = n ? [
        r,
        g
    ] : [
        g,
        r
    ], C = a >> 3, h = 7 & a, l = e1.length;
    i = new Uint32Array(i.buffer);
    let Q = 0;
    for(let a = 0; a < s; a++){
        for(const a = t + C; t < a; t++){
            const a = t < l ? e1[t] : 255;
            i[Q++] = 128 & a ? c : o;
            i[Q++] = 64 & a ? c : o;
            i[Q++] = 32 & a ? c : o;
            i[Q++] = 16 & a ? c : o;
            i[Q++] = 8 & a ? c : o;
            i[Q++] = 4 & a ? c : o;
            i[Q++] = 2 & a ? c : o;
            i[Q++] = 1 & a ? c : o;
        }
        if (0 === h) continue;
        const a = t < l ? e1[t++] : 255;
        for(let e1 = 0; e1 < h; e1++)i[Q++] = a & 1 << 7 - e1 ? c : o;
    }
    return {
        srcPos: t,
        destPos: Q
    };
}
class JpegError extends ot {
    constructor(e1){
        super(e1, "JpegError");
    }
}
class DNLMarkerError extends ot {
    constructor(e1, t){
        super(e1, "DNLMarkerError");
        this.scanLines = t;
    }
}
class EOIMarkerError extends ot {
    constructor(e1){
        super(e1, "EOIMarkerError");
    }
}
const Wt = new Uint8Array([
    0,
    1,
    8,
    16,
    9,
    2,
    3,
    10,
    17,
    24,
    32,
    25,
    18,
    11,
    4,
    5,
    12,
    19,
    26,
    33,
    40,
    48,
    41,
    34,
    27,
    20,
    13,
    6,
    7,
    14,
    21,
    28,
    35,
    42,
    49,
    56,
    57,
    50,
    43,
    36,
    29,
    22,
    15,
    23,
    30,
    37,
    44,
    51,
    58,
    59,
    52,
    45,
    38,
    31,
    39,
    46,
    53,
    60,
    61,
    54,
    47,
    55,
    62,
    63
]), jt = 4017, Xt = 799, Zt = 3406, Vt = 2276, zt = 1567, _t = 3784, $t = 5793, Ai = 2896;
function buildHuffmanTable(e1, t) {
    let i, a, s = 0, r = 16;
    for(; r > 0 && !e1[r - 1];)r--;
    const n = [
        {
            children: [],
            index: 0
        }
    ];
    let g, o = n[0];
    for(i = 0; i < r; i++){
        for(a = 0; a < e1[i]; a++){
            o = n.pop();
            o.children[o.index] = t[s];
            for(; o.index > 0;)o = n.pop();
            o.index++;
            n.push(o);
            for(; n.length <= i;){
                n.push(g = {
                    children: [],
                    index: 0
                });
                o.children[o.index] = g.children;
                o = g;
            }
            s++;
        }
        if (i + 1 < r) {
            n.push(g = {
                children: [],
                index: 0
            });
            o.children[o.index] = g.children;
            o = g;
        }
    }
    return n[0].children;
}
function getBlockBufferOffset(e1, t, i) {
    return 64 * ((e1.blocksPerLine + 1) * t + i);
}
function decodeScan(e1, t, i, a, s, r, n, g, o, c = !1) {
    const C = i.mcusPerLine, h = i.progressive, l = t;
    let Q = 0, E = 0;
    function readBit() {
        if (E > 0) {
            E--;
            return Q >> E & 1;
        }
        Q = e1[t++];
        if (255 === Q) {
            const a = e1[t++];
            if (a) {
                if (220 === a && c) {
                    const a = readUint16(e1, t += 2);
                    t += 2;
                    if (a > 0 && a !== i.scanLines) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", a);
                } else if (217 === a) {
                    if (c) {
                        const e1 = p * (8 === i.precision ? 8 : 0);
                        if (e1 > 0 && Math.round(i.scanLines / e1) >= 5) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e1);
                    }
                    throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                }
                throw new JpegError(`unexpected marker ${(Q << 8 | a).toString(16)}`);
            }
        }
        E = 7;
        return Q >>> 7;
    }
    function decodeHuffman(e1) {
        let t = e1;
        for(;;){
            t = t[readBit()];
            switch(typeof t){
                case "number":
                    return t;
                case "object":
                    continue;
            }
            throw new JpegError("invalid huffman sequence");
        }
    }
    function receive(e1) {
        let t = 0;
        for(; e1 > 0;){
            t = t << 1 | readBit();
            e1--;
        }
        return t;
    }
    function receiveAndExtend(e1) {
        if (1 === e1) return 1 === readBit() ? 1 : -1;
        const t = receive(e1);
        return t >= 1 << e1 - 1 ? t : t + (-1 << e1) + 1;
    }
    let u = 0;
    let d, f = 0;
    let p = 0;
    function decodeMcu(e1, t, i, a, s) {
        const r = i % C;
        p = (i / C | 0) * e1.v + a;
        const n = r * e1.h + s;
        t(e1, getBlockBufferOffset(e1, p, n));
    }
    function decodeBlock(e1, t, i) {
        p = i / e1.blocksPerLine | 0;
        const a = i % e1.blocksPerLine;
        t(e1, getBlockBufferOffset(e1, p, a));
    }
    const m = a.length;
    let y, w, D, b, F, S;
    S = h ? 0 === r ? 0 === g ? function decodeDCFirst(e1, t) {
        const i = decodeHuffman(e1.huffmanTableDC), a = 0 === i ? 0 : receiveAndExtend(i) << o;
        e1.blockData[t] = e1.pred += a;
    } : function decodeDCSuccessive(e1, t) {
        e1.blockData[t] |= readBit() << o;
    } : 0 === g ? function decodeACFirst(e1, t) {
        if (u > 0) {
            u--;
            return;
        }
        let i = r;
        const a = n;
        for(; i <= a;){
            const a = decodeHuffman(e1.huffmanTableAC), s = 15 & a, r = a >> 4;
            if (0 === s) {
                if (r < 15) {
                    u = receive(r) + (1 << r) - 1;
                    break;
                }
                i += 16;
                continue;
            }
            i += r;
            const n = Wt[i];
            e1.blockData[t + n] = receiveAndExtend(s) * (1 << o);
            i++;
        }
    } : function decodeACSuccessive(e1, t) {
        let i = r;
        const a = n;
        let s, g, c = 0;
        for(; i <= a;){
            const a = t + Wt[i], r = e1.blockData[a] < 0 ? -1 : 1;
            switch(f){
                case 0:
                    g = decodeHuffman(e1.huffmanTableAC);
                    s = 15 & g;
                    c = g >> 4;
                    if (0 === s) if (c < 15) {
                        u = receive(c) + (1 << c);
                        f = 4;
                    } else {
                        c = 16;
                        f = 1;
                    }
                    else {
                        if (1 !== s) throw new JpegError("invalid ACn encoding");
                        d = receiveAndExtend(s);
                        f = c ? 2 : 3;
                    }
                    continue;
                case 1:
                case 2:
                    if (e1.blockData[a]) e1.blockData[a] += r * (readBit() << o);
                    else {
                        c--;
                        0 === c && (f = 2 === f ? 3 : 0);
                    }
                    break;
                case 3:
                    if (e1.blockData[a]) e1.blockData[a] += r * (readBit() << o);
                    else {
                        e1.blockData[a] = d << o;
                        f = 0;
                    }
                    break;
                case 4:
                    e1.blockData[a] && (e1.blockData[a] += r * (readBit() << o));
            }
            i++;
        }
        if (4 === f) {
            u--;
            0 === u && (f = 0);
        }
    } : function decodeBaseline(e1, t) {
        const i = decodeHuffman(e1.huffmanTableDC), a = 0 === i ? 0 : receiveAndExtend(i);
        e1.blockData[t] = e1.pred += a;
        let s = 1;
        for(; s < 64;){
            const i = decodeHuffman(e1.huffmanTableAC), a = 15 & i, r = i >> 4;
            if (0 === a) {
                if (r < 15) break;
                s += 16;
                continue;
            }
            s += r;
            const n = Wt[s];
            e1.blockData[t + n] = receiveAndExtend(a);
            s++;
        }
    };
    let k, R = 0;
    const N = 1 === m ? a[0].blocksPerLine * a[0].blocksPerColumn : C * i.mcusPerColumn;
    let G, M;
    for(; R <= N;){
        const i = s ? Math.min(N - R, s) : N;
        if (i > 0) {
            for(w = 0; w < m; w++)a[w].pred = 0;
            u = 0;
            if (1 === m) {
                y = a[0];
                for(F = 0; F < i; F++){
                    decodeBlock(y, S, R);
                    R++;
                }
            } else for(F = 0; F < i; F++){
                for(w = 0; w < m; w++){
                    y = a[w];
                    G = y.h;
                    M = y.v;
                    for(D = 0; D < M; D++)for(b = 0; b < G; b++)decodeMcu(y, S, R, D, b);
                }
                R++;
            }
        }
        E = 0;
        k = findNextFileMarker(e1, t);
        if (!k) break;
        if (k.invalid) {
            warn(`decodeScan - ${i > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${k.invalid}`);
            t = k.offset;
        }
        if (!(k.marker >= 65488 && k.marker <= 65495)) break;
        t += 2;
    }
    return t - l;
}
function quantizeAndInverse(e1, t, i) {
    const a = e1.quantizationTable, s = e1.blockData;
    let r, n, g, o, c, C, h, l, Q, E, u, d, f, p, m, y, w;
    if (!a) throw new JpegError("missing required Quantization Table.");
    for(let e1 = 0; e1 < 64; e1 += 8){
        Q = s[t + e1];
        E = s[t + e1 + 1];
        u = s[t + e1 + 2];
        d = s[t + e1 + 3];
        f = s[t + e1 + 4];
        p = s[t + e1 + 5];
        m = s[t + e1 + 6];
        y = s[t + e1 + 7];
        Q *= a[e1];
        if (E | u | d | f | p | m | y) {
            E *= a[e1 + 1];
            u *= a[e1 + 2];
            d *= a[e1 + 3];
            f *= a[e1 + 4];
            p *= a[e1 + 5];
            m *= a[e1 + 6];
            y *= a[e1 + 7];
            r = $t * Q + 128 >> 8;
            n = $t * f + 128 >> 8;
            g = u;
            o = m;
            c = Ai * (E - y) + 128 >> 8;
            l = Ai * (E + y) + 128 >> 8;
            C = d << 4;
            h = p << 4;
            r = r + n + 1 >> 1;
            n = r - n;
            w = g * _t + o * zt + 128 >> 8;
            g = g * zt - o * _t + 128 >> 8;
            o = w;
            c = c + h + 1 >> 1;
            h = c - h;
            l = l + C + 1 >> 1;
            C = l - C;
            r = r + o + 1 >> 1;
            o = r - o;
            n = n + g + 1 >> 1;
            g = n - g;
            w = c * Vt + l * Zt + 2048 >> 12;
            c = c * Zt - l * Vt + 2048 >> 12;
            l = w;
            w = C * Xt + h * jt + 2048 >> 12;
            C = C * jt - h * Xt + 2048 >> 12;
            h = w;
            i[e1] = r + l;
            i[e1 + 7] = r - l;
            i[e1 + 1] = n + h;
            i[e1 + 6] = n - h;
            i[e1 + 2] = g + C;
            i[e1 + 5] = g - C;
            i[e1 + 3] = o + c;
            i[e1 + 4] = o - c;
        } else {
            w = $t * Q + 512 >> 10;
            i[e1] = w;
            i[e1 + 1] = w;
            i[e1 + 2] = w;
            i[e1 + 3] = w;
            i[e1 + 4] = w;
            i[e1 + 5] = w;
            i[e1 + 6] = w;
            i[e1 + 7] = w;
        }
    }
    for(let e1 = 0; e1 < 8; ++e1){
        Q = i[e1];
        E = i[e1 + 8];
        u = i[e1 + 16];
        d = i[e1 + 24];
        f = i[e1 + 32];
        p = i[e1 + 40];
        m = i[e1 + 48];
        y = i[e1 + 56];
        if (E | u | d | f | p | m | y) {
            r = $t * Q + 2048 >> 12;
            n = $t * f + 2048 >> 12;
            g = u;
            o = m;
            c = Ai * (E - y) + 2048 >> 12;
            l = Ai * (E + y) + 2048 >> 12;
            C = d;
            h = p;
            r = 4112 + (r + n + 1 >> 1);
            n = r - n;
            w = g * _t + o * zt + 2048 >> 12;
            g = g * zt - o * _t + 2048 >> 12;
            o = w;
            c = c + h + 1 >> 1;
            h = c - h;
            l = l + C + 1 >> 1;
            C = l - C;
            r = r + o + 1 >> 1;
            o = r - o;
            n = n + g + 1 >> 1;
            g = n - g;
            w = c * Vt + l * Zt + 2048 >> 12;
            c = c * Zt - l * Vt + 2048 >> 12;
            l = w;
            w = C * Xt + h * jt + 2048 >> 12;
            C = C * jt - h * Xt + 2048 >> 12;
            h = w;
            Q = r + l;
            y = r - l;
            E = n + h;
            m = n - h;
            u = g + C;
            p = g - C;
            d = o + c;
            f = o - c;
            Q < 16 ? Q = 0 : Q >= 4080 ? Q = 255 : Q >>= 4;
            E < 16 ? E = 0 : E >= 4080 ? E = 255 : E >>= 4;
            u < 16 ? u = 0 : u >= 4080 ? u = 255 : u >>= 4;
            d < 16 ? d = 0 : d >= 4080 ? d = 255 : d >>= 4;
            f < 16 ? f = 0 : f >= 4080 ? f = 255 : f >>= 4;
            p < 16 ? p = 0 : p >= 4080 ? p = 255 : p >>= 4;
            m < 16 ? m = 0 : m >= 4080 ? m = 255 : m >>= 4;
            y < 16 ? y = 0 : y >= 4080 ? y = 255 : y >>= 4;
            s[t + e1] = Q;
            s[t + e1 + 8] = E;
            s[t + e1 + 16] = u;
            s[t + e1 + 24] = d;
            s[t + e1 + 32] = f;
            s[t + e1 + 40] = p;
            s[t + e1 + 48] = m;
            s[t + e1 + 56] = y;
        } else {
            w = $t * Q + 8192 >> 14;
            w = w < -2040 ? 0 : w >= 2024 ? 255 : w + 2056 >> 4;
            s[t + e1] = w;
            s[t + e1 + 8] = w;
            s[t + e1 + 16] = w;
            s[t + e1 + 24] = w;
            s[t + e1 + 32] = w;
            s[t + e1 + 40] = w;
            s[t + e1 + 48] = w;
            s[t + e1 + 56] = w;
        }
    }
}
function buildComponentData(e1, t) {
    const i = t.blocksPerLine, a = t.blocksPerColumn, s = new Int16Array(64);
    for(let e1 = 0; e1 < a; e1++)for(let a = 0; a < i; a++){
        quantizeAndInverse(t, getBlockBufferOffset(t, e1, a), s);
    }
    return t.blockData;
}
function findNextFileMarker(e1, t, i = t) {
    const a = e1.length - 1;
    let s = i < t ? i : t;
    if (t >= a) return null;
    const r = readUint16(e1, t);
    if (r >= 65472 && r <= 65534) return {
        invalid: null,
        marker: r,
        offset: t
    };
    let n = readUint16(e1, s);
    for(; !(n >= 65472 && n <= 65534);){
        if (++s >= a) return null;
        n = readUint16(e1, s);
    }
    return {
        invalid: r.toString(16),
        marker: n,
        offset: s
    };
}
function prepareComponents(e1) {
    const t = Math.ceil(e1.samplesPerLine / 8 / e1.maxH), i = Math.ceil(e1.scanLines / 8 / e1.maxV);
    for (const a of e1.components){
        const s = Math.ceil(Math.ceil(e1.samplesPerLine / 8) * a.h / e1.maxH), r = Math.ceil(Math.ceil(e1.scanLines / 8) * a.v / e1.maxV), n = t * a.h, g = 64 * (i * a.v) * (n + 1);
        a.blockData = new Int16Array(g);
        a.blocksPerLine = s;
        a.blocksPerColumn = r;
    }
    e1.mcusPerLine = t;
    e1.mcusPerColumn = i;
}
function readDataBlock(e1, t) {
    const i = readUint16(e1, t);
    let a = (t += 2) + i - 2;
    const s = findNextFileMarker(e1, a, t);
    if (s?.invalid) {
        warn("readDataBlock - incorrect length, current marker is: " + s.invalid);
        a = s.offset;
    }
    const r = e1.subarray(t, a);
    return {
        appData: r,
        newOffset: t += r.length
    };
}
function skipData(e1, t) {
    const i = readUint16(e1, t), a = (t += 2) + i - 2, s = findNextFileMarker(e1, a, t);
    return s?.invalid ? s.offset : a;
}
class JpegImage {
    constructor({ decodeTransform: e1 = null, colorTransform: t = -1 } = {}){
        this._decodeTransform = e1;
        this._colorTransform = t;
    }
    static canUseImageDecoder(e1, t = -1) {
        let i = 0, a = null, s = readUint16(e1, i);
        i += 2;
        if (65496 !== s) throw new JpegError("SOI not found");
        s = readUint16(e1, i);
        i += 2;
        A: for(; 65497 !== s;){
            switch(s){
                case 65472:
                case 65473:
                case 65474:
                    a = e1[i + 7];
                    break A;
                case 65535:
                    255 !== e1[i] && i--;
            }
            i = skipData(e1, i);
            s = readUint16(e1, i);
            i += 2;
        }
        return 4 !== a && (3 !== a || 0 !== t);
    }
    parse(e1, { dnlScanLines: t = null } = {}) {
        let i, a, s = 0, r = null, n = null, g = 0;
        const o = [], c = [], C = [];
        let h = readUint16(e1, s);
        s += 2;
        if (65496 !== h) throw new JpegError("SOI not found");
        h = readUint16(e1, s);
        s += 2;
        A: for(; 65497 !== h;){
            let l, Q, E;
            switch(h){
                case 65504:
                case 65505:
                case 65506:
                case 65507:
                case 65508:
                case 65509:
                case 65510:
                case 65511:
                case 65512:
                case 65513:
                case 65514:
                case 65515:
                case 65516:
                case 65517:
                case 65518:
                case 65519:
                case 65534:
                    const { appData: u, newOffset: d } = readDataBlock(e1, s);
                    s = d;
                    65504 === h && 74 === u[0] && 70 === u[1] && 73 === u[2] && 70 === u[3] && 0 === u[4] && (r = {
                        version: {
                            major: u[5],
                            minor: u[6]
                        },
                        densityUnits: u[7],
                        xDensity: u[8] << 8 | u[9],
                        yDensity: u[10] << 8 | u[11],
                        thumbWidth: u[12],
                        thumbHeight: u[13],
                        thumbData: u.subarray(14, 14 + 3 * u[12] * u[13])
                    });
                    65518 === h && 65 === u[0] && 100 === u[1] && 111 === u[2] && 98 === u[3] && 101 === u[4] && (n = {
                        version: u[5] << 8 | u[6],
                        flags0: u[7] << 8 | u[8],
                        flags1: u[9] << 8 | u[10],
                        transformCode: u[11]
                    });
                    break;
                case 65499:
                    const f = readUint16(e1, s);
                    s += 2;
                    const p = f + s - 2;
                    let m;
                    for(; s < p;){
                        const t = e1[s++], i = new Uint16Array(64);
                        if (t >> 4) {
                            if (t >> 4 != 1) throw new JpegError("DQT - invalid table spec");
                            for(Q = 0; Q < 64; Q++){
                                m = Wt[Q];
                                i[m] = readUint16(e1, s);
                                s += 2;
                            }
                        } else for(Q = 0; Q < 64; Q++){
                            m = Wt[Q];
                            i[m] = e1[s++];
                        }
                        o[15 & t] = i;
                    }
                    break;
                case 65472:
                case 65473:
                case 65474:
                    if (i) throw new JpegError("Only single frame JPEGs supported");
                    s += 2;
                    i = {};
                    i.extended = 65473 === h;
                    i.progressive = 65474 === h;
                    i.precision = e1[s++];
                    const y = readUint16(e1, s);
                    s += 2;
                    i.scanLines = t || y;
                    i.samplesPerLine = readUint16(e1, s);
                    s += 2;
                    i.components = [];
                    i.componentIds = {};
                    const w = e1[s++];
                    let D = 0, b = 0;
                    for(l = 0; l < w; l++){
                        const t = e1[s], a = e1[s + 1] >> 4, r = 15 & e1[s + 1];
                        D < a && (D = a);
                        b < r && (b = r);
                        const n = e1[s + 2];
                        E = i.components.push({
                            h: a,
                            v: r,
                            quantizationId: n,
                            quantizationTable: null
                        });
                        i.componentIds[t] = E - 1;
                        s += 3;
                    }
                    i.maxH = D;
                    i.maxV = b;
                    prepareComponents(i);
                    break;
                case 65476:
                    const F = readUint16(e1, s);
                    s += 2;
                    for(l = 2; l < F;){
                        const t = e1[s++], i = new Uint8Array(16);
                        let a = 0;
                        for(Q = 0; Q < 16; Q++, s++)a += i[Q] = e1[s];
                        const r = new Uint8Array(a);
                        for(Q = 0; Q < a; Q++, s++)r[Q] = e1[s];
                        l += 17 + a;
                        (t >> 4 ? c : C)[15 & t] = buildHuffmanTable(i, r);
                    }
                    break;
                case 65501:
                    s += 2;
                    a = readUint16(e1, s);
                    s += 2;
                    break;
                case 65498:
                    const S = 1 == ++g && !t;
                    s += 2;
                    const k = e1[s++], R = [];
                    for(l = 0; l < k; l++){
                        const t = e1[s++], a = i.componentIds[t], r = i.components[a];
                        r.index = t;
                        const n = e1[s++];
                        r.huffmanTableDC = C[n >> 4];
                        r.huffmanTableAC = c[15 & n];
                        R.push(r);
                    }
                    const N = e1[s++], G = e1[s++], M = e1[s++];
                    try {
                        s += decodeScan(e1, s, i, R, a, N, G, M >> 4, 15 & M, S);
                    } catch (t) {
                        if (t instanceof DNLMarkerError) {
                            warn(`${t.message} -- attempting to re-parse the JPEG image.`);
                            return this.parse(e1, {
                                dnlScanLines: t.scanLines
                            });
                        }
                        if (t instanceof EOIMarkerError) {
                            warn(`${t.message} -- ignoring the rest of the image data.`);
                            break A;
                        }
                        throw t;
                    }
                    break;
                case 65500:
                    s += 4;
                    break;
                case 65535:
                    255 !== e1[s] && s--;
                    break;
                default:
                    const U = findNextFileMarker(e1, s - 2, s - 3);
                    if (U?.invalid) {
                        warn("JpegImage.parse - unexpected data, current marker is: " + U.invalid);
                        s = U.offset;
                        break;
                    }
                    if (!U || s >= e1.length - 1) {
                        warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                        break A;
                    }
                    throw new JpegError("JpegImage.parse - unknown marker: " + h.toString(16));
            }
            h = readUint16(e1, s);
            s += 2;
        }
        if (!i) throw new JpegError("JpegImage.parse - no frame data found.");
        this.width = i.samplesPerLine;
        this.height = i.scanLines;
        this.jfif = r;
        this.adobe = n;
        this.components = [];
        for (const e1 of i.components){
            const t = o[e1.quantizationId];
            t && (e1.quantizationTable = t);
            this.components.push({
                index: e1.index,
                output: buildComponentData(0, e1),
                scaleX: e1.h / i.maxH,
                scaleY: e1.v / i.maxV,
                blocksPerLine: e1.blocksPerLine,
                blocksPerColumn: e1.blocksPerColumn
            });
        }
        this.numComponents = this.components.length;
    }
    _getLinearizedBlockData(e1, t, i = !1) {
        const a = this.width / e1, s = this.height / t;
        let r, n, g, o, c, C, h, l, Q, E, u, d = 0;
        const f = this.components.length, p = e1 * t * f, m = new Uint8ClampedArray(p), y = new Uint32Array(e1), w = 4294967288;
        let D;
        for(h = 0; h < f; h++){
            r = this.components[h];
            n = r.scaleX * a;
            g = r.scaleY * s;
            d = h;
            u = r.output;
            o = r.blocksPerLine + 1 << 3;
            if (n !== D) {
                for(c = 0; c < e1; c++){
                    l = 0 | c * n;
                    y[c] = (l & w) << 3 | 7 & l;
                }
                D = n;
            }
            for(C = 0; C < t; C++){
                l = 0 | C * g;
                E = o * (l & w) | (7 & l) << 3;
                for(c = 0; c < e1; c++){
                    m[d] = u[E + y[c]];
                    d += f;
                }
            }
        }
        let b = this._decodeTransform;
        i || 4 !== f || b || (b = new Int32Array([
            -256,
            255,
            -256,
            255,
            -256,
            255,
            -256,
            255
        ]));
        if (b) for(h = 0; h < p;)for(l = 0, Q = 0; l < f; l++, h++, Q += 2)m[h] = (m[h] * b[Q] >> 8) + b[Q + 1];
        return m;
    }
    get _isColorConversionNeeded() {
        return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
    }
    _convertYccToRgb(e1) {
        let t, i, a;
        for(let s = 0, r = e1.length; s < r; s += 3){
            t = e1[s];
            i = e1[s + 1];
            a = e1[s + 2];
            e1[s] = t - 179.456 + 1.402 * a;
            e1[s + 1] = t + 135.459 - .344 * i - .714 * a;
            e1[s + 2] = t - 226.816 + 1.772 * i;
        }
        return e1;
    }
    _convertYccToRgba(e1, t) {
        for(let i = 0, a = 0, s = e1.length; i < s; i += 3, a += 4){
            const s = e1[i], r = e1[i + 1], n = e1[i + 2];
            t[a] = s - 179.456 + 1.402 * n;
            t[a + 1] = s + 135.459 - .344 * r - .714 * n;
            t[a + 2] = s - 226.816 + 1.772 * r;
            t[a + 3] = 255;
        }
        return t;
    }
    _convertYcckToRgb(e1) {
        let t, i, a, s, r = 0;
        for(let n = 0, g = e1.length; n < g; n += 4){
            t = e1[n];
            i = e1[n + 1];
            a = e1[n + 2];
            s = e1[n + 3];
            e1[r++] = i * (-660635669420364e-19 * i + .000437130475926232 * a - 54080610064599e-18 * t + .00048449797120281 * s - .154362151871126) - 122.67195406894 + a * (-.000957964378445773 * a + .000817076911346625 * t - .00477271405408747 * s + 1.53380253221734) + t * (.000961250184130688 * t - .00266257332283933 * s + .48357088451265) + s * (-.000336197177618394 * s + .484791561490776);
            e1[r++] = 107.268039397724 + i * (219927104525741e-19 * i - .000640992018297945 * a + .000659397001245577 * t + .000426105652938837 * s - .176491792462875) + a * (-.000778269941513683 * a + .00130872261408275 * t + .000770482631801132 * s - .151051492775562) + t * (.00126935368114843 * t - .00265090189010898 * s + .25802910206845) + s * (-.000318913117588328 * s - .213742400323665);
            e1[r++] = i * (-.000570115196973677 * i - 263409051004589e-19 * a + .0020741088115012 * t - .00288260236853442 * s + .814272968359295) - 20.810012546947 + a * (-153496057440975e-19 * a - .000132689043961446 * t + .000560833691242812 * s - .195152027534049) + t * (.00174418132927582 * t - .00255243321439347 * s + .116935020465145) + s * (-.000343531996510555 * s + .24165260232407);
        }
        return e1.subarray(0, r);
    }
    _convertYcckToRgba(e1) {
        for(let t = 0, i = e1.length; t < i; t += 4){
            const i = e1[t], a = e1[t + 1], s = e1[t + 2], r = e1[t + 3];
            e1[t] = a * (-660635669420364e-19 * a + .000437130475926232 * s - 54080610064599e-18 * i + .00048449797120281 * r - .154362151871126) - 122.67195406894 + s * (-.000957964378445773 * s + .000817076911346625 * i - .00477271405408747 * r + 1.53380253221734) + i * (.000961250184130688 * i - .00266257332283933 * r + .48357088451265) + r * (-.000336197177618394 * r + .484791561490776);
            e1[t + 1] = 107.268039397724 + a * (219927104525741e-19 * a - .000640992018297945 * s + .000659397001245577 * i + .000426105652938837 * r - .176491792462875) + s * (-.000778269941513683 * s + .00130872261408275 * i + .000770482631801132 * r - .151051492775562) + i * (.00126935368114843 * i - .00265090189010898 * r + .25802910206845) + r * (-.000318913117588328 * r - .213742400323665);
            e1[t + 2] = a * (-.000570115196973677 * a - 263409051004589e-19 * s + .0020741088115012 * i - .00288260236853442 * r + .814272968359295) - 20.810012546947 + s * (-153496057440975e-19 * s - .000132689043961446 * i + .000560833691242812 * r - .195152027534049) + i * (.00174418132927582 * i - .00255243321439347 * r + .116935020465145) + r * (-.000343531996510555 * r + .24165260232407);
            e1[t + 3] = 255;
        }
        return e1;
    }
    _convertYcckToCmyk(e1) {
        let t, i, a;
        for(let s = 0, r = e1.length; s < r; s += 4){
            t = e1[s];
            i = e1[s + 1];
            a = e1[s + 2];
            e1[s] = 434.456 - t - 1.402 * a;
            e1[s + 1] = 119.541 - t + .344 * i + .714 * a;
            e1[s + 2] = 481.816 - t - 1.772 * i;
        }
        return e1;
    }
    _convertCmykToRgb(e1) {
        let t, i, a, s, r = 0;
        for(let n = 0, g = e1.length; n < g; n += 4){
            t = e1[n];
            i = e1[n + 1];
            a = e1[n + 2];
            s = e1[n + 3];
            e1[r++] = 255 + t * (-6747147073602441e-20 * t + .0008379262121013727 * i + .0002894718188643294 * a + .003264231057537806 * s - 1.1185611867203937) + i * (26374107616089405e-21 * i - 8626949158638572e-20 * a - .0002748769067499491 * s - .02155688794978967) + a * (-3878099212869363e-20 * a - .0003267808279485286 * s + .0686742238595345) - s * (.0003361971776183937 * s + .7430659151342254);
            e1[r++] = 255 + t * (.00013596372813588848 * t + .000924537132573585 * i + .00010567359618683593 * a + .0004791864687436512 * s - .3109689587515875) + i * (-.00023545346108370344 * i + .0002702845253534714 * a + .0020200308977307156 * s - .7488052167015494) + a * (6834815998235662e-20 * a + .00015168452363460973 * s - .09751927774728933) - s * (.0003189131175883281 * s + .7364883807733168);
            e1[r++] = 255 + t * (13598650411385307e-21 * t + .00012423956175490851 * i + .0004751985097583589 * a - 36729317476630422e-22 * s - .05562186980264034) + i * (.00016141380598724676 * i + .0009692239130725186 * a + .0007782692450036253 * s - .44015232367526463) + a * (5.068882914068769e-7 * a + .0017778369011375071 * s - .7591454649749609) - s * (.0003435319965105553 * s + .7063770186160144);
        }
        return e1.subarray(0, r);
    }
    _convertCmykToRgba(e1) {
        for(let t = 0, i = e1.length; t < i; t += 4){
            const i = e1[t], a = e1[t + 1], s = e1[t + 2], r = e1[t + 3];
            e1[t] = 255 + i * (-6747147073602441e-20 * i + .0008379262121013727 * a + .0002894718188643294 * s + .003264231057537806 * r - 1.1185611867203937) + a * (26374107616089405e-21 * a - 8626949158638572e-20 * s - .0002748769067499491 * r - .02155688794978967) + s * (-3878099212869363e-20 * s - .0003267808279485286 * r + .0686742238595345) - r * (.0003361971776183937 * r + .7430659151342254);
            e1[t + 1] = 255 + i * (.00013596372813588848 * i + .000924537132573585 * a + .00010567359618683593 * s + .0004791864687436512 * r - .3109689587515875) + a * (-.00023545346108370344 * a + .0002702845253534714 * s + .0020200308977307156 * r - .7488052167015494) + s * (6834815998235662e-20 * s + .00015168452363460973 * r - .09751927774728933) - r * (.0003189131175883281 * r + .7364883807733168);
            e1[t + 2] = 255 + i * (13598650411385307e-21 * i + .00012423956175490851 * a + .0004751985097583589 * s - 36729317476630422e-22 * r - .05562186980264034) + a * (.00016141380598724676 * a + .0009692239130725186 * s + .0007782692450036253 * r - .44015232367526463) + s * (5.068882914068769e-7 * s + .0017778369011375071 * r - .7591454649749609) - r * (.0003435319965105553 * r + .7063770186160144);
            e1[t + 3] = 255;
        }
        return e1;
    }
    getData({ width: e1, height: t, forceRGBA: i = !1, forceRGB: a = !1, isSourcePDF: s = !1 }) {
        if (this.numComponents > 4) throw new JpegError("Unsupported color mode");
        const r = this._getLinearizedBlockData(e1, t, s);
        if (1 === this.numComponents && (i || a)) {
            const e1 = r.length * (i ? 4 : 3), t = new Uint8ClampedArray(e1);
            let a = 0;
            if (i) !function grayToRGBA(e1, t) {
                if (FeatureTest.isLittleEndian) for(let i = 0, a = e1.length; i < a; i++)t[i] = 65793 * e1[i] | 4278190080;
                else for(let i = 0, a = e1.length; i < a; i++)t[i] = 16843008 * e1[i] | 255;
            }(r, new Uint32Array(t.buffer));
            else for (const e1 of r){
                t[a++] = e1;
                t[a++] = e1;
                t[a++] = e1;
            }
            return t;
        }
        if (3 === this.numComponents && this._isColorConversionNeeded) {
            if (i) {
                const e1 = new Uint8ClampedArray(r.length / 3 * 4);
                return this._convertYccToRgba(r, e1);
            }
            return this._convertYccToRgb(r);
        }
        if (4 === this.numComponents) {
            if (this._isColorConversionNeeded) return i ? this._convertYcckToRgba(r) : a ? this._convertYcckToRgb(r) : this._convertYcckToCmyk(r);
            if (i) return this._convertCmykToRgba(r);
            if (a) return this._convertCmykToRgb(r);
        }
        return r;
    }
}
class JpegStream extends DecodeStream {
    static #y = FeatureTest.isImageDecoderSupported;
    constructor(e1, t, i){
        super(t);
        this.stream = e1;
        this.dict = e1.dict;
        this.maybeLength = t;
        this.params = i;
    }
    static get canUseImageDecoder() {
        return shadow(this, "canUseImageDecoder", this.#y ? ImageDecoder.isTypeSupported("image/jpeg") : Promise.resolve(!1));
    }
    static setOptions({ isImageDecoderSupported: e1 = !1 }) {
        this.#y = e1;
    }
    get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e1) {}
    readBlock() {
        this.decodeImage();
    }
    get jpegOptions() {
        const e1 = {
            decodeTransform: void 0,
            colorTransform: void 0
        }, t = this.dict.getArray("D", "Decode");
        if ((this.forceRGBA || this.forceRGB) && Array.isArray(t)) {
            const i = this.dict.get("BPC", "BitsPerComponent") || 8, a = t.length, s = new Int32Array(a);
            let r = !1;
            const n = (1 << i) - 1;
            for(let e1 = 0; e1 < a; e1 += 2){
                s[e1] = 256 * (t[e1 + 1] - t[e1]) | 0;
                s[e1 + 1] = t[e1] * n | 0;
                256 === s[e1] && 0 === s[e1 + 1] || (r = !0);
            }
            r && (e1.decodeTransform = s);
        }
        if (this.params instanceof Dict) {
            const t = this.params.get("ColorTransform");
            Number.isInteger(t) && (e1.colorTransform = t);
        }
        return shadow(this, "jpegOptions", e1);
    }
    #w(e1) {
        for(let t = 0, i = e1.length - 1; t < i; t++)if (255 === e1[t] && 216 === e1[t + 1]) {
            t > 0 && (e1 = e1.subarray(t));
            break;
        }
        return e1;
    }
    decodeImage(e1) {
        if (this.eof) return this.buffer;
        e1 = this.#w(e1 || this.bytes);
        const t = new JpegImage(this.jpegOptions);
        t.parse(e1);
        const i = t.getData({
            width: this.drawWidth,
            height: this.drawHeight,
            forceRGBA: this.forceRGBA,
            forceRGB: this.forceRGB,
            isSourcePDF: !0
        });
        this.buffer = i;
        this.bufferLength = i.length;
        this.eof = !0;
        return this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
    }
    async getTransferableImage() {
        if (!await JpegStream.canUseImageDecoder) return null;
        const e1 = this.jpegOptions;
        if (e1.decodeTransform) return null;
        let t;
        try {
            const i = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
            if (!i) return null;
            const a = this.#w(i);
            if (!JpegImage.canUseImageDecoder(a, e1.colorTransform)) return null;
            t = new ImageDecoder({
                data: a,
                type: "image/jpeg",
                preferAnimation: !1
            });
            return (await t.decode()).image;
        } catch (e1) {
            warn(`getTransferableImage - failed: "${e1}".`);
            return null;
        } finally{
            t?.close();
        }
    }
}
var ei, ti = (ei = "undefined" != typeof document ? document.currentScript?.src : void 0, function(e1 = {}) {
    var t, i, a = e1;
    new Promise((e1, a)=>{
        t = e1;
        i = a;
    });
    a.decode = function(e1, { numComponents: t = 4, isIndexedColormap: i = !1, smaskInData: s = !1 }) {
        const r = e1.length, n = a._malloc(r);
        a.HEAPU8.set(e1, n);
        const g = a._jp2_decode(n, r, t > 0 ? t : 0, !!i, !!s);
        a._free(n);
        if (g) {
            const { errorMessages: e1 } = a;
            if (e1) {
                delete a.errorMessages;
                return e1;
            }
            return "Unknown error";
        }
        const { imageData: o } = a;
        a.imageData = null;
        return o;
    };
    var s = Object.assign({}, a), r = "./this.program", quit_ = (e1, t)=>{
        throw t;
    }, n = "";
    "undefined" != typeof document && document.currentScript && (n = document.currentScript.src);
    ei && (n = ei);
    n = n.startsWith("blob:") ? "" : n.substr(0, n.replace(/[?#].*/, "").lastIndexOf("/") + 1);
    var g = a.print || console.log.bind(console), o = a.printErr || console.error.bind(console);
    Object.assign(a, s);
    s = null;
    a.arguments && a.arguments;
    a.thisProgram && (r = a.thisProgram);
    var c, C = a.wasmBinary;
    function tryParseAsDataURI(e1) {
        if (isDataURI(e1)) return function intArrayFromBase64(e1) {
            for(var t = atob(e1), i = new Uint8Array(t.length), a = 0; a < t.length; ++a)i[a] = t.charCodeAt(a);
            return i;
        }(e1.slice(b.length));
    }
    var h, l, Q, E, u = !1;
    function updateMemoryViews() {
        var e1 = c.buffer;
        a.HEAP8 = l = new Int8Array(e1);
        a.HEAP16 = new Int16Array(e1);
        a.HEAPU8 = Q = new Uint8Array(e1);
        a.HEAPU16 = new Uint16Array(e1);
        a.HEAP32 = new Int32Array(e1);
        a.HEAPU32 = E = new Uint32Array(e1);
        a.HEAPF32 = new Float32Array(e1);
        a.HEAPF64 = new Float64Array(e1);
    }
    var d, f = [], p = [], m = [], y = 0, w = null, D = null, b = "data:application/octet-stream;base64,", isDataURI = (e1)=>e1.startsWith(b);
    function instantiateSync(e1, t) {
        var i, a = function getBinarySync(e1) {
            if (e1 == d && C) return new Uint8Array(C);
            var t = tryParseAsDataURI(e1);
            if (t) return t;
            throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
        }(e1);
        i = new WebAssembly.Module(a);
        return [
            new WebAssembly.Instance(i, t),
            i
        ];
    }
    class ExitStatus {
        name = "ExitStatus";
        constructor(e1){
            this.message = `Program terminated with exit(${e1})`;
            this.status = e1;
        }
    }
    var F, callRuntimeCallbacks = (e1)=>{
        for(; e1.length > 0;)e1.shift()(a);
    }, S = a.noExitRuntime || !0, k = 0, R = {}, handleException = (e1)=>{
        if (e1 instanceof ExitStatus || "unwind" == e1) return h;
        quit_(0, e1);
    }, keepRuntimeAlive = ()=>S || k > 0, _proc_exit = (e1)=>{
        h = e1;
        if (!keepRuntimeAlive()) {
            a.onExit?.(e1);
            u = !0;
        }
        quit_(0, new ExitStatus(e1));
    }, _exit = (e1, t)=>{
        h = e1;
        _proc_exit(e1);
    }, callUserCallback = (e1)=>{
        if (!u) try {
            e1();
            (()=>{
                if (!keepRuntimeAlive()) try {
                    _exit(h);
                } catch (e1) {
                    handleException(e1);
                }
            })();
        } catch (e1) {
            handleException(e1);
        }
    }, growMemory = (e1)=>{
        var t = (e1 - c.buffer.byteLength + 65535) / 65536 | 0;
        try {
            c.grow(t);
            updateMemoryViews();
            return 1;
        } catch (e1) {}
    }, N = {}, getEnvStrings = ()=>{
        if (!getEnvStrings.strings) {
            var e1 = {
                USER: "web_user",
                LOGNAME: "web_user",
                PATH: "/",
                PWD: "/",
                HOME: "/home/web_user",
                LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                _: r || "./this.program"
            };
            for(var t in N)void 0 === N[t] ? delete e1[t] : e1[t] = N[t];
            var i = [];
            for(var t in e1)i.push(`${t}=${e1[t]}`);
            getEnvStrings.strings = i;
        }
        return getEnvStrings.strings;
    }, G = [
        null,
        [],
        []
    ], M = "undefined" != typeof TextDecoder ? new TextDecoder : void 0, UTF8ArrayToString = (e1, t = 0, i = NaN)=>{
        for(var a = t + i, s = t; e1[s] && !(s >= a);)++s;
        if (s - t > 16 && e1.buffer && M) return M.decode(e1.subarray(t, s));
        for(var r = ""; t < s;){
            var n = e1[t++];
            if (128 & n) {
                var g = 63 & e1[t++];
                if (192 != (224 & n)) {
                    var o = 63 & e1[t++];
                    if ((n = 224 == (240 & n) ? (15 & n) << 12 | g << 6 | o : (7 & n) << 18 | g << 12 | o << 6 | 63 & e1[t++]) < 65536) r += String.fromCharCode(n);
                    else {
                        var c = n - 65536;
                        r += String.fromCharCode(55296 | c >> 10, 56320 | 1023 & c);
                    }
                } else r += String.fromCharCode((31 & n) << 6 | g);
            } else r += String.fromCharCode(n);
        }
        return r;
    }, printChar = (e1, t)=>{
        var i = G[e1];
        if (0 === t || 10 === t) {
            (1 === e1 ? g : o)(UTF8ArrayToString(i));
            i.length = 0;
        } else i.push(t);
    }, UTF8ToString = (e1, t)=>e1 ? UTF8ArrayToString(Q, e1, t) : "", U = {
        m: ()=>(function abort(e1) {
                a.onAbort?.(e1);
                o(e1 = "Aborted(" + e1 + ")");
                u = !0;
                e1 += ". Build with -sASSERTIONS for more info.";
                var t = new WebAssembly.RuntimeError(e1);
                i(t);
                throw t;
            })(""),
        c: (e1, t, i)=>Q.copyWithin(e1, t, t + i),
        l: ()=>{
            S = !1;
            k = 0;
        },
        n: (e1, t)=>{
            if (R[e1]) {
                clearTimeout(R[e1].id);
                delete R[e1];
            }
            if (!t) return 0;
            var i = setTimeout(()=>{
                delete R[e1];
                callUserCallback(()=>L(e1, performance.now()));
            }, t);
            R[e1] = {
                id: i,
                timeout_ms: t
            };
            return 0;
        },
        g: function _copy_pixels_1(e1, t) {
            e1 >>= 2;
            const i = a.imageData = new Uint8ClampedArray(t), s = a.HEAP32.subarray(e1, e1 + t);
            i.set(s);
        },
        f: function _copy_pixels_3(e1, t, i, s) {
            e1 >>= 2;
            t >>= 2;
            i >>= 2;
            const r = a.imageData = new Uint8ClampedArray(3 * s), n = a.HEAP32.subarray(e1, e1 + s), g = a.HEAP32.subarray(t, t + s), o = a.HEAP32.subarray(i, i + s);
            for(let e1 = 0; e1 < s; e1++){
                r[3 * e1] = n[e1];
                r[3 * e1 + 1] = g[e1];
                r[3 * e1 + 2] = o[e1];
            }
        },
        e: function _copy_pixels_4(e1, t, i, s, r) {
            e1 >>= 2;
            t >>= 2;
            i >>= 2;
            s >>= 2;
            const n = a.imageData = new Uint8ClampedArray(4 * r), g = a.HEAP32.subarray(e1, e1 + r), o = a.HEAP32.subarray(t, t + r), c = a.HEAP32.subarray(i, i + r), C = a.HEAP32.subarray(s, s + r);
            for(let e1 = 0; e1 < r; e1++){
                n[4 * e1] = g[e1];
                n[4 * e1 + 1] = o[e1];
                n[4 * e1 + 2] = c[e1];
                n[4 * e1 + 3] = C[e1];
            }
        },
        o: (e1)=>{
            var t, i, a = Q.length, s = 2147483648;
            if ((e1 >>>= 0) > s) return !1;
            for(var r = 1; r <= 4; r *= 2){
                var n = a * (1 + .2 / r);
                n = Math.min(n, e1 + 100663296);
                var g = Math.min(s, (t = Math.max(e1, n), i = 65536, Math.ceil(t / i) * i));
                if (growMemory(g)) return !0;
            }
            return !1;
        },
        p: (e1, t)=>{
            var i = 0;
            getEnvStrings().forEach((a, s)=>{
                var r = t + i;
                E[e1 + 4 * s >> 2] = r;
                ((e1, t)=>{
                    for(var i = 0; i < e1.length; ++i)l[t++] = e1.charCodeAt(i);
                    l[t] = 0;
                })(a, r);
                i += a.length + 1;
            });
            return 0;
        },
        q: (e1, t)=>{
            var i = getEnvStrings();
            E[e1 >> 2] = i.length;
            var a = 0;
            i.forEach((e1)=>a += e1.length + 1);
            E[t >> 2] = a;
            return 0;
        },
        r: (e1)=>52,
        j: function _fd_seek(e1, t, i, a, s) {
            return 70;
        },
        b: (e1, t, i, a)=>{
            for(var s = 0, r = 0; r < i; r++){
                var n = E[t >> 2], g = E[t + 4 >> 2];
                t += 8;
                for(var o = 0; o < g; o++)printChar(e1, Q[n + o]);
                s += g;
            }
            E[a >> 2] = s;
            return 0;
        },
        s: function _gray_to_rgba(e1, t) {
            e1 >>= 2;
            const i = a.imageData = new Uint8ClampedArray(4 * t), s = a.HEAP32.subarray(e1, e1 + t);
            for(let e1 = 0; e1 < t; e1++){
                i[4 * e1] = i[4 * e1 + 1] = i[4 * e1 + 2] = s[e1];
                i[4 * e1 + 3] = 255;
            }
        },
        i: function _graya_to_rgba(e1, t, i) {
            e1 >>= 2;
            t >>= 2;
            const s = a.imageData = new Uint8ClampedArray(4 * i), r = a.HEAP32.subarray(e1, e1 + i), n = a.HEAP32.subarray(t, t + i);
            for(let e1 = 0; e1 < i; e1++){
                s[4 * e1] = s[4 * e1 + 1] = s[4 * e1 + 2] = r[e1];
                s[4 * e1 + 3] = n[e1];
            }
        },
        d: function _jsPrintWarning(e1) {
            const t = UTF8ToString(e1);
            (a.warn || console.warn)(`OpenJPEG: ${t}`);
        },
        k: _proc_exit,
        h: function _rgb_to_rgba(e1, t, i, s) {
            e1 >>= 2;
            t >>= 2;
            i >>= 2;
            const r = a.imageData = new Uint8ClampedArray(4 * s), n = a.HEAP32.subarray(e1, e1 + s), g = a.HEAP32.subarray(t, t + s), o = a.HEAP32.subarray(i, i + s);
            for(let e1 = 0; e1 < s; e1++){
                r[4 * e1] = n[e1];
                r[4 * e1 + 1] = g[e1];
                r[4 * e1 + 2] = o[e1];
                r[4 * e1 + 3] = 255;
            }
        },
        a: function _storeErrorMessage(e1) {
            const t = UTF8ToString(e1);
            a.errorMessages ? a.errorMessages += "\n" + t : a.errorMessages = t;
        }
    }, x = function createWasm() {
        function receiveInstance(e1, t) {
            x = e1.exports;
            c = x.t;
            updateMemoryViews();
            !function addOnInit(e1) {
                p.unshift(e1);
            }(x.u);
            !function removeRunDependency(e1) {
                y--;
                a.monitorRunDependencies?.(y);
                if (0 == y) {
                    if ("TURBOPACK compile-time falsy", 0) {
                        "TURBOPACK unreachable";
                    }
                    if (D) {
                        var t = D;
                        D = null;
                        t();
                    }
                }
            }();
            return x;
        }
        !function addRunDependency(e1) {
            y++;
            a.monitorRunDependencies?.(y);
        }();
        var e1 = function getWasmImports() {
            return {
                a: U
            };
        }();
        if (a.instantiateWasm) try {
            return a.instantiateWasm(e1, receiveInstance);
        } catch (e1) {
            o(`Module.instantiateWasm callback failed with error: ${e1}`);
            i(e1);
        }
        d ??= "data:application/octet-stream;base64,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A3FFBEACQCAAQQNxRQRAIAAhAgwBCyACRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAkEDcUUNASACIANJDQALCyADQXxxIQQCQCADQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0EEayIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAswAQF/AkAgAEUNACABRQ0AQQggACABbCIBECkiAARAIABBACABEBkaCyAAIQILIAILEQAgAEUEQEEADwtBCCAAECkL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASAC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CyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMPCyABQYCABGtB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBA8LC0HUzQFBGTYCAEF/DwsgACABOgAAQQELfgIBfwF+IAC9IgNCNIinQf8PcSICQf8PRwR8IAJFBEAgASAARAAAAAAAAAAAYQR/QQAFIABEAAAAAAAA8EOiIAEQcCEAIAEoAgBBQGoLNgIAIAAPCyABIAJB/gdrNgIAIANC/////////4eAf4NCgICAgICAgPA/hL8FIAALC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC28BBX8gACgCACIDLAAAQTBrIgFBCUsEQEEADwsDQEF/IQQgAkHMmbPmAE0EQEF/IAEgAkEKbCIFaiABIAVB/////wdzSxshBAsgACADQQFqIgU2AgAgAywAASAEIQIgBSEDQTBrIgFBCkkNAAsgAgtJAQF/AkBBAUEsEBciAQRAIAFBADYCEAJAIABBAEwEQCABQQFBCBAXIgA2AiQgAEUNAQwDCyABQQA2AgwLIAEQFAtBACEBCyABC64UAhJ/An4jAEFAaiIIJAAgCCABNgI8IAhBJ2ohFyAIQShqIRICQAJAAkACQANAQQAhBwNA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KAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGEBYaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEEBYaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACC6YFAgZ+BH8gASABKAIAQQdqQXhxIgFBEGo2AgAgACABKQMAIQIgASkDCCEHIwBBIGsiCCQAIAdC////////P4MhBAJ+IAdCMIhC//8BgyIDpyIKQYH4AGtB/Q9NBEAgBEIEhiACQjyIhCEDIApBgPgAa60hBAJAIAJC//////////8PgyICQoGAgICAgICACFoEQCADQgF8IQMMAQsgAkKAgICAgICAgAhSDQAgA0IBgyADfCEDC0IAIAMgA0L/////////B1YiABshAiAArSAEfAwBCwJAIAIgBIRQDQAgA0L//wFSDQAgBEIEhiACQjyIhEKAgICAgICABIQhAkL/DwwBCyAKQf6HAUsEQEIAIQJC/w8MAQtBgPgAQYH4ACADUCIBGyIAIAprIglB8ABKBEBCACECQgAMAQsgAiEDIAQgBEKAgICAgIDAAIQgARsiBSEGAkBBgAEgCWsiAUHAAHEEQCACIAFBQGqthiEGQgAhAwwBCyABRQ0AIAYgAa0iBIYgA0HAACABa62IhCEGIAMgBIYhAwsgCCADNwMQIAggBjcDGAJAIAlBwABxBEAgBSAJQUBqrYghAkIAIQUMAQsgCUUNACAFQcAAIAlrrYYgAiAJrSIDiIQhAiAFIAOIIQULIAggAjcDACAIIAU3AwggCCkDCEIEhiAIKQMAIgNCPIiEIQICQCAAIApHIAgpAxAgCCkDGIRCAFJxrSADQv//////////D4OEIgNCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyADQoCAgICAgICACFINACACQgGDIAJ8IQILIAJCgICAgICAgAiFIAIgAkL/////////B1YiABshAiAArQshAyAIQSBqJAAgB0KAgICAgICAgIB/gyADQjSGhCAChL85AwAL9BcDEn8BfAN+IwBBsARrIgwkACAMQQA2AiwCQCABvSIZQgBTBEBBASEQQboIIRQgAZoiAb0hGQwBCyAEQYAQcQRAQQEhEEG9CCEUDAELQcAI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ACgCRCICQQN0aiIFIAQoAhQ7AQAgBSAEKAIQNgIEQQEhBSAAIAJBAWo2AkQgASAJaiECIAZBAWoiBiAKRw0ACwwCC0EBIAYgBkEBTRshByAAKAJEIQFBACEGA0AgBCABNgIUIAEgACgChAEgACgCgAFsTw0BIAIgBEEQaiAJEBUgCCAAKAJEIgpBA3RqIgUgATsBACAFIAQoAhA2AgRBASEFIAAgCkEBaiIBNgJEIAIgCWohAiAGQQFqIgYgB0cNAAsMAQsgAEEBNgJMIAQgATYCACADQQJB0jwgBBATCyAEQSBqJAAgBQsEAEEACwvLwQEhAEGACAvgmQFjYW5ub3QgYWxsb2NhdGUgb3BqX3RjZF9zZWdfZGF0YV9jaHVua190KiBhcnJheQAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AFVua25vd24gZm9ybWF0AEZhaWxlZCB0byBzZXR1cCB0aGUgZGVjb2RlcgBGYWlsZWQgdG8gcmVhZCB0aGUgaGVhZGVyAG5hbgAqbF90aWxlX2xlbiA+IFVJTlRfTUFYIC0gT1BKX0NPTU1PTl9DQkxLX0RBVEFfRVhUUkEgLSBwX2oyay0+bV9zcGVjaWZpY19wYXJhbS5tX2RlY29kZXIubV9zb3RfbGVuZ3RoAGluZgBGYWlsZWQgdG8gZGVjb2RlIHRoZSBpbWFnZQBJbnZhbGlkIGFjY2VzcyB0byBwaS0+aW5jbHVkZQAvdG1wL29wZW5qcGVnL3NyYy9iaW4vY29tbW9uL2NvbG9yLmMAQUxMX0NQVVMAT1BKX05VTV9USFJFQURTAE5BTgBPSlBfRE9fTk9UX0RJU1BMQVlfVElMRV9JTkRFWF9JRl9UTE0ASU5GAHBfajJrLT5tX3NwZWNpZmljX3BhcmFtLm1fZGVjb2Rlci5tX3NvdF9sZW5ndGggPiBVSU5UX01BWCAtIE9QSl9DT01NT05fQ0JMS19EQVRBX0VYVFJBAAkJCSBwcmVjY2ludHNpemUgKHcsaCk9AAkJCSBzdGVwc2l6ZXMgKG0sZSk9AFNPVCBtYXJrZXIgZm9yIHRpbGUgJXUgZGVjbGFyZXMgbW9yZSB0aWxlLXBhcnRzIHRoYW4gZm91bmQgaW4gVExNIG1hcmtlci4AKG51bGwpACglZCwlZCkgACVzfQoACQkgfQoAW0RFVl0gRHVtcCBhbiBpbWFnZV9jb21wX2hlYWRlciBzdHJ1Y3QgewoAW0RFVl0gRHVtcCBhbiBpbWFnZV9oZWFkZXIgc3RydWN0IHsKAEltYWdlIGluZm8gewoACSBkZWZhdWx0IHRpbGUgewoAJXMJIGNvbXBvbmVudCAlZCB7CgAJCSBjb21wICVkIHsKAAkgVGlsZSBpbmRleDogewoACSBNYXJrZXIgbGlzdDogewoAQ29kZXN0cmVhbSBpbmRleCBmcm9tIG1haW4gaGVhZGVyOiB7CgBDb2Rlc3RyZWFtIGluZm8gZnJvbSBtYWluIGhlYWRlcjogewoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3gKAEZvdW5kIGEgbWlzcGxhY2VkICclYyVjJWMlYycgYm94IG91dHNpZGUganAyaCBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IGZpcnN0IGJveCBtdXN0IGJlIEpQRUcgMjAwMCBzaWduYXR1cmUgYm94CgBNYWxmb3JtZWQgSlAyIGZpbGUgZm9ybWF0OiBzZWNvbmQgYm94IG11c3QgYmUgZmlsZSB0eXBlIGJveAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGpwZWcyMDAwIGJveAoATm90IGVub3VnaCBtZW1vcnkgd2l0aCBGVFlQIEJveAoAQSBtYXJrZXIgSUQgd2FzIGV4cGVjdGVkICgweGZmLS0pIGluc3RlYWQgb2YgJS44eAoACQkgbWN0PSV4CgAJCQkgY2Jsa3N0eT0lI3gKAAkJCSBjc3R5PSUjeAoACQkgcHJnPSUjeAoASW50ZWdlciBvdmVyZmxvdwoACSB0ZHg9JXUsIHRkeT0ldQoACSB0dz0ldSwgdGg9JXUKAAkgdHgwPSV1LCB0eTA9JXUKAEludmFsaWQgY29tcG9uZW50IGluZGV4OiAldQoAU3RyZWFtIHRvbyBzaG9ydAoATWFya2VyIGhhbmRsZXIgZnVuY3Rpb24gZmFpbGVkIHRvIHJlYWQgdGhlIG1hcmtlciBzZWdtZW50CgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgY3VycmVudCBwcmVjaW5jdCBjb2RlYmxvY2sgZWxlbWVudAoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNRY2Qgb3IgU1FjYyBlbGVtZW50CgBBIEJQQ0MgaGVhZGVyIGJveCBpcyBhdmFpbGFibGUgYWx0aG91Z2ggQlBDIGdpdmVuIGJ5IHRoZSBJSERSIGJveCAoJWQpIGluZGljYXRlIGNvbXBvbmVudHMgYml0IGRlcHRoIGlzIGNvbnN0YW50CgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGlsbGVnYWwgdGlsZSBvZmZzZXQKAEludmFsaWQgcHJlY2luY3QKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBiYW5kIHByZWNpbnRzCgBGYWlsZWQgdG8gZGVjb2RlIGFsbCB1c2VkIGNvbXBvbmVudHMKAFNpemUgb2YgY29kZSBibG9jayBkYXRhIGV4Y2VlZHMgc3lzdGVtIGxpbWl0cwoAU2l6ZSBvZiB0aWxlIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgTUNUIG1hcmtlcnMKAENvcnJ1cHRlZCBQUE0gbWFya2VycwoATm90IGVub3VnaCBtZW1vcnkgZm9yIHRpbGUgcmVzb2x1dGlvbnMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBjb2xsZWN0aW9ucwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAwIHBhbGV0dGUgY29sdW1ucwoAV2UgZG8gbm90IHN1cHBvcnQgUk9JIGluIGRlY29kaW5nIEhUIGNvZGVibG9ja3MKAENhbm5vdCBoYW5kbGUgYm94IG9mIHVuZGVmaW5lZCBzaXplcwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIHdpdGhvdXQgc2FtZSBudW1iZXIgb2YgaW5kaXhlcwoASW52YWxpZCB0aWxlYy0+d2luX3h4eCB2YWx1ZXMKAENhbm5vdCBoYW5kbGUgYm94IG9mIGxlc3MgdGhhbiA4IGJ5dGVzCgBDYW5ub3QgaGFuZGxlIFhMIGJveCBvZiBsZXNzIHRoYW4gMTYgYnl0ZXMKAENvbXBvbmVudCBpbmRleCAldSB1c2VkIHNldmVyYWwgdGltZXMKAEludmFsaWQgUENMUiBib3guIFJlcG9ydHMgJWQgZW50cmllcwoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlIG5vZGVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbWN0IGRhdGEgd2l0aGluIG11bHRpcGxlIE1DVCByZWNvcmRzCgBDYW5ub3QgZGVjb2RlIHRpbGUsIG1lbW9yeSBlcnJvcgoAb3BqX2oya19hcHBseV9uYl90aWxlX3BhcnRzX2NvcnJlY3Rpb24gZXJyb3IKAFByb2JsZW0gd2l0aCBza2lwcGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAUHJvYmxlbSB3aXRoIHJlYWRpbmcgSlBFRzIwMDAgYm94LCBzdHJlYW0gZXJyb3IKAFVua25vd24gbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgdGwgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgbWggbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byB0YWtlIGluIGNoYXJnZSBTSVogbWFya2VyCgBFcnJvciByZWFkaW5nIFBQVCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBTT1QgbWFya2VyCgBEaWQgbm90IGdldCBleHBlY3RlZCBTT1QgbWFya2VyCgBFcnJvciByZWFkaW5nIFBMVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIHNwYWNlIGZvciBleHBlY3RlZCBTT1AgbWFya2VyCgBFeHBlY3RlZCBTT1AgbWFya2VyCgBFcnJvciByZWFkaW5nIE1DTyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUkdOIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQUE0gbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIFBQTSBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUExNIG1hcmtlcgoARXhwZWN0ZWQgRVBIIG1hcmtlcgoATm90IGVub3VnaCBzcGFjZSBmb3IgcmVxdWlyZWQgRVBIIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDUkcgbWFya2VyCgBVbmtub3duIHByb2dyZXNzaW9uIG9yZGVyIGluIENPRCBtYXJrZXIKAFVua25vd24gU2NvZCB2YWx1ZSBpbiBDT0QgbWFya2VyCgBFcnJvciByZWFkaW5nIENPRCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUUNEIG1hcmtlcgoAQ3Jyb3IgcmVhZGluZyBDQkQgbWFya2VyCgBFcnJvciByZWFkaW5nIFBPQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlcgoARXJyb3IgcmVhZGluZyBRQ0MgbWFya2VyCgBFcnJvciByZWFkaW5nIE1DQyBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgTUNDIG1hcmtlcgoAcmVxdWlyZWQgU0laIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAHJlcXVpcmVkIENPRCBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgByZXF1aXJlZCBRQ0QgbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGpwZWcyMDAwIGZpbGUgaGVhZGVyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIGhlYWRlcgoARXJyb3Igd2l0aCBKUCBTaWduYXR1cmUgOiBiYWQgbWFnaWMgbnVtYmVyCgBJbiBTT1QgbWFya2VyLCBUUFNvdCAoJWQpIGlzIG5vdCB2YWxpZCByZWdhcmRzIHRvIHRoZSBjdXJyZW50IG51bWJlciBvZiB0aWxlLXBhcnQgKCVkKSwgZ2l2aW5nIHVwCgBJbiBTT1QgbWFya2VyLCBUUFNvdCAoJWQpIGlzIG5vdCB2YWxpZCByZWdhcmRzIHRvIHRoZSBwcmV2aW91cyBudW1iZXIgb2YgdGlsZS1wYXJ0ICglZCksIGdpdmluZyB1cAoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgY3VycmVudCBudW1iZXIgb2YgdGlsZS1wYXJ0IChoZWFkZXIpICglZCksIGdpdmluZyB1cAoAdGlsZXMgcmVxdWlyZSBhdCBsZWFzdCBvbmUgcmVzb2x1dGlvbgoATWFya2VyIGlzIG5vdCBjb21wbGlhbnQgd2l0aCBpdHMgcG9zaXRpb24KAFByb2JsZW0gd2l0aCBzZWVrIGZ1bmN0aW9uCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQsIEludmFsaWQgY2Jsa3cvY2Jsa2ggY29tYmluYXRpb24KAEludmFsaWQgbXVsdGlwbGUgY29tcG9uZW50IHRyYW5zZm9ybWF0aW9uCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgb3RoZXIgdGhhbiBhcnJheSBkZWNvcnJlbGF0aW9uCgBUb28gbGFyZ2UgdmFsdWUgZm9yIE5wcG0KAE5vdCBlbm91Z2ggYnl0ZXMgdG8gcmVhZCBOcHBtCgBiYWQgcGxhY2VkIGpwZWcgY29kZXN0cmVhbQoACSBNYWluIGhlYWRlciBzdGFydCBwb3NpdGlvbj0lbGxpCgkgTWFpbiBoZWFkZXIgZW5kIHBvc2l0aW9uPSVsbGkKAE1hcmtlciBzaXplIGluY29uc2lzdGVudCB3aXRoIHN0cmVhbSBsZW5ndGgKAFRpbGUgcGFydCBsZW5ndGggc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCBzdHJlYW0gbGVuZ3RoCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgZGF0YSBzcGFubmluZwoAV3JvbmcgZmxhZwoARXJyb3Igd2l0aCBGVFlQIHNpZ25hdHVyZSBCb3ggc2l6ZQoARXJyb3Igd2l0aCBKUCBzaWduYXR1cmUgQm94IHNpemUKAEludmFsaWQgcHJlY2luY3Qgc2l6ZQoASW5jb25zaXN0ZW50IG1hcmtlciBzaXplCgBJbnZhbGlkIG1hcmtlciBzaXplCgBFcnJvciB3aXRoIFNJWiBtYXJrZXIgc2l6ZQoATm90IGVub3VnaCBtZW1vcnkgdG8gYWRkIGEgbmV3IHZhbGlkYXRpb24gcHJvY2VkdXJlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBkZWNvZGUgdGlsZQoARmFpbGVkIHRvIGRlY29kZSB0aGUgY29kZXN0cmVhbSBpbiB0aGUgSlAyIGZpbGUKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBjb2xsZWN0aW9ucyB3aXRoIGluZGl4IHNodWZmbGUKAENhbm5vdCBhbGxvY2F0ZSBUaWVyIDEgaGFuZGxlCgBObyBkZWNvZGVkIGFyZWEgcGFyYW1ldGVycywgc2V0IHRoZSBkZWNvZGVkIGFyZWEgdG8gdGhlIHdob2xlIGltYWdlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBjcmVhdGUgVGFnLXRyZWUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlaW5pdGlhbGl6ZSB0aGUgdGFnIHRyZWUKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudCwgSW52YWxpZCB0cmFuc2Zvcm1hdGlvbiBmb3VuZAoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LiBVbnN1cHBvcnRlZCBNaXhlZCBIVCBjb2RlLWJsb2NrIHN0eWxlIGZvdW5kCgBUaWxlIFkgY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQKAFRpbGUgWCBjb29yZGluYXRlcyBhcmUgbm90IHN1cHBvcnRlZAoASW1hZ2UgY29vcmRpbmF0ZXMgYWJvdmUgSU5UX01BWCBhcmUgbm90IHN1cHBvcnRlZAoASlBFRzIwMDAgSGVhZGVyIGJveCBub3QgcmVhZCB5ZXQsICclYyVjJWMlYycgYm94IHdpbGwgYmUgaWdub3JlZAoAb3BqX2oya19tZXJnZV9wcHQoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZAoAb3BqX2oya19idWlsZF90cF9pbmRleF9mcm9tX3RsbSgpOiB0aWxlIGluZGV4IGFsbG9jYXRpb24gZmFpbGVkCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIFNPVCBtYXJrZXIuIFRpbGUgaW5kZXggYWxsb2NhdGlvbiBmYWlsZWQKAElnbm9yaW5nIGloZHIgYm94LiBGaXJzdCBpaGRyIGJveCBhbHJlYWR5IHJlYWQKAFpwcHQgJXUgYWxyZWFkeSByZWFkCgBacHBtICV1IGFscmVhZHkgcmVhZAoAUFRFUk0gY2hlY2sgZmFpbHVyZTogJWQgc3ludGhlc2l6ZWQgMHhGRiBtYXJrZXJzIHJlYWQKAAkJCSBjYmxrdz0yXiVkCgAJCQkgY2Jsa2g9Ml4lZAoACQkJIHFudHN0eT0lZAoAJXMgZHg9JWQsIGR5PSVkCgAJCQkgcm9pc2hpZnQ9JWQKAAkJCSBudW1nYml0cz0lZAoACQkgbnVtbGF5ZXJzPSVkCgAlcyBudW1jb21wcz0lZAoAb3BqX2pwMl9hcHBseV9jZGVmOiBhY249JWQsIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGNuPSVkLCBudW1jb21wcz0lZAoACQkJIG51bXJlc29sdXRpb25zPSVkCgAJCSB0eXBlPSUjeCwgcG9zPSVsbGksIGxlbj0lZAoAJXMgc2duZD0lZAoACQkJIHFtZmJpZD0lZAoAJXMgcHJlYz0lZAoACQkgbmIgb2YgdGlsZS1wYXJ0IGluIHRpbGUgWyVkXT0lZAoAJXMgeDE9JWQsIHkxPSVkCgAlcyB4MD0lZCwgeTA9JWQKAEZhaWxlZCB0byBkZWNvZGUgdGlsZSAlZC8lZAoAU2V0dGluZyBkZWNvZGluZyBhcmVhIHRvICVkLCVkLCVkLCVkCgBGYWlsZWQgdG8gZGVjb2RlIGNvbXBvbmVudCAlZAoASW52YWxpZCB2YWx1ZSBmb3IgbnVtcmVzb2x1dGlvbnMgOiAlZCwgbWF4IHZhbHVlIGlzIHNldCBpbiBvcGVuanBlZy5oIGF0ICVkCgBJbnZhbGlkIGNvbXBvbmVudCBudW1iZXI6ICVkLCByZWdhcmRpbmcgdGhlIG51bWJlciBvZiBjb21wb25lbnRzICVkCgBUb28gbWFueSBQT0NzICVkCgBvcGpfajJrX3JlYWRfdGxtKCk6IGludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBwYXJ0IGluZGV4IGZvciB0aWxlIG51bWJlciAlZC4gR290ICVkLCBleHBlY3RlZCAlZAoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBudW1iZXIgb2YgY29tcG9uZW50IGlzIGlsbGVnYWwgLT4gJWQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjaWVsYWIKAENhbm5vdCBhbGxvY2F0ZSBjYmxrLT5kZWNvZGVkX2RhdGEKAEZhaWxlZCB0byBtZXJnZSBQUFQgZGF0YQoARmFpbGVkIHRvIG1lcmdlIFBQTSBkYXRhCgBJbnZhbGlkIG51bWJlciBvZiBsYXllcnMgaW4gQ09EIG1hcmtlciA6ICVkIG5vdCBpbiByYW5nZSBbMS02NTUzNV0KACVzOiVkOmNvbG9yX2NteWtfdG9fcmdiCglDQU4gTk9UIENPTlZFUlQKACVzOiVkOmNvbG9yX2VzeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgAlczolZDpjb2xvcl9zeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU290IGxlbmd0aCBpcyBsZXNzIHRoYW4gbWFya2VyIHNpemUgKyBtYXJrZXIgSUQKAFN0cmVhbSBkb2VzIG5vdCBlbmQgd2l0aCBFT0MKAENhbm5vdCBoYW5kbGUgYm94IHNpemVzIGhpZ2hlciB0aGFuIDJeMzIKAG9wal9waV9uZXh0X2xyY3AoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X3JsY3AoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X2NwcmwoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X3BjcmwoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X3JwY2woKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal90MV9kZWNvZGVfY2JsaygpOiB1bnN1cHBvcnRlZCBicG5vX3BsdXNfb25lID0gJWQgPj0gMzEKAEZhaWxlZCB0byBkZWNvZGUgdGlsZSAxLzEKAEluc3VmZmljaWVudCBkYXRhIGZvciBDTUFQIGJveC4KAE5lZWQgdG8gcmVhZCBhIFBDTFIgYm94IGJlZm9yZSB0aGUgQ01BUCBib3guCgBJbnN1ZmZpY2llbnQgZGF0YSBmb3IgQ0RFRiBib3guCgBOdW1iZXIgb2YgY2hhbm5lbCBkZXNjcmlwdGlvbiBpcyBlcXVhbCB0byB6ZXJvIGluIENERUYgYm94LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IG5vICdpaGRyJyBib3guCgBOb24gY29uZm9ybWFudCBjb2Rlc3RyZWFtIFRQc290PT1UTnNvdC4KAFN0cmVhbSBlcnJvciB3aGlsZSByZWFkaW5nIEpQMiBIZWFkZXIgYm94OiBib3ggbGVuZ3RoIGlzIGluY29uc2lzdGVudC4KAEJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAUmVzb2x1dGlvbiBmYWN0b3IgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHJlc29sdXRpb24gaW4gdGhlIGNvbXBvbmVudC4KAENvbXBvbmVudCBtYXBwaW5nIHNlZW1zIHdyb25nLiBUcnlpbmcgdG8gY29ycmVjdC4KAG9wal9qMmtfYnVpbGRfdHBfaW5kZXhfZnJvbV90bG0oKTogdGlsZSAlZCBoYXMgbm8gcmVnaXN0ZXJlZCB0aWxlLXBhcnQgaW4gVExNIG1hcmtlciBzZWdtZW50cy4KAG9wal9qMmtfcmVhZF90bG0oKTogdG9vIG1hbnkgVExNIG1hcmtlcnMuCgBvcGpfajJrX3JlYWRfdGxtKCk6IGNhbm5vdCBhbGxvY2F0ZSBtX3RpbGVfcGFydF9pbmZvcy4KAEluY29tcGxldGUgY2hhbm5lbCBkZWZpbml0aW9ucy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIEludmFsaWQgY29kZWJsb2NrIGxlbmd0aCB2YWx1ZXMuCgBXZSBkbyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gMyBjb2RpbmcgcGFzc2VzIGluIGFuIEhUIGNvZGVibG9jazsgVGhpcyBjb2RlYmxvY2tzIGhhcyAlZCBwYXNzZXMuCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBUaGVyZSBhcmUgJWQgemVybyBiaXRwbGFuZXMgaW4gJWQgYml0cGxhbmVzLgoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIHRyYW5zZm9ybWF0aW9uIHN0YWdlcy4KAFVua25vd24gbWFya2VyIGhhcyBiZWVuIGRldGVjdGVkIGFuZCBnZW5lcmF0ZWQgZXJyb3IuCgBDb2RlYyBwcm92aWRlZCB0byB0aGUgb3BqX3NldHVwX2RlY29kZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBDb2RlYyBwcm92aWRlZCB0byB0aGUgb3BqX3JlYWRfaGVhZGVyIGZ1bmN0aW9uIGlzIG5vdCBhIGRlY29tcHJlc3NvciBoYW5kbGVyLgoARXJyb3IgcmVhZGluZyBUTE0gbWFya2VyLgoAVGlsZXMgZG9uJ3QgYWxsIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLiBTa2lwIHRoZSBNQ1Qgc3RlcC4KAE51bWJlciBvZiBjb21wb25lbnRzICglZCkgaXMgaW5jb25zaXN0ZW50IHdpdGggYSBNQ1QuIFNraXAgdGhlIE1DVCBzdGVwLgoASlAyIGJveCB3aGljaCBhcmUgYWZ0ZXIgdGhlIGNvZGVzdHJlYW0gd2lsbCBub3QgYmUgcmVhZCBieSB0aGlzIGZ1bmN0aW9uLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gV2hlbiB0aGUgbnVtYmVyIG9mIHplcm8gcGxhbmVzIGJpdHBsYW5lcyBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGJpdHBsYW5lcywgb25seSB0aGUgY2xlYW51cCBwYXNzIG1ha2VzIHNlbnNlLCBidXQgd2UgaGF2ZSAlZCBwYXNzZXMgaW4gdGhpcyBjb2RlYmxvY2suIFRoZXJlZm9yZSwgb25seSB0aGUgY2xlYW51cCBwYXNzIHdpbGwgYmUgZGVjb2RlZC4gVGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIGRpc3BsYXllZCBhZ2Fpbi4KAEltYWdlIGhhcyBsZXNzIGNvbXBvbmVudHMgdGhhbiBjb2Rlc3RyZWFtLgoATmVlZCB0byBkZWNvZGUgdGhlIG1haW4gaGVhZGVyIGJlZm9yZSBiZWdpbiB0byBkZWNvZGUgdGhlIHJlbWFpbmluZyBjb2Rlc3RyZWFtLgoAUHNvdCB2YWx1ZSBvZiB0aGUgY3VycmVudCB0aWxlLXBhcnQgaXMgZXF1YWwgdG8gemVybywgd2UgYXNzdW1pbmcgaXQgaXMgdGhlIGxhc3QgdGlsZS1wYXJ0IG9mIHRoZSBjb2Rlc3RyZWFtLgoAQSBtYWxmb3JtZWQgY29kZWJsb2NrIHRoYXQgaGFzIG1vcmUgdGhhbiBvbmUgY29kaW5nIHBhc3MsIGJ1dCB6ZXJvIGxlbmd0aCBmb3IgMm5kIGFuZCBwb3RlbnRpYWxseSB0aGUgM3JkIHBhc3MgaW4gYW4gSFQgY29kZWJsb2NrLgoACQkJIHRpbGUtcGFydFslZF06IHN0YXJfcG9zPSVsbGksIGVuZF9oZWFkZXI9JWxsaSwgZW5kX3Bvcz0lbGxpLgoAVGlsZSAldSBoYXMgVFBzb3QgPT0gMCBhbmQgVE5zb3QgPT0gMCwgYnV0IG5vIG90aGVyIHRpbGUtcGFydHMgd2VyZSBmb3VuZC4gRU9DIGlzIGFsc28gbWlzc2luZy4KAENvbXBvbmVudCAlZCBkb2Vzbid0IGhhdmUgYSBtYXBwaW5nLgoAb3BqX2oya19yZWFkX3RsbSgpOiBUTE0gbWFya2VyIG5vdCBvZiBleHBlY3RlZCBzaXplLgoAQSBjb25mb3JtaW5nIEpQMiByZWFkZXIgc2hhbGwgaWdub3JlIGFsbCBDb2xvdXIgU3BlY2lmaWNhdGlvbiBib3hlcyBhZnRlciB0aGUgZmlyc3QsIHNvIHdlIGlnbm9yZSB0aGlzIG9uZS4KAFRoZSBzaWduYXR1cmUgYm94IG11c3QgYmUgdGhlIGZpcnN0IGJveCBpbiB0aGUgZmlsZS4KAFRoZSAgYm94IG11c3QgYmUgdGhlIGZpcnN0IGJveCBpbiB0aGUgZmlsZS4KAFRoZSBmdHlwIGJveCBtdXN0IGJlIHRoZSBzZWNvbmQgYm94IGluIHRoZSBmaWxlLgoARmFpbGVkIHRvIGRlY29kZS4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIEluY29ycmVjdCBNRUwgc2VnbWVudCBzZXF1ZW5jZS4KAENvbXBvbmVudCAlZCBpcyBtYXBwZWQgdHdpY2UuCgBvcGpfajJrX3JlYWRfdGxtKCk6IFNUID0gMyBpcyBpbnZhbGlkLgoAT25seSBvbmUgQ01BUCBib3ggaXMgYWxsb3dlZC4KAFdlIG5lZWQgYW4gaW1hZ2UgcHJldmlvdXNseSBjcmVhdGVkLgoASUhEUiBib3hfbWlzc2luZy4gUmVxdWlyZWQuCgBKUDJIIGJveCBtaXNzaW5nLiBSZXF1aXJlZC4KAE5vdCBzdXJlIGhvdyB0aGF0IGhhcHBlbmVkLgoATWFpbiBoZWFkZXIgaGFzIGJlZW4gY29ycmVjdGx5IGRlY29kZWQuCgBUaWxlICVkLyVkIGhhcyBiZWVuIGRlY29kZWQuCgBIZWFkZXIgb2YgdGlsZSAlZCAvICVkIGhhcyBiZWVuIHJlYWQuCgBFbXB0eSBTT1QgbWFya2VyIGRldGVjdGVkOiBQc290PSVkLgoARGlyZWN0IHVzZSBhdCAjJWQgaG93ZXZlciBwY29sPSVkLgoASW1wbGVtZW50YXRpb24gbGltaXRhdGlvbjogZm9yIHBhbGV0dGUgbWFwcGluZywgcGNvbFslZF0gc2hvdWxkIGJlIGVxdWFsIHRvICVkLCBidXQgaXMgZXF1YWwgdG8gJWQuCgBJbnZhbGlkIGNvbXBvbmVudC9wYWxldHRlIGluZGV4IGZvciBkaXJlY3QgbWFwcGluZyAlZC4KAEludmFsaWQgdmFsdWUgZm9yIGNtYXBbJWRdLm10eXAgPSAlZC4KAFBzb3QgdmFsdWUgaXMgbm90IGNvcnJlY3QgcmVnYXJkcyB0byB0aGUgSlBFRzIwMDAgbm9ybTogJWQuCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBWTEMgY29kZSBwcm9kdWNlcyBzaWduaWZpY2FudCBzYW1wbGVzIG91dHNpZGUgdGhlIGNvZGVibG9jayBhcmVhLgoAVW5leHBlY3RlZCBPT00uCgAzMiBiaXRzIGFyZSBub3QgZW5vdWdoIHRvIGRlY29kZSB0aGlzIGNvZGVibG9jaywgc2luY2UgdGhlIG51bWJlciBvZiBiaXRwbGFuZSwgJWQsIGlzIGxhcmdlciB0aGFuIDMwLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgc2hvdWxkIGJlID4gMC4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgc2hvdWxkIGJlID4gMC4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgc2hvdWxkIGJlID49IDAuCgBMZWZ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MD0lZCkgc2hvdWxkIGJlID49IDAuCgBFcnJvciByZWFkaW5nIFBQVCBtYXJrZXI6IHBhY2tldCBoZWFkZXIgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZm91bmQgaW4gdGhlIG1haW4gaGVhZGVyIChQUE0gbWFya2VyKS4KAFN0YXJ0IHRvIHJlYWQgajJrIG1haW4gaGVhZGVyICglbGxkKS4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFlzaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWHNpej0lZCkuCgBMZWZ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWHNpej0lZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFlPc2l6PSVkKS4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWE9zaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAFNpemUgeCBvZiB0aGUgZGVjb2RlZCBjb21wb25lbnQgaW1hZ2UgaXMgaW5jb3JyZWN0IChjb21wWyVkXS53PSVkKS4KAFNpemUgeSBvZiB0aGUgZGVjb2RlZCBjb21wb25lbnQgaW1hZ2UgaXMgaW5jb3JyZWN0IChjb21wWyVkXS5oPSVkKS4KAFRpbGUgcmVhZCwgZGVjb2RlZCBhbmQgdXBkYXRlZCBpcyBub3QgdGhlIGRlc2lyZWQgb25lICglZCB2cyAlZCkuCgBJbnZhbGlkIGNvbXBvbmVudCBpbmRleCAlZCAoPj0gJWQpLgoAb3BqX3JlYWRfaGVhZGVyKCkgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgb3BqX3NldF9kZWNvZGVkX2NvbXBvbmVudHMoKS4KAE1lbW9yeSBhbGxvY2F0aW9uIGZhaWx1cmUgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbWFnZS0+Y29tcHNbJWRdLmRhdGEgPT0gTlVMTCBpbiBvcGpfanAyX2FwcGx5X3BjbHIoKS4KAGludmFsaWQgYm94IHNpemUgJWQgKCV4KQoARmFpbCB0byByZWFkIHRoZSBjdXJyZW50IG1hcmtlciBzZWdtZW50ICglI3gpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IElIRFIgdygldSkgaCgldSkgdnMuIFNJWiB3KCV1KSBoKCV1KQoARXJyb3IgcmVhZGluZyBDT0MgbWFya2VyIChiYWQgbnVtYmVyIG9mIGNvbXBvbmVudHMpCgBJbnZhbGlkIG51bWJlciBvZiB0aWxlcyA6ICV1IHggJXUgKG1heGltdW0gZml4ZWQgYnkganBlZzIwMDAgbm9ybSBpcyA2NTUzNSB0aWxlcykKAEludmFsaWQgbnVtYmVyIG9mIGNvbXBvbmVudHMgKGloZHIpCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUgaW1hZ2UgaGVhZGVyIChpaGRyKQoAV3JvbmcgdmFsdWVzIGZvcjogdyglZCkgaCglZCkgbnVtY29tcHMoJWQpIChpaGRyKQoASW52YWxpZCB2YWx1ZXMgZm9yIGNvbXAgPSAlZCA6IGR4PSV1IGR5PSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAyNTUgYWNjb3JkaW5nIHRvIHRoZSBKUEVHMjAwMCBub3JtKQoAQmFkIGltYWdlIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBCYWQgQlBDQyBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbmVnYXRpdmUgb3IgemVybyBpbWFnZSBzaXplICglbGxkIHggJWxsZCkKAHNraXA6IHNlZ21lbnQgdG9vIGxvbmcgKCVkKSB3aXRoIG1heCAoJWQpIGZvciBjb2RlYmxvY2sgJWQgKHA9JWQsIGI9JWQsIHI9JWQsIGM9JWQpCgByZWFkOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoARGVzcGl0ZSBKUDIgQlBDIT0yNTUsIHByZWNpc2lvbiBhbmQvb3Igc2duZCB2YWx1ZXMgZm9yIGNvbXBbJWRdIGlzIGRpZmZlcmVudCB0aGFuIGNvbXBbMF06CiAgICAgICAgWzBdIHByZWMoJWQpIHNnbmQoJWQpIFslZF0gcHJlYyglZCkgc2duZCglZCkKAGJhZCBjb21wb25lbnQgbnVtYmVyIGluIFJHTiAoJWQgd2hlbiB0aGVyZSBhcmUgb25seSAlZCkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbnVtYmVyIG9mIGNvbXBvbmVudCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSByZW1haW5pbmcgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCAlZCB2cyAlZCkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaW52YWxpZCB0aWxlIHNpemUgKHRkeDogJWQsIHRkeTogJWQpCgBCYWQgQ09MUiBoZWFkZXIgYm94IChiYWQgc2l6ZTogJWQpCgBCYWQgQ09MUiBoZWFkZXIgYm94IChDSUVMYWIsIGJhZCBzaXplOiAlZCkKAFBURVJNIGNoZWNrIGZhaWx1cmU6ICVkIHJlbWFpbmluZyBieXRlcyBpbiBjb2RlIGJsb2NrICglZCB1c2VkIC8gJWQpCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBPbmUgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gaXMgbm90IG1ldDogMiA8PSBTY3VwIDw9IG1pbihMY3VwLCA0MDc5KQoASW52YWxpZCB2YWx1ZXMgZm9yIGNvbXAgPSAlZCA6IHByZWM9JXUgKHNob3VsZCBiZSBiZXR3ZWVuIDEgYW5kIDM4IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybS4gT3BlbkpwZWcgb25seSBzdXBwb3J0cyB1cCB0byAzMSkKAEludmFsaWQgYml0IG51bWJlciAlZCBpbiBvcGpfdDJfcmVhZF9wYWNrZXRfaGVhZGVyKCkKAFN0cmVhbSBlcnJvciEKAEVycm9yIG9uIHdyaXRpbmcgc3RyZWFtIQoAU3RyZWFtIHJlYWNoZWQgaXRzIGVuZCAhCgBFeHBlY3RlZCBhIFNPQyBtYXJrZXIgCgBJbnZhbGlkIGJveCBzaXplICVkIGZvciBib3ggJyVjJWMlYyVjJy4gTmVlZCAlZCBieXRlcywgJWQgYnl0ZXMgcmVtYWluaW5nIAoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gRGVjb2RpbmcgdGhpcyBjb2RlYmxvY2sgaXMgc3RvcHBlZC4gVV9xIGlzIGxhcmdlciB0aGFuIHplcm8gYml0cGxhbmVzICsgMSAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpc2xhcmdlciB0aGFuIGJpdHBsYW5lcyArIDEgCgBDT0xSIEJPWCBtZXRoIHZhbHVlIGlzIG5vdCBhIHJlZ3VsYXIgdmFsdWUgKCVkKSwgc28gd2Ugd2lsbCBpZ25vcmUgdGhlIGVudGlyZSBDb2xvdXIgU3BlY2lmaWNhdGlvbiBib3guIAoAV2hpbGUgcmVhZGluZyBDQ1BfUU5UU1RZIGVsZW1lbnQgaW5zaWRlIFFDRCBvciBRQ0MgbWFy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AAAAAFQAAKBTAAABJAAAAAAAABBUAACwUwAAASQAAAEAAAAgVAAAwFMAAAEiAAAAAAAAMFQAANBTAAABIgAAAQAAAEBUAADgUwAAARwAAAAAAABQVAAA8FMAAAEcAAABAAAAYFQAAABUAAABGAAAAAAAAHBUAAAQVAAAARgAAAEAAACAVAAAIFQAAAEWAAAAAAAAkFQAADBUAAABFgAAAQAAAKBUAABAVAAAARQAAAAAAACwVAAAUFQAAAEUAAABAAAAwFQAAGBUAAABEgAAAAAAANBUAABwVAAAARIAAAEAAADgVAAAgFQAAAERAAAAAAAA8FQAAJBUAAABEQAAAQAAAABVAACgVAAAwQoAAAAAAAAQVQAAsFQAAMEKAAABAAAAIFUAAMBUAADBCQAAAAAAADBVAADQVAAAwQkAAAEAAABAVQAA4FQAAKEIAAAAAAAAUFUAAPBUAAChCAAAAQAAAGBVAAAAVQAAIQUAAAAAAABwVQAAEFUAACEFAAABAAAAgFUAACBVAABBBAAAAAAAAJBVAAAwVQAAQQQAAAEAAACgVQAAQFUAAKECAAAAAAAAsFUAAFBVAAChAgAAAQAAAMBVAABgVQAAIQIAAAAAAADQVQAAcFUAACECAAABAAAA4FUAAIBVAABBAQAAAAAAAPBVAACQVQAAQQEAAAEAAAAAVgAAoFUAABEBAAAAAAAAEFYAALBVAAARAQAAAQAAACBWAADAVQAAhQAAAAAAAAAwVgAA0FUAAIUAAAABAAAAQFYAAOBVAABJAAAAAAAAAFBWAADwVQAASQAAAAEAAABgVgAAAFYAACUAAAAAAAAAcFYAABBWAAAlAAAAAQAAAIBWAAAgVgAAFQAAAAAAAACQVgAAMFYAABUAAAABAAAAoFYAAEBWAAAJAAAAAAAAALBWAABQVgAACQAAAAEAAADAVgAAYFYAAAUAAAAAAAAA0FYAAHBWAAAFAAAAAQAAAOBWAACAVgAAAQAAAAAAAADQVgAAkFYAAAEAAAABAAAA4FYAAKBWAAABVgAAAAAAAPBWAADwVgAAAVYAAAEAAAAAVwAAAFcAAAABAwMBAgMDBQYHBwYGBwcAAQMDAQIDAwUGBwcGBgcHBQYHBwYGBwcICAgICAgICAUGBwcGBgcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAgIDAwICAwMGBgcHBgYHBwICAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAAEFBgECBgYDAwcHAwMHBwABBQYBAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwECBgYCAgYGAwMHBwMDBwcBAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcFBggIBgYICAcHCAgHBwgIBQYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAECBgYCAgYGAwMHBwMDBwcBAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcCAgYGAgIGBgMDBwcDAwcHAgIGBgICBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgAAQMDAQIDAwUGBwcGBgcHAAEDAwECAwMFBgcHBgYHBwUGBwcGBgcHCAgICAgICAgFBgcHBgYHBwgICAgICAgIAQIDAwICAwMGBgcHBgYHBwECAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAQIDAwICAwMGBgcHBgYHBwECAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAICAwMCAgMDBgYHBwYGBwcCAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAADAQQDBgQHAQQCBQQHBQcAAwEEAwYEBwEEAgUEBwUHAQQCBQQHBQcCBQIFBQcFBwEEAgUEBwUHAgUCBQUHBQcDBgQHBggHCAQHBQcHCAcIAwYEBwYIBwgEBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIAQQCBQQHBQcCBQIFBQcFBwEEAgUEBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwQHBQcHCAcIBQcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgDBgQHBggHCAQHBQcHCAcIAwYEBwYIBwgEBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIBggHCAgICAgHCAcICAgICAYIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAQHBQcHCAcIBQcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgICQkKCgkJCgoMDA0LDAwNCwkJCgoJCQoKDAwLDQwMCw0MDA0NDAwLCwwJDQoJDAoLDAwLCwwMDQ0MCQsKCQwKDQkJCgoJCQoKDAwNCwwMDQsJCQoKCQkKCgwMCw0MDAsNDAwNDQwMCwsMCQ0KCQwKCwwMCwsMDA0NDAkLCgkMCg0KCgoKCgoKCg0LDQsNCw0LCgoJCQoKCQkNCwwMDQsMDA0NDQ0LCwsLDQoNCgoLCgsNDQwMCwsMDA0KDAkKCwkMCgoJCQoKCQkLDQwMCw0MDAoKCgoKCgoKCw0LDQsNCw0LCwwMDQ0MDAsKDAkKDQkMCwsLCw0NDQ0LCgsKCg0KDQBBmcABCzcBAAEAAQABAAABAQAAAQEAAQABAAEAAQAAAAABAQEBAAAAAAABAAEAAAAAAQEBAQAAAAEAAQEBAEHZwAELNwEAAQABAAEAAAEBAAABAQABAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAQABAQEAQZnBAQsHAQABAAEAAQBBqcEBC5UCAQABAAEAAQAAAAABAQEBAAAAAAABAAEAAAAAAQEBAQAAAAAAAQABAQEAAAEBAAAAAQABAAEAAQEBAQEBAQEBAAEAAQABAAEAAAAAAQEBAQABAAABAQABAAAAAAEBAQEAAQABAQEBAQIAAAAEAAAABAAAAAgAAACQ/wAADAAAABkAAABS/wAAFAAAABoAAABT/wAAFAAAABsAAABe/wAAFAAAABwAAABc/wAAFAAAAB0AAABd/wAAFAAAAB4AAABf/wAAFAAAAB8AAABR/wAAAgAAACAAAABV/wAABAAAACEAAABX/wAABAAAACIAAABY/wAAEAAAACMAAABg/wAABAAAACQAAABh/wAAEAAAACUAAACR/wBByMMBC2Vj/wAABAAAACYAAABk/wAAFAAAACcAAAB0/wAAFAAAACgAAAB4/wAABAAAACkAAABQ/wAABAAAACoAAABZ/wAABAAAACsAAAB1/wAAFAAAACwAAAB3/wAAFAAAAC0AAAAAAAAAFABBwMQBCzUuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAACAgUGo3AAAAcHl0ZjgAAABoMnBqOQBBgMUBCzJyZGhpOgAAAHJsb2M7AAAAY2NwYjwAAABybGNwPQAAAHBhbWM+AAAAZmVkYz8AAABAZgBBwMUBC0EZAAsAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkACgoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQBBkcYBCyEOAAAAAAAAAAAZAAsNGRkZAA0AAAIACQ4AAAAJAA4AAA4AQcvGAQsBDABB18YBCxUTAAAAABMAAAAACQwAAAAAAAwAAAwAQYXHAQsBEABBkccBCxUPAAAABA8AAAAACRAAAAAAABAAABAAQb/HAQsBEgBBy8cBCx4RAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAQYLIAQsOGgAAABoaGgAAAAAAAAkAQbPIAQsBFABBv8gBCxUXAAAAABcAAAAACRQAAAAAABQAABQAQe3IAQsBFgBB+cgBC2QVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUYAAAAAcAAAAHAAAABxAAAAcQAAAHEAAABxAAAAcQAAAHEAAABwAAAAcAAAAHEAAABwAAAAcAAAAHAAAABwAEGAygELHXEAAABxAAAAcAAAAHAAAAAAAAAAcAAAAAAAAABxAEGoywELCVBwAQAAAAAABQBBvMsBCwFrAEHUywELCmwAAABtAAAAuGsAQezLAQsBAgBB/MsBCwj//////////wBBwMwBCwEFAEHMzAELAW4AQeTMAQsObAAAAG8AAADIawAAAAQAQfzMAQsBAQBBjM0BCwX/////Cg==";
        return receiveInstance(instantiateSync(d, e1)[0]);
    }(), L = (x.u, a._malloc = x.v, a._free = x.w, a._jp2_decode = x.y, x.z);
    D = function runCaller() {
        F || run();
        F || (D = runCaller);
    };
    function run() {
        if (!(y > 0)) {
            !function preRun() {
                if (a.preRun) {
                    "function" == typeof a.preRun && (a.preRun = [
                        a.preRun
                    ]);
                    for(; a.preRun.length;)e1 = a.preRun.shift(), f.unshift(e1);
                }
                var e1;
                callRuntimeCallbacks(f);
            }();
            if (!(y > 0)) if (a.setStatus) {
                a.setStatus("Running...");
                setTimeout(()=>{
                    setTimeout(()=>a.setStatus(""), 1);
                    doRun();
                }, 1);
            } else doRun();
        }
        function doRun() {
            if (!F) {
                F = !0;
                a.calledRun = !0;
                if (!u) {
                    !function initRuntime() {
                        callRuntimeCallbacks(p);
                    }();
                    t(a);
                    a.onRuntimeInitialized?.();
                    !function postRun() {
                        if (a.postRun) {
                            "function" == typeof a.postRun && (a.postRun = [
                                a.postRun
                            ]);
                            for(; a.postRun.length;)e1 = a.postRun.shift(), m.unshift(e1);
                        }
                        var e1;
                        callRuntimeCallbacks(m);
                    }();
                }
            }
        }
    }
    if (a.preInit) {
        "function" == typeof a.preInit && (a.preInit = [
            a.preInit
        ]);
        for(; a.preInit.length > 0;)a.preInit.pop()();
    }
    run();
    return a;
});
const ii = ti;
class JpxError extends ot {
    constructor(e1){
        super(e1, "JpxError");
    }
}
class JpxImage {
    static #D = null;
    static decode(e1, t) {
        t ||= {};
        this.#D ||= ii({
            warn
        });
        const i = this.#D.decode(e1, t);
        if ("string" == typeof i) throw new JpxError(i);
        return i;
    }
    static cleanup() {
        this.#D = null;
    }
    static parseImageProperties(e1) {
        let t = e1.getByte();
        for(; t >= 0;){
            const i = t;
            t = e1.getByte();
            if (65361 === (i << 8 | t)) {
                e1.skip(4);
                const t = e1.getInt32() >>> 0, i = e1.getInt32() >>> 0, a = e1.getInt32() >>> 0, s = e1.getInt32() >>> 0;
                e1.skip(16);
                return {
                    width: t - a,
                    height: i - s,
                    bitsPerComponent: 8,
                    componentsCount: e1.getUint16()
                };
            }
        }
        throw new JpxError("No size marker found in JPX stream");
    }
}
class JpxStream extends DecodeStream {
    constructor(e1, t, i){
        super(t);
        this.stream = e1;
        this.dict = e1.dict;
        this.maybeLength = t;
        this.params = i;
    }
    get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e1) {}
    readBlock(e1) {
        this.decodeImage(null, e1);
    }
    decodeImage(e1, t) {
        if (this.eof) return this.buffer;
        e1 ||= this.bytes;
        this.buffer = JpxImage.decode(e1, t);
        this.bufferLength = this.buffer.length;
        this.eof = !0;
        return this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
    }
}
class LZWStream extends DecodeStream {
    constructor(e1, t, i){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        this.cachedData = 0;
        this.bitsCached = 0;
        const a = 4096, s = {
            earlyChange: i,
            codeLength: 9,
            nextCode: 258,
            dictionaryValues: new Uint8Array(a),
            dictionaryLengths: new Uint16Array(a),
            dictionaryPrevCodes: new Uint16Array(a),
            currentSequence: new Uint8Array(a),
            currentSequenceLength: 0
        };
        for(let e1 = 0; e1 < 256; ++e1){
            s.dictionaryValues[e1] = e1;
            s.dictionaryLengths[e1] = 1;
        }
        this.lzwState = s;
    }
    readBits(e1) {
        let t = this.bitsCached, i = this.cachedData;
        for(; t < e1;){
            const e1 = this.str.getByte();
            if (-1 === e1) {
                this.eof = !0;
                return null;
            }
            i = i << 8 | e1;
            t += 8;
        }
        this.bitsCached = t -= e1;
        this.cachedData = i;
        this.lastCode = null;
        return i >>> t & (1 << e1) - 1;
    }
    readBlock() {
        let e1, t, i, a = 1024;
        const s = this.lzwState;
        if (!s) return;
        const r = s.earlyChange;
        let n = s.nextCode;
        const g = s.dictionaryValues, o = s.dictionaryLengths, c = s.dictionaryPrevCodes;
        let C = s.codeLength, h = s.prevCode;
        const l = s.currentSequence;
        let Q = s.currentSequenceLength, E = 0, u = this.bufferLength, d = this.ensureBuffer(this.bufferLength + a);
        for(e1 = 0; e1 < 512; e1++){
            const e1 = this.readBits(C), s = Q > 0;
            if (e1 < 256) {
                l[0] = e1;
                Q = 1;
            } else {
                if (!(e1 >= 258)) {
                    if (256 === e1) {
                        C = 9;
                        n = 258;
                        Q = 0;
                        continue;
                    }
                    this.eof = !0;
                    delete this.lzwState;
                    break;
                }
                if (e1 < n) {
                    Q = o[e1];
                    for(t = Q - 1, i = e1; t >= 0; t--){
                        l[t] = g[i];
                        i = c[i];
                    }
                } else l[Q++] = l[0];
            }
            if (s) {
                c[n] = h;
                o[n] = o[h] + 1;
                g[n] = l[0];
                n++;
                C = n + r & n + r - 1 ? C : 0 | Math.min(Math.log(n + r) / .6931471805599453 + 1, 12);
            }
            h = e1;
            E += Q;
            if (a < E) {
                do {
                    a += 512;
                }while (a < E)
                d = this.ensureBuffer(this.bufferLength + a);
            }
            for(t = 0; t < Q; t++)d[u++] = l[t];
        }
        s.nextCode = n;
        s.codeLength = C;
        s.prevCode = h;
        s.currentSequenceLength = Q;
        this.bufferLength = u;
    }
}
class PredictorStream extends DecodeStream {
    constructor(e1, t, i){
        super(t);
        if (!(i instanceof Dict)) return e1;
        const a = this.predictor = i.get("Predictor") || 1;
        if (a <= 1) return e1;
        if (2 !== a && (a < 10 || a > 15)) throw new FormatError(`Unsupported predictor: ${a}`);
        this.readBlock = 2 === a ? this.readBlockTiff : this.readBlockPng;
        this.str = e1;
        this.dict = e1.dict;
        const s = this.colors = i.get("Colors") || 1, r = this.bits = i.get("BPC", "BitsPerComponent") || 8, n = this.columns = i.get("Columns") || 1;
        this.pixBytes = s * r + 7 >> 3;
        this.rowBytes = n * s * r + 7 >> 3;
        return this;
    }
    readBlockTiff() {
        const e1 = this.rowBytes, t = this.bufferLength, i = this.ensureBuffer(t + e1), a = this.bits, s = this.colors, r = this.str.getBytes(e1);
        this.eof = !r.length;
        if (this.eof) return;
        let n, g = 0, o = 0, c = 0, C = 0, h = t;
        if (1 === a && 1 === s) for(n = 0; n < e1; ++n){
            let e1 = r[n] ^ g;
            e1 ^= e1 >> 1;
            e1 ^= e1 >> 2;
            e1 ^= e1 >> 4;
            g = (1 & e1) << 7;
            i[h++] = e1;
        }
        else if (8 === a) {
            for(n = 0; n < s; ++n)i[h++] = r[n];
            for(; n < e1; ++n){
                i[h] = i[h - s] + r[n];
                h++;
            }
        } else if (16 === a) {
            const t = 2 * s;
            for(n = 0; n < t; ++n)i[h++] = r[n];
            for(; n < e1; n += 2){
                const e1 = ((255 & r[n]) << 8) + (255 & r[n + 1]) + ((255 & i[h - t]) << 8) + (255 & i[h - t + 1]);
                i[h++] = e1 >> 8 & 255;
                i[h++] = 255 & e1;
            }
        } else {
            const e1 = new Uint8Array(s + 1), h = (1 << a) - 1;
            let l = 0, Q = t;
            const E = this.columns;
            for(n = 0; n < E; ++n)for(let t = 0; t < s; ++t){
                if (c < a) {
                    g = g << 8 | 255 & r[l++];
                    c += 8;
                }
                e1[t] = e1[t] + (g >> c - a) & h;
                c -= a;
                o = o << a | e1[t];
                C += a;
                if (C >= 8) {
                    i[Q++] = o >> C - 8 & 255;
                    C -= 8;
                }
            }
            C > 0 && (i[Q++] = (o << 8 - C) + (g & (1 << 8 - C) - 1));
        }
        this.bufferLength += e1;
    }
    readBlockPng() {
        const e1 = this.rowBytes, t = this.pixBytes, i = this.str.getByte(), a = this.str.getBytes(e1);
        this.eof = !a.length;
        if (this.eof) return;
        const s = this.bufferLength, r = this.ensureBuffer(s + e1);
        let n = r.subarray(s - e1, s);
        0 === n.length && (n = new Uint8Array(e1));
        let g, o, c, C = s;
        switch(i){
            case 0:
                for(g = 0; g < e1; ++g)r[C++] = a[g];
                break;
            case 1:
                for(g = 0; g < t; ++g)r[C++] = a[g];
                for(; g < e1; ++g){
                    r[C] = r[C - t] + a[g] & 255;
                    C++;
                }
                break;
            case 2:
                for(g = 0; g < e1; ++g)r[C++] = n[g] + a[g] & 255;
                break;
            case 3:
                for(g = 0; g < t; ++g)r[C++] = (n[g] >> 1) + a[g];
                for(; g < e1; ++g){
                    r[C] = (n[g] + r[C - t] >> 1) + a[g] & 255;
                    C++;
                }
                break;
            case 4:
                for(g = 0; g < t; ++g){
                    o = n[g];
                    c = a[g];
                    r[C++] = o + c;
                }
                for(; g < e1; ++g){
                    o = n[g];
                    const e1 = n[g - t], i = r[C - t], s = i + o - e1;
                    let h = s - i;
                    h < 0 && (h = -h);
                    let l = s - o;
                    l < 0 && (l = -l);
                    let Q = s - e1;
                    Q < 0 && (Q = -Q);
                    c = a[g];
                    r[C++] = h <= l && h <= Q ? i + c : l <= Q ? o + c : e1 + c;
                }
                break;
            default:
                throw new FormatError(`Unsupported predictor: ${i}`);
        }
        this.bufferLength += e1;
    }
}
class RunLengthStream extends DecodeStream {
    constructor(e1, t){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
    }
    readBlock() {
        const e1 = this.str.getBytes(2);
        if (!e1 || e1.length < 2 || 128 === e1[0]) {
            this.eof = !0;
            return;
        }
        let t, i = this.bufferLength, a = e1[0];
        if (a < 128) {
            t = this.ensureBuffer(i + a + 1);
            t[i++] = e1[1];
            if (a > 0) {
                const e1 = this.str.getBytes(a);
                t.set(e1, i);
                i += a;
            }
        } else {
            a = 257 - a;
            const s = e1[1];
            t = this.ensureBuffer(i + a + 1);
            for(let e1 = 0; e1 < a; e1++)t[i++] = s;
        }
        this.bufferLength = i;
    }
}
class Parser {
    constructor({ lexer: e1, xref: t, allowStreams: i = !1, recoveryMode: a = !1 }){
        this.lexer = e1;
        this.xref = t;
        this.allowStreams = i;
        this.recoveryMode = a;
        this.imageCache = Object.create(null);
        this._imageId = 0;
        this.refill();
    }
    refill() {
        this.buf1 = this.lexer.getObj();
        this.buf2 = this.lexer.getObj();
    }
    shift() {
        if (this.buf2 instanceof Cmd && "ID" === this.buf2.cmd) {
            this.buf1 = this.buf2;
            this.buf2 = null;
        } else {
            this.buf1 = this.buf2;
            this.buf2 = this.lexer.getObj();
        }
    }
    tryShift() {
        try {
            this.shift();
            return !0;
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            return !1;
        }
    }
    getObj(e1 = null) {
        const t = this.buf1;
        this.shift();
        if (t instanceof Cmd) switch(t.cmd){
            case "BI":
                return this.makeInlineImage(e1);
            case "[":
                const i = [];
                for(; !isCmd(this.buf1, "]") && this.buf1 !== Bt;)i.push(this.getObj(e1));
                if (this.buf1 === Bt) {
                    if (this.recoveryMode) return i;
                    throw new ParserEOFException("End of file inside array.");
                }
                this.shift();
                return i;
            case "<<":
                const a = new Dict(this.xref);
                for(; !isCmd(this.buf1, ">>") && this.buf1 !== Bt;){
                    if (!(this.buf1 instanceof Name)) {
                        info("Malformed dictionary: key must be a name object");
                        this.shift();
                        continue;
                    }
                    const t = this.buf1.name;
                    this.shift();
                    if (this.buf1 === Bt) break;
                    a.set(t, this.getObj(e1));
                }
                if (this.buf1 === Bt) {
                    if (this.recoveryMode) return a;
                    throw new ParserEOFException("End of file inside dictionary.");
                }
                if (isCmd(this.buf2, "stream")) return this.allowStreams ? this.makeStream(a, e1) : a;
                this.shift();
                return a;
            default:
                return t;
        }
        if (Number.isInteger(t)) {
            if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
                const e1 = Ref.get(t, this.buf1);
                this.shift();
                this.shift();
                return e1;
            }
            return t;
        }
        return "string" == typeof t && e1 ? e1.decryptString(t) : t;
    }
    findDefaultInlineStreamEnd(e1) {
        const { knownCommands: t } = this.lexer, i = e1.pos;
        let a, s, r = 0;
        for(; -1 !== (a = e1.getByte());)if (0 === r) r = 69 === a ? 1 : 0;
        else if (1 === r) r = 73 === a ? 2 : 0;
        else if (32 === a || 10 === a || 13 === a) {
            s = e1.pos;
            const i = e1.peekBytes(15), n = i.length;
            if (0 === n) break;
            for(let e1 = 0; e1 < n; e1++){
                a = i[e1];
                if ((0 !== a || 0 === i[e1 + 1]) && 10 !== a && 13 !== a && (a < 32 || a > 127)) {
                    r = 0;
                    break;
                }
            }
            if (2 !== r) continue;
            if (!t) {
                warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                continue;
            }
            const g = new Lexer(new Stream(i.slice()), t);
            g._hexStringWarn = ()=>{};
            let o = 0;
            for(;;){
                const e1 = g.getObj();
                if (e1 === Bt) {
                    r = 0;
                    break;
                }
                if (e1 instanceof Cmd) {
                    const i = t[e1.cmd];
                    if (!i) {
                        r = 0;
                        break;
                    }
                    if (i.variableArgs ? o <= i.numArgs : o === i.numArgs) break;
                    o = 0;
                } else o++;
            }
            if (2 === r) break;
        } else r = 0;
        if (-1 === a) {
            warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
            if (s) {
                warn('... trying to recover by using the last "EI" occurrence.');
                e1.skip(-(e1.pos - s));
            }
        }
        let n = 4;
        e1.skip(-n);
        a = e1.peekByte();
        e1.skip(n);
        isWhiteSpace(a) || n--;
        return e1.pos - n - i;
    }
    findDCTDecodeInlineStreamEnd(e1) {
        const t = e1.pos;
        let i, a, s = !1;
        for(; -1 !== (i = e1.getByte());)if (255 === i) {
            switch(e1.getByte()){
                case 0:
                    break;
                case 255:
                    e1.skip(-1);
                    break;
                case 217:
                    s = !0;
                    break;
                case 192:
                case 193:
                case 194:
                case 195:
                case 197:
                case 198:
                case 199:
                case 201:
                case 202:
                case 203:
                case 205:
                case 206:
                case 207:
                case 196:
                case 204:
                case 218:
                case 219:
                case 220:
                case 221:
                case 222:
                case 223:
                case 224:
                case 225:
                case 226:
                case 227:
                case 228:
                case 229:
                case 230:
                case 231:
                case 232:
                case 233:
                case 234:
                case 235:
                case 236:
                case 237:
                case 238:
                case 239:
                case 254:
                    a = e1.getUint16();
                    a > 2 ? e1.skip(a - 2) : e1.skip(-2);
            }
            if (s) break;
        }
        const r = e1.pos - t;
        if (-1 === i) {
            warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
            e1.skip(-r);
            return this.findDefaultInlineStreamEnd(e1);
        }
        this.inlineStreamSkipEI(e1);
        return r;
    }
    findASCII85DecodeInlineStreamEnd(e1) {
        const t = e1.pos;
        let i;
        for(; -1 !== (i = e1.getByte());)if (126 === i) {
            const t = e1.pos;
            i = e1.peekByte();
            for(; isWhiteSpace(i);){
                e1.skip();
                i = e1.peekByte();
            }
            if (62 === i) {
                e1.skip();
                break;
            }
            if (e1.pos > t) {
                const t = e1.peekBytes(2);
                if (69 === t[0] && 73 === t[1]) break;
            }
        }
        const a = e1.pos - t;
        if (-1 === i) {
            warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
            e1.skip(-a);
            return this.findDefaultInlineStreamEnd(e1);
        }
        this.inlineStreamSkipEI(e1);
        return a;
    }
    findASCIIHexDecodeInlineStreamEnd(e1) {
        const t = e1.pos;
        let i;
        for(; -1 !== (i = e1.getByte()) && 62 !== i;);
        const a = e1.pos - t;
        if (-1 === i) {
            warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
            e1.skip(-a);
            return this.findDefaultInlineStreamEnd(e1);
        }
        this.inlineStreamSkipEI(e1);
        return a;
    }
    inlineStreamSkipEI(e1) {
        let t, i = 0;
        for(; -1 !== (t = e1.getByte());)if (0 === i) i = 69 === t ? 1 : 0;
        else if (1 === i) i = 73 === t ? 2 : 0;
        else if (2 === i) break;
    }
    makeInlineImage(e1) {
        const t = this.lexer, i = t.stream, a = Object.create(null);
        let s;
        for(; !isCmd(this.buf1, "ID") && this.buf1 !== Bt;){
            if (!(this.buf1 instanceof Name)) throw new FormatError("Dictionary key must be a name object");
            const t = this.buf1.name;
            this.shift();
            if (this.buf1 === Bt) break;
            a[t] = this.getObj(e1);
        }
        -1 !== t.beginInlineImagePos && (s = i.pos - t.beginInlineImagePos);
        const r = this.xref.fetchIfRef(a.F || a.Filter);
        let n;
        if (r instanceof Name) n = r.name;
        else if (Array.isArray(r)) {
            const e1 = this.xref.fetchIfRef(r[0]);
            e1 instanceof Name && (n = e1.name);
        }
        const g = i.pos;
        let o, c;
        switch(n){
            case "DCT":
            case "DCTDecode":
                o = this.findDCTDecodeInlineStreamEnd(i);
                break;
            case "A85":
            case "ASCII85Decode":
                o = this.findASCII85DecodeInlineStreamEnd(i);
                break;
            case "AHx":
            case "ASCIIHexDecode":
                o = this.findASCIIHexDecodeInlineStreamEnd(i);
                break;
            default:
                o = this.findDefaultInlineStreamEnd(i);
        }
        if (o < 1e3 && s > 0) {
            const e1 = i.pos;
            i.pos = t.beginInlineImagePos;
            c = function getInlineImageCacheKey(e1) {
                const t = [], i = e1.length;
                let a = 0;
                for(; a < i - 1;)t.push(e1[a++] << 8 | e1[a++]);
                a < i && t.push(e1[a]);
                return i + "_" + String.fromCharCode.apply(null, t);
            }(i.getBytes(s + o));
            i.pos = e1;
            const a = this.imageCache[c];
            if (void 0 !== a) {
                this.buf2 = Cmd.get("EI");
                this.shift();
                a.reset();
                return a;
            }
        }
        const C = new Dict(this.xref);
        for(const e1 in a)C.set(e1, a[e1]);
        let h = i.makeSubStream(g, o, C);
        e1 && (h = e1.createStream(h, o));
        h = this.filter(h, C, o);
        h.dict = C;
        if (void 0 !== c) {
            h.cacheKey = "inline_img_" + ++this._imageId;
            this.imageCache[c] = h;
        }
        this.buf2 = Cmd.get("EI");
        this.shift();
        return h;
    }
    #b(e1) {
        const { stream: t } = this.lexer;
        t.pos = e1;
        const i = new Uint8Array([
            101,
            110,
            100
        ]), a = i.length, s = [
            new Uint8Array([
                115,
                116,
                114,
                101,
                97,
                109
            ]),
            new Uint8Array([
                115,
                116,
                101,
                97,
                109
            ]),
            new Uint8Array([
                115,
                116,
                114,
                101,
                97
            ])
        ], r = 9 - a;
        for(; t.pos < t.end;){
            const n = t.peekBytes(2048), g = n.length - 9;
            if (g <= 0) break;
            let o = 0;
            for(; o < g;){
                let g = 0;
                for(; g < a && n[o + g] === i[g];)g++;
                if (g >= a) {
                    let a = !1;
                    for (const e1 of s){
                        const t = e1.length;
                        let s = 0;
                        for(; s < t && n[o + g + s] === e1[s];)s++;
                        if (s >= r) {
                            a = !0;
                            break;
                        }
                        if (s >= t) {
                            if (isWhiteSpace(n[o + g + s])) {
                                info(`Found "${bytesToString([
                                    ...i,
                                    ...e1
                                ])}" when searching for endstream command.`);
                                a = !0;
                            }
                            break;
                        }
                    }
                    if (a) {
                        t.pos += o;
                        return t.pos - e1;
                    }
                }
                o++;
            }
            t.pos += g;
        }
        return -1;
    }
    makeStream(e1, t) {
        const i = this.lexer;
        let a = i.stream;
        i.skipToNextLine();
        const s = a.pos - 1;
        let r = e1.get("Length");
        if (!Number.isInteger(r)) {
            info(`Bad length "${r && r.toString()}" in stream.`);
            r = 0;
        }
        a.pos = s + r;
        i.nextChar();
        if (this.tryShift() && isCmd(this.buf2, "endstream")) this.shift();
        else {
            r = this.#b(s);
            if (r < 0) throw new FormatError("Missing endstream command.");
            i.nextChar();
            this.shift();
            this.shift();
        }
        this.shift();
        a = a.makeSubStream(s, r, e1);
        t && (a = t.createStream(a, r));
        a = this.filter(a, e1, r);
        a.dict = e1;
        return a;
    }
    filter(e1, t, i) {
        let a = t.get("F", "Filter"), s = t.get("DP", "DecodeParms");
        if (a instanceof Name) {
            Array.isArray(s) && warn("/DecodeParms should not be an Array, when /Filter is a Name.");
            return this.makeFilter(e1, a.name, i, s);
        }
        let r = i;
        if (Array.isArray(a)) {
            const t = a, i = s;
            for(let n = 0, g = t.length; n < g; ++n){
                a = this.xref.fetchIfRef(t[n]);
                if (!(a instanceof Name)) throw new FormatError(`Bad filter name "${a}"`);
                s = null;
                Array.isArray(i) && n in i && (s = this.xref.fetchIfRef(i[n]));
                e1 = this.makeFilter(e1, a.name, r, s);
                r = null;
            }
        }
        return e1;
    }
    makeFilter(e1, t, i, a) {
        if (0 === i) {
            warn(`Empty "${t}" stream.`);
            return new NullStream;
        }
        try {
            switch(t){
                case "Fl":
                case "FlateDecode":
                    return a ? new PredictorStream(new FlateStream(e1, i), i, a) : new FlateStream(e1, i);
                case "LZW":
                case "LZWDecode":
                    let t1 = 1;
                    if (a) {
                        a.has("EarlyChange") && (t1 = a.get("EarlyChange"));
                        return new PredictorStream(new LZWStream(e1, i, t1), i, a);
                    }
                    return new LZWStream(e1, i, t1);
                case "DCT":
                case "DCTDecode":
                    return new JpegStream(e1, i, a);
                case "JPX":
                case "JPXDecode":
                    return new JpxStream(e1, i, a);
                case "A85":
                case "ASCII85Decode":
                    return new Ascii85Stream(e1, i);
                case "AHx":
                case "ASCIIHexDecode":
                    return new AsciiHexStream(e1, i);
                case "CCF":
                case "CCITTFaxDecode":
                    return new CCITTFaxStream(e1, i, a);
                case "RL":
                case "RunLengthDecode":
                    return new RunLengthStream(e1, i);
                case "JBIG2Decode":
                    return new Jbig2Stream(e1, i, a);
            }
            warn(`Filter "${t}" is not supported.`);
            return e1;
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`Invalid stream: "${e1}"`);
            return new NullStream;
        }
    }
}
const ai = [
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    2,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
function toHexDigit(e1) {
    return e1 >= 48 && e1 <= 57 ? 15 & e1 : e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102 ? 9 + (15 & e1) : -1;
}
class Lexer {
    constructor(e1, t = null){
        this.stream = e1;
        this.nextChar();
        this.strBuf = [];
        this.knownCommands = t;
        this._hexStringNumWarn = 0;
        this.beginInlineImagePos = -1;
    }
    nextChar() {
        return this.currentChar = this.stream.getByte();
    }
    peekChar() {
        return this.stream.peekByte();
    }
    getNumber() {
        let e1 = this.currentChar, t = !1, i = 0, a = 1;
        if (45 === e1) {
            a = -1;
            e1 = this.nextChar();
            45 === e1 && (e1 = this.nextChar());
        } else 43 === e1 && (e1 = this.nextChar());
        if (10 === e1 || 13 === e1) do {
            e1 = this.nextChar();
        }while (10 === e1 || 13 === e1)
        if (46 === e1) {
            i = 10;
            e1 = this.nextChar();
        }
        if (e1 < 48 || e1 > 57) {
            const t = `Invalid number: ${String.fromCharCode(e1)} (charCode ${e1})`;
            if (isWhiteSpace(e1) || -1 === e1) {
                info(`Lexer.getNumber - "${t}".`);
                return 0;
            }
            throw new FormatError(t);
        }
        let s = e1 - 48, r = 0, n = 1;
        for(; (e1 = this.nextChar()) >= 0;)if (e1 >= 48 && e1 <= 57) {
            const a = e1 - 48;
            if (t) r = 10 * r + a;
            else {
                0 !== i && (i *= 10);
                s = 10 * s + a;
            }
        } else if (46 === e1) {
            if (0 !== i) break;
            i = 1;
        } else if (45 === e1) warn("Badly formatted number: minus sign in the middle");
        else {
            if (69 !== e1 && 101 !== e1) break;
            e1 = this.peekChar();
            if (43 === e1 || 45 === e1) {
                n = 45 === e1 ? -1 : 1;
                this.nextChar();
            } else if (e1 < 48 || e1 > 57) break;
            t = !0;
        }
        0 !== i && (s /= i);
        t && (s *= 10 ** (n * r));
        return a * s;
    }
    getString() {
        let e1 = 1, t = !1;
        const i = this.strBuf;
        i.length = 0;
        let a = this.nextChar();
        for(;;){
            let s = !1;
            switch(0 | a){
                case -1:
                    warn("Unterminated string");
                    t = !0;
                    break;
                case 40:
                    ++e1;
                    i.push("(");
                    break;
                case 41:
                    if (0 == --e1) {
                        this.nextChar();
                        t = !0;
                    } else i.push(")");
                    break;
                case 92:
                    a = this.nextChar();
                    switch(a){
                        case -1:
                            warn("Unterminated string");
                            t = !0;
                            break;
                        case 110:
                            i.push("\n");
                            break;
                        case 114:
                            i.push("\r");
                            break;
                        case 116:
                            i.push("\t");
                            break;
                        case 98:
                            i.push("\b");
                            break;
                        case 102:
                            i.push("\f");
                            break;
                        case 92:
                        case 40:
                        case 41:
                            i.push(String.fromCharCode(a));
                            break;
                        case 48:
                        case 49:
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                        case 54:
                        case 55:
                            let e2 = 15 & a;
                            a = this.nextChar();
                            s = !0;
                            if (a >= 48 && a <= 55) {
                                e2 = (e2 << 3) + (15 & a);
                                a = this.nextChar();
                                if (a >= 48 && a <= 55) {
                                    s = !1;
                                    e2 = (e2 << 3) + (15 & a);
                                }
                            }
                            i.push(String.fromCharCode(e2));
                            break;
                        case 13:
                            10 === this.peekChar() && this.nextChar();
                            break;
                        case 10:
                            break;
                        default:
                            i.push(String.fromCharCode(a));
                    }
                    break;
                default:
                    i.push(String.fromCharCode(a));
            }
            if (t) break;
            s || (a = this.nextChar());
        }
        return i.join("");
    }
    getName() {
        let e1, t;
        const i = this.strBuf;
        i.length = 0;
        for(; (e1 = this.nextChar()) >= 0 && !ai[e1];)if (35 === e1) {
            e1 = this.nextChar();
            if (ai[e1]) {
                warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                i.push("#");
                break;
            }
            const a = toHexDigit(e1);
            if (-1 !== a) {
                t = e1;
                e1 = this.nextChar();
                const s = toHexDigit(e1);
                if (-1 === s) {
                    warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e1)}) in hexadecimal number.`);
                    i.push("#", String.fromCharCode(t));
                    if (ai[e1]) break;
                    i.push(String.fromCharCode(e1));
                    continue;
                }
                i.push(String.fromCharCode(a << 4 | s));
            } else i.push("#", String.fromCharCode(e1));
        } else i.push(String.fromCharCode(e1));
        i.length > 127 && warn(`Name token is longer than allowed by the spec: ${i.length}`);
        return Name.get(i.join(""));
    }
    _hexStringWarn(e1) {
        5 != this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn(`getHexString - ignoring invalid character: ${e1}`) : warn("getHexString - ignoring additional invalid characters.");
    }
    getHexString() {
        const e1 = this.strBuf;
        e1.length = 0;
        let t = this.currentChar, i = -1, a = -1;
        this._hexStringNumWarn = 0;
        for(;;){
            if (t < 0) {
                warn("Unterminated hex string");
                break;
            }
            if (62 === t) {
                this.nextChar();
                break;
            }
            if (1 !== ai[t]) {
                a = toHexDigit(t);
                if (-1 === a) this._hexStringWarn(t);
                else if (-1 === i) i = a;
                else {
                    e1.push(String.fromCharCode(i << 4 | a));
                    i = -1;
                }
                t = this.nextChar();
            } else t = this.nextChar();
        }
        -1 !== i && e1.push(String.fromCharCode(i << 4));
        return e1.join("");
    }
    getObj() {
        let e1 = !1, t = this.currentChar;
        for(;;){
            if (t < 0) return Bt;
            if (e1) 10 !== t && 13 !== t || (e1 = !1);
            else if (37 === t) e1 = !0;
            else if (1 !== ai[t]) break;
            t = this.nextChar();
        }
        switch(0 | t){
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 43:
            case 45:
            case 46:
                return this.getNumber();
            case 40:
                return this.getString();
            case 47:
                return this.getName();
            case 91:
                this.nextChar();
                return Cmd.get("[");
            case 93:
                this.nextChar();
                return Cmd.get("]");
            case 60:
                t = this.nextChar();
                if (60 === t) {
                    this.nextChar();
                    return Cmd.get("<<");
                }
                return this.getHexString();
            case 62:
                t = this.nextChar();
                if (62 === t) {
                    this.nextChar();
                    return Cmd.get(">>");
                }
                return Cmd.get(">");
            case 123:
                this.nextChar();
                return Cmd.get("{");
            case 125:
                this.nextChar();
                return Cmd.get("}");
            case 41:
                this.nextChar();
                throw new FormatError(`Illegal character: ${t}`);
        }
        let i = String.fromCharCode(t);
        if (t < 32 || t > 127) {
            const e1 = this.peekChar();
            if (e1 >= 32 && e1 <= 127) {
                this.nextChar();
                return Cmd.get(i);
            }
        }
        const a = this.knownCommands;
        let s = void 0 !== a?.[i];
        for(; (t = this.nextChar()) >= 0 && !ai[t];){
            const e1 = i + String.fromCharCode(t);
            if (s && void 0 === a[e1]) break;
            if (128 === i.length) throw new FormatError(`Command token too long: ${i.length}`);
            i = e1;
            s = void 0 !== a?.[i];
        }
        if ("true" === i) return !0;
        if ("false" === i) return !1;
        if ("null" === i) return null;
        "BI" === i && (this.beginInlineImagePos = this.stream.pos);
        return Cmd.get(i);
    }
    skipToNextLine() {
        let e1 = this.currentChar;
        for(; e1 >= 0;){
            if (13 === e1) {
                e1 = this.nextChar();
                10 === e1 && this.nextChar();
                break;
            }
            if (10 === e1) {
                this.nextChar();
                break;
            }
            e1 = this.nextChar();
        }
    }
}
class Linearization {
    static create(e1) {
        function getInt(e1, t, i = !1) {
            const a = e1.get(t);
            if (Number.isInteger(a) && (i ? a >= 0 : a > 0)) return a;
            throw new Error(`The "${t}" parameter in the linearization dictionary is invalid.`);
        }
        const t = new Parser({
            lexer: new Lexer(e1),
            xref: null
        }), i = t.getObj(), a = t.getObj(), s = t.getObj(), r = t.getObj();
        let n, g;
        if (!(Number.isInteger(i) && Number.isInteger(a) && isCmd(s, "obj") && r instanceof Dict && "number" == typeof (n = r.get("Linearized")) && n > 0)) return null;
        if ((g = getInt(r, "L")) !== e1.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
        return {
            length: g,
            hints: function getHints(e1) {
                const t = e1.get("H");
                let i;
                if (Array.isArray(t) && (2 === (i = t.length) || 4 === i)) {
                    for(let e1 = 0; e1 < i; e1++){
                        const i = t[e1];
                        if (!(Number.isInteger(i) && i > 0)) throw new Error(`Hint (${e1}) in the linearization dictionary is invalid.`);
                    }
                    return t;
                }
                throw new Error("Hint array in the linearization dictionary is invalid.");
            }(r),
            objectNumberFirst: getInt(r, "O"),
            endFirst: getInt(r, "E"),
            numPages: getInt(r, "N"),
            mainXRefEntriesOffset: getInt(r, "T"),
            pageFirst: r.has("P") ? getInt(r, "P", !0) : 0
        };
    }
}
const si = [
    "Adobe-GB1-UCS2",
    "Adobe-CNS1-UCS2",
    "Adobe-Japan1-UCS2",
    "Adobe-Korea1-UCS2",
    "78-EUC-H",
    "78-EUC-V",
    "78-H",
    "78-RKSJ-H",
    "78-RKSJ-V",
    "78-V",
    "78ms-RKSJ-H",
    "78ms-RKSJ-V",
    "83pv-RKSJ-H",
    "90ms-RKSJ-H",
    "90ms-RKSJ-V",
    "90msp-RKSJ-H",
    "90msp-RKSJ-V",
    "90pv-RKSJ-H",
    "90pv-RKSJ-V",
    "Add-H",
    "Add-RKSJ-H",
    "Add-RKSJ-V",
    "Add-V",
    "Adobe-CNS1-0",
    "Adobe-CNS1-1",
    "Adobe-CNS1-2",
    "Adobe-CNS1-3",
    "Adobe-CNS1-4",
    "Adobe-CNS1-5",
    "Adobe-CNS1-6",
    "Adobe-GB1-0",
    "Adobe-GB1-1",
    "Adobe-GB1-2",
    "Adobe-GB1-3",
    "Adobe-GB1-4",
    "Adobe-GB1-5",
    "Adobe-Japan1-0",
    "Adobe-Japan1-1",
    "Adobe-Japan1-2",
    "Adobe-Japan1-3",
    "Adobe-Japan1-4",
    "Adobe-Japan1-5",
    "Adobe-Japan1-6",
    "Adobe-Korea1-0",
    "Adobe-Korea1-1",
    "Adobe-Korea1-2",
    "B5-H",
    "B5-V",
    "B5pc-H",
    "B5pc-V",
    "CNS-EUC-H",
    "CNS-EUC-V",
    "CNS1-H",
    "CNS1-V",
    "CNS2-H",
    "CNS2-V",
    "ETHK-B5-H",
    "ETHK-B5-V",
    "ETen-B5-H",
    "ETen-B5-V",
    "ETenms-B5-H",
    "ETenms-B5-V",
    "EUC-H",
    "EUC-V",
    "Ext-H",
    "Ext-RKSJ-H",
    "Ext-RKSJ-V",
    "Ext-V",
    "GB-EUC-H",
    "GB-EUC-V",
    "GB-H",
    "GB-V",
    "GBK-EUC-H",
    "GBK-EUC-V",
    "GBK2K-H",
    "GBK2K-V",
    "GBKp-EUC-H",
    "GBKp-EUC-V",
    "GBT-EUC-H",
    "GBT-EUC-V",
    "GBT-H",
    "GBT-V",
    "GBTpc-EUC-H",
    "GBTpc-EUC-V",
    "GBpc-EUC-H",
    "GBpc-EUC-V",
    "H",
    "HKdla-B5-H",
    "HKdla-B5-V",
    "HKdlb-B5-H",
    "HKdlb-B5-V",
    "HKgccs-B5-H",
    "HKgccs-B5-V",
    "HKm314-B5-H",
    "HKm314-B5-V",
    "HKm471-B5-H",
    "HKm471-B5-V",
    "HKscs-B5-H",
    "HKscs-B5-V",
    "Hankaku",
    "Hiragana",
    "KSC-EUC-H",
    "KSC-EUC-V",
    "KSC-H",
    "KSC-Johab-H",
    "KSC-Johab-V",
    "KSC-V",
    "KSCms-UHC-H",
    "KSCms-UHC-HW-H",
    "KSCms-UHC-HW-V",
    "KSCms-UHC-V",
    "KSCpc-EUC-H",
    "KSCpc-EUC-V",
    "Katakana",
    "NWP-H",
    "NWP-V",
    "RKSJ-H",
    "RKSJ-V",
    "Roman",
    "UniCNS-UCS2-H",
    "UniCNS-UCS2-V",
    "UniCNS-UTF16-H",
    "UniCNS-UTF16-V",
    "UniCNS-UTF32-H",
    "UniCNS-UTF32-V",
    "UniCNS-UTF8-H",
    "UniCNS-UTF8-V",
    "UniGB-UCS2-H",
    "UniGB-UCS2-V",
    "UniGB-UTF16-H",
    "UniGB-UTF16-V",
    "UniGB-UTF32-H",
    "UniGB-UTF32-V",
    "UniGB-UTF8-H",
    "UniGB-UTF8-V",
    "UniJIS-UCS2-H",
    "UniJIS-UCS2-HW-H",
    "UniJIS-UCS2-HW-V",
    "UniJIS-UCS2-V",
    "UniJIS-UTF16-H",
    "UniJIS-UTF16-V",
    "UniJIS-UTF32-H",
    "UniJIS-UTF32-V",
    "UniJIS-UTF8-H",
    "UniJIS-UTF8-V",
    "UniJIS2004-UTF16-H",
    "UniJIS2004-UTF16-V",
    "UniJIS2004-UTF32-H",
    "UniJIS2004-UTF32-V",
    "UniJIS2004-UTF8-H",
    "UniJIS2004-UTF8-V",
    "UniJISPro-UCS2-HW-V",
    "UniJISPro-UCS2-V",
    "UniJISPro-UTF8-V",
    "UniJISX0213-UTF32-H",
    "UniJISX0213-UTF32-V",
    "UniJISX02132004-UTF32-H",
    "UniJISX02132004-UTF32-V",
    "UniKS-UCS2-H",
    "UniKS-UCS2-V",
    "UniKS-UTF16-H",
    "UniKS-UTF16-V",
    "UniKS-UTF32-H",
    "UniKS-UTF32-V",
    "UniKS-UTF8-H",
    "UniKS-UTF8-V",
    "V",
    "WP-Symbol"
], ri = 2 ** 24 - 1;
class CMap {
    constructor(e1 = !1){
        this.codespaceRanges = [
            [],
            [],
            [],
            []
        ];
        this.numCodespaceRanges = 0;
        this._map = [];
        this.name = "";
        this.vertical = !1;
        this.useCMap = null;
        this.builtInCMap = e1;
    }
    addCodespaceRange(e1, t, i) {
        this.codespaceRanges[e1 - 1].push(t, i);
        this.numCodespaceRanges++;
    }
    mapCidRange(e1, t, i) {
        if (t - e1 > ri) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
        for(; e1 <= t;)this._map[e1++] = i++;
    }
    mapBfRange(e1, t, i) {
        if (t - e1 > ri) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
        const a = i.length - 1;
        for(; e1 <= t;){
            this._map[e1++] = i;
            const t = i.charCodeAt(a) + 1;
            t > 255 ? i = i.substring(0, a - 1) + String.fromCharCode(i.charCodeAt(a - 1) + 1) + "\0" : i = i.substring(0, a) + String.fromCharCode(t);
        }
    }
    mapBfRangeToArray(e1, t, i) {
        if (t - e1 > ri) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
        const a = i.length;
        let s = 0;
        for(; e1 <= t && s < a;){
            this._map[e1] = i[s++];
            ++e1;
        }
    }
    mapOne(e1, t) {
        this._map[e1] = t;
    }
    lookup(e1) {
        return this._map[e1];
    }
    contains(e1) {
        return void 0 !== this._map[e1];
    }
    forEach(e1) {
        const t = this._map, i = t.length;
        if (i <= 65536) for(let a = 0; a < i; a++)void 0 !== t[a] && e1(a, t[a]);
        else for(const i in t)e1(i, t[i]);
    }
    charCodeOf(e1) {
        const t = this._map;
        if (t.length <= 65536) return t.indexOf(e1);
        for(const i in t)if (t[i] === e1) return 0 | i;
        return -1;
    }
    getMap() {
        return this._map;
    }
    readCharCode(e1, t, i) {
        let a = 0;
        const s = this.codespaceRanges;
        for(let r = 0, n = s.length; r < n; r++){
            a = (a << 8 | e1.charCodeAt(t + r)) >>> 0;
            const n = s[r];
            for(let e1 = 0, t = n.length; e1 < t;){
                const t = n[e1++], s = n[e1++];
                if (a >= t && a <= s) {
                    i.charcode = a;
                    i.length = r + 1;
                    return;
                }
            }
        }
        i.charcode = 0;
        i.length = 1;
    }
    getCharCodeLength(e1) {
        const t = this.codespaceRanges;
        for(let i = 0, a = t.length; i < a; i++){
            const a = t[i];
            for(let t = 0, s = a.length; t < s;){
                const s = a[t++], r = a[t++];
                if (e1 >= s && e1 <= r) return i + 1;
            }
        }
        return 1;
    }
    get length() {
        return this._map.length;
    }
    get isIdentityCMap() {
        if ("Identity-H" !== this.name && "Identity-V" !== this.name) return !1;
        if (65536 !== this._map.length) return !1;
        for(let e1 = 0; e1 < 65536; e1++)if (this._map[e1] !== e1) return !1;
        return !0;
    }
}
class IdentityCMap extends CMap {
    constructor(e1, t){
        super();
        this.vertical = e1;
        this.addCodespaceRange(t, 0, 65535);
    }
    mapCidRange(e1, t, i) {
        unreachable("should not call mapCidRange");
    }
    mapBfRange(e1, t, i) {
        unreachable("should not call mapBfRange");
    }
    mapBfRangeToArray(e1, t, i) {
        unreachable("should not call mapBfRangeToArray");
    }
    mapOne(e1, t) {
        unreachable("should not call mapCidOne");
    }
    lookup(e1) {
        return Number.isInteger(e1) && e1 <= 65535 ? e1 : void 0;
    }
    contains(e1) {
        return Number.isInteger(e1) && e1 <= 65535;
    }
    forEach(e1) {
        for(let t = 0; t <= 65535; t++)e1(t, t);
    }
    charCodeOf(e1) {
        return Number.isInteger(e1) && e1 <= 65535 ? e1 : -1;
    }
    getMap() {
        const e1 = new Array(65536);
        for(let t = 0; t <= 65535; t++)e1[t] = t;
        return e1;
    }
    get length() {
        return 65536;
    }
    get isIdentityCMap() {
        unreachable("should not access .isIdentityCMap");
    }
}
function strToInt(e1) {
    let t = 0;
    for(let i = 0; i < e1.length; i++)t = t << 8 | e1.charCodeAt(i);
    return t >>> 0;
}
function expectString(e1) {
    if ("string" != typeof e1) throw new FormatError("Malformed CMap: expected string.");
}
function expectInt(e1) {
    if (!Number.isInteger(e1)) throw new FormatError("Malformed CMap: expected int.");
}
function parseBfChar(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === Bt) break;
        if (isCmd(i, "endbfchar")) return;
        expectString(i);
        const a = strToInt(i);
        i = t.getObj();
        expectString(i);
        const s = i;
        e1.mapOne(a, s);
    }
}
function parseBfRange(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === Bt) break;
        if (isCmd(i, "endbfrange")) return;
        expectString(i);
        const a = strToInt(i);
        i = t.getObj();
        expectString(i);
        const s = strToInt(i);
        i = t.getObj();
        if (Number.isInteger(i) || "string" == typeof i) {
            const t = Number.isInteger(i) ? String.fromCharCode(i) : i;
            e1.mapBfRange(a, s, t);
        } else {
            if (!isCmd(i, "[")) break;
            {
                i = t.getObj();
                const r = [];
                for(; !isCmd(i, "]") && i !== Bt;){
                    r.push(i);
                    i = t.getObj();
                }
                e1.mapBfRangeToArray(a, s, r);
            }
        }
    }
    throw new FormatError("Invalid bf range.");
}
function parseCidChar(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === Bt) break;
        if (isCmd(i, "endcidchar")) return;
        expectString(i);
        const a = strToInt(i);
        i = t.getObj();
        expectInt(i);
        const s = i;
        e1.mapOne(a, s);
    }
}
function parseCidRange(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === Bt) break;
        if (isCmd(i, "endcidrange")) return;
        expectString(i);
        const a = strToInt(i);
        i = t.getObj();
        expectString(i);
        const s = strToInt(i);
        i = t.getObj();
        expectInt(i);
        const r = i;
        e1.mapCidRange(a, s, r);
    }
}
function parseCodespaceRange(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === Bt) break;
        if (isCmd(i, "endcodespacerange")) return;
        if ("string" != typeof i) break;
        const a = strToInt(i);
        i = t.getObj();
        if ("string" != typeof i) break;
        const s = strToInt(i);
        e1.addCodespaceRange(i.length, a, s);
    }
    throw new FormatError("Invalid codespace range.");
}
function parseWMode(e1, t) {
    const i = t.getObj();
    Number.isInteger(i) && (e1.vertical = !!i);
}
function parseCMapName(e1, t) {
    const i = t.getObj();
    i instanceof Name && (e1.name = i.name);
}
async function parseCMap(e1, t, i, a) {
    let s, r;
    A: for(;;)try {
        const i = t.getObj();
        if (i === Bt) break;
        if (i instanceof Name) {
            "WMode" === i.name ? parseWMode(e1, t) : "CMapName" === i.name && parseCMapName(e1, t);
            s = i;
        } else if (i instanceof Cmd) switch(i.cmd){
            case "endcmap":
                break A;
            case "usecmap":
                s instanceof Name && (r = s.name);
                break;
            case "begincodespacerange":
                parseCodespaceRange(e1, t);
                break;
            case "beginbfchar":
                parseBfChar(e1, t);
                break;
            case "begincidchar":
                parseCidChar(e1, t);
                break;
            case "beginbfrange":
                parseBfRange(e1, t);
                break;
            case "begincidrange":
                parseCidRange(e1, t);
        }
    } catch (e1) {
        if (e1 instanceof MissingDataException) throw e1;
        warn("Invalid cMap data: " + e1);
        continue;
    }
    !a && r && (a = r);
    return a ? extendCMap(e1, i, a) : e1;
}
async function extendCMap(e1, t, i) {
    e1.useCMap = await createBuiltInCMap(i, t);
    if (0 === e1.numCodespaceRanges) {
        const t = e1.useCMap.codespaceRanges;
        for(let i = 0; i < t.length; i++)e1.codespaceRanges[i] = t[i].slice();
        e1.numCodespaceRanges = e1.useCMap.numCodespaceRanges;
    }
    e1.useCMap.forEach(function(t, i) {
        e1.contains(t) || e1.mapOne(t, i);
    });
    return e1;
}
async function createBuiltInCMap(e1, t) {
    if ("Identity-H" === e1) return new IdentityCMap(!1, 2);
    if ("Identity-V" === e1) return new IdentityCMap(!0, 2);
    if (!si.includes(e1)) throw new Error("Unknown CMap name: " + e1);
    if (!t) throw new Error("Built-in CMap parameters are not provided.");
    const { cMapData: i, isCompressed: a } = await t(e1), s = new CMap(!0);
    if (a) return (new BinaryCMapReader).process(i, s, (e1)=>extendCMap(s, t, e1));
    const r = new Lexer(new Stream(i));
    return parseCMap(s, r, t, null);
}
class CMapFactory {
    static async create({ encoding: e1, fetchBuiltInCMap: t, useCMap: i }) {
        if (e1 instanceof Name) return createBuiltInCMap(e1.name, t);
        if (e1 instanceof BaseStream) {
            const a = await parseCMap(new CMap, new Lexer(e1), t, i);
            return a.isIdentityCMap ? createBuiltInCMap(a.name, t) : a;
        }
        throw new Error("Encoding required.");
    }
}
const ni = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron"
], gi = [
    ".notdef",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
], oi = [
    ".notdef",
    "space",
    "dollaroldstyle",
    "dollarsuperior",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "hyphensuperior",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "centoldstyle",
    "figuredash",
    "hypheninferior",
    "onequarter",
    "onehalf",
    "threequarters",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior"
], Ii = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "",
    "",
    "",
    "isuperior",
    "",
    "",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "",
    "",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "",
    "",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "",
    "Dotaccentsmall",
    "",
    "",
    "Macronsmall",
    "",
    "",
    "figuredash",
    "hypheninferior",
    "",
    "",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "",
    "",
    "",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "",
    "",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
], ci = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "centoldstyle",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "",
    "threequartersemdash",
    "",
    "questionsmall",
    "",
    "",
    "",
    "",
    "Ethsmall",
    "",
    "",
    "onequarter",
    "onehalf",
    "threequarters",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "",
    "",
    "",
    "",
    "",
    "",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "",
    "parenrightinferior",
    "Circumflexsmall",
    "hypheninferior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "",
    "",
    "asuperior",
    "centsuperior",
    "",
    "",
    "",
    "",
    "Aacutesmall",
    "Agravesmall",
    "Acircumflexsmall",
    "Adieresissmall",
    "Atildesmall",
    "Aringsmall",
    "Ccedillasmall",
    "Eacutesmall",
    "Egravesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Iacutesmall",
    "Igravesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ntildesmall",
    "Oacutesmall",
    "Ogravesmall",
    "Ocircumflexsmall",
    "Odieresissmall",
    "Otildesmall",
    "Uacutesmall",
    "Ugravesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "",
    "eightsuperior",
    "fourinferior",
    "threeinferior",
    "sixinferior",
    "eightinferior",
    "seveninferior",
    "Scaronsmall",
    "",
    "centinferior",
    "twoinferior",
    "",
    "Dieresissmall",
    "",
    "Caronsmall",
    "osuperior",
    "fiveinferior",
    "",
    "commainferior",
    "periodinferior",
    "Yacutesmall",
    "",
    "dollarinferior",
    "",
    "",
    "Thornsmall",
    "",
    "nineinferior",
    "zeroinferior",
    "Zcaronsmall",
    "AEsmall",
    "Oslashsmall",
    "questiondownsmall",
    "oneinferior",
    "Lslashsmall",
    "",
    "",
    "",
    "",
    "",
    "",
    "Cedillasmall",
    "",
    "",
    "",
    "",
    "",
    "OEsmall",
    "figuredash",
    "hyphensuperior",
    "",
    "",
    "",
    "",
    "exclamdownsmall",
    "",
    "Ydieresissmall",
    "",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "ninesuperior",
    "zerosuperior",
    "",
    "esuperior",
    "rsuperior",
    "tsuperior",
    "",
    "",
    "isuperior",
    "ssuperior",
    "dsuperior",
    "",
    "",
    "",
    "",
    "",
    "lsuperior",
    "Ogoneksmall",
    "Brevesmall",
    "Macronsmall",
    "bsuperior",
    "nsuperior",
    "msuperior",
    "commasuperior",
    "periodsuperior",
    "Dotaccentsmall",
    "Ringsmall",
    "",
    "",
    "",
    ""
], Ci = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "space",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron"
], hi = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "",
    "questiondown",
    "",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "",
    "ring",
    "cedilla",
    "",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "AE",
    "",
    "ordfeminine",
    "",
    "",
    "",
    "",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "",
    "",
    "",
    "",
    "",
    "ae",
    "",
    "",
    "",
    "dotlessi",
    "",
    "",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "",
    "",
    "",
    ""
], li = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "bullet",
    "Euro",
    "bullet",
    "quotesinglbase",
    "florin",
    "quotedblbase",
    "ellipsis",
    "dagger",
    "daggerdbl",
    "circumflex",
    "perthousand",
    "Scaron",
    "guilsinglleft",
    "OE",
    "bullet",
    "Zcaron",
    "bullet",
    "bullet",
    "quoteleft",
    "quoteright",
    "quotedblleft",
    "quotedblright",
    "bullet",
    "endash",
    "emdash",
    "tilde",
    "trademark",
    "scaron",
    "guilsinglright",
    "oe",
    "bullet",
    "zcaron",
    "Ydieresis",
    "space",
    "exclamdown",
    "cent",
    "sterling",
    "currency",
    "yen",
    "brokenbar",
    "section",
    "dieresis",
    "copyright",
    "ordfeminine",
    "guillemotleft",
    "logicalnot",
    "hyphen",
    "registered",
    "macron",
    "degree",
    "plusminus",
    "twosuperior",
    "threesuperior",
    "acute",
    "mu",
    "paragraph",
    "periodcentered",
    "cedilla",
    "onesuperior",
    "ordmasculine",
    "guillemotright",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondown",
    "Agrave",
    "Aacute",
    "Acircumflex",
    "Atilde",
    "Adieresis",
    "Aring",
    "AE",
    "Ccedilla",
    "Egrave",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Igrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Eth",
    "Ntilde",
    "Ograve",
    "Oacute",
    "Ocircumflex",
    "Otilde",
    "Odieresis",
    "multiply",
    "Oslash",
    "Ugrave",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Yacute",
    "Thorn",
    "germandbls",
    "agrave",
    "aacute",
    "acircumflex",
    "atilde",
    "adieresis",
    "aring",
    "ae",
    "ccedilla",
    "egrave",
    "eacute",
    "ecircumflex",
    "edieresis",
    "igrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "eth",
    "ntilde",
    "ograve",
    "oacute",
    "ocircumflex",
    "otilde",
    "odieresis",
    "divide",
    "oslash",
    "ugrave",
    "uacute",
    "ucircumflex",
    "udieresis",
    "yacute",
    "thorn",
    "ydieresis"
], Bi = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "universal",
    "numbersign",
    "existential",
    "percent",
    "ampersand",
    "suchthat",
    "parenleft",
    "parenright",
    "asteriskmath",
    "plus",
    "comma",
    "minus",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "congruent",
    "Alpha",
    "Beta",
    "Chi",
    "Delta",
    "Epsilon",
    "Phi",
    "Gamma",
    "Eta",
    "Iota",
    "theta1",
    "Kappa",
    "Lambda",
    "Mu",
    "Nu",
    "Omicron",
    "Pi",
    "Theta",
    "Rho",
    "Sigma",
    "Tau",
    "Upsilon",
    "sigma1",
    "Omega",
    "Xi",
    "Psi",
    "Zeta",
    "bracketleft",
    "therefore",
    "bracketright",
    "perpendicular",
    "underscore",
    "radicalex",
    "alpha",
    "beta",
    "chi",
    "delta",
    "epsilon",
    "phi",
    "gamma",
    "eta",
    "iota",
    "phi1",
    "kappa",
    "lambda",
    "mu",
    "nu",
    "omicron",
    "pi",
    "theta",
    "rho",
    "sigma",
    "tau",
    "upsilon",
    "omega1",
    "omega",
    "xi",
    "psi",
    "zeta",
    "braceleft",
    "bar",
    "braceright",
    "similar",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Euro",
    "Upsilon1",
    "minute",
    "lessequal",
    "fraction",
    "infinity",
    "florin",
    "club",
    "diamond",
    "heart",
    "spade",
    "arrowboth",
    "arrowleft",
    "arrowup",
    "arrowright",
    "arrowdown",
    "degree",
    "plusminus",
    "second",
    "greaterequal",
    "multiply",
    "proportional",
    "partialdiff",
    "bullet",
    "divide",
    "notequal",
    "equivalence",
    "approxequal",
    "ellipsis",
    "arrowvertex",
    "arrowhorizex",
    "carriagereturn",
    "aleph",
    "Ifraktur",
    "Rfraktur",
    "weierstrass",
    "circlemultiply",
    "circleplus",
    "emptyset",
    "intersection",
    "union",
    "propersuperset",
    "reflexsuperset",
    "notsubset",
    "propersubset",
    "reflexsubset",
    "element",
    "notelement",
    "angle",
    "gradient",
    "registerserif",
    "copyrightserif",
    "trademarkserif",
    "product",
    "radical",
    "dotmath",
    "logicalnot",
    "logicaland",
    "logicalor",
    "arrowdblboth",
    "arrowdblleft",
    "arrowdblup",
    "arrowdblright",
    "arrowdbldown",
    "lozenge",
    "angleleft",
    "registersans",
    "copyrightsans",
    "trademarksans",
    "summation",
    "parenlefttp",
    "parenleftex",
    "parenleftbt",
    "bracketlefttp",
    "bracketleftex",
    "bracketleftbt",
    "bracelefttp",
    "braceleftmid",
    "braceleftbt",
    "braceex",
    "",
    "angleright",
    "integral",
    "integraltp",
    "integralex",
    "integralbt",
    "parenrighttp",
    "parenrightex",
    "parenrightbt",
    "bracketrighttp",
    "bracketrightex",
    "bracketrightbt",
    "bracerighttp",
    "bracerightmid",
    "bracerightbt",
    ""
], Qi = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "a1",
    "a2",
    "a202",
    "a3",
    "a4",
    "a5",
    "a119",
    "a118",
    "a117",
    "a11",
    "a12",
    "a13",
    "a14",
    "a15",
    "a16",
    "a105",
    "a17",
    "a18",
    "a19",
    "a20",
    "a21",
    "a22",
    "a23",
    "a24",
    "a25",
    "a26",
    "a27",
    "a28",
    "a6",
    "a7",
    "a8",
    "a9",
    "a10",
    "a29",
    "a30",
    "a31",
    "a32",
    "a33",
    "a34",
    "a35",
    "a36",
    "a37",
    "a38",
    "a39",
    "a40",
    "a41",
    "a42",
    "a43",
    "a44",
    "a45",
    "a46",
    "a47",
    "a48",
    "a49",
    "a50",
    "a51",
    "a52",
    "a53",
    "a54",
    "a55",
    "a56",
    "a57",
    "a58",
    "a59",
    "a60",
    "a61",
    "a62",
    "a63",
    "a64",
    "a65",
    "a66",
    "a67",
    "a68",
    "a69",
    "a70",
    "a71",
    "a72",
    "a73",
    "a74",
    "a203",
    "a75",
    "a204",
    "a76",
    "a77",
    "a78",
    "a79",
    "a81",
    "a82",
    "a83",
    "a84",
    "a97",
    "a98",
    "a99",
    "a100",
    "",
    "a89",
    "a90",
    "a93",
    "a94",
    "a91",
    "a92",
    "a205",
    "a85",
    "a206",
    "a86",
    "a87",
    "a88",
    "a95",
    "a96",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "a101",
    "a102",
    "a103",
    "a104",
    "a106",
    "a107",
    "a108",
    "a112",
    "a111",
    "a110",
    "a109",
    "a120",
    "a121",
    "a122",
    "a123",
    "a124",
    "a125",
    "a126",
    "a127",
    "a128",
    "a129",
    "a130",
    "a131",
    "a132",
    "a133",
    "a134",
    "a135",
    "a136",
    "a137",
    "a138",
    "a139",
    "a140",
    "a141",
    "a142",
    "a143",
    "a144",
    "a145",
    "a146",
    "a147",
    "a148",
    "a149",
    "a150",
    "a151",
    "a152",
    "a153",
    "a154",
    "a155",
    "a156",
    "a157",
    "a158",
    "a159",
    "a160",
    "a161",
    "a163",
    "a164",
    "a196",
    "a165",
    "a192",
    "a166",
    "a167",
    "a168",
    "a169",
    "a170",
    "a171",
    "a172",
    "a173",
    "a162",
    "a174",
    "a175",
    "a176",
    "a177",
    "a178",
    "a179",
    "a193",
    "a180",
    "a199",
    "a181",
    "a200",
    "a182",
    "",
    "a201",
    "a183",
    "a184",
    "a197",
    "a185",
    "a194",
    "a198",
    "a186",
    "a195",
    "a187",
    "a188",
    "a189",
    "a190",
    "a191",
    ""
];
function getEncoding(e1) {
    switch(e1){
        case "WinAnsiEncoding":
            return li;
        case "StandardEncoding":
            return hi;
        case "MacRomanEncoding":
            return Ci;
        case "SymbolSetEncoding":
            return Bi;
        case "ZapfDingbatsEncoding":
            return Qi;
        case "ExpertEncoding":
            return Ii;
        case "MacExpertEncoding":
            return ci;
        default:
            return null;
    }
}
const Ei = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall",
    "001.000",
    "001.001",
    "001.002",
    "001.003",
    "Black",
    "Bold",
    "Book",
    "Light",
    "Medium",
    "Regular",
    "Roman",
    "Semibold"
], ui = 391, di = [
    null,
    {
        id: "hstem",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    null,
    {
        id: "vstem",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    {
        id: "vmoveto",
        min: 1,
        stackClearing: !0
    },
    {
        id: "rlineto",
        min: 2,
        resetStack: !0
    },
    {
        id: "hlineto",
        min: 1,
        resetStack: !0
    },
    {
        id: "vlineto",
        min: 1,
        resetStack: !0
    },
    {
        id: "rrcurveto",
        min: 6,
        resetStack: !0
    },
    null,
    {
        id: "callsubr",
        min: 1,
        undefStack: !0
    },
    {
        id: "return",
        min: 0,
        undefStack: !0
    },
    null,
    null,
    {
        id: "endchar",
        min: 0,
        stackClearing: !0
    },
    null,
    null,
    null,
    {
        id: "hstemhm",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    {
        id: "hintmask",
        min: 0,
        stackClearing: !0
    },
    {
        id: "cntrmask",
        min: 0,
        stackClearing: !0
    },
    {
        id: "rmoveto",
        min: 2,
        stackClearing: !0
    },
    {
        id: "hmoveto",
        min: 1,
        stackClearing: !0
    },
    {
        id: "vstemhm",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    {
        id: "rcurveline",
        min: 8,
        resetStack: !0
    },
    {
        id: "rlinecurve",
        min: 8,
        resetStack: !0
    },
    {
        id: "vvcurveto",
        min: 4,
        resetStack: !0
    },
    {
        id: "hhcurveto",
        min: 4,
        resetStack: !0
    },
    null,
    {
        id: "callgsubr",
        min: 1,
        undefStack: !0
    },
    {
        id: "vhcurveto",
        min: 4,
        resetStack: !0
    },
    {
        id: "hvcurveto",
        min: 4,
        resetStack: !0
    }
], fi = [
    null,
    null,
    null,
    {
        id: "and",
        min: 2,
        stackDelta: -1
    },
    {
        id: "or",
        min: 2,
        stackDelta: -1
    },
    {
        id: "not",
        min: 1,
        stackDelta: 0
    },
    null,
    null,
    null,
    {
        id: "abs",
        min: 1,
        stackDelta: 0
    },
    {
        id: "add",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] + e1[t - 1];
        }
    },
    {
        id: "sub",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] - e1[t - 1];
        }
    },
    {
        id: "div",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] / e1[t - 1];
        }
    },
    null,
    {
        id: "neg",
        min: 1,
        stackDelta: 0,
        stackFn (e1, t) {
            e1[t - 1] = -e1[t - 1];
        }
    },
    {
        id: "eq",
        min: 2,
        stackDelta: -1
    },
    null,
    null,
    {
        id: "drop",
        min: 1,
        stackDelta: -1
    },
    null,
    {
        id: "put",
        min: 2,
        stackDelta: -2
    },
    {
        id: "get",
        min: 1,
        stackDelta: 0
    },
    {
        id: "ifelse",
        min: 4,
        stackDelta: -3
    },
    {
        id: "random",
        min: 0,
        stackDelta: 1
    },
    {
        id: "mul",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] * e1[t - 1];
        }
    },
    null,
    {
        id: "sqrt",
        min: 1,
        stackDelta: 0
    },
    {
        id: "dup",
        min: 1,
        stackDelta: 1
    },
    {
        id: "exch",
        min: 2,
        stackDelta: 0
    },
    {
        id: "index",
        min: 2,
        stackDelta: 0
    },
    {
        id: "roll",
        min: 3,
        stackDelta: -2
    },
    null,
    null,
    null,
    {
        id: "hflex",
        min: 7,
        resetStack: !0
    },
    {
        id: "flex",
        min: 13,
        resetStack: !0
    },
    {
        id: "hflex1",
        min: 9,
        resetStack: !0
    },
    {
        id: "flex1",
        min: 11,
        resetStack: !0
    }
];
class CFFParser {
    constructor(e1, t, i){
        this.bytes = e1.getBytes();
        this.properties = t;
        this.seacAnalysisEnabled = !!i;
    }
    parse() {
        const e1 = this.properties, t = new CFF;
        this.cff = t;
        const i = this.parseHeader(), a = this.parseIndex(i.endPos), s = this.parseIndex(a.endPos), r = this.parseIndex(s.endPos), n = this.parseIndex(r.endPos), g = this.parseDict(s.obj.get(0)), o = this.createDict(CFFTopDict, g, t.strings);
        t.header = i.obj;
        t.names = this.parseNameIndex(a.obj);
        t.strings = this.parseStringIndex(r.obj);
        t.topDict = o;
        t.globalSubrIndex = n.obj;
        this.parsePrivateDict(t.topDict);
        t.isCIDFont = o.hasName("ROS");
        const c = o.getByName("CharStrings"), C = this.parseIndex(c).obj, h = o.getByName("FontMatrix");
        h && (e1.fontMatrix = h);
        const l = o.getByName("FontBBox");
        if (l) {
            e1.ascent = Math.max(l[3], l[1]);
            e1.descent = Math.min(l[1], l[3]);
            e1.ascentScaled = !0;
        }
        let Q, E;
        if (t.isCIDFont) {
            const e1 = this.parseIndex(o.getByName("FDArray")).obj;
            for(let i = 0, a = e1.count; i < a; ++i){
                const a = e1.get(i), s = this.createDict(CFFTopDict, this.parseDict(a), t.strings);
                this.parsePrivateDict(s);
                t.fdArray.push(s);
            }
            E = null;
            Q = this.parseCharsets(o.getByName("charset"), C.count, t.strings, !0);
            t.fdSelect = this.parseFDSelect(o.getByName("FDSelect"), C.count);
        } else {
            Q = this.parseCharsets(o.getByName("charset"), C.count, t.strings, !1);
            E = this.parseEncoding(o.getByName("Encoding"), e1, t.strings, Q.charset);
        }
        t.charset = Q;
        t.encoding = E;
        const u = this.parseCharStrings({
            charStrings: C,
            localSubrIndex: o.privateDict.subrsIndex,
            globalSubrIndex: n.obj,
            fdSelect: t.fdSelect,
            fdArray: t.fdArray,
            privateDict: o.privateDict
        });
        t.charStrings = u.charStrings;
        t.seacs = u.seacs;
        t.widths = u.widths;
        return t;
    }
    parseHeader() {
        let e1 = this.bytes;
        const t = e1.length;
        let i = 0;
        for(; i < t && 1 !== e1[i];)++i;
        if (i >= t) throw new FormatError("Invalid CFF header");
        if (0 !== i) {
            info("cff data is shifted");
            e1 = e1.subarray(i);
            this.bytes = e1;
        }
        const a = e1[0], s = e1[1], r = e1[2], n = e1[3];
        return {
            obj: new CFFHeader(a, s, r, n),
            endPos: r
        };
    }
    parseDict(e1) {
        let t = 0;
        function parseOperand() {
            let i = e1[t++];
            if (30 === i) return function parseFloatOperand() {
                let i = "";
                const a = 15, s = [
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9",
                    ".",
                    "E",
                    "E-",
                    null,
                    "-"
                ], r = e1.length;
                for(; t < r;){
                    const r = e1[t++], n = r >> 4, g = 15 & r;
                    if (n === a) break;
                    i += s[n];
                    if (g === a) break;
                    i += s[g];
                }
                return parseFloat(i);
            }();
            if (28 === i) {
                i = e1[t++];
                i = (i << 24 | e1[t++] << 16) >> 16;
                return i;
            }
            if (29 === i) {
                i = e1[t++];
                i = i << 8 | e1[t++];
                i = i << 8 | e1[t++];
                i = i << 8 | e1[t++];
                return i;
            }
            if (i >= 32 && i <= 246) return i - 139;
            if (i >= 247 && i <= 250) return 256 * (i - 247) + e1[t++] + 108;
            if (i >= 251 && i <= 254) return -256 * (i - 251) - e1[t++] - 108;
            warn('CFFParser_parseDict: "' + i + '" is a reserved command.');
            return NaN;
        }
        let i = [];
        const a = [];
        t = 0;
        const s = e1.length;
        for(; t < s;){
            let s = e1[t];
            if (s <= 21) {
                12 === s && (s = s << 8 | e1[++t]);
                a.push([
                    s,
                    i
                ]);
                i = [];
                ++t;
            } else i.push(parseOperand());
        }
        return a;
    }
    parseIndex(e1) {
        const t = new CFFIndex, i = this.bytes, a = i[e1++] << 8 | i[e1++], s = [];
        let r, n, g = e1;
        if (0 !== a) {
            const t = i[e1++], o = e1 + (a + 1) * t - 1;
            for(r = 0, n = a + 1; r < n; ++r){
                let a = 0;
                for(let s = 0; s < t; ++s){
                    a <<= 8;
                    a += i[e1++];
                }
                s.push(o + a);
            }
            g = s[a];
        }
        for(r = 0, n = s.length - 1; r < n; ++r){
            const e1 = s[r], a = s[r + 1];
            t.add(i.subarray(e1, a));
        }
        return {
            obj: t,
            endPos: g
        };
    }
    parseNameIndex(e1) {
        const t = [];
        for(let i = 0, a = e1.count; i < a; ++i){
            const a = e1.get(i);
            t.push(bytesToString(a));
        }
        return t;
    }
    parseStringIndex(e1) {
        const t = new CFFStrings;
        for(let i = 0, a = e1.count; i < a; ++i){
            const a = e1.get(i);
            t.add(bytesToString(a));
        }
        return t;
    }
    createDict(e1, t, i) {
        const a = new e1(i);
        for (const [e1, i] of t)a.setByKey(e1, i);
        return a;
    }
    parseCharString(e1, t, i, a) {
        if (!t || e1.callDepth > 10) return !1;
        let s = e1.stackSize;
        const r = e1.stack;
        let n = t.length;
        for(let g = 0; g < n;){
            const o = t[g++];
            let c = null;
            if (12 === o) {
                const e1 = t[g++];
                if (0 === e1) {
                    t[g - 2] = 139;
                    t[g - 1] = 22;
                    s = 0;
                } else c = fi[e1];
            } else if (28 === o) {
                r[s] = (t[g] << 24 | t[g + 1] << 16) >> 16;
                g += 2;
                s++;
            } else if (14 === o) {
                if (s >= 4) {
                    s -= 4;
                    if (this.seacAnalysisEnabled) {
                        e1.seac = r.slice(s, s + 4);
                        return !1;
                    }
                }
                c = di[o];
            } else if (o >= 32 && o <= 246) {
                r[s] = o - 139;
                s++;
            } else if (o >= 247 && o <= 254) {
                r[s] = o < 251 ? (o - 247 << 8) + t[g] + 108 : -(o - 251 << 8) - t[g] - 108;
                g++;
                s++;
            } else if (255 === o) {
                r[s] = (t[g] << 24 | t[g + 1] << 16 | t[g + 2] << 8 | t[g + 3]) / 65536;
                g += 4;
                s++;
            } else if (19 === o || 20 === o) {
                e1.hints += s >> 1;
                if (0 === e1.hints) {
                    t.copyWithin(g - 1, g, -1);
                    g -= 1;
                    n -= 1;
                    continue;
                }
                g += e1.hints + 7 >> 3;
                s %= 2;
                c = di[o];
            } else {
                if (10 === o || 29 === o) {
                    const t = 10 === o ? i : a;
                    if (!t) {
                        c = di[o];
                        warn("Missing subrsIndex for " + c.id);
                        return !1;
                    }
                    let n = 32768;
                    t.count < 1240 ? n = 107 : t.count < 33900 && (n = 1131);
                    const g = r[--s] + n;
                    if (g < 0 || g >= t.count || isNaN(g)) {
                        c = di[o];
                        warn("Out of bounds subrIndex for " + c.id);
                        return !1;
                    }
                    e1.stackSize = s;
                    e1.callDepth++;
                    if (!this.parseCharString(e1, t.get(g), i, a)) return !1;
                    e1.callDepth--;
                    s = e1.stackSize;
                    continue;
                }
                if (11 === o) {
                    e1.stackSize = s;
                    return !0;
                }
                if (0 === o && g === t.length) {
                    t[g - 1] = 14;
                    c = di[14];
                } else {
                    if (9 === o) {
                        t.copyWithin(g - 1, g, -1);
                        g -= 1;
                        n -= 1;
                        continue;
                    }
                    c = di[o];
                }
            }
            if (c) {
                if (c.stem) {
                    e1.hints += s >> 1;
                    if (3 === o || 23 === o) e1.hasVStems = !0;
                    else if (e1.hasVStems && (1 === o || 18 === o)) {
                        warn("CFF stem hints are in wrong order");
                        t[g - 1] = 1 === o ? 3 : 23;
                    }
                }
                if ("min" in c && !e1.undefStack && s < c.min) {
                    warn("Not enough parameters for " + c.id + "; actual: " + s + ", expected: " + c.min);
                    if (0 === s) {
                        t[g - 1] = 14;
                        return !0;
                    }
                    return !1;
                }
                if (e1.firstStackClearing && c.stackClearing) {
                    e1.firstStackClearing = !1;
                    s -= c.min;
                    s >= 2 && c.stem ? s %= 2 : s > 1 && warn("Found too many parameters for stack-clearing command");
                    s > 0 && (e1.width = r[s - 1]);
                }
                if ("stackDelta" in c) {
                    "stackFn" in c && c.stackFn(r, s);
                    s += c.stackDelta;
                } else if (c.stackClearing) s = 0;
                else if (c.resetStack) {
                    s = 0;
                    e1.undefStack = !1;
                } else if (c.undefStack) {
                    s = 0;
                    e1.undefStack = !0;
                    e1.firstStackClearing = !1;
                }
            }
        }
        n < t.length && t.fill(14, n);
        e1.stackSize = s;
        return !0;
    }
    parseCharStrings({ charStrings: e1, localSubrIndex: t, globalSubrIndex: i, fdSelect: a, fdArray: s, privateDict: r }) {
        const n = [], g = [], o = e1.count;
        for(let c = 0; c < o; c++){
            const o = e1.get(c), C = {
                callDepth: 0,
                stackSize: 0,
                stack: [],
                undefStack: !0,
                hints: 0,
                firstStackClearing: !0,
                seac: null,
                width: null,
                hasVStems: !1
            };
            let h = !0, l = null, Q = r;
            if (a && s.length) {
                const e1 = a.getFDIndex(c);
                if (-1 === e1) {
                    warn("Glyph index is not in fd select.");
                    h = !1;
                }
                if (e1 >= s.length) {
                    warn("Invalid fd index for glyph index.");
                    h = !1;
                }
                if (h) {
                    Q = s[e1].privateDict;
                    l = Q.subrsIndex;
                }
            } else t && (l = t);
            h && (h = this.parseCharString(C, o, l, i));
            if (null !== C.width) {
                const e1 = Q.getByName("nominalWidthX");
                g[c] = e1 + C.width;
            } else {
                const e1 = Q.getByName("defaultWidthX");
                g[c] = e1;
            }
            null !== C.seac && (n[c] = C.seac);
            h || e1.set(c, new Uint8Array([
                14
            ]));
        }
        return {
            charStrings: e1,
            seacs: n,
            widths: g
        };
    }
    emptyPrivateDictionary(e1) {
        const t = this.createDict(CFFPrivateDict, [], e1.strings);
        e1.setByKey(18, [
            0,
            0
        ]);
        e1.privateDict = t;
    }
    parsePrivateDict(e1) {
        if (!e1.hasName("Private")) {
            this.emptyPrivateDictionary(e1);
            return;
        }
        const t = e1.getByName("Private");
        if (!Array.isArray(t) || 2 !== t.length) {
            e1.removeByName("Private");
            return;
        }
        const i = t[0], a = t[1];
        if (0 === i || a >= this.bytes.length) {
            this.emptyPrivateDictionary(e1);
            return;
        }
        const s = a + i, r = this.bytes.subarray(a, s), n = this.parseDict(r), g = this.createDict(CFFPrivateDict, n, e1.strings);
        e1.privateDict = g;
        0 === g.getByName("ExpansionFactor") && g.setByName("ExpansionFactor", .06);
        if (!g.getByName("Subrs")) return;
        const o = g.getByName("Subrs"), c = a + o;
        if (0 === o || c >= this.bytes.length) {
            this.emptyPrivateDictionary(e1);
            return;
        }
        const C = this.parseIndex(c);
        g.subrsIndex = C.obj;
    }
    parseCharsets(e1, t, i, a) {
        if (0 === e1) return new CFFCharset(!0, yi.ISO_ADOBE, ni);
        if (1 === e1) return new CFFCharset(!0, yi.EXPERT, gi);
        if (2 === e1) return new CFFCharset(!0, yi.EXPERT_SUBSET, oi);
        const s = this.bytes, r = e1, n = s[e1++], g = [
            a ? 0 : ".notdef"
        ];
        let o, c, C;
        t -= 1;
        switch(n){
            case 0:
                for(C = 0; C < t; C++){
                    o = s[e1++] << 8 | s[e1++];
                    g.push(a ? o : i.get(o));
                }
                break;
            case 1:
                for(; g.length <= t;){
                    o = s[e1++] << 8 | s[e1++];
                    c = s[e1++];
                    for(C = 0; C <= c; C++)g.push(a ? o++ : i.get(o++));
                }
                break;
            case 2:
                for(; g.length <= t;){
                    o = s[e1++] << 8 | s[e1++];
                    c = s[e1++] << 8 | s[e1++];
                    for(C = 0; C <= c; C++)g.push(a ? o++ : i.get(o++));
                }
                break;
            default:
                throw new FormatError("Unknown charset format");
        }
        const h = e1, l = s.subarray(r, h);
        return new CFFCharset(!1, n, g, l);
    }
    parseEncoding(e1, t, i, a) {
        const s = Object.create(null), r = this.bytes;
        let n, g, o, c = !1, C = null;
        if (0 === e1 || 1 === e1) {
            c = !0;
            n = e1;
            const t = e1 ? Ii : hi;
            for(g = 0, o = a.length; g < o; g++){
                const e1 = t.indexOf(a[g]);
                -1 !== e1 && (s[e1] = g);
            }
        } else {
            const t = e1;
            n = r[e1++];
            switch(127 & n){
                case 0:
                    const t1 = r[e1++];
                    for(g = 1; g <= t1; g++)s[r[e1++]] = g;
                    break;
                case 1:
                    const i1 = r[e1++];
                    let a1 = 1;
                    for(g = 0; g < i1; g++){
                        const t = r[e1++], i = r[e1++];
                        for(let e1 = t; e1 <= t + i; e1++)s[e1] = a1++;
                    }
                    break;
                default:
                    throw new FormatError(`Unknown encoding format: ${n} in CFF`);
            }
            const o = e1;
            if (128 & n) {
                r[t] &= 127;
                !function readSupplement() {
                    const t = r[e1++];
                    for(g = 0; g < t; g++){
                        const t = r[e1++], n = (r[e1++] << 8) + (255 & r[e1++]);
                        s[t] = a.indexOf(i.get(n));
                    }
                }();
            }
            C = r.subarray(t, o);
        }
        n &= 127;
        return new CFFEncoding(c, n, s, C);
    }
    parseFDSelect(e1, t) {
        const i = this.bytes, a = i[e1++], s = [];
        let r;
        switch(a){
            case 0:
                for(r = 0; r < t; ++r){
                    const t = i[e1++];
                    s.push(t);
                }
                break;
            case 3:
                const n = i[e1++] << 8 | i[e1++];
                for(r = 0; r < n; ++r){
                    let t = i[e1++] << 8 | i[e1++];
                    if (0 === r && 0 !== t) {
                        warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
                        t = 0;
                    }
                    const a = i[e1++], n = i[e1] << 8 | i[e1 + 1];
                    for(let e1 = t; e1 < n; ++e1)s.push(a);
                }
                e1 += 2;
                break;
            default:
                throw new FormatError(`parseFDSelect: Unknown format "${a}".`);
        }
        if (s.length !== t) throw new FormatError("parseFDSelect: Invalid font data.");
        return new CFFFDSelect(a, s);
    }
}
class CFF {
    constructor(){
        this.header = null;
        this.names = [];
        this.topDict = null;
        this.strings = new CFFStrings;
        this.globalSubrIndex = null;
        this.encoding = null;
        this.charset = null;
        this.charStrings = null;
        this.fdArray = [];
        this.fdSelect = null;
        this.isCIDFont = !1;
    }
    duplicateFirstGlyph() {
        if (this.charStrings.count >= 65535) {
            warn("Not enough space in charstrings to duplicate first glyph.");
            return;
        }
        const e1 = this.charStrings.get(0);
        this.charStrings.add(e1);
        this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
    }
    hasGlyphId(e1) {
        if (e1 < 0 || e1 >= this.charStrings.count) return !1;
        return this.charStrings.get(e1).length > 0;
    }
}
class CFFHeader {
    constructor(e1, t, i, a){
        this.major = e1;
        this.minor = t;
        this.hdrSize = i;
        this.offSize = a;
    }
}
class CFFStrings {
    constructor(){
        this.strings = [];
    }
    get(e1) {
        return e1 >= 0 && e1 <= 390 ? Ei[e1] : e1 - ui <= this.strings.length ? this.strings[e1 - ui] : Ei[0];
    }
    getSID(e1) {
        let t = Ei.indexOf(e1);
        if (-1 !== t) return t;
        t = this.strings.indexOf(e1);
        return -1 !== t ? t + ui : -1;
    }
    add(e1) {
        this.strings.push(e1);
    }
    get count() {
        return this.strings.length;
    }
}
class CFFIndex {
    constructor(){
        this.objects = [];
        this.length = 0;
    }
    add(e1) {
        this.length += e1.length;
        this.objects.push(e1);
    }
    set(e1, t) {
        this.length += t.length - this.objects[e1].length;
        this.objects[e1] = t;
    }
    get(e1) {
        return this.objects[e1];
    }
    get count() {
        return this.objects.length;
    }
}
class CFFDict {
    constructor(e1, t){
        this.keyToNameMap = e1.keyToNameMap;
        this.nameToKeyMap = e1.nameToKeyMap;
        this.defaults = e1.defaults;
        this.types = e1.types;
        this.opcodes = e1.opcodes;
        this.order = e1.order;
        this.strings = t;
        this.values = Object.create(null);
    }
    setByKey(e1, t) {
        if (!(e1 in this.keyToNameMap)) return !1;
        if (0 === t.length) return !0;
        for (const i of t)if (isNaN(i)) {
            warn(`Invalid CFFDict value: "${t}" for key "${e1}".`);
            return !0;
        }
        const i = this.types[e1];
        "num" !== i && "sid" !== i && "offset" !== i || (t = t[0]);
        this.values[e1] = t;
        return !0;
    }
    setByName(e1, t) {
        if (!(e1 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name "${e1}"`);
        this.values[this.nameToKeyMap[e1]] = t;
    }
    hasName(e1) {
        return this.nameToKeyMap[e1] in this.values;
    }
    getByName(e1) {
        if (!(e1 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name ${e1}"`);
        const t = this.nameToKeyMap[e1];
        return t in this.values ? this.values[t] : this.defaults[t];
    }
    removeByName(e1) {
        delete this.values[this.nameToKeyMap[e1]];
    }
    static createTables(e1) {
        const t = {
            keyToNameMap: {},
            nameToKeyMap: {},
            defaults: {},
            types: {},
            opcodes: {},
            order: []
        };
        for (const i of e1){
            const e1 = Array.isArray(i[0]) ? (i[0][0] << 8) + i[0][1] : i[0];
            t.keyToNameMap[e1] = i[1];
            t.nameToKeyMap[i[1]] = e1;
            t.types[e1] = i[2];
            t.defaults[e1] = i[3];
            t.opcodes[e1] = Array.isArray(i[0]) ? i[0] : [
                i[0]
            ];
            t.order.push(e1);
        }
        return t;
    }
}
const pi = [
    [
        [
            12,
            30
        ],
        "ROS",
        [
            "sid",
            "sid",
            "num"
        ],
        null
    ],
    [
        [
            12,
            20
        ],
        "SyntheticBase",
        "num",
        null
    ],
    [
        0,
        "version",
        "sid",
        null
    ],
    [
        1,
        "Notice",
        "sid",
        null
    ],
    [
        [
            12,
            0
        ],
        "Copyright",
        "sid",
        null
    ],
    [
        2,
        "FullName",
        "sid",
        null
    ],
    [
        3,
        "FamilyName",
        "sid",
        null
    ],
    [
        4,
        "Weight",
        "sid",
        null
    ],
    [
        [
            12,
            1
        ],
        "isFixedPitch",
        "num",
        0
    ],
    [
        [
            12,
            2
        ],
        "ItalicAngle",
        "num",
        0
    ],
    [
        [
            12,
            3
        ],
        "UnderlinePosition",
        "num",
        -100
    ],
    [
        [
            12,
            4
        ],
        "UnderlineThickness",
        "num",
        50
    ],
    [
        [
            12,
            5
        ],
        "PaintType",
        "num",
        0
    ],
    [
        [
            12,
            6
        ],
        "CharstringType",
        "num",
        2
    ],
    [
        [
            12,
            7
        ],
        "FontMatrix",
        [
            "num",
            "num",
            "num",
            "num",
            "num",
            "num"
        ],
        [
            .001,
            0,
            0,
            .001,
            0,
            0
        ]
    ],
    [
        13,
        "UniqueID",
        "num",
        null
    ],
    [
        5,
        "FontBBox",
        [
            "num",
            "num",
            "num",
            "num"
        ],
        [
            0,
            0,
            0,
            0
        ]
    ],
    [
        [
            12,
            8
        ],
        "StrokeWidth",
        "num",
        0
    ],
    [
        14,
        "XUID",
        "array",
        null
    ],
    [
        15,
        "charset",
        "offset",
        0
    ],
    [
        16,
        "Encoding",
        "offset",
        0
    ],
    [
        17,
        "CharStrings",
        "offset",
        0
    ],
    [
        18,
        "Private",
        [
            "offset",
            "offset"
        ],
        null
    ],
    [
        [
            12,
            21
        ],
        "PostScript",
        "sid",
        null
    ],
    [
        [
            12,
            22
        ],
        "BaseFontName",
        "sid",
        null
    ],
    [
        [
            12,
            23
        ],
        "BaseFontBlend",
        "delta",
        null
    ],
    [
        [
            12,
            31
        ],
        "CIDFontVersion",
        "num",
        0
    ],
    [
        [
            12,
            32
        ],
        "CIDFontRevision",
        "num",
        0
    ],
    [
        [
            12,
            33
        ],
        "CIDFontType",
        "num",
        0
    ],
    [
        [
            12,
            34
        ],
        "CIDCount",
        "num",
        8720
    ],
    [
        [
            12,
            35
        ],
        "UIDBase",
        "num",
        null
    ],
    [
        [
            12,
            37
        ],
        "FDSelect",
        "offset",
        null
    ],
    [
        [
            12,
            36
        ],
        "FDArray",
        "offset",
        null
    ],
    [
        [
            12,
            38
        ],
        "FontName",
        "sid",
        null
    ]
];
class CFFTopDict extends CFFDict {
    static get tables() {
        return shadow(this, "tables", this.createTables(pi));
    }
    constructor(e1){
        super(CFFTopDict.tables, e1);
        this.privateDict = null;
    }
}
const mi = [
    [
        6,
        "BlueValues",
        "delta",
        null
    ],
    [
        7,
        "OtherBlues",
        "delta",
        null
    ],
    [
        8,
        "FamilyBlues",
        "delta",
        null
    ],
    [
        9,
        "FamilyOtherBlues",
        "delta",
        null
    ],
    [
        [
            12,
            9
        ],
        "BlueScale",
        "num",
        .039625
    ],
    [
        [
            12,
            10
        ],
        "BlueShift",
        "num",
        7
    ],
    [
        [
            12,
            11
        ],
        "BlueFuzz",
        "num",
        1
    ],
    [
        10,
        "StdHW",
        "num",
        null
    ],
    [
        11,
        "StdVW",
        "num",
        null
    ],
    [
        [
            12,
            12
        ],
        "StemSnapH",
        "delta",
        null
    ],
    [
        [
            12,
            13
        ],
        "StemSnapV",
        "delta",
        null
    ],
    [
        [
            12,
            14
        ],
        "ForceBold",
        "num",
        0
    ],
    [
        [
            12,
            17
        ],
        "LanguageGroup",
        "num",
        0
    ],
    [
        [
            12,
            18
        ],
        "ExpansionFactor",
        "num",
        .06
    ],
    [
        [
            12,
            19
        ],
        "initialRandomSeed",
        "num",
        0
    ],
    [
        20,
        "defaultWidthX",
        "num",
        0
    ],
    [
        21,
        "nominalWidthX",
        "num",
        0
    ],
    [
        19,
        "Subrs",
        "offset",
        null
    ]
];
class CFFPrivateDict extends CFFDict {
    static get tables() {
        return shadow(this, "tables", this.createTables(mi));
    }
    constructor(e1){
        super(CFFPrivateDict.tables, e1);
        this.subrsIndex = null;
    }
}
const yi = {
    ISO_ADOBE: 0,
    EXPERT: 1,
    EXPERT_SUBSET: 2
};
class CFFCharset {
    constructor(e1, t, i, a){
        this.predefined = e1;
        this.format = t;
        this.charset = i;
        this.raw = a;
    }
}
class CFFEncoding {
    constructor(e1, t, i, a){
        this.predefined = e1;
        this.format = t;
        this.encoding = i;
        this.raw = a;
    }
}
class CFFFDSelect {
    constructor(e1, t){
        this.format = e1;
        this.fdSelect = t;
    }
    getFDIndex(e1) {
        return e1 < 0 || e1 >= this.fdSelect.length ? -1 : this.fdSelect[e1];
    }
}
class CFFOffsetTracker {
    constructor(){
        this.offsets = Object.create(null);
    }
    isTracking(e1) {
        return e1 in this.offsets;
    }
    track(e1, t) {
        if (e1 in this.offsets) throw new FormatError(`Already tracking location of ${e1}`);
        this.offsets[e1] = t;
    }
    offset(e1) {
        for(const t in this.offsets)this.offsets[t] += e1;
    }
    setEntryLocation(e1, t, i) {
        if (!(e1 in this.offsets)) throw new FormatError(`Not tracking location of ${e1}`);
        const a = i.data, s = this.offsets[e1];
        for(let e1 = 0, i = t.length; e1 < i; ++e1){
            const i = 5 * e1 + s, r = i + 1, n = i + 2, g = i + 3, o = i + 4;
            if (29 !== a[i] || 0 !== a[r] || 0 !== a[n] || 0 !== a[g] || 0 !== a[o]) throw new FormatError("writing to an offset that is not empty");
            const c = t[e1];
            a[i] = 29;
            a[r] = c >> 24 & 255;
            a[n] = c >> 16 & 255;
            a[g] = c >> 8 & 255;
            a[o] = 255 & c;
        }
    }
}
class CFFCompiler {
    constructor(e1){
        this.cff = e1;
    }
    compile() {
        const e1 = this.cff, t = {
            data: [],
            length: 0,
            add (e1) {
                try {
                    this.data.push(...e1);
                } catch  {
                    this.data = this.data.concat(e1);
                }
                this.length = this.data.length;
            }
        }, i = this.compileHeader(e1.header);
        t.add(i);
        const a = this.compileNameIndex(e1.names);
        t.add(a);
        if (e1.isCIDFont && e1.topDict.hasName("FontMatrix")) {
            const t = e1.topDict.getByName("FontMatrix");
            e1.topDict.removeByName("FontMatrix");
            for (const i of e1.fdArray){
                let e1 = t.slice(0);
                i.hasName("FontMatrix") && (e1 = Util.transform(e1, i.getByName("FontMatrix")));
                i.setByName("FontMatrix", e1);
            }
        }
        const s = e1.topDict.getByName("XUID");
        s?.length > 16 && e1.topDict.removeByName("XUID");
        e1.topDict.setByName("charset", 0);
        let r = this.compileTopDicts([
            e1.topDict
        ], t.length, e1.isCIDFont);
        t.add(r.output);
        const n = r.trackers[0], g = this.compileStringIndex(e1.strings.strings);
        t.add(g);
        const o = this.compileIndex(e1.globalSubrIndex);
        t.add(o);
        if (e1.encoding && e1.topDict.hasName("Encoding")) if (e1.encoding.predefined) n.setEntryLocation("Encoding", [
            e1.encoding.format
        ], t);
        else {
            const i = this.compileEncoding(e1.encoding);
            n.setEntryLocation("Encoding", [
                t.length
            ], t);
            t.add(i);
        }
        const c = this.compileCharset(e1.charset, e1.charStrings.count, e1.strings, e1.isCIDFont);
        n.setEntryLocation("charset", [
            t.length
        ], t);
        t.add(c);
        const C = this.compileCharStrings(e1.charStrings);
        n.setEntryLocation("CharStrings", [
            t.length
        ], t);
        t.add(C);
        if (e1.isCIDFont) {
            n.setEntryLocation("FDSelect", [
                t.length
            ], t);
            const i = this.compileFDSelect(e1.fdSelect);
            t.add(i);
            r = this.compileTopDicts(e1.fdArray, t.length, !0);
            n.setEntryLocation("FDArray", [
                t.length
            ], t);
            t.add(r.output);
            const a = r.trackers;
            this.compilePrivateDicts(e1.fdArray, a, t);
        }
        this.compilePrivateDicts([
            e1.topDict
        ], [
            n
        ], t);
        t.add([
            0
        ]);
        return t.data;
    }
    encodeNumber(e1) {
        return Number.isInteger(e1) ? this.encodeInteger(e1) : this.encodeFloat(e1);
    }
    static get EncodeFloatRegExp() {
        return shadow(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
    }
    encodeFloat(e1) {
        let t = e1.toString();
        const i = CFFCompiler.EncodeFloatRegExp.exec(t);
        if (i) {
            const a = parseFloat("1e" + ((i[2] ? +i[2] : 0) + i[1].length));
            t = (Math.round(e1 * a) / a).toString();
        }
        let a, s, r = "";
        for(a = 0, s = t.length; a < s; ++a){
            const e1 = t[a];
            r += "e" === e1 ? "-" === t[++a] ? "c" : "b" : "." === e1 ? "a" : "-" === e1 ? "e" : e1;
        }
        r += 1 & r.length ? "f" : "ff";
        const n = [
            30
        ];
        for(a = 0, s = r.length; a < s; a += 2)n.push(parseInt(r.substring(a, a + 2), 16));
        return n;
    }
    encodeInteger(e1) {
        let t;
        t = e1 >= -107 && e1 <= 107 ? [
            e1 + 139
        ] : e1 >= 108 && e1 <= 1131 ? [
            247 + ((e1 -= 108) >> 8),
            255 & e1
        ] : e1 >= -1131 && e1 <= -108 ? [
            251 + ((e1 = -e1 - 108) >> 8),
            255 & e1
        ] : e1 >= -32768 && e1 <= 32767 ? [
            28,
            e1 >> 8 & 255,
            255 & e1
        ] : [
            29,
            e1 >> 24 & 255,
            e1 >> 16 & 255,
            e1 >> 8 & 255,
            255 & e1
        ];
        return t;
    }
    compileHeader(e1) {
        return [
            e1.major,
            e1.minor,
            4,
            e1.offSize
        ];
    }
    compileNameIndex(e1) {
        const t = new CFFIndex;
        for (const i of e1){
            const e1 = Math.min(i.length, 127);
            let a = new Array(e1);
            for(let t = 0; t < e1; t++){
                let e1 = i[t];
                (e1 < "!" || e1 > "~" || "[" === e1 || "]" === e1 || "(" === e1 || ")" === e1 || "{" === e1 || "}" === e1 || "<" === e1 || ">" === e1 || "/" === e1 || "%" === e1) && (e1 = "_");
                a[t] = e1;
            }
            a = a.join("");
            "" === a && (a = "Bad_Font_Name");
            t.add(stringToBytes(a));
        }
        return this.compileIndex(t);
    }
    compileTopDicts(e1, t, i) {
        const a = [];
        let s = new CFFIndex;
        for (const r of e1){
            if (i) {
                r.removeByName("CIDFontVersion");
                r.removeByName("CIDFontRevision");
                r.removeByName("CIDFontType");
                r.removeByName("CIDCount");
                r.removeByName("UIDBase");
            }
            const e1 = new CFFOffsetTracker, n = this.compileDict(r, e1);
            a.push(e1);
            s.add(n);
            e1.offset(t);
        }
        s = this.compileIndex(s, a);
        return {
            trackers: a,
            output: s
        };
    }
    compilePrivateDicts(e1, t, i) {
        for(let a = 0, s = e1.length; a < s; ++a){
            const s = e1[a], r = s.privateDict;
            if (!r || !s.hasName("Private")) throw new FormatError("There must be a private dictionary.");
            const n = new CFFOffsetTracker, g = this.compileDict(r, n);
            let o = i.length;
            n.offset(o);
            g.length || (o = 0);
            t[a].setEntryLocation("Private", [
                g.length,
                o
            ], i);
            i.add(g);
            if (r.subrsIndex && r.hasName("Subrs")) {
                const e1 = this.compileIndex(r.subrsIndex);
                n.setEntryLocation("Subrs", [
                    g.length
                ], i);
                i.add(e1);
            }
        }
    }
    compileDict(e1, t) {
        const i = [];
        for (const a of e1.order){
            if (!(a in e1.values)) continue;
            let s = e1.values[a], r = e1.types[a];
            Array.isArray(r) || (r = [
                r
            ]);
            Array.isArray(s) || (s = [
                s
            ]);
            if (0 !== s.length) {
                for(let n = 0, g = r.length; n < g; ++n){
                    const g = r[n], o = s[n];
                    switch(g){
                        case "num":
                        case "sid":
                            i.push(...this.encodeNumber(o));
                            break;
                        case "offset":
                            const r1 = e1.keyToNameMap[a];
                            t.isTracking(r1) || t.track(r1, i.length);
                            i.push(29, 0, 0, 0, 0);
                            break;
                        case "array":
                        case "delta":
                            i.push(...this.encodeNumber(o));
                            for(let e1 = 1, t = s.length; e1 < t; ++e1)i.push(...this.encodeNumber(s[e1]));
                            break;
                        default:
                            throw new FormatError(`Unknown data type of ${g}`);
                    }
                }
                i.push(...e1.opcodes[a]);
            }
        }
        return i;
    }
    compileStringIndex(e1) {
        const t = new CFFIndex;
        for (const i of e1)t.add(stringToBytes(i));
        return this.compileIndex(t);
    }
    compileCharStrings(e1) {
        const t = new CFFIndex;
        for(let i = 0; i < e1.count; i++){
            const a = e1.get(i);
            0 !== a.length ? t.add(a) : t.add(new Uint8Array([
                139,
                14
            ]));
        }
        return this.compileIndex(t);
    }
    compileCharset(e1, t, i, a) {
        let s;
        const r = t - 1;
        if (a) s = new Uint8Array([
            2,
            0,
            0,
            r >> 8 & 255,
            255 & r
        ]);
        else {
            s = new Uint8Array(1 + 2 * r);
            s[0] = 0;
            let t = 0;
            const a = e1.charset.length;
            let n = !1;
            for(let r = 1; r < s.length; r += 2){
                let g = 0;
                if (t < a) {
                    const a = e1.charset[t++];
                    g = i.getSID(a);
                    if (-1 === g) {
                        g = 0;
                        if (!n) {
                            n = !0;
                            warn(`Couldn't find ${a} in CFF strings`);
                        }
                    }
                }
                s[r] = g >> 8 & 255;
                s[r + 1] = 255 & g;
            }
        }
        return this.compileTypedArray(s);
    }
    compileEncoding(e1) {
        return this.compileTypedArray(e1.raw);
    }
    compileFDSelect(e1) {
        const t = e1.format;
        let i, a;
        switch(t){
            case 0:
                i = new Uint8Array(1 + e1.fdSelect.length);
                i[0] = t;
                for(a = 0; a < e1.fdSelect.length; a++)i[a + 1] = e1.fdSelect[a];
                break;
            case 3:
                const s = 0;
                let r = e1.fdSelect[0];
                const n = [
                    t,
                    0,
                    0,
                    s >> 8 & 255,
                    255 & s,
                    r
                ];
                for(a = 1; a < e1.fdSelect.length; a++){
                    const t = e1.fdSelect[a];
                    if (t !== r) {
                        n.push(a >> 8 & 255, 255 & a, t);
                        r = t;
                    }
                }
                const g = (n.length - 3) / 3;
                n[1] = g >> 8 & 255;
                n[2] = 255 & g;
                n.push(a >> 8 & 255, 255 & a);
                i = new Uint8Array(n);
        }
        return this.compileTypedArray(i);
    }
    compileTypedArray(e1) {
        return Array.from(e1);
    }
    compileIndex(e1, t = []) {
        const i = e1.objects, a = i.length;
        if (0 === a) return [
            0,
            0
        ];
        const s = [
            a >> 8 & 255,
            255 & a
        ];
        let r, n, g = 1;
        for(r = 0; r < a; ++r)g += i[r].length;
        n = g < 256 ? 1 : g < 65536 ? 2 : g < 16777216 ? 3 : 4;
        s.push(n);
        let o = 1;
        for(r = 0; r < a + 1; r++){
            1 === n ? s.push(255 & o) : 2 === n ? s.push(o >> 8 & 255, 255 & o) : 3 === n ? s.push(o >> 16 & 255, o >> 8 & 255, 255 & o) : s.push(o >>> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o);
            i[r] && (o += i[r].length);
        }
        for(r = 0; r < a; r++){
            t[r] && t[r].offset(s.length);
            s.push(...i[r]);
        }
        return s;
    }
}
const wi = getLookupTableFactory(function(e1) {
    e1.A = 65;
    e1.AE = 198;
    e1.AEacute = 508;
    e1.AEmacron = 482;
    e1.AEsmall = 63462;
    e1.Aacute = 193;
    e1.Aacutesmall = 63457;
    e1.Abreve = 258;
    e1.Abreveacute = 7854;
    e1.Abrevecyrillic = 1232;
    e1.Abrevedotbelow = 7862;
    e1.Abrevegrave = 7856;
    e1.Abrevehookabove = 7858;
    e1.Abrevetilde = 7860;
    e1.Acaron = 461;
    e1.Acircle = 9398;
    e1.Acircumflex = 194;
    e1.Acircumflexacute = 7844;
    e1.Acircumflexdotbelow = 7852;
    e1.Acircumflexgrave = 7846;
    e1.Acircumflexhookabove = 7848;
    e1.Acircumflexsmall = 63458;
    e1.Acircumflextilde = 7850;
    e1.Acute = 63177;
    e1.Acutesmall = 63412;
    e1.Acyrillic = 1040;
    e1.Adblgrave = 512;
    e1.Adieresis = 196;
    e1.Adieresiscyrillic = 1234;
    e1.Adieresismacron = 478;
    e1.Adieresissmall = 63460;
    e1.Adotbelow = 7840;
    e1.Adotmacron = 480;
    e1.Agrave = 192;
    e1.Agravesmall = 63456;
    e1.Ahookabove = 7842;
    e1.Aiecyrillic = 1236;
    e1.Ainvertedbreve = 514;
    e1.Alpha = 913;
    e1.Alphatonos = 902;
    e1.Amacron = 256;
    e1.Amonospace = 65313;
    e1.Aogonek = 260;
    e1.Aring = 197;
    e1.Aringacute = 506;
    e1.Aringbelow = 7680;
    e1.Aringsmall = 63461;
    e1.Asmall = 63329;
    e1.Atilde = 195;
    e1.Atildesmall = 63459;
    e1.Aybarmenian = 1329;
    e1.B = 66;
    e1.Bcircle = 9399;
    e1.Bdotaccent = 7682;
    e1.Bdotbelow = 7684;
    e1.Becyrillic = 1041;
    e1.Benarmenian = 1330;
    e1.Beta = 914;
    e1.Bhook = 385;
    e1.Blinebelow = 7686;
    e1.Bmonospace = 65314;
    e1.Brevesmall = 63220;
    e1.Bsmall = 63330;
    e1.Btopbar = 386;
    e1.C = 67;
    e1.Caarmenian = 1342;
    e1.Cacute = 262;
    e1.Caron = 63178;
    e1.Caronsmall = 63221;
    e1.Ccaron = 268;
    e1.Ccedilla = 199;
    e1.Ccedillaacute = 7688;
    e1.Ccedillasmall = 63463;
    e1.Ccircle = 9400;
    e1.Ccircumflex = 264;
    e1.Cdot = 266;
    e1.Cdotaccent = 266;
    e1.Cedillasmall = 63416;
    e1.Chaarmenian = 1353;
    e1.Cheabkhasiancyrillic = 1212;
    e1.Checyrillic = 1063;
    e1.Chedescenderabkhasiancyrillic = 1214;
    e1.Chedescendercyrillic = 1206;
    e1.Chedieresiscyrillic = 1268;
    e1.Cheharmenian = 1347;
    e1.Chekhakassiancyrillic = 1227;
    e1.Cheverticalstrokecyrillic = 1208;
    e1.Chi = 935;
    e1.Chook = 391;
    e1.Circumflexsmall = 63222;
    e1.Cmonospace = 65315;
    e1.Coarmenian = 1361;
    e1.Csmall = 63331;
    e1.D = 68;
    e1.DZ = 497;
    e1.DZcaron = 452;
    e1.Daarmenian = 1332;
    e1.Dafrican = 393;
    e1.Dcaron = 270;
    e1.Dcedilla = 7696;
    e1.Dcircle = 9401;
    e1.Dcircumflexbelow = 7698;
    e1.Dcroat = 272;
    e1.Ddotaccent = 7690;
    e1.Ddotbelow = 7692;
    e1.Decyrillic = 1044;
    e1.Deicoptic = 1006;
    e1.Delta = 8710;
    e1.Deltagreek = 916;
    e1.Dhook = 394;
    e1.Dieresis = 63179;
    e1.DieresisAcute = 63180;
    e1.DieresisGrave = 63181;
    e1.Dieresissmall = 63400;
    e1.Digammagreek = 988;
    e1.Djecyrillic = 1026;
    e1.Dlinebelow = 7694;
    e1.Dmonospace = 65316;
    e1.Dotaccentsmall = 63223;
    e1.Dslash = 272;
    e1.Dsmall = 63332;
    e1.Dtopbar = 395;
    e1.Dz = 498;
    e1.Dzcaron = 453;
    e1.Dzeabkhasiancyrillic = 1248;
    e1.Dzecyrillic = 1029;
    e1.Dzhecyrillic = 1039;
    e1.E = 69;
    e1.Eacute = 201;
    e1.Eacutesmall = 63465;
    e1.Ebreve = 276;
    e1.Ecaron = 282;
    e1.Ecedillabreve = 7708;
    e1.Echarmenian = 1333;
    e1.Ecircle = 9402;
    e1.Ecircumflex = 202;
    e1.Ecircumflexacute = 7870;
    e1.Ecircumflexbelow = 7704;
    e1.Ecircumflexdotbelow = 7878;
    e1.Ecircumflexgrave = 7872;
    e1.Ecircumflexhookabove = 7874;
    e1.Ecircumflexsmall = 63466;
    e1.Ecircumflextilde = 7876;
    e1.Ecyrillic = 1028;
    e1.Edblgrave = 516;
    e1.Edieresis = 203;
    e1.Edieresissmall = 63467;
    e1.Edot = 278;
    e1.Edotaccent = 278;
    e1.Edotbelow = 7864;
    e1.Efcyrillic = 1060;
    e1.Egrave = 200;
    e1.Egravesmall = 63464;
    e1.Eharmenian = 1335;
    e1.Ehookabove = 7866;
    e1.Eightroman = 8551;
    e1.Einvertedbreve = 518;
    e1.Eiotifiedcyrillic = 1124;
    e1.Elcyrillic = 1051;
    e1.Elevenroman = 8554;
    e1.Emacron = 274;
    e1.Emacronacute = 7702;
    e1.Emacrongrave = 7700;
    e1.Emcyrillic = 1052;
    e1.Emonospace = 65317;
    e1.Encyrillic = 1053;
    e1.Endescendercyrillic = 1186;
    e1.Eng = 330;
    e1.Enghecyrillic = 1188;
    e1.Enhookcyrillic = 1223;
    e1.Eogonek = 280;
    e1.Eopen = 400;
    e1.Epsilon = 917;
    e1.Epsilontonos = 904;
    e1.Ercyrillic = 1056;
    e1.Ereversed = 398;
    e1.Ereversedcyrillic = 1069;
    e1.Escyrillic = 1057;
    e1.Esdescendercyrillic = 1194;
    e1.Esh = 425;
    e1.Esmall = 63333;
    e1.Eta = 919;
    e1.Etarmenian = 1336;
    e1.Etatonos = 905;
    e1.Eth = 208;
    e1.Ethsmall = 63472;
    e1.Etilde = 7868;
    e1.Etildebelow = 7706;
    e1.Euro = 8364;
    e1.Ezh = 439;
    e1.Ezhcaron = 494;
    e1.Ezhreversed = 440;
    e1.F = 70;
    e1.Fcircle = 9403;
    e1.Fdotaccent = 7710;
    e1.Feharmenian = 1366;
    e1.Feicoptic = 996;
    e1.Fhook = 401;
    e1.Fitacyrillic = 1138;
    e1.Fiveroman = 8548;
    e1.Fmonospace = 65318;
    e1.Fourroman = 8547;
    e1.Fsmall = 63334;
    e1.G = 71;
    e1.GBsquare = 13191;
    e1.Gacute = 500;
    e1.Gamma = 915;
    e1.Gammaafrican = 404;
    e1.Gangiacoptic = 1002;
    e1.Gbreve = 286;
    e1.Gcaron = 486;
    e1.Gcedilla = 290;
    e1.Gcircle = 9404;
    e1.Gcircumflex = 284;
    e1.Gcommaaccent = 290;
    e1.Gdot = 288;
    e1.Gdotaccent = 288;
    e1.Gecyrillic = 1043;
    e1.Ghadarmenian = 1346;
    e1.Ghemiddlehookcyrillic = 1172;
    e1.Ghestrokecyrillic = 1170;
    e1.Gheupturncyrillic = 1168;
    e1.Ghook = 403;
    e1.Gimarmenian = 1331;
    e1.Gjecyrillic = 1027;
    e1.Gmacron = 7712;
    e1.Gmonospace = 65319;
    e1.Grave = 63182;
    e1.Gravesmall = 63328;
    e1.Gsmall = 63335;
    e1.Gsmallhook = 667;
    e1.Gstroke = 484;
    e1.H = 72;
    e1.H18533 = 9679;
    e1.H18543 = 9642;
    e1.H18551 = 9643;
    e1.H22073 = 9633;
    e1.HPsquare = 13259;
    e1.Haabkhasiancyrillic = 1192;
    e1.Hadescendercyrillic = 1202;
    e1.Hardsigncyrillic = 1066;
    e1.Hbar = 294;
    e1.Hbrevebelow = 7722;
    e1.Hcedilla = 7720;
    e1.Hcircle = 9405;
    e1.Hcircumflex = 292;
    e1.Hdieresis = 7718;
    e1.Hdotaccent = 7714;
    e1.Hdotbelow = 7716;
    e1.Hmonospace = 65320;
    e1.Hoarmenian = 1344;
    e1.Horicoptic = 1e3;
    e1.Hsmall = 63336;
    e1.Hungarumlaut = 63183;
    e1.Hungarumlautsmall = 63224;
    e1.Hzsquare = 13200;
    e1.I = 73;
    e1.IAcyrillic = 1071;
    e1.IJ = 306;
    e1.IUcyrillic = 1070;
    e1.Iacute = 205;
    e1.Iacutesmall = 63469;
    e1.Ibreve = 300;
    e1.Icaron = 463;
    e1.Icircle = 9406;
    e1.Icircumflex = 206;
    e1.Icircumflexsmall = 63470;
    e1.Icyrillic = 1030;
    e1.Idblgrave = 520;
    e1.Idieresis = 207;
    e1.Idieresisacute = 7726;
    e1.Idieresiscyrillic = 1252;
    e1.Idieresissmall = 63471;
    e1.Idot = 304;
    e1.Idotaccent = 304;
    e1.Idotbelow = 7882;
    e1.Iebrevecyrillic = 1238;
    e1.Iecyrillic = 1045;
    e1.Ifraktur = 8465;
    e1.Igrave = 204;
    e1.Igravesmall = 63468;
    e1.Ihookabove = 7880;
    e1.Iicyrillic = 1048;
    e1.Iinvertedbreve = 522;
    e1.Iishortcyrillic = 1049;
    e1.Imacron = 298;
    e1.Imacroncyrillic = 1250;
    e1.Imonospace = 65321;
    e1.Iniarmenian = 1339;
    e1.Iocyrillic = 1025;
    e1.Iogonek = 302;
    e1.Iota = 921;
    e1.Iotaafrican = 406;
    e1.Iotadieresis = 938;
    e1.Iotatonos = 906;
    e1.Ismall = 63337;
    e1.Istroke = 407;
    e1.Itilde = 296;
    e1.Itildebelow = 7724;
    e1.Izhitsacyrillic = 1140;
    e1.Izhitsadblgravecyrillic = 1142;
    e1.J = 74;
    e1.Jaarmenian = 1345;
    e1.Jcircle = 9407;
    e1.Jcircumflex = 308;
    e1.Jecyrillic = 1032;
    e1.Jheharmenian = 1355;
    e1.Jmonospace = 65322;
    e1.Jsmall = 63338;
    e1.K = 75;
    e1.KBsquare = 13189;
    e1.KKsquare = 13261;
    e1.Kabashkircyrillic = 1184;
    e1.Kacute = 7728;
    e1.Kacyrillic = 1050;
    e1.Kadescendercyrillic = 1178;
    e1.Kahookcyrillic = 1219;
    e1.Kappa = 922;
    e1.Kastrokecyrillic = 1182;
    e1.Kaverticalstrokecyrillic = 1180;
    e1.Kcaron = 488;
    e1.Kcedilla = 310;
    e1.Kcircle = 9408;
    e1.Kcommaaccent = 310;
    e1.Kdotbelow = 7730;
    e1.Keharmenian = 1364;
    e1.Kenarmenian = 1343;
    e1.Khacyrillic = 1061;
    e1.Kheicoptic = 998;
    e1.Khook = 408;
    e1.Kjecyrillic = 1036;
    e1.Klinebelow = 7732;
    e1.Kmonospace = 65323;
    e1.Koppacyrillic = 1152;
    e1.Koppagreek = 990;
    e1.Ksicyrillic = 1134;
    e1.Ksmall = 63339;
    e1.L = 76;
    e1.LJ = 455;
    e1.LL = 63167;
    e1.Lacute = 313;
    e1.Lambda = 923;
    e1.Lcaron = 317;
    e1.Lcedilla = 315;
    e1.Lcircle = 9409;
    e1.Lcircumflexbelow = 7740;
    e1.Lcommaaccent = 315;
    e1.Ldot = 319;
    e1.Ldotaccent = 319;
    e1.Ldotbelow = 7734;
    e1.Ldotbelowmacron = 7736;
    e1.Liwnarmenian = 1340;
    e1.Lj = 456;
    e1.Ljecyrillic = 1033;
    e1.Llinebelow = 7738;
    e1.Lmonospace = 65324;
    e1.Lslash = 321;
    e1.Lslashsmall = 63225;
    e1.Lsmall = 63340;
    e1.M = 77;
    e1.MBsquare = 13190;
    e1.Macron = 63184;
    e1.Macronsmall = 63407;
    e1.Macute = 7742;
    e1.Mcircle = 9410;
    e1.Mdotaccent = 7744;
    e1.Mdotbelow = 7746;
    e1.Menarmenian = 1348;
    e1.Mmonospace = 65325;
    e1.Msmall = 63341;
    e1.Mturned = 412;
    e1.Mu = 924;
    e1.N = 78;
    e1.NJ = 458;
    e1.Nacute = 323;
    e1.Ncaron = 327;
    e1.Ncedilla = 325;
    e1.Ncircle = 9411;
    e1.Ncircumflexbelow = 7754;
    e1.Ncommaaccent = 325;
    e1.Ndotaccent = 7748;
    e1.Ndotbelow = 7750;
    e1.Nhookleft = 413;
    e1.Nineroman = 8552;
    e1.Nj = 459;
    e1.Njecyrillic = 1034;
    e1.Nlinebelow = 7752;
    e1.Nmonospace = 65326;
    e1.Nowarmenian = 1350;
    e1.Nsmall = 63342;
    e1.Ntilde = 209;
    e1.Ntildesmall = 63473;
    e1.Nu = 925;
    e1.O = 79;
    e1.OE = 338;
    e1.OEsmall = 63226;
    e1.Oacute = 211;
    e1.Oacutesmall = 63475;
    e1.Obarredcyrillic = 1256;
    e1.Obarreddieresiscyrillic = 1258;
    e1.Obreve = 334;
    e1.Ocaron = 465;
    e1.Ocenteredtilde = 415;
    e1.Ocircle = 9412;
    e1.Ocircumflex = 212;
    e1.Ocircumflexacute = 7888;
    e1.Ocircumflexdotbelow = 7896;
    e1.Ocircumflexgrave = 7890;
    e1.Ocircumflexhookabove = 7892;
    e1.Ocircumflexsmall = 63476;
    e1.Ocircumflextilde = 7894;
    e1.Ocyrillic = 1054;
    e1.Odblacute = 336;
    e1.Odblgrave = 524;
    e1.Odieresis = 214;
    e1.Odieresiscyrillic = 1254;
    e1.Odieresissmall = 63478;
    e1.Odotbelow = 7884;
    e1.Ogoneksmall = 63227;
    e1.Ograve = 210;
    e1.Ogravesmall = 63474;
    e1.Oharmenian = 1365;
    e1.Ohm = 8486;
    e1.Ohookabove = 7886;
    e1.Ohorn = 416;
    e1.Ohornacute = 7898;
    e1.Ohorndotbelow = 7906;
    e1.Ohorngrave = 7900;
    e1.Ohornhookabove = 7902;
    e1.Ohorntilde = 7904;
    e1.Ohungarumlaut = 336;
    e1.Oi = 418;
    e1.Oinvertedbreve = 526;
    e1.Omacron = 332;
    e1.Omacronacute = 7762;
    e1.Omacrongrave = 7760;
    e1.Omega = 8486;
    e1.Omegacyrillic = 1120;
    e1.Omegagreek = 937;
    e1.Omegaroundcyrillic = 1146;
    e1.Omegatitlocyrillic = 1148;
    e1.Omegatonos = 911;
    e1.Omicron = 927;
    e1.Omicrontonos = 908;
    e1.Omonospace = 65327;
    e1.Oneroman = 8544;
    e1.Oogonek = 490;
    e1.Oogonekmacron = 492;
    e1.Oopen = 390;
    e1.Oslash = 216;
    e1.Oslashacute = 510;
    e1.Oslashsmall = 63480;
    e1.Osmall = 63343;
    e1.Ostrokeacute = 510;
    e1.Otcyrillic = 1150;
    e1.Otilde = 213;
    e1.Otildeacute = 7756;
    e1.Otildedieresis = 7758;
    e1.Otildesmall = 63477;
    e1.P = 80;
    e1.Pacute = 7764;
    e1.Pcircle = 9413;
    e1.Pdotaccent = 7766;
    e1.Pecyrillic = 1055;
    e1.Peharmenian = 1354;
    e1.Pemiddlehookcyrillic = 1190;
    e1.Phi = 934;
    e1.Phook = 420;
    e1.Pi = 928;
    e1.Piwrarmenian = 1363;
    e1.Pmonospace = 65328;
    e1.Psi = 936;
    e1.Psicyrillic = 1136;
    e1.Psmall = 63344;
    e1.Q = 81;
    e1.Qcircle = 9414;
    e1.Qmonospace = 65329;
    e1.Qsmall = 63345;
    e1.R = 82;
    e1.Raarmenian = 1356;
    e1.Racute = 340;
    e1.Rcaron = 344;
    e1.Rcedilla = 342;
    e1.Rcircle = 9415;
    e1.Rcommaaccent = 342;
    e1.Rdblgrave = 528;
    e1.Rdotaccent = 7768;
    e1.Rdotbelow = 7770;
    e1.Rdotbelowmacron = 7772;
    e1.Reharmenian = 1360;
    e1.Rfraktur = 8476;
    e1.Rho = 929;
    e1.Ringsmall = 63228;
    e1.Rinvertedbreve = 530;
    e1.Rlinebelow = 7774;
    e1.Rmonospace = 65330;
    e1.Rsmall = 63346;
    e1.Rsmallinverted = 641;
    e1.Rsmallinvertedsuperior = 694;
    e1.S = 83;
    e1.SF010000 = 9484;
    e1.SF020000 = 9492;
    e1.SF030000 = 9488;
    e1.SF040000 = 9496;
    e1.SF050000 = 9532;
    e1.SF060000 = 9516;
    e1.SF070000 = 9524;
    e1.SF080000 = 9500;
    e1.SF090000 = 9508;
    e1.SF100000 = 9472;
    e1.SF110000 = 9474;
    e1.SF190000 = 9569;
    e1.SF200000 = 9570;
    e1.SF210000 = 9558;
    e1.SF220000 = 9557;
    e1.SF230000 = 9571;
    e1.SF240000 = 9553;
    e1.SF250000 = 9559;
    e1.SF260000 = 9565;
    e1.SF270000 = 9564;
    e1.SF280000 = 9563;
    e1.SF360000 = 9566;
    e1.SF370000 = 9567;
    e1.SF380000 = 9562;
    e1.SF390000 = 9556;
    e1.SF400000 = 9577;
    e1.SF410000 = 9574;
    e1.SF420000 = 9568;
    e1.SF430000 = 9552;
    e1.SF440000 = 9580;
    e1.SF450000 = 9575;
    e1.SF460000 = 9576;
    e1.SF470000 = 9572;
    e1.SF480000 = 9573;
    e1.SF490000 = 9561;
    e1.SF500000 = 9560;
    e1.SF510000 = 9554;
    e1.SF520000 = 9555;
    e1.SF530000 = 9579;
    e1.SF540000 = 9578;
    e1.Sacute = 346;
    e1.Sacutedotaccent = 7780;
    e1.Sampigreek = 992;
    e1.Scaron = 352;
    e1.Scarondotaccent = 7782;
    e1.Scaronsmall = 63229;
    e1.Scedilla = 350;
    e1.Schwa = 399;
    e1.Schwacyrillic = 1240;
    e1.Schwadieresiscyrillic = 1242;
    e1.Scircle = 9416;
    e1.Scircumflex = 348;
    e1.Scommaaccent = 536;
    e1.Sdotaccent = 7776;
    e1.Sdotbelow = 7778;
    e1.Sdotbelowdotaccent = 7784;
    e1.Seharmenian = 1357;
    e1.Sevenroman = 8550;
    e1.Shaarmenian = 1351;
    e1.Shacyrillic = 1064;
    e1.Shchacyrillic = 1065;
    e1.Sheicoptic = 994;
    e1.Shhacyrillic = 1210;
    e1.Shimacoptic = 1004;
    e1.Sigma = 931;
    e1.Sixroman = 8549;
    e1.Smonospace = 65331;
    e1.Softsigncyrillic = 1068;
    e1.Ssmall = 63347;
    e1.Stigmagreek = 986;
    e1.T = 84;
    e1.Tau = 932;
    e1.Tbar = 358;
    e1.Tcaron = 356;
    e1.Tcedilla = 354;
    e1.Tcircle = 9417;
    e1.Tcircumflexbelow = 7792;
    e1.Tcommaaccent = 354;
    e1.Tdotaccent = 7786;
    e1.Tdotbelow = 7788;
    e1.Tecyrillic = 1058;
    e1.Tedescendercyrillic = 1196;
    e1.Tenroman = 8553;
    e1.Tetsecyrillic = 1204;
    e1.Theta = 920;
    e1.Thook = 428;
    e1.Thorn = 222;
    e1.Thornsmall = 63486;
    e1.Threeroman = 8546;
    e1.Tildesmall = 63230;
    e1.Tiwnarmenian = 1359;
    e1.Tlinebelow = 7790;
    e1.Tmonospace = 65332;
    e1.Toarmenian = 1337;
    e1.Tonefive = 444;
    e1.Tonesix = 388;
    e1.Tonetwo = 423;
    e1.Tretroflexhook = 430;
    e1.Tsecyrillic = 1062;
    e1.Tshecyrillic = 1035;
    e1.Tsmall = 63348;
    e1.Twelveroman = 8555;
    e1.Tworoman = 8545;
    e1.U = 85;
    e1.Uacute = 218;
    e1.Uacutesmall = 63482;
    e1.Ubreve = 364;
    e1.Ucaron = 467;
    e1.Ucircle = 9418;
    e1.Ucircumflex = 219;
    e1.Ucircumflexbelow = 7798;
    e1.Ucircumflexsmall = 63483;
    e1.Ucyrillic = 1059;
    e1.Udblacute = 368;
    e1.Udblgrave = 532;
    e1.Udieresis = 220;
    e1.Udieresisacute = 471;
    e1.Udieresisbelow = 7794;
    e1.Udieresiscaron = 473;
    e1.Udieresiscyrillic = 1264;
    e1.Udieresisgrave = 475;
    e1.Udieresismacron = 469;
    e1.Udieresissmall = 63484;
    e1.Udotbelow = 7908;
    e1.Ugrave = 217;
    e1.Ugravesmall = 63481;
    e1.Uhookabove = 7910;
    e1.Uhorn = 431;
    e1.Uhornacute = 7912;
    e1.Uhorndotbelow = 7920;
    e1.Uhorngrave = 7914;
    e1.Uhornhookabove = 7916;
    e1.Uhorntilde = 7918;
    e1.Uhungarumlaut = 368;
    e1.Uhungarumlautcyrillic = 1266;
    e1.Uinvertedbreve = 534;
    e1.Ukcyrillic = 1144;
    e1.Umacron = 362;
    e1.Umacroncyrillic = 1262;
    e1.Umacrondieresis = 7802;
    e1.Umonospace = 65333;
    e1.Uogonek = 370;
    e1.Upsilon = 933;
    e1.Upsilon1 = 978;
    e1.Upsilonacutehooksymbolgreek = 979;
    e1.Upsilonafrican = 433;
    e1.Upsilondieresis = 939;
    e1.Upsilondieresishooksymbolgreek = 980;
    e1.Upsilonhooksymbol = 978;
    e1.Upsilontonos = 910;
    e1.Uring = 366;
    e1.Ushortcyrillic = 1038;
    e1.Usmall = 63349;
    e1.Ustraightcyrillic = 1198;
    e1.Ustraightstrokecyrillic = 1200;
    e1.Utilde = 360;
    e1.Utildeacute = 7800;
    e1.Utildebelow = 7796;
    e1.V = 86;
    e1.Vcircle = 9419;
    e1.Vdotbelow = 7806;
    e1.Vecyrillic = 1042;
    e1.Vewarmenian = 1358;
    e1.Vhook = 434;
    e1.Vmonospace = 65334;
    e1.Voarmenian = 1352;
    e1.Vsmall = 63350;
    e1.Vtilde = 7804;
    e1.W = 87;
    e1.Wacute = 7810;
    e1.Wcircle = 9420;
    e1.Wcircumflex = 372;
    e1.Wdieresis = 7812;
    e1.Wdotaccent = 7814;
    e1.Wdotbelow = 7816;
    e1.Wgrave = 7808;
    e1.Wmonospace = 65335;
    e1.Wsmall = 63351;
    e1.X = 88;
    e1.Xcircle = 9421;
    e1.Xdieresis = 7820;
    e1.Xdotaccent = 7818;
    e1.Xeharmenian = 1341;
    e1.Xi = 926;
    e1.Xmonospace = 65336;
    e1.Xsmall = 63352;
    e1.Y = 89;
    e1.Yacute = 221;
    e1.Yacutesmall = 63485;
    e1.Yatcyrillic = 1122;
    e1.Ycircle = 9422;
    e1.Ycircumflex = 374;
    e1.Ydieresis = 376;
    e1.Ydieresissmall = 63487;
    e1.Ydotaccent = 7822;
    e1.Ydotbelow = 7924;
    e1.Yericyrillic = 1067;
    e1.Yerudieresiscyrillic = 1272;
    e1.Ygrave = 7922;
    e1.Yhook = 435;
    e1.Yhookabove = 7926;
    e1.Yiarmenian = 1349;
    e1.Yicyrillic = 1031;
    e1.Yiwnarmenian = 1362;
    e1.Ymonospace = 65337;
    e1.Ysmall = 63353;
    e1.Ytilde = 7928;
    e1.Yusbigcyrillic = 1130;
    e1.Yusbigiotifiedcyrillic = 1132;
    e1.Yuslittlecyrillic = 1126;
    e1.Yuslittleiotifiedcyrillic = 1128;
    e1.Z = 90;
    e1.Zaarmenian = 1334;
    e1.Zacute = 377;
    e1.Zcaron = 381;
    e1.Zcaronsmall = 63231;
    e1.Zcircle = 9423;
    e1.Zcircumflex = 7824;
    e1.Zdot = 379;
    e1.Zdotaccent = 379;
    e1.Zdotbelow = 7826;
    e1.Zecyrillic = 1047;
    e1.Zedescendercyrillic = 1176;
    e1.Zedieresiscyrillic = 1246;
    e1.Zeta = 918;
    e1.Zhearmenian = 1338;
    e1.Zhebrevecyrillic = 1217;
    e1.Zhecyrillic = 1046;
    e1.Zhedescendercyrillic = 1174;
    e1.Zhedieresiscyrillic = 1244;
    e1.Zlinebelow = 7828;
    e1.Zmonospace = 65338;
    e1.Zsmall = 63354;
    e1.Zstroke = 437;
    e1.a = 97;
    e1.aabengali = 2438;
    e1.aacute = 225;
    e1.aadeva = 2310;
    e1.aagujarati = 2694;
    e1.aagurmukhi = 2566;
    e1.aamatragurmukhi = 2622;
    e1.aarusquare = 13059;
    e1.aavowelsignbengali = 2494;
    e1.aavowelsigndeva = 2366;
    e1.aavowelsigngujarati = 2750;
    e1.abbreviationmarkarmenian = 1375;
    e1.abbreviationsigndeva = 2416;
    e1.abengali = 2437;
    e1.abopomofo = 12570;
    e1.abreve = 259;
    e1.abreveacute = 7855;
    e1.abrevecyrillic = 1233;
    e1.abrevedotbelow = 7863;
    e1.abrevegrave = 7857;
    e1.abrevehookabove = 7859;
    e1.abrevetilde = 7861;
    e1.acaron = 462;
    e1.acircle = 9424;
    e1.acircumflex = 226;
    e1.acircumflexacute = 7845;
    e1.acircumflexdotbelow = 7853;
    e1.acircumflexgrave = 7847;
    e1.acircumflexhookabove = 7849;
    e1.acircumflextilde = 7851;
    e1.acute = 180;
    e1.acutebelowcmb = 791;
    e1.acutecmb = 769;
    e1.acutecomb = 769;
    e1.acutedeva = 2388;
    e1.acutelowmod = 719;
    e1.acutetonecmb = 833;
    e1.acyrillic = 1072;
    e1.adblgrave = 513;
    e1.addakgurmukhi = 2673;
    e1.adeva = 2309;
    e1.adieresis = 228;
    e1.adieresiscyrillic = 1235;
    e1.adieresismacron = 479;
    e1.adotbelow = 7841;
    e1.adotmacron = 481;
    e1.ae = 230;
    e1.aeacute = 509;
    e1.aekorean = 12624;
    e1.aemacron = 483;
    e1.afii00208 = 8213;
    e1.afii08941 = 8356;
    e1.afii10017 = 1040;
    e1.afii10018 = 1041;
    e1.afii10019 = 1042;
    e1.afii10020 = 1043;
    e1.afii10021 = 1044;
    e1.afii10022 = 1045;
    e1.afii10023 = 1025;
    e1.afii10024 = 1046;
    e1.afii10025 = 1047;
    e1.afii10026 = 1048;
    e1.afii10027 = 1049;
    e1.afii10028 = 1050;
    e1.afii10029 = 1051;
    e1.afii10030 = 1052;
    e1.afii10031 = 1053;
    e1.afii10032 = 1054;
    e1.afii10033 = 1055;
    e1.afii10034 = 1056;
    e1.afii10035 = 1057;
    e1.afii10036 = 1058;
    e1.afii10037 = 1059;
    e1.afii10038 = 1060;
    e1.afii10039 = 1061;
    e1.afii10040 = 1062;
    e1.afii10041 = 1063;
    e1.afii10042 = 1064;
    e1.afii10043 = 1065;
    e1.afii10044 = 1066;
    e1.afii10045 = 1067;
    e1.afii10046 = 1068;
    e1.afii10047 = 1069;
    e1.afii10048 = 1070;
    e1.afii10049 = 1071;
    e1.afii10050 = 1168;
    e1.afii10051 = 1026;
    e1.afii10052 = 1027;
    e1.afii10053 = 1028;
    e1.afii10054 = 1029;
    e1.afii10055 = 1030;
    e1.afii10056 = 1031;
    e1.afii10057 = 1032;
    e1.afii10058 = 1033;
    e1.afii10059 = 1034;
    e1.afii10060 = 1035;
    e1.afii10061 = 1036;
    e1.afii10062 = 1038;
    e1.afii10063 = 63172;
    e1.afii10064 = 63173;
    e1.afii10065 = 1072;
    e1.afii10066 = 1073;
    e1.afii10067 = 1074;
    e1.afii10068 = 1075;
    e1.afii10069 = 1076;
    e1.afii10070 = 1077;
    e1.afii10071 = 1105;
    e1.afii10072 = 1078;
    e1.afii10073 = 1079;
    e1.afii10074 = 1080;
    e1.afii10075 = 1081;
    e1.afii10076 = 1082;
    e1.afii10077 = 1083;
    e1.afii10078 = 1084;
    e1.afii10079 = 1085;
    e1.afii10080 = 1086;
    e1.afii10081 = 1087;
    e1.afii10082 = 1088;
    e1.afii10083 = 1089;
    e1.afii10084 = 1090;
    e1.afii10085 = 1091;
    e1.afii10086 = 1092;
    e1.afii10087 = 1093;
    e1.afii10088 = 1094;
    e1.afii10089 = 1095;
    e1.afii10090 = 1096;
    e1.afii10091 = 1097;
    e1.afii10092 = 1098;
    e1.afii10093 = 1099;
    e1.afii10094 = 1100;
    e1.afii10095 = 1101;
    e1.afii10096 = 1102;
    e1.afii10097 = 1103;
    e1.afii10098 = 1169;
    e1.afii10099 = 1106;
    e1.afii10100 = 1107;
    e1.afii10101 = 1108;
    e1.afii10102 = 1109;
    e1.afii10103 = 1110;
    e1.afii10104 = 1111;
    e1.afii10105 = 1112;
    e1.afii10106 = 1113;
    e1.afii10107 = 1114;
    e1.afii10108 = 1115;
    e1.afii10109 = 1116;
    e1.afii10110 = 1118;
    e1.afii10145 = 1039;
    e1.afii10146 = 1122;
    e1.afii10147 = 1138;
    e1.afii10148 = 1140;
    e1.afii10192 = 63174;
    e1.afii10193 = 1119;
    e1.afii10194 = 1123;
    e1.afii10195 = 1139;
    e1.afii10196 = 1141;
    e1.afii10831 = 63175;
    e1.afii10832 = 63176;
    e1.afii10846 = 1241;
    e1.afii299 = 8206;
    e1.afii300 = 8207;
    e1.afii301 = 8205;
    e1.afii57381 = 1642;
    e1.afii57388 = 1548;
    e1.afii57392 = 1632;
    e1.afii57393 = 1633;
    e1.afii57394 = 1634;
    e1.afii57395 = 1635;
    e1.afii57396 = 1636;
    e1.afii57397 = 1637;
    e1.afii57398 = 1638;
    e1.afii57399 = 1639;
    e1.afii57400 = 1640;
    e1.afii57401 = 1641;
    e1.afii57403 = 1563;
    e1.afii57407 = 1567;
    e1.afii57409 = 1569;
    e1.afii57410 = 1570;
    e1.afii57411 = 1571;
    e1.afii57412 = 1572;
    e1.afii57413 = 1573;
    e1.afii57414 = 1574;
    e1.afii57415 = 1575;
    e1.afii57416 = 1576;
    e1.afii57417 = 1577;
    e1.afii57418 = 1578;
    e1.afii57419 = 1579;
    e1.afii57420 = 1580;
    e1.afii57421 = 1581;
    e1.afii57422 = 1582;
    e1.afii57423 = 1583;
    e1.afii57424 = 1584;
    e1.afii57425 = 1585;
    e1.afii57426 = 1586;
    e1.afii57427 = 1587;
    e1.afii57428 = 1588;
    e1.afii57429 = 1589;
    e1.afii57430 = 1590;
    e1.afii57431 = 1591;
    e1.afii57432 = 1592;
    e1.afii57433 = 1593;
    e1.afii57434 = 1594;
    e1.afii57440 = 1600;
    e1.afii57441 = 1601;
    e1.afii57442 = 1602;
    e1.afii57443 = 1603;
    e1.afii57444 = 1604;
    e1.afii57445 = 1605;
    e1.afii57446 = 1606;
    e1.afii57448 = 1608;
    e1.afii57449 = 1609;
    e1.afii57450 = 1610;
    e1.afii57451 = 1611;
    e1.afii57452 = 1612;
    e1.afii57453 = 1613;
    e1.afii57454 = 1614;
    e1.afii57455 = 1615;
    e1.afii57456 = 1616;
    e1.afii57457 = 1617;
    e1.afii57458 = 1618;
    e1.afii57470 = 1607;
    e1.afii57505 = 1700;
    e1.afii57506 = 1662;
    e1.afii57507 = 1670;
    e1.afii57508 = 1688;
    e1.afii57509 = 1711;
    e1.afii57511 = 1657;
    e1.afii57512 = 1672;
    e1.afii57513 = 1681;
    e1.afii57514 = 1722;
    e1.afii57519 = 1746;
    e1.afii57534 = 1749;
    e1.afii57636 = 8362;
    e1.afii57645 = 1470;
    e1.afii57658 = 1475;
    e1.afii57664 = 1488;
    e1.afii57665 = 1489;
    e1.afii57666 = 1490;
    e1.afii57667 = 1491;
    e1.afii57668 = 1492;
    e1.afii57669 = 1493;
    e1.afii57670 = 1494;
    e1.afii57671 = 1495;
    e1.afii57672 = 1496;
    e1.afii57673 = 1497;
    e1.afii57674 = 1498;
    e1.afii57675 = 1499;
    e1.afii57676 = 1500;
    e1.afii57677 = 1501;
    e1.afii57678 = 1502;
    e1.afii57679 = 1503;
    e1.afii57680 = 1504;
    e1.afii57681 = 1505;
    e1.afii57682 = 1506;
    e1.afii57683 = 1507;
    e1.afii57684 = 1508;
    e1.afii57685 = 1509;
    e1.afii57686 = 1510;
    e1.afii57687 = 1511;
    e1.afii57688 = 1512;
    e1.afii57689 = 1513;
    e1.afii57690 = 1514;
    e1.afii57694 = 64298;
    e1.afii57695 = 64299;
    e1.afii57700 = 64331;
    e1.afii57705 = 64287;
    e1.afii57716 = 1520;
    e1.afii57717 = 1521;
    e1.afii57718 = 1522;
    e1.afii57723 = 64309;
    e1.afii57793 = 1460;
    e1.afii57794 = 1461;
    e1.afii57795 = 1462;
    e1.afii57796 = 1467;
    e1.afii57797 = 1464;
    e1.afii57798 = 1463;
    e1.afii57799 = 1456;
    e1.afii57800 = 1458;
    e1.afii57801 = 1457;
    e1.afii57802 = 1459;
    e1.afii57803 = 1474;
    e1.afii57804 = 1473;
    e1.afii57806 = 1465;
    e1.afii57807 = 1468;
    e1.afii57839 = 1469;
    e1.afii57841 = 1471;
    e1.afii57842 = 1472;
    e1.afii57929 = 700;
    e1.afii61248 = 8453;
    e1.afii61289 = 8467;
    e1.afii61352 = 8470;
    e1.afii61573 = 8236;
    e1.afii61574 = 8237;
    e1.afii61575 = 8238;
    e1.afii61664 = 8204;
    e1.afii63167 = 1645;
    e1.afii64937 = 701;
    e1.agrave = 224;
    e1.agujarati = 2693;
    e1.agurmukhi = 2565;
    e1.ahiragana = 12354;
    e1.ahookabove = 7843;
    e1.aibengali = 2448;
    e1.aibopomofo = 12574;
    e1.aideva = 2320;
    e1.aiecyrillic = 1237;
    e1.aigujarati = 2704;
    e1.aigurmukhi = 2576;
    e1.aimatragurmukhi = 2632;
    e1.ainarabic = 1593;
    e1.ainfinalarabic = 65226;
    e1.aininitialarabic = 65227;
    e1.ainmedialarabic = 65228;
    e1.ainvertedbreve = 515;
    e1.aivowelsignbengali = 2504;
    e1.aivowelsigndeva = 2376;
    e1.aivowelsigngujarati = 2760;
    e1.akatakana = 12450;
    e1.akatakanahalfwidth = 65393;
    e1.akorean = 12623;
    e1.alef = 1488;
    e1.alefarabic = 1575;
    e1.alefdageshhebrew = 64304;
    e1.aleffinalarabic = 65166;
    e1.alefhamzaabovearabic = 1571;
    e1.alefhamzaabovefinalarabic = 65156;
    e1.alefhamzabelowarabic = 1573;
    e1.alefhamzabelowfinalarabic = 65160;
    e1.alefhebrew = 1488;
    e1.aleflamedhebrew = 64335;
    e1.alefmaddaabovearabic = 1570;
    e1.alefmaddaabovefinalarabic = 65154;
    e1.alefmaksuraarabic = 1609;
    e1.alefmaksurafinalarabic = 65264;
    e1.alefmaksurainitialarabic = 65267;
    e1.alefmaksuramedialarabic = 65268;
    e1.alefpatahhebrew = 64302;
    e1.alefqamatshebrew = 64303;
    e1.aleph = 8501;
    e1.allequal = 8780;
    e1.alpha = 945;
    e1.alphatonos = 940;
    e1.amacron = 257;
    e1.amonospace = 65345;
    e1.ampersand = 38;
    e1.ampersandmonospace = 65286;
    e1.ampersandsmall = 63270;
    e1.amsquare = 13250;
    e1.anbopomofo = 12578;
    e1.angbopomofo = 12580;
    e1.angbracketleft = 12296;
    e1.angbracketright = 12297;
    e1.angkhankhuthai = 3674;
    e1.angle = 8736;
    e1.anglebracketleft = 12296;
    e1.anglebracketleftvertical = 65087;
    e1.anglebracketright = 12297;
    e1.anglebracketrightvertical = 65088;
    e1.angleleft = 9001;
    e1.angleright = 9002;
    e1.angstrom = 8491;
    e1.anoteleia = 903;
    e1.anudattadeva = 2386;
    e1.anusvarabengali = 2434;
    e1.anusvaradeva = 2306;
    e1.anusvaragujarati = 2690;
    e1.aogonek = 261;
    e1.apaatosquare = 13056;
    e1.aparen = 9372;
    e1.apostrophearmenian = 1370;
    e1.apostrophemod = 700;
    e1.apple = 63743;
    e1.approaches = 8784;
    e1.approxequal = 8776;
    e1.approxequalorimage = 8786;
    e1.approximatelyequal = 8773;
    e1.araeaekorean = 12686;
    e1.araeakorean = 12685;
    e1.arc = 8978;
    e1.arighthalfring = 7834;
    e1.aring = 229;
    e1.aringacute = 507;
    e1.aringbelow = 7681;
    e1.arrowboth = 8596;
    e1.arrowdashdown = 8675;
    e1.arrowdashleft = 8672;
    e1.arrowdashright = 8674;
    e1.arrowdashup = 8673;
    e1.arrowdblboth = 8660;
    e1.arrowdbldown = 8659;
    e1.arrowdblleft = 8656;
    e1.arrowdblright = 8658;
    e1.arrowdblup = 8657;
    e1.arrowdown = 8595;
    e1.arrowdownleft = 8601;
    e1.arrowdownright = 8600;
    e1.arrowdownwhite = 8681;
    e1.arrowheaddownmod = 709;
    e1.arrowheadleftmod = 706;
    e1.arrowheadrightmod = 707;
    e1.arrowheadupmod = 708;
    e1.arrowhorizex = 63719;
    e1.arrowleft = 8592;
    e1.arrowleftdbl = 8656;
    e1.arrowleftdblstroke = 8653;
    e1.arrowleftoverright = 8646;
    e1.arrowleftwhite = 8678;
    e1.arrowright = 8594;
    e1.arrowrightdblstroke = 8655;
    e1.arrowrightheavy = 10142;
    e1.arrowrightoverleft = 8644;
    e1.arrowrightwhite = 8680;
    e1.arrowtableft = 8676;
    e1.arrowtabright = 8677;
    e1.arrowup = 8593;
    e1.arrowupdn = 8597;
    e1.arrowupdnbse = 8616;
    e1.arrowupdownbase = 8616;
    e1.arrowupleft = 8598;
    e1.arrowupleftofdown = 8645;
    e1.arrowupright = 8599;
    e1.arrowupwhite = 8679;
    e1.arrowvertex = 63718;
    e1.asciicircum = 94;
    e1.asciicircummonospace = 65342;
    e1.asciitilde = 126;
    e1.asciitildemonospace = 65374;
    e1.ascript = 593;
    e1.ascriptturned = 594;
    e1.asmallhiragana = 12353;
    e1.asmallkatakana = 12449;
    e1.asmallkatakanahalfwidth = 65383;
    e1.asterisk = 42;
    e1.asteriskaltonearabic = 1645;
    e1.asteriskarabic = 1645;
    e1.asteriskmath = 8727;
    e1.asteriskmonospace = 65290;
    e1.asterisksmall = 65121;
    e1.asterism = 8258;
    e1.asuperior = 63209;
    e1.asymptoticallyequal = 8771;
    e1.at = 64;
    e1.atilde = 227;
    e1.atmonospace = 65312;
    e1.atsmall = 65131;
    e1.aturned = 592;
    e1.aubengali = 2452;
    e1.aubopomofo = 12576;
    e1.audeva = 2324;
    e1.augujarati = 2708;
    e1.augurmukhi = 2580;
    e1.aulengthmarkbengali = 2519;
    e1.aumatragurmukhi = 2636;
    e1.auvowelsignbengali = 2508;
    e1.auvowelsigndeva = 2380;
    e1.auvowelsigngujarati = 2764;
    e1.avagrahadeva = 2365;
    e1.aybarmenian = 1377;
    e1.ayin = 1506;
    e1.ayinaltonehebrew = 64288;
    e1.ayinhebrew = 1506;
    e1.b = 98;
    e1.babengali = 2476;
    e1.backslash = 92;
    e1.backslashmonospace = 65340;
    e1.badeva = 2348;
    e1.bagujarati = 2732;
    e1.bagurmukhi = 2604;
    e1.bahiragana = 12400;
    e1.bahtthai = 3647;
    e1.bakatakana = 12496;
    e1.bar = 124;
    e1.barmonospace = 65372;
    e1.bbopomofo = 12549;
    e1.bcircle = 9425;
    e1.bdotaccent = 7683;
    e1.bdotbelow = 7685;
    e1.beamedsixteenthnotes = 9836;
    e1.because = 8757;
    e1.becyrillic = 1073;
    e1.beharabic = 1576;
    e1.behfinalarabic = 65168;
    e1.behinitialarabic = 65169;
    e1.behiragana = 12409;
    e1.behmedialarabic = 65170;
    e1.behmeeminitialarabic = 64671;
    e1.behmeemisolatedarabic = 64520;
    e1.behnoonfinalarabic = 64621;
    e1.bekatakana = 12505;
    e1.benarmenian = 1378;
    e1.bet = 1489;
    e1.beta = 946;
    e1.betasymbolgreek = 976;
    e1.betdagesh = 64305;
    e1.betdageshhebrew = 64305;
    e1.bethebrew = 1489;
    e1.betrafehebrew = 64332;
    e1.bhabengali = 2477;
    e1.bhadeva = 2349;
    e1.bhagujarati = 2733;
    e1.bhagurmukhi = 2605;
    e1.bhook = 595;
    e1.bihiragana = 12403;
    e1.bikatakana = 12499;
    e1.bilabialclick = 664;
    e1.bindigurmukhi = 2562;
    e1.birusquare = 13105;
    e1.blackcircle = 9679;
    e1.blackdiamond = 9670;
    e1.blackdownpointingtriangle = 9660;
    e1.blackleftpointingpointer = 9668;
    e1.blackleftpointingtriangle = 9664;
    e1.blacklenticularbracketleft = 12304;
    e1.blacklenticularbracketleftvertical = 65083;
    e1.blacklenticularbracketright = 12305;
    e1.blacklenticularbracketrightvertical = 65084;
    e1.blacklowerlefttriangle = 9699;
    e1.blacklowerrighttriangle = 9698;
    e1.blackrectangle = 9644;
    e1.blackrightpointingpointer = 9658;
    e1.blackrightpointingtriangle = 9654;
    e1.blacksmallsquare = 9642;
    e1.blacksmilingface = 9787;
    e1.blacksquare = 9632;
    e1.blackstar = 9733;
    e1.blackupperlefttriangle = 9700;
    e1.blackupperrighttriangle = 9701;
    e1.blackuppointingsmalltriangle = 9652;
    e1.blackuppointingtriangle = 9650;
    e1.blank = 9251;
    e1.blinebelow = 7687;
    e1.block = 9608;
    e1.bmonospace = 65346;
    e1.bobaimaithai = 3610;
    e1.bohiragana = 12412;
    e1.bokatakana = 12508;
    e1.bparen = 9373;
    e1.bqsquare = 13251;
    e1.braceex = 63732;
    e1.braceleft = 123;
    e1.braceleftbt = 63731;
    e1.braceleftmid = 63730;
    e1.braceleftmonospace = 65371;
    e1.braceleftsmall = 65115;
    e1.bracelefttp = 63729;
    e1.braceleftvertical = 65079;
    e1.braceright = 125;
    e1.bracerightbt = 63742;
    e1.bracerightmid = 63741;
    e1.bracerightmonospace = 65373;
    e1.bracerightsmall = 65116;
    e1.bracerighttp = 63740;
    e1.bracerightvertical = 65080;
    e1.bracketleft = 91;
    e1.bracketleftbt = 63728;
    e1.bracketleftex = 63727;
    e1.bracketleftmonospace = 65339;
    e1.bracketlefttp = 63726;
    e1.bracketright = 93;
    e1.bracketrightbt = 63739;
    e1.bracketrightex = 63738;
    e1.bracketrightmonospace = 65341;
    e1.bracketrighttp = 63737;
    e1.breve = 728;
    e1.brevebelowcmb = 814;
    e1.brevecmb = 774;
    e1.breveinvertedbelowcmb = 815;
    e1.breveinvertedcmb = 785;
    e1.breveinverteddoublecmb = 865;
    e1.bridgebelowcmb = 810;
    e1.bridgeinvertedbelowcmb = 826;
    e1.brokenbar = 166;
    e1.bstroke = 384;
    e1.bsuperior = 63210;
    e1.btopbar = 387;
    e1.buhiragana = 12406;
    e1.bukatakana = 12502;
    e1.bullet = 8226;
    e1.bulletinverse = 9688;
    e1.bulletoperator = 8729;
    e1.bullseye = 9678;
    e1.c = 99;
    e1.caarmenian = 1390;
    e1.cabengali = 2458;
    e1.cacute = 263;
    e1.cadeva = 2330;
    e1.cagujarati = 2714;
    e1.cagurmukhi = 2586;
    e1.calsquare = 13192;
    e1.candrabindubengali = 2433;
    e1.candrabinducmb = 784;
    e1.candrabindudeva = 2305;
    e1.candrabindugujarati = 2689;
    e1.capslock = 8682;
    e1.careof = 8453;
    e1.caron = 711;
    e1.caronbelowcmb = 812;
    e1.caroncmb = 780;
    e1.carriagereturn = 8629;
    e1.cbopomofo = 12568;
    e1.ccaron = 269;
    e1.ccedilla = 231;
    e1.ccedillaacute = 7689;
    e1.ccircle = 9426;
    e1.ccircumflex = 265;
    e1.ccurl = 597;
    e1.cdot = 267;
    e1.cdotaccent = 267;
    e1.cdsquare = 13253;
    e1.cedilla = 184;
    e1.cedillacmb = 807;
    e1.cent = 162;
    e1.centigrade = 8451;
    e1.centinferior = 63199;
    e1.centmonospace = 65504;
    e1.centoldstyle = 63394;
    e1.centsuperior = 63200;
    e1.chaarmenian = 1401;
    e1.chabengali = 2459;
    e1.chadeva = 2331;
    e1.chagujarati = 2715;
    e1.chagurmukhi = 2587;
    e1.chbopomofo = 12564;
    e1.cheabkhasiancyrillic = 1213;
    e1.checkmark = 10003;
    e1.checyrillic = 1095;
    e1.chedescenderabkhasiancyrillic = 1215;
    e1.chedescendercyrillic = 1207;
    e1.chedieresiscyrillic = 1269;
    e1.cheharmenian = 1395;
    e1.chekhakassiancyrillic = 1228;
    e1.cheverticalstrokecyrillic = 1209;
    e1.chi = 967;
    e1.chieuchacirclekorean = 12919;
    e1.chieuchaparenkorean = 12823;
    e1.chieuchcirclekorean = 12905;
    e1.chieuchkorean = 12618;
    e1.chieuchparenkorean = 12809;
    e1.chochangthai = 3594;
    e1.chochanthai = 3592;
    e1.chochingthai = 3593;
    e1.chochoethai = 3596;
    e1.chook = 392;
    e1.cieucacirclekorean = 12918;
    e1.cieucaparenkorean = 12822;
    e1.cieuccirclekorean = 12904;
    e1.cieuckorean = 12616;
    e1.cieucparenkorean = 12808;
    e1.cieucuparenkorean = 12828;
    e1.circle = 9675;
    e1.circlecopyrt = 169;
    e1.circlemultiply = 8855;
    e1.circleot = 8857;
    e1.circleplus = 8853;
    e1.circlepostalmark = 12342;
    e1.circlewithlefthalfblack = 9680;
    e1.circlewithrighthalfblack = 9681;
    e1.circumflex = 710;
    e1.circumflexbelowcmb = 813;
    e1.circumflexcmb = 770;
    e1.clear = 8999;
    e1.clickalveolar = 450;
    e1.clickdental = 448;
    e1.clicklateral = 449;
    e1.clickretroflex = 451;
    e1.club = 9827;
    e1.clubsuitblack = 9827;
    e1.clubsuitwhite = 9831;
    e1.cmcubedsquare = 13220;
    e1.cmonospace = 65347;
    e1.cmsquaredsquare = 13216;
    e1.coarmenian = 1409;
    e1.colon = 58;
    e1.colonmonetary = 8353;
    e1.colonmonospace = 65306;
    e1.colonsign = 8353;
    e1.colonsmall = 65109;
    e1.colontriangularhalfmod = 721;
    e1.colontriangularmod = 720;
    e1.comma = 44;
    e1.commaabovecmb = 787;
    e1.commaaboverightcmb = 789;
    e1.commaaccent = 63171;
    e1.commaarabic = 1548;
    e1.commaarmenian = 1373;
    e1.commainferior = 63201;
    e1.commamonospace = 65292;
    e1.commareversedabovecmb = 788;
    e1.commareversedmod = 701;
    e1.commasmall = 65104;
    e1.commasuperior = 63202;
    e1.commaturnedabovecmb = 786;
    e1.commaturnedmod = 699;
    e1.compass = 9788;
    e1.congruent = 8773;
    e1.contourintegral = 8750;
    e1.control = 8963;
    e1.controlACK = 6;
    e1.controlBEL = 7;
    e1.controlBS = 8;
    e1.controlCAN = 24;
    e1.controlCR = 13;
    e1.controlDC1 = 17;
    e1.controlDC2 = 18;
    e1.controlDC3 = 19;
    e1.controlDC4 = 20;
    e1.controlDEL = 127;
    e1.controlDLE = 16;
    e1.controlEM = 25;
    e1.controlENQ = 5;
    e1.controlEOT = 4;
    e1.controlESC = 27;
    e1.controlETB = 23;
    e1.controlETX = 3;
    e1.controlFF = 12;
    e1.controlFS = 28;
    e1.controlGS = 29;
    e1.controlHT = 9;
    e1.controlLF = 10;
    e1.controlNAK = 21;
    e1.controlNULL = 0;
    e1.controlRS = 30;
    e1.controlSI = 15;
    e1.controlSO = 14;
    e1.controlSOT = 2;
    e1.controlSTX = 1;
    e1.controlSUB = 26;
    e1.controlSYN = 22;
    e1.controlUS = 31;
    e1.controlVT = 11;
    e1.copyright = 169;
    e1.copyrightsans = 63721;
    e1.copyrightserif = 63193;
    e1.cornerbracketleft = 12300;
    e1.cornerbracketlefthalfwidth = 65378;
    e1.cornerbracketleftvertical = 65089;
    e1.cornerbracketright = 12301;
    e1.cornerbracketrighthalfwidth = 65379;
    e1.cornerbracketrightvertical = 65090;
    e1.corporationsquare = 13183;
    e1.cosquare = 13255;
    e1.coverkgsquare = 13254;
    e1.cparen = 9374;
    e1.cruzeiro = 8354;
    e1.cstretched = 663;
    e1.curlyand = 8911;
    e1.curlyor = 8910;
    e1.currency = 164;
    e1.cyrBreve = 63185;
    e1.cyrFlex = 63186;
    e1.cyrbreve = 63188;
    e1.cyrflex = 63189;
    e1.d = 100;
    e1.daarmenian = 1380;
    e1.dabengali = 2470;
    e1.dadarabic = 1590;
    e1.dadeva = 2342;
    e1.dadfinalarabic = 65214;
    e1.dadinitialarabic = 65215;
    e1.dadmedialarabic = 65216;
    e1.dagesh = 1468;
    e1.dageshhebrew = 1468;
    e1.dagger = 8224;
    e1.daggerdbl = 8225;
    e1.dagujarati = 2726;
    e1.dagurmukhi = 2598;
    e1.dahiragana = 12384;
    e1.dakatakana = 12480;
    e1.dalarabic = 1583;
    e1.dalet = 1491;
    e1.daletdagesh = 64307;
    e1.daletdageshhebrew = 64307;
    e1.dalethebrew = 1491;
    e1.dalfinalarabic = 65194;
    e1.dammaarabic = 1615;
    e1.dammalowarabic = 1615;
    e1.dammatanaltonearabic = 1612;
    e1.dammatanarabic = 1612;
    e1.danda = 2404;
    e1.dargahebrew = 1447;
    e1.dargalefthebrew = 1447;
    e1.dasiapneumatacyrilliccmb = 1157;
    e1.dblGrave = 63187;
    e1.dblanglebracketleft = 12298;
    e1.dblanglebracketleftvertical = 65085;
    e1.dblanglebracketright = 12299;
    e1.dblanglebracketrightvertical = 65086;
    e1.dblarchinvertedbelowcmb = 811;
    e1.dblarrowleft = 8660;
    e1.dblarrowright = 8658;
    e1.dbldanda = 2405;
    e1.dblgrave = 63190;
    e1.dblgravecmb = 783;
    e1.dblintegral = 8748;
    e1.dbllowline = 8215;
    e1.dbllowlinecmb = 819;
    e1.dbloverlinecmb = 831;
    e1.dblprimemod = 698;
    e1.dblverticalbar = 8214;
    e1.dblverticallineabovecmb = 782;
    e1.dbopomofo = 12553;
    e1.dbsquare = 13256;
    e1.dcaron = 271;
    e1.dcedilla = 7697;
    e1.dcircle = 9427;
    e1.dcircumflexbelow = 7699;
    e1.dcroat = 273;
    e1.ddabengali = 2465;
    e1.ddadeva = 2337;
    e1.ddagujarati = 2721;
    e1.ddagurmukhi = 2593;
    e1.ddalarabic = 1672;
    e1.ddalfinalarabic = 64393;
    e1.dddhadeva = 2396;
    e1.ddhabengali = 2466;
    e1.ddhadeva = 2338;
    e1.ddhagujarati = 2722;
    e1.ddhagurmukhi = 2594;
    e1.ddotaccent = 7691;
    e1.ddotbelow = 7693;
    e1.decimalseparatorarabic = 1643;
    e1.decimalseparatorpersian = 1643;
    e1.decyrillic = 1076;
    e1.degree = 176;
    e1.dehihebrew = 1453;
    e1.dehiragana = 12391;
    e1.deicoptic = 1007;
    e1.dekatakana = 12487;
    e1.deleteleft = 9003;
    e1.deleteright = 8998;
    e1.delta = 948;
    e1.deltaturned = 397;
    e1.denominatorminusonenumeratorbengali = 2552;
    e1.dezh = 676;
    e1.dhabengali = 2471;
    e1.dhadeva = 2343;
    e1.dhagujarati = 2727;
    e1.dhagurmukhi = 2599;
    e1.dhook = 599;
    e1.dialytikatonos = 901;
    e1.dialytikatonoscmb = 836;
    e1.diamond = 9830;
    e1.diamondsuitwhite = 9826;
    e1.dieresis = 168;
    e1.dieresisacute = 63191;
    e1.dieresisbelowcmb = 804;
    e1.dieresiscmb = 776;
    e1.dieresisgrave = 63192;
    e1.dieresistonos = 901;
    e1.dihiragana = 12386;
    e1.dikatakana = 12482;
    e1.dittomark = 12291;
    e1.divide = 247;
    e1.divides = 8739;
    e1.divisionslash = 8725;
    e1.djecyrillic = 1106;
    e1.dkshade = 9619;
    e1.dlinebelow = 7695;
    e1.dlsquare = 13207;
    e1.dmacron = 273;
    e1.dmonospace = 65348;
    e1.dnblock = 9604;
    e1.dochadathai = 3598;
    e1.dodekthai = 3604;
    e1.dohiragana = 12393;
    e1.dokatakana = 12489;
    e1.dollar = 36;
    e1.dollarinferior = 63203;
    e1.dollarmonospace = 65284;
    e1.dollaroldstyle = 63268;
    e1.dollarsmall = 65129;
    e1.dollarsuperior = 63204;
    e1.dong = 8363;
    e1.dorusquare = 13094;
    e1.dotaccent = 729;
    e1.dotaccentcmb = 775;
    e1.dotbelowcmb = 803;
    e1.dotbelowcomb = 803;
    e1.dotkatakana = 12539;
    e1.dotlessi = 305;
    e1.dotlessj = 63166;
    e1.dotlessjstrokehook = 644;
    e1.dotmath = 8901;
    e1.dottedcircle = 9676;
    e1.doubleyodpatah = 64287;
    e1.doubleyodpatahhebrew = 64287;
    e1.downtackbelowcmb = 798;
    e1.downtackmod = 725;
    e1.dparen = 9375;
    e1.dsuperior = 63211;
    e1.dtail = 598;
    e1.dtopbar = 396;
    e1.duhiragana = 12389;
    e1.dukatakana = 12485;
    e1.dz = 499;
    e1.dzaltone = 675;
    e1.dzcaron = 454;
    e1.dzcurl = 677;
    e1.dzeabkhasiancyrillic = 1249;
    e1.dzecyrillic = 1109;
    e1.dzhecyrillic = 1119;
    e1.e = 101;
    e1.eacute = 233;
    e1.earth = 9793;
    e1.ebengali = 2447;
    e1.ebopomofo = 12572;
    e1.ebreve = 277;
    e1.ecandradeva = 2317;
    e1.ecandragujarati = 2701;
    e1.ecandravowelsigndeva = 2373;
    e1.ecandravowelsigngujarati = 2757;
    e1.ecaron = 283;
    e1.ecedillabreve = 7709;
    e1.echarmenian = 1381;
    e1.echyiwnarmenian = 1415;
    e1.ecircle = 9428;
    e1.ecircumflex = 234;
    e1.ecircumflexacute = 7871;
    e1.ecircumflexbelow = 7705;
    e1.ecircumflexdotbelow = 7879;
    e1.ecircumflexgrave = 7873;
    e1.ecircumflexhookabove = 7875;
    e1.ecircumflextilde = 7877;
    e1.ecyrillic = 1108;
    e1.edblgrave = 517;
    e1.edeva = 2319;
    e1.edieresis = 235;
    e1.edot = 279;
    e1.edotaccent = 279;
    e1.edotbelow = 7865;
    e1.eegurmukhi = 2575;
    e1.eematragurmukhi = 2631;
    e1.efcyrillic = 1092;
    e1.egrave = 232;
    e1.egujarati = 2703;
    e1.eharmenian = 1383;
    e1.ehbopomofo = 12573;
    e1.ehiragana = 12360;
    e1.ehookabove = 7867;
    e1.eibopomofo = 12575;
    e1.eight = 56;
    e1.eightarabic = 1640;
    e1.eightbengali = 2542;
    e1.eightcircle = 9319;
    e1.eightcircleinversesansserif = 10129;
    e1.eightdeva = 2414;
    e1.eighteencircle = 9329;
    e1.eighteenparen = 9349;
    e1.eighteenperiod = 9369;
    e1.eightgujarati = 2798;
    e1.eightgurmukhi = 2670;
    e1.eighthackarabic = 1640;
    e1.eighthangzhou = 12328;
    e1.eighthnotebeamed = 9835;
    e1.eightideographicparen = 12839;
    e1.eightinferior = 8328;
    e1.eightmonospace = 65304;
    e1.eightoldstyle = 63288;
    e1.eightparen = 9339;
    e1.eightperiod = 9359;
    e1.eightpersian = 1784;
    e1.eightroman = 8567;
    e1.eightsuperior = 8312;
    e1.eightthai = 3672;
    e1.einvertedbreve = 519;
    e1.eiotifiedcyrillic = 1125;
    e1.ekatakana = 12456;
    e1.ekatakanahalfwidth = 65396;
    e1.ekonkargurmukhi = 2676;
    e1.ekorean = 12628;
    e1.elcyrillic = 1083;
    e1.element = 8712;
    e1.elevencircle = 9322;
    e1.elevenparen = 9342;
    e1.elevenperiod = 9362;
    e1.elevenroman = 8570;
    e1.ellipsis = 8230;
    e1.ellipsisvertical = 8942;
    e1.emacron = 275;
    e1.emacronacute = 7703;
    e1.emacrongrave = 7701;
    e1.emcyrillic = 1084;
    e1.emdash = 8212;
    e1.emdashvertical = 65073;
    e1.emonospace = 65349;
    e1.emphasismarkarmenian = 1371;
    e1.emptyset = 8709;
    e1.enbopomofo = 12579;
    e1.encyrillic = 1085;
    e1.endash = 8211;
    e1.endashvertical = 65074;
    e1.endescendercyrillic = 1187;
    e1.eng = 331;
    e1.engbopomofo = 12581;
    e1.enghecyrillic = 1189;
    e1.enhookcyrillic = 1224;
    e1.enspace = 8194;
    e1.eogonek = 281;
    e1.eokorean = 12627;
    e1.eopen = 603;
    e1.eopenclosed = 666;
    e1.eopenreversed = 604;
    e1.eopenreversedclosed = 606;
    e1.eopenreversedhook = 605;
    e1.eparen = 9376;
    e1.epsilon = 949;
    e1.epsilontonos = 941;
    e1.equal = 61;
    e1.equalmonospace = 65309;
    e1.equalsmall = 65126;
    e1.equalsuperior = 8316;
    e1.equivalence = 8801;
    e1.erbopomofo = 12582;
    e1.ercyrillic = 1088;
    e1.ereversed = 600;
    e1.ereversedcyrillic = 1101;
    e1.escyrillic = 1089;
    e1.esdescendercyrillic = 1195;
    e1.esh = 643;
    e1.eshcurl = 646;
    e1.eshortdeva = 2318;
    e1.eshortvowelsigndeva = 2374;
    e1.eshreversedloop = 426;
    e1.eshsquatreversed = 645;
    e1.esmallhiragana = 12359;
    e1.esmallkatakana = 12455;
    e1.esmallkatakanahalfwidth = 65386;
    e1.estimated = 8494;
    e1.esuperior = 63212;
    e1.eta = 951;
    e1.etarmenian = 1384;
    e1.etatonos = 942;
    e1.eth = 240;
    e1.etilde = 7869;
    e1.etildebelow = 7707;
    e1.etnahtafoukhhebrew = 1425;
    e1.etnahtafoukhlefthebrew = 1425;
    e1.etnahtahebrew = 1425;
    e1.etnahtalefthebrew = 1425;
    e1.eturned = 477;
    e1.eukorean = 12641;
    e1.euro = 8364;
    e1.evowelsignbengali = 2503;
    e1.evowelsigndeva = 2375;
    e1.evowelsigngujarati = 2759;
    e1.exclam = 33;
    e1.exclamarmenian = 1372;
    e1.exclamdbl = 8252;
    e1.exclamdown = 161;
    e1.exclamdownsmall = 63393;
    e1.exclammonospace = 65281;
    e1.exclamsmall = 63265;
    e1.existential = 8707;
    e1.ezh = 658;
    e1.ezhcaron = 495;
    e1.ezhcurl = 659;
    e1.ezhreversed = 441;
    e1.ezhtail = 442;
    e1.f = 102;
    e1.fadeva = 2398;
    e1.fagurmukhi = 2654;
    e1.fahrenheit = 8457;
    e1.fathaarabic = 1614;
    e1.fathalowarabic = 1614;
    e1.fathatanarabic = 1611;
    e1.fbopomofo = 12552;
    e1.fcircle = 9429;
    e1.fdotaccent = 7711;
    e1.feharabic = 1601;
    e1.feharmenian = 1414;
    e1.fehfinalarabic = 65234;
    e1.fehinitialarabic = 65235;
    e1.fehmedialarabic = 65236;
    e1.feicoptic = 997;
    e1.female = 9792;
    e1.ff = 64256;
    e1.f_f = 64256;
    e1.ffi = 64259;
    e1.f_f_i = 64259;
    e1.ffl = 64260;
    e1.f_f_l = 64260;
    e1.fi = 64257;
    e1.f_i = 64257;
    e1.fifteencircle = 9326;
    e1.fifteenparen = 9346;
    e1.fifteenperiod = 9366;
    e1.figuredash = 8210;
    e1.filledbox = 9632;
    e1.filledrect = 9644;
    e1.finalkaf = 1498;
    e1.finalkafdagesh = 64314;
    e1.finalkafdageshhebrew = 64314;
    e1.finalkafhebrew = 1498;
    e1.finalmem = 1501;
    e1.finalmemhebrew = 1501;
    e1.finalnun = 1503;
    e1.finalnunhebrew = 1503;
    e1.finalpe = 1507;
    e1.finalpehebrew = 1507;
    e1.finaltsadi = 1509;
    e1.finaltsadihebrew = 1509;
    e1.firsttonechinese = 713;
    e1.fisheye = 9673;
    e1.fitacyrillic = 1139;
    e1.five = 53;
    e1.fivearabic = 1637;
    e1.fivebengali = 2539;
    e1.fivecircle = 9316;
    e1.fivecircleinversesansserif = 10126;
    e1.fivedeva = 2411;
    e1.fiveeighths = 8541;
    e1.fivegujarati = 2795;
    e1.fivegurmukhi = 2667;
    e1.fivehackarabic = 1637;
    e1.fivehangzhou = 12325;
    e1.fiveideographicparen = 12836;
    e1.fiveinferior = 8325;
    e1.fivemonospace = 65301;
    e1.fiveoldstyle = 63285;
    e1.fiveparen = 9336;
    e1.fiveperiod = 9356;
    e1.fivepersian = 1781;
    e1.fiveroman = 8564;
    e1.fivesuperior = 8309;
    e1.fivethai = 3669;
    e1.fl = 64258;
    e1.f_l = 64258;
    e1.florin = 402;
    e1.fmonospace = 65350;
    e1.fmsquare = 13209;
    e1.fofanthai = 3615;
    e1.fofathai = 3613;
    e1.fongmanthai = 3663;
    e1.forall = 8704;
    e1.four = 52;
    e1.fourarabic = 1636;
    e1.fourbengali = 2538;
    e1.fourcircle = 9315;
    e1.fourcircleinversesansserif = 10125;
    e1.fourdeva = 2410;
    e1.fourgujarati = 2794;
    e1.fourgurmukhi = 2666;
    e1.fourhackarabic = 1636;
    e1.fourhangzhou = 12324;
    e1.fourideographicparen = 12835;
    e1.fourinferior = 8324;
    e1.fourmonospace = 65300;
    e1.fournumeratorbengali = 2551;
    e1.fouroldstyle = 63284;
    e1.fourparen = 9335;
    e1.fourperiod = 9355;
    e1.fourpersian = 1780;
    e1.fourroman = 8563;
    e1.foursuperior = 8308;
    e1.fourteencircle = 9325;
    e1.fourteenparen = 9345;
    e1.fourteenperiod = 9365;
    e1.fourthai = 3668;
    e1.fourthtonechinese = 715;
    e1.fparen = 9377;
    e1.fraction = 8260;
    e1.franc = 8355;
    e1.g = 103;
    e1.gabengali = 2455;
    e1.gacute = 501;
    e1.gadeva = 2327;
    e1.gafarabic = 1711;
    e1.gaffinalarabic = 64403;
    e1.gafinitialarabic = 64404;
    e1.gafmedialarabic = 64405;
    e1.gagujarati = 2711;
    e1.gagurmukhi = 2583;
    e1.gahiragana = 12364;
    e1.gakatakana = 12460;
    e1.gamma = 947;
    e1.gammalatinsmall = 611;
    e1.gammasuperior = 736;
    e1.gangiacoptic = 1003;
    e1.gbopomofo = 12557;
    e1.gbreve = 287;
    e1.gcaron = 487;
    e1.gcedilla = 291;
    e1.gcircle = 9430;
    e1.gcircumflex = 285;
    e1.gcommaaccent = 291;
    e1.gdot = 289;
    e1.gdotaccent = 289;
    e1.gecyrillic = 1075;
    e1.gehiragana = 12370;
    e1.gekatakana = 12466;
    e1.geometricallyequal = 8785;
    e1.gereshaccenthebrew = 1436;
    e1.gereshhebrew = 1523;
    e1.gereshmuqdamhebrew = 1437;
    e1.germandbls = 223;
    e1.gershayimaccenthebrew = 1438;
    e1.gershayimhebrew = 1524;
    e1.getamark = 12307;
    e1.ghabengali = 2456;
    e1.ghadarmenian = 1394;
    e1.ghadeva = 2328;
    e1.ghagujarati = 2712;
    e1.ghagurmukhi = 2584;
    e1.ghainarabic = 1594;
    e1.ghainfinalarabic = 65230;
    e1.ghaininitialarabic = 65231;
    e1.ghainmedialarabic = 65232;
    e1.ghemiddlehookcyrillic = 1173;
    e1.ghestrokecyrillic = 1171;
    e1.gheupturncyrillic = 1169;
    e1.ghhadeva = 2394;
    e1.ghhagurmukhi = 2650;
    e1.ghook = 608;
    e1.ghzsquare = 13203;
    e1.gihiragana = 12366;
    e1.gikatakana = 12462;
    e1.gimarmenian = 1379;
    e1.gimel = 1490;
    e1.gimeldagesh = 64306;
    e1.gimeldageshhebrew = 64306;
    e1.gimelhebrew = 1490;
    e1.gjecyrillic = 1107;
    e1.glottalinvertedstroke = 446;
    e1.glottalstop = 660;
    e1.glottalstopinverted = 662;
    e1.glottalstopmod = 704;
    e1.glottalstopreversed = 661;
    e1.glottalstopreversedmod = 705;
    e1.glottalstopreversedsuperior = 740;
    e1.glottalstopstroke = 673;
    e1.glottalstopstrokereversed = 674;
    e1.gmacron = 7713;
    e1.gmonospace = 65351;
    e1.gohiragana = 12372;
    e1.gokatakana = 12468;
    e1.gparen = 9378;
    e1.gpasquare = 13228;
    e1.gradient = 8711;
    e1.grave = 96;
    e1.gravebelowcmb = 790;
    e1.gravecmb = 768;
    e1.gravecomb = 768;
    e1.gravedeva = 2387;
    e1.gravelowmod = 718;
    e1.gravemonospace = 65344;
    e1.gravetonecmb = 832;
    e1.greater = 62;
    e1.greaterequal = 8805;
    e1.greaterequalorless = 8923;
    e1.greatermonospace = 65310;
    e1.greaterorequivalent = 8819;
    e1.greaterorless = 8823;
    e1.greateroverequal = 8807;
    e1.greatersmall = 65125;
    e1.gscript = 609;
    e1.gstroke = 485;
    e1.guhiragana = 12368;
    e1.guillemotleft = 171;
    e1.guillemotright = 187;
    e1.guilsinglleft = 8249;
    e1.guilsinglright = 8250;
    e1.gukatakana = 12464;
    e1.guramusquare = 13080;
    e1.gysquare = 13257;
    e1.h = 104;
    e1.haabkhasiancyrillic = 1193;
    e1.haaltonearabic = 1729;
    e1.habengali = 2489;
    e1.hadescendercyrillic = 1203;
    e1.hadeva = 2361;
    e1.hagujarati = 2745;
    e1.hagurmukhi = 2617;
    e1.haharabic = 1581;
    e1.hahfinalarabic = 65186;
    e1.hahinitialarabic = 65187;
    e1.hahiragana = 12399;
    e1.hahmedialarabic = 65188;
    e1.haitusquare = 13098;
    e1.hakatakana = 12495;
    e1.hakatakanahalfwidth = 65418;
    e1.halantgurmukhi = 2637;
    e1.hamzaarabic = 1569;
    e1.hamzalowarabic = 1569;
    e1.hangulfiller = 12644;
    e1.hardsigncyrillic = 1098;
    e1.harpoonleftbarbup = 8636;
    e1.harpoonrightbarbup = 8640;
    e1.hasquare = 13258;
    e1.hatafpatah = 1458;
    e1.hatafpatah16 = 1458;
    e1.hatafpatah23 = 1458;
    e1.hatafpatah2f = 1458;
    e1.hatafpatahhebrew = 1458;
    e1.hatafpatahnarrowhebrew = 1458;
    e1.hatafpatahquarterhebrew = 1458;
    e1.hatafpatahwidehebrew = 1458;
    e1.hatafqamats = 1459;
    e1.hatafqamats1b = 1459;
    e1.hatafqamats28 = 1459;
    e1.hatafqamats34 = 1459;
    e1.hatafqamatshebrew = 1459;
    e1.hatafqamatsnarrowhebrew = 1459;
    e1.hatafqamatsquarterhebrew = 1459;
    e1.hatafqamatswidehebrew = 1459;
    e1.hatafsegol = 1457;
    e1.hatafsegol17 = 1457;
    e1.hatafsegol24 = 1457;
    e1.hatafsegol30 = 1457;
    e1.hatafsegolhebrew = 1457;
    e1.hatafsegolnarrowhebrew = 1457;
    e1.hatafsegolquarterhebrew = 1457;
    e1.hatafsegolwidehebrew = 1457;
    e1.hbar = 295;
    e1.hbopomofo = 12559;
    e1.hbrevebelow = 7723;
    e1.hcedilla = 7721;
    e1.hcircle = 9431;
    e1.hcircumflex = 293;
    e1.hdieresis = 7719;
    e1.hdotaccent = 7715;
    e1.hdotbelow = 7717;
    e1.he = 1492;
    e1.heart = 9829;
    e1.heartsuitblack = 9829;
    e1.heartsuitwhite = 9825;
    e1.hedagesh = 64308;
    e1.hedageshhebrew = 64308;
    e1.hehaltonearabic = 1729;
    e1.heharabic = 1607;
    e1.hehebrew = 1492;
    e1.hehfinalaltonearabic = 64423;
    e1.hehfinalalttwoarabic = 65258;
    e1.hehfinalarabic = 65258;
    e1.hehhamzaabovefinalarabic = 64421;
    e1.hehhamzaaboveisolatedarabic = 64420;
    e1.hehinitialaltonearabic = 64424;
    e1.hehinitialarabic = 65259;
    e1.hehiragana = 12408;
    e1.hehmedialaltonearabic = 64425;
    e1.hehmedialarabic = 65260;
    e1.heiseierasquare = 13179;
    e1.hekatakana = 12504;
    e1.hekatakanahalfwidth = 65421;
    e1.hekutaarusquare = 13110;
    e1.henghook = 615;
    e1.herutusquare = 13113;
    e1.het = 1495;
    e1.hethebrew = 1495;
    e1.hhook = 614;
    e1.hhooksuperior = 689;
    e1.hieuhacirclekorean = 12923;
    e1.hieuhaparenkorean = 12827;
    e1.hieuhcirclekorean = 12909;
    e1.hieuhkorean = 12622;
    e1.hieuhparenkorean = 12813;
    e1.hihiragana = 12402;
    e1.hikatakana = 12498;
    e1.hikatakanahalfwidth = 65419;
    e1.hiriq = 1460;
    e1.hiriq14 = 1460;
    e1.hiriq21 = 1460;
    e1.hiriq2d = 1460;
    e1.hiriqhebrew = 1460;
    e1.hiriqnarrowhebrew = 1460;
    e1.hiriqquarterhebrew = 1460;
    e1.hiriqwidehebrew = 1460;
    e1.hlinebelow = 7830;
    e1.hmonospace = 65352;
    e1.hoarmenian = 1392;
    e1.hohipthai = 3627;
    e1.hohiragana = 12411;
    e1.hokatakana = 12507;
    e1.hokatakanahalfwidth = 65422;
    e1.holam = 1465;
    e1.holam19 = 1465;
    e1.holam26 = 1465;
    e1.holam32 = 1465;
    e1.holamhebrew = 1465;
    e1.holamnarrowhebrew = 1465;
    e1.holamquarterhebrew = 1465;
    e1.holamwidehebrew = 1465;
    e1.honokhukthai = 3630;
    e1.hookabovecomb = 777;
    e1.hookcmb = 777;
    e1.hookpalatalizedbelowcmb = 801;
    e1.hookretroflexbelowcmb = 802;
    e1.hoonsquare = 13122;
    e1.horicoptic = 1001;
    e1.horizontalbar = 8213;
    e1.horncmb = 795;
    e1.hotsprings = 9832;
    e1.house = 8962;
    e1.hparen = 9379;
    e1.hsuperior = 688;
    e1.hturned = 613;
    e1.huhiragana = 12405;
    e1.huiitosquare = 13107;
    e1.hukatakana = 12501;
    e1.hukatakanahalfwidth = 65420;
    e1.hungarumlaut = 733;
    e1.hungarumlautcmb = 779;
    e1.hv = 405;
    e1.hyphen = 45;
    e1.hypheninferior = 63205;
    e1.hyphenmonospace = 65293;
    e1.hyphensmall = 65123;
    e1.hyphensuperior = 63206;
    e1.hyphentwo = 8208;
    e1.i = 105;
    e1.iacute = 237;
    e1.iacyrillic = 1103;
    e1.ibengali = 2439;
    e1.ibopomofo = 12583;
    e1.ibreve = 301;
    e1.icaron = 464;
    e1.icircle = 9432;
    e1.icircumflex = 238;
    e1.icyrillic = 1110;
    e1.idblgrave = 521;
    e1.ideographearthcircle = 12943;
    e1.ideographfirecircle = 12939;
    e1.ideographicallianceparen = 12863;
    e1.ideographiccallparen = 12858;
    e1.ideographiccentrecircle = 12965;
    e1.ideographicclose = 12294;
    e1.ideographiccomma = 12289;
    e1.ideographiccommaleft = 65380;
    e1.ideographiccongratulationparen = 12855;
    e1.ideographiccorrectcircle = 12963;
    e1.ideographicearthparen = 12847;
    e1.ideographicenterpriseparen = 12861;
    e1.ideographicexcellentcircle = 12957;
    e1.ideographicfestivalparen = 12864;
    e1.ideographicfinancialcircle = 12950;
    e1.ideographicfinancialparen = 12854;
    e1.ideographicfireparen = 12843;
    e1.ideographichaveparen = 12850;
    e1.ideographichighcircle = 12964;
    e1.ideographiciterationmark = 12293;
    e1.ideographiclaborcircle = 12952;
    e1.ideographiclaborparen = 12856;
    e1.ideographicleftcircle = 12967;
    e1.ideographiclowcircle = 12966;
    e1.ideographicmedicinecircle = 12969;
    e1.ideographicmetalparen = 12846;
    e1.ideographicmoonparen = 12842;
    e1.ideographicnameparen = 12852;
    e1.ideographicperiod = 12290;
    e1.ideographicprintcircle = 12958;
    e1.ideographicreachparen = 12867;
    e1.ideographicrepresentparen = 12857;
    e1.ideographicresourceparen = 12862;
    e1.ideographicrightcircle = 12968;
    e1.ideographicsecretcircle = 12953;
    e1.ideographicselfparen = 12866;
    e1.ideographicsocietyparen = 12851;
    e1.ideographicspace = 12288;
    e1.ideographicspecialparen = 12853;
    e1.ideographicstockparen = 12849;
    e1.ideographicstudyparen = 12859;
    e1.ideographicsunparen = 12848;
    e1.ideographicsuperviseparen = 12860;
    e1.ideographicwaterparen = 12844;
    e1.ideographicwoodparen = 12845;
    e1.ideographiczero = 12295;
    e1.ideographmetalcircle = 12942;
    e1.ideographmooncircle = 12938;
    e1.ideographnamecircle = 12948;
    e1.ideographsuncircle = 12944;
    e1.ideographwatercircle = 12940;
    e1.ideographwoodcircle = 12941;
    e1.ideva = 2311;
    e1.idieresis = 239;
    e1.idieresisacute = 7727;
    e1.idieresiscyrillic = 1253;
    e1.idotbelow = 7883;
    e1.iebrevecyrillic = 1239;
    e1.iecyrillic = 1077;
    e1.ieungacirclekorean = 12917;
    e1.ieungaparenkorean = 12821;
    e1.ieungcirclekorean = 12903;
    e1.ieungkorean = 12615;
    e1.ieungparenkorean = 12807;
    e1.igrave = 236;
    e1.igujarati = 2695;
    e1.igurmukhi = 2567;
    e1.ihiragana = 12356;
    e1.ihookabove = 7881;
    e1.iibengali = 2440;
    e1.iicyrillic = 1080;
    e1.iideva = 2312;
    e1.iigujarati = 2696;
    e1.iigurmukhi = 2568;
    e1.iimatragurmukhi = 2624;
    e1.iinvertedbreve = 523;
    e1.iishortcyrillic = 1081;
    e1.iivowelsignbengali = 2496;
    e1.iivowelsigndeva = 2368;
    e1.iivowelsigngujarati = 2752;
    e1.ij = 307;
    e1.ikatakana = 12452;
    e1.ikatakanahalfwidth = 65394;
    e1.ikorean = 12643;
    e1.ilde = 732;
    e1.iluyhebrew = 1452;
    e1.imacron = 299;
    e1.imacroncyrillic = 1251;
    e1.imageorapproximatelyequal = 8787;
    e1.imatragurmukhi = 2623;
    e1.imonospace = 65353;
    e1.increment = 8710;
    e1.infinity = 8734;
    e1.iniarmenian = 1387;
    e1.integral = 8747;
    e1.integralbottom = 8993;
    e1.integralbt = 8993;
    e1.integralex = 63733;
    e1.integraltop = 8992;
    e1.integraltp = 8992;
    e1.intersection = 8745;
    e1.intisquare = 13061;
    e1.invbullet = 9688;
    e1.invcircle = 9689;
    e1.invsmileface = 9787;
    e1.iocyrillic = 1105;
    e1.iogonek = 303;
    e1.iota = 953;
    e1.iotadieresis = 970;
    e1.iotadieresistonos = 912;
    e1.iotalatin = 617;
    e1.iotatonos = 943;
    e1.iparen = 9380;
    e1.irigurmukhi = 2674;
    e1.ismallhiragana = 12355;
    e1.ismallkatakana = 12451;
    e1.ismallkatakanahalfwidth = 65384;
    e1.issharbengali = 2554;
    e1.istroke = 616;
    e1.isuperior = 63213;
    e1.iterationhiragana = 12445;
    e1.iterationkatakana = 12541;
    e1.itilde = 297;
    e1.itildebelow = 7725;
    e1.iubopomofo = 12585;
    e1.iucyrillic = 1102;
    e1.ivowelsignbengali = 2495;
    e1.ivowelsigndeva = 2367;
    e1.ivowelsigngujarati = 2751;
    e1.izhitsacyrillic = 1141;
    e1.izhitsadblgravecyrillic = 1143;
    e1.j = 106;
    e1.jaarmenian = 1393;
    e1.jabengali = 2460;
    e1.jadeva = 2332;
    e1.jagujarati = 2716;
    e1.jagurmukhi = 2588;
    e1.jbopomofo = 12560;
    e1.jcaron = 496;
    e1.jcircle = 9433;
    e1.jcircumflex = 309;
    e1.jcrossedtail = 669;
    e1.jdotlessstroke = 607;
    e1.jecyrillic = 1112;
    e1.jeemarabic = 1580;
    e1.jeemfinalarabic = 65182;
    e1.jeeminitialarabic = 65183;
    e1.jeemmedialarabic = 65184;
    e1.jeharabic = 1688;
    e1.jehfinalarabic = 64395;
    e1.jhabengali = 2461;
    e1.jhadeva = 2333;
    e1.jhagujarati = 2717;
    e1.jhagurmukhi = 2589;
    e1.jheharmenian = 1403;
    e1.jis = 12292;
    e1.jmonospace = 65354;
    e1.jparen = 9381;
    e1.jsuperior = 690;
    e1.k = 107;
    e1.kabashkircyrillic = 1185;
    e1.kabengali = 2453;
    e1.kacute = 7729;
    e1.kacyrillic = 1082;
    e1.kadescendercyrillic = 1179;
    e1.kadeva = 2325;
    e1.kaf = 1499;
    e1.kafarabic = 1603;
    e1.kafdagesh = 64315;
    e1.kafdageshhebrew = 64315;
    e1.kaffinalarabic = 65242;
    e1.kafhebrew = 1499;
    e1.kafinitialarabic = 65243;
    e1.kafmedialarabic = 65244;
    e1.kafrafehebrew = 64333;
    e1.kagujarati = 2709;
    e1.kagurmukhi = 2581;
    e1.kahiragana = 12363;
    e1.kahookcyrillic = 1220;
    e1.kakatakana = 12459;
    e1.kakatakanahalfwidth = 65398;
    e1.kappa = 954;
    e1.kappasymbolgreek = 1008;
    e1.kapyeounmieumkorean = 12657;
    e1.kapyeounphieuphkorean = 12676;
    e1.kapyeounpieupkorean = 12664;
    e1.kapyeounssangpieupkorean = 12665;
    e1.karoriisquare = 13069;
    e1.kashidaautoarabic = 1600;
    e1.kashidaautonosidebearingarabic = 1600;
    e1.kasmallkatakana = 12533;
    e1.kasquare = 13188;
    e1.kasraarabic = 1616;
    e1.kasratanarabic = 1613;
    e1.kastrokecyrillic = 1183;
    e1.katahiraprolongmarkhalfwidth = 65392;
    e1.kaverticalstrokecyrillic = 1181;
    e1.kbopomofo = 12558;
    e1.kcalsquare = 13193;
    e1.kcaron = 489;
    e1.kcedilla = 311;
    e1.kcircle = 9434;
    e1.kcommaaccent = 311;
    e1.kdotbelow = 7731;
    e1.keharmenian = 1412;
    e1.kehiragana = 12369;
    e1.kekatakana = 12465;
    e1.kekatakanahalfwidth = 65401;
    e1.kenarmenian = 1391;
    e1.kesmallkatakana = 12534;
    e1.kgreenlandic = 312;
    e1.khabengali = 2454;
    e1.khacyrillic = 1093;
    e1.khadeva = 2326;
    e1.khagujarati = 2710;
    e1.khagurmukhi = 2582;
    e1.khaharabic = 1582;
    e1.khahfinalarabic = 65190;
    e1.khahinitialarabic = 65191;
    e1.khahmedialarabic = 65192;
    e1.kheicoptic = 999;
    e1.khhadeva = 2393;
    e1.khhagurmukhi = 2649;
    e1.khieukhacirclekorean = 12920;
    e1.khieukhaparenkorean = 12824;
    e1.khieukhcirclekorean = 12906;
    e1.khieukhkorean = 12619;
    e1.khieukhparenkorean = 12810;
    e1.khokhaithai = 3586;
    e1.khokhonthai = 3589;
    e1.khokhuatthai = 3587;
    e1.khokhwaithai = 3588;
    e1.khomutthai = 3675;
    e1.khook = 409;
    e1.khorakhangthai = 3590;
    e1.khzsquare = 13201;
    e1.kihiragana = 12365;
    e1.kikatakana = 12461;
    e1.kikatakanahalfwidth = 65399;
    e1.kiroguramusquare = 13077;
    e1.kiromeetorusquare = 13078;
    e1.kirosquare = 13076;
    e1.kiyeokacirclekorean = 12910;
    e1.kiyeokaparenkorean = 12814;
    e1.kiyeokcirclekorean = 12896;
    e1.kiyeokkorean = 12593;
    e1.kiyeokparenkorean = 12800;
    e1.kiyeoksioskorean = 12595;
    e1.kjecyrillic = 1116;
    e1.klinebelow = 7733;
    e1.klsquare = 13208;
    e1.kmcubedsquare = 13222;
    e1.kmonospace = 65355;
    e1.kmsquaredsquare = 13218;
    e1.kohiragana = 12371;
    e1.kohmsquare = 13248;
    e1.kokaithai = 3585;
    e1.kokatakana = 12467;
    e1.kokatakanahalfwidth = 65402;
    e1.kooposquare = 13086;
    e1.koppacyrillic = 1153;
    e1.koreanstandardsymbol = 12927;
    e1.koroniscmb = 835;
    e1.kparen = 9382;
    e1.kpasquare = 13226;
    e1.ksicyrillic = 1135;
    e1.ktsquare = 13263;
    e1.kturned = 670;
    e1.kuhiragana = 12367;
    e1.kukatakana = 12463;
    e1.kukatakanahalfwidth = 65400;
    e1.kvsquare = 13240;
    e1.kwsquare = 13246;
    e1.l = 108;
    e1.labengali = 2482;
    e1.lacute = 314;
    e1.ladeva = 2354;
    e1.lagujarati = 2738;
    e1.lagurmukhi = 2610;
    e1.lakkhangyaothai = 3653;
    e1.lamaleffinalarabic = 65276;
    e1.lamalefhamzaabovefinalarabic = 65272;
    e1.lamalefhamzaaboveisolatedarabic = 65271;
    e1.lamalefhamzabelowfinalarabic = 65274;
    e1.lamalefhamzabelowisolatedarabic = 65273;
    e1.lamalefisolatedarabic = 65275;
    e1.lamalefmaddaabovefinalarabic = 65270;
    e1.lamalefmaddaaboveisolatedarabic = 65269;
    e1.lamarabic = 1604;
    e1.lambda = 955;
    e1.lambdastroke = 411;
    e1.lamed = 1500;
    e1.lameddagesh = 64316;
    e1.lameddageshhebrew = 64316;
    e1.lamedhebrew = 1500;
    e1.lamfinalarabic = 65246;
    e1.lamhahinitialarabic = 64714;
    e1.laminitialarabic = 65247;
    e1.lamjeeminitialarabic = 64713;
    e1.lamkhahinitialarabic = 64715;
    e1.lamlamhehisolatedarabic = 65010;
    e1.lammedialarabic = 65248;
    e1.lammeemhahinitialarabic = 64904;
    e1.lammeeminitialarabic = 64716;
    e1.largecircle = 9711;
    e1.lbar = 410;
    e1.lbelt = 620;
    e1.lbopomofo = 12556;
    e1.lcaron = 318;
    e1.lcedilla = 316;
    e1.lcircle = 9435;
    e1.lcircumflexbelow = 7741;
    e1.lcommaaccent = 316;
    e1.ldot = 320;
    e1.ldotaccent = 320;
    e1.ldotbelow = 7735;
    e1.ldotbelowmacron = 7737;
    e1.leftangleabovecmb = 794;
    e1.lefttackbelowcmb = 792;
    e1.less = 60;
    e1.lessequal = 8804;
    e1.lessequalorgreater = 8922;
    e1.lessmonospace = 65308;
    e1.lessorequivalent = 8818;
    e1.lessorgreater = 8822;
    e1.lessoverequal = 8806;
    e1.lesssmall = 65124;
    e1.lezh = 622;
    e1.lfblock = 9612;
    e1.lhookretroflex = 621;
    e1.lira = 8356;
    e1.liwnarmenian = 1388;
    e1.lj = 457;
    e1.ljecyrillic = 1113;
    e1.ll = 63168;
    e1.lladeva = 2355;
    e1.llagujarati = 2739;
    e1.llinebelow = 7739;
    e1.llladeva = 2356;
    e1.llvocalicbengali = 2529;
    e1.llvocalicdeva = 2401;
    e1.llvocalicvowelsignbengali = 2531;
    e1.llvocalicvowelsigndeva = 2403;
    e1.lmiddletilde = 619;
    e1.lmonospace = 65356;
    e1.lmsquare = 13264;
    e1.lochulathai = 3628;
    e1.logicaland = 8743;
    e1.logicalnot = 172;
    e1.logicalnotreversed = 8976;
    e1.logicalor = 8744;
    e1.lolingthai = 3621;
    e1.longs = 383;
    e1.lowlinecenterline = 65102;
    e1.lowlinecmb = 818;
    e1.lowlinedashed = 65101;
    e1.lozenge = 9674;
    e1.lparen = 9383;
    e1.lslash = 322;
    e1.lsquare = 8467;
    e1.lsuperior = 63214;
    e1.ltshade = 9617;
    e1.luthai = 3622;
    e1.lvocalicbengali = 2444;
    e1.lvocalicdeva = 2316;
    e1.lvocalicvowelsignbengali = 2530;
    e1.lvocalicvowelsigndeva = 2402;
    e1.lxsquare = 13267;
    e1.m = 109;
    e1.mabengali = 2478;
    e1.macron = 175;
    e1.macronbelowcmb = 817;
    e1.macroncmb = 772;
    e1.macronlowmod = 717;
    e1.macronmonospace = 65507;
    e1.macute = 7743;
    e1.madeva = 2350;
    e1.magujarati = 2734;
    e1.magurmukhi = 2606;
    e1.mahapakhhebrew = 1444;
    e1.mahapakhlefthebrew = 1444;
    e1.mahiragana = 12414;
    e1.maichattawalowleftthai = 63637;
    e1.maichattawalowrightthai = 63636;
    e1.maichattawathai = 3659;
    e1.maichattawaupperleftthai = 63635;
    e1.maieklowleftthai = 63628;
    e1.maieklowrightthai = 63627;
    e1.maiekthai = 3656;
    e1.maiekupperleftthai = 63626;
    e1.maihanakatleftthai = 63620;
    e1.maihanakatthai = 3633;
    e1.maitaikhuleftthai = 63625;
    e1.maitaikhuthai = 3655;
    e1.maitholowleftthai = 63631;
    e1.maitholowrightthai = 63630;
    e1.maithothai = 3657;
    e1.maithoupperleftthai = 63629;
    e1.maitrilowleftthai = 63634;
    e1.maitrilowrightthai = 63633;
    e1.maitrithai = 3658;
    e1.maitriupperleftthai = 63632;
    e1.maiyamokthai = 3654;
    e1.makatakana = 12510;
    e1.makatakanahalfwidth = 65423;
    e1.male = 9794;
    e1.mansyonsquare = 13127;
    e1.maqafhebrew = 1470;
    e1.mars = 9794;
    e1.masoracirclehebrew = 1455;
    e1.masquare = 13187;
    e1.mbopomofo = 12551;
    e1.mbsquare = 13268;
    e1.mcircle = 9436;
    e1.mcubedsquare = 13221;
    e1.mdotaccent = 7745;
    e1.mdotbelow = 7747;
    e1.meemarabic = 1605;
    e1.meemfinalarabic = 65250;
    e1.meeminitialarabic = 65251;
    e1.meemmedialarabic = 65252;
    e1.meemmeeminitialarabic = 64721;
    e1.meemmeemisolatedarabic = 64584;
    e1.meetorusquare = 13133;
    e1.mehiragana = 12417;
    e1.meizierasquare = 13182;
    e1.mekatakana = 12513;
    e1.mekatakanahalfwidth = 65426;
    e1.mem = 1502;
    e1.memdagesh = 64318;
    e1.memdageshhebrew = 64318;
    e1.memhebrew = 1502;
    e1.menarmenian = 1396;
    e1.merkhahebrew = 1445;
    e1.merkhakefulahebrew = 1446;
    e1.merkhakefulalefthebrew = 1446;
    e1.merkhalefthebrew = 1445;
    e1.mhook = 625;
    e1.mhzsquare = 13202;
    e1.middledotkatakanahalfwidth = 65381;
    e1.middot = 183;
    e1.mieumacirclekorean = 12914;
    e1.mieumaparenkorean = 12818;
    e1.mieumcirclekorean = 12900;
    e1.mieumkorean = 12609;
    e1.mieumpansioskorean = 12656;
    e1.mieumparenkorean = 12804;
    e1.mieumpieupkorean = 12654;
    e1.mieumsioskorean = 12655;
    e1.mihiragana = 12415;
    e1.mikatakana = 12511;
    e1.mikatakanahalfwidth = 65424;
    e1.minus = 8722;
    e1.minusbelowcmb = 800;
    e1.minuscircle = 8854;
    e1.minusmod = 727;
    e1.minusplus = 8723;
    e1.minute = 8242;
    e1.miribaarusquare = 13130;
    e1.mirisquare = 13129;
    e1.mlonglegturned = 624;
    e1.mlsquare = 13206;
    e1.mmcubedsquare = 13219;
    e1.mmonospace = 65357;
    e1.mmsquaredsquare = 13215;
    e1.mohiragana = 12418;
    e1.mohmsquare = 13249;
    e1.mokatakana = 12514;
    e1.mokatakanahalfwidth = 65427;
    e1.molsquare = 13270;
    e1.momathai = 3617;
    e1.moverssquare = 13223;
    e1.moverssquaredsquare = 13224;
    e1.mparen = 9384;
    e1.mpasquare = 13227;
    e1.mssquare = 13235;
    e1.msuperior = 63215;
    e1.mturned = 623;
    e1.mu = 181;
    e1.mu1 = 181;
    e1.muasquare = 13186;
    e1.muchgreater = 8811;
    e1.muchless = 8810;
    e1.mufsquare = 13196;
    e1.mugreek = 956;
    e1.mugsquare = 13197;
    e1.muhiragana = 12416;
    e1.mukatakana = 12512;
    e1.mukatakanahalfwidth = 65425;
    e1.mulsquare = 13205;
    e1.multiply = 215;
    e1.mumsquare = 13211;
    e1.munahhebrew = 1443;
    e1.munahlefthebrew = 1443;
    e1.musicalnote = 9834;
    e1.musicalnotedbl = 9835;
    e1.musicflatsign = 9837;
    e1.musicsharpsign = 9839;
    e1.mussquare = 13234;
    e1.muvsquare = 13238;
    e1.muwsquare = 13244;
    e1.mvmegasquare = 13241;
    e1.mvsquare = 13239;
    e1.mwmegasquare = 13247;
    e1.mwsquare = 13245;
    e1.n = 110;
    e1.nabengali = 2472;
    e1.nabla = 8711;
    e1.nacute = 324;
    e1.nadeva = 2344;
    e1.nagujarati = 2728;
    e1.nagurmukhi = 2600;
    e1.nahiragana = 12394;
    e1.nakatakana = 12490;
    e1.nakatakanahalfwidth = 65413;
    e1.napostrophe = 329;
    e1.nasquare = 13185;
    e1.nbopomofo = 12555;
    e1.nbspace = 160;
    e1.ncaron = 328;
    e1.ncedilla = 326;
    e1.ncircle = 9437;
    e1.ncircumflexbelow = 7755;
    e1.ncommaaccent = 326;
    e1.ndotaccent = 7749;
    e1.ndotbelow = 7751;
    e1.nehiragana = 12397;
    e1.nekatakana = 12493;
    e1.nekatakanahalfwidth = 65416;
    e1.newsheqelsign = 8362;
    e1.nfsquare = 13195;
    e1.ngabengali = 2457;
    e1.ngadeva = 2329;
    e1.ngagujarati = 2713;
    e1.ngagurmukhi = 2585;
    e1.ngonguthai = 3591;
    e1.nhiragana = 12435;
    e1.nhookleft = 626;
    e1.nhookretroflex = 627;
    e1.nieunacirclekorean = 12911;
    e1.nieunaparenkorean = 12815;
    e1.nieuncieuckorean = 12597;
    e1.nieuncirclekorean = 12897;
    e1.nieunhieuhkorean = 12598;
    e1.nieunkorean = 12596;
    e1.nieunpansioskorean = 12648;
    e1.nieunparenkorean = 12801;
    e1.nieunsioskorean = 12647;
    e1.nieuntikeutkorean = 12646;
    e1.nihiragana = 12395;
    e1.nikatakana = 12491;
    e1.nikatakanahalfwidth = 65414;
    e1.nikhahitleftthai = 63641;
    e1.nikhahitthai = 3661;
    e1.nine = 57;
    e1.ninearabic = 1641;
    e1.ninebengali = 2543;
    e1.ninecircle = 9320;
    e1.ninecircleinversesansserif = 10130;
    e1.ninedeva = 2415;
    e1.ninegujarati = 2799;
    e1.ninegurmukhi = 2671;
    e1.ninehackarabic = 1641;
    e1.ninehangzhou = 12329;
    e1.nineideographicparen = 12840;
    e1.nineinferior = 8329;
    e1.ninemonospace = 65305;
    e1.nineoldstyle = 63289;
    e1.nineparen = 9340;
    e1.nineperiod = 9360;
    e1.ninepersian = 1785;
    e1.nineroman = 8568;
    e1.ninesuperior = 8313;
    e1.nineteencircle = 9330;
    e1.nineteenparen = 9350;
    e1.nineteenperiod = 9370;
    e1.ninethai = 3673;
    e1.nj = 460;
    e1.njecyrillic = 1114;
    e1.nkatakana = 12531;
    e1.nkatakanahalfwidth = 65437;
    e1.nlegrightlong = 414;
    e1.nlinebelow = 7753;
    e1.nmonospace = 65358;
    e1.nmsquare = 13210;
    e1.nnabengali = 2467;
    e1.nnadeva = 2339;
    e1.nnagujarati = 2723;
    e1.nnagurmukhi = 2595;
    e1.nnnadeva = 2345;
    e1.nohiragana = 12398;
    e1.nokatakana = 12494;
    e1.nokatakanahalfwidth = 65417;
    e1.nonbreakingspace = 160;
    e1.nonenthai = 3603;
    e1.nonuthai = 3609;
    e1.noonarabic = 1606;
    e1.noonfinalarabic = 65254;
    e1.noonghunnaarabic = 1722;
    e1.noonghunnafinalarabic = 64415;
    e1.nooninitialarabic = 65255;
    e1.noonjeeminitialarabic = 64722;
    e1.noonjeemisolatedarabic = 64587;
    e1.noonmedialarabic = 65256;
    e1.noonmeeminitialarabic = 64725;
    e1.noonmeemisolatedarabic = 64590;
    e1.noonnoonfinalarabic = 64653;
    e1.notcontains = 8716;
    e1.notelement = 8713;
    e1.notelementof = 8713;
    e1.notequal = 8800;
    e1.notgreater = 8815;
    e1.notgreaternorequal = 8817;
    e1.notgreaternorless = 8825;
    e1.notidentical = 8802;
    e1.notless = 8814;
    e1.notlessnorequal = 8816;
    e1.notparallel = 8742;
    e1.notprecedes = 8832;
    e1.notsubset = 8836;
    e1.notsucceeds = 8833;
    e1.notsuperset = 8837;
    e1.nowarmenian = 1398;
    e1.nparen = 9385;
    e1.nssquare = 13233;
    e1.nsuperior = 8319;
    e1.ntilde = 241;
    e1.nu = 957;
    e1.nuhiragana = 12396;
    e1.nukatakana = 12492;
    e1.nukatakanahalfwidth = 65415;
    e1.nuktabengali = 2492;
    e1.nuktadeva = 2364;
    e1.nuktagujarati = 2748;
    e1.nuktagurmukhi = 2620;
    e1.numbersign = 35;
    e1.numbersignmonospace = 65283;
    e1.numbersignsmall = 65119;
    e1.numeralsigngreek = 884;
    e1.numeralsignlowergreek = 885;
    e1.numero = 8470;
    e1.nun = 1504;
    e1.nundagesh = 64320;
    e1.nundageshhebrew = 64320;
    e1.nunhebrew = 1504;
    e1.nvsquare = 13237;
    e1.nwsquare = 13243;
    e1.nyabengali = 2462;
    e1.nyadeva = 2334;
    e1.nyagujarati = 2718;
    e1.nyagurmukhi = 2590;
    e1.o = 111;
    e1.oacute = 243;
    e1.oangthai = 3629;
    e1.obarred = 629;
    e1.obarredcyrillic = 1257;
    e1.obarreddieresiscyrillic = 1259;
    e1.obengali = 2451;
    e1.obopomofo = 12571;
    e1.obreve = 335;
    e1.ocandradeva = 2321;
    e1.ocandragujarati = 2705;
    e1.ocandravowelsigndeva = 2377;
    e1.ocandravowelsigngujarati = 2761;
    e1.ocaron = 466;
    e1.ocircle = 9438;
    e1.ocircumflex = 244;
    e1.ocircumflexacute = 7889;
    e1.ocircumflexdotbelow = 7897;
    e1.ocircumflexgrave = 7891;
    e1.ocircumflexhookabove = 7893;
    e1.ocircumflextilde = 7895;
    e1.ocyrillic = 1086;
    e1.odblacute = 337;
    e1.odblgrave = 525;
    e1.odeva = 2323;
    e1.odieresis = 246;
    e1.odieresiscyrillic = 1255;
    e1.odotbelow = 7885;
    e1.oe = 339;
    e1.oekorean = 12634;
    e1.ogonek = 731;
    e1.ogonekcmb = 808;
    e1.ograve = 242;
    e1.ogujarati = 2707;
    e1.oharmenian = 1413;
    e1.ohiragana = 12362;
    e1.ohookabove = 7887;
    e1.ohorn = 417;
    e1.ohornacute = 7899;
    e1.ohorndotbelow = 7907;
    e1.ohorngrave = 7901;
    e1.ohornhookabove = 7903;
    e1.ohorntilde = 7905;
    e1.ohungarumlaut = 337;
    e1.oi = 419;
    e1.oinvertedbreve = 527;
    e1.okatakana = 12458;
    e1.okatakanahalfwidth = 65397;
    e1.okorean = 12631;
    e1.olehebrew = 1451;
    e1.omacron = 333;
    e1.omacronacute = 7763;
    e1.omacrongrave = 7761;
    e1.omdeva = 2384;
    e1.omega = 969;
    e1.omega1 = 982;
    e1.omegacyrillic = 1121;
    e1.omegalatinclosed = 631;
    e1.omegaroundcyrillic = 1147;
    e1.omegatitlocyrillic = 1149;
    e1.omegatonos = 974;
    e1.omgujarati = 2768;
    e1.omicron = 959;
    e1.omicrontonos = 972;
    e1.omonospace = 65359;
    e1.one = 49;
    e1.onearabic = 1633;
    e1.onebengali = 2535;
    e1.onecircle = 9312;
    e1.onecircleinversesansserif = 10122;
    e1.onedeva = 2407;
    e1.onedotenleader = 8228;
    e1.oneeighth = 8539;
    e1.onefitted = 63196;
    e1.onegujarati = 2791;
    e1.onegurmukhi = 2663;
    e1.onehackarabic = 1633;
    e1.onehalf = 189;
    e1.onehangzhou = 12321;
    e1.oneideographicparen = 12832;
    e1.oneinferior = 8321;
    e1.onemonospace = 65297;
    e1.onenumeratorbengali = 2548;
    e1.oneoldstyle = 63281;
    e1.oneparen = 9332;
    e1.oneperiod = 9352;
    e1.onepersian = 1777;
    e1.onequarter = 188;
    e1.oneroman = 8560;
    e1.onesuperior = 185;
    e1.onethai = 3665;
    e1.onethird = 8531;
    e1.oogonek = 491;
    e1.oogonekmacron = 493;
    e1.oogurmukhi = 2579;
    e1.oomatragurmukhi = 2635;
    e1.oopen = 596;
    e1.oparen = 9386;
    e1.openbullet = 9702;
    e1.option = 8997;
    e1.ordfeminine = 170;
    e1.ordmasculine = 186;
    e1.orthogonal = 8735;
    e1.oshortdeva = 2322;
    e1.oshortvowelsigndeva = 2378;
    e1.oslash = 248;
    e1.oslashacute = 511;
    e1.osmallhiragana = 12361;
    e1.osmallkatakana = 12457;
    e1.osmallkatakanahalfwidth = 65387;
    e1.ostrokeacute = 511;
    e1.osuperior = 63216;
    e1.otcyrillic = 1151;
    e1.otilde = 245;
    e1.otildeacute = 7757;
    e1.otildedieresis = 7759;
    e1.oubopomofo = 12577;
    e1.overline = 8254;
    e1.overlinecenterline = 65098;
    e1.overlinecmb = 773;
    e1.overlinedashed = 65097;
    e1.overlinedblwavy = 65100;
    e1.overlinewavy = 65099;
    e1.overscore = 175;
    e1.ovowelsignbengali = 2507;
    e1.ovowelsigndeva = 2379;
    e1.ovowelsigngujarati = 2763;
    e1.p = 112;
    e1.paampssquare = 13184;
    e1.paasentosquare = 13099;
    e1.pabengali = 2474;
    e1.pacute = 7765;
    e1.padeva = 2346;
    e1.pagedown = 8671;
    e1.pageup = 8670;
    e1.pagujarati = 2730;
    e1.pagurmukhi = 2602;
    e1.pahiragana = 12401;
    e1.paiyannoithai = 3631;
    e1.pakatakana = 12497;
    e1.palatalizationcyrilliccmb = 1156;
    e1.palochkacyrillic = 1216;
    e1.pansioskorean = 12671;
    e1.paragraph = 182;
    e1.parallel = 8741;
    e1.parenleft = 40;
    e1.parenleftaltonearabic = 64830;
    e1.parenleftbt = 63725;
    e1.parenleftex = 63724;
    e1.parenleftinferior = 8333;
    e1.parenleftmonospace = 65288;
    e1.parenleftsmall = 65113;
    e1.parenleftsuperior = 8317;
    e1.parenlefttp = 63723;
    e1.parenleftvertical = 65077;
    e1.parenright = 41;
    e1.parenrightaltonearabic = 64831;
    e1.parenrightbt = 63736;
    e1.parenrightex = 63735;
    e1.parenrightinferior = 8334;
    e1.parenrightmonospace = 65289;
    e1.parenrightsmall = 65114;
    e1.parenrightsuperior = 8318;
    e1.parenrighttp = 63734;
    e1.parenrightvertical = 65078;
    e1.partialdiff = 8706;
    e1.paseqhebrew = 1472;
    e1.pashtahebrew = 1433;
    e1.pasquare = 13225;
    e1.patah = 1463;
    e1.patah11 = 1463;
    e1.patah1d = 1463;
    e1.patah2a = 1463;
    e1.patahhebrew = 1463;
    e1.patahnarrowhebrew = 1463;
    e1.patahquarterhebrew = 1463;
    e1.patahwidehebrew = 1463;
    e1.pazerhebrew = 1441;
    e1.pbopomofo = 12550;
    e1.pcircle = 9439;
    e1.pdotaccent = 7767;
    e1.pe = 1508;
    e1.pecyrillic = 1087;
    e1.pedagesh = 64324;
    e1.pedageshhebrew = 64324;
    e1.peezisquare = 13115;
    e1.pefinaldageshhebrew = 64323;
    e1.peharabic = 1662;
    e1.peharmenian = 1402;
    e1.pehebrew = 1508;
    e1.pehfinalarabic = 64343;
    e1.pehinitialarabic = 64344;
    e1.pehiragana = 12410;
    e1.pehmedialarabic = 64345;
    e1.pekatakana = 12506;
    e1.pemiddlehookcyrillic = 1191;
    e1.perafehebrew = 64334;
    e1.percent = 37;
    e1.percentarabic = 1642;
    e1.percentmonospace = 65285;
    e1.percentsmall = 65130;
    e1.period = 46;
    e1.periodarmenian = 1417;
    e1.periodcentered = 183;
    e1.periodhalfwidth = 65377;
    e1.periodinferior = 63207;
    e1.periodmonospace = 65294;
    e1.periodsmall = 65106;
    e1.periodsuperior = 63208;
    e1.perispomenigreekcmb = 834;
    e1.perpendicular = 8869;
    e1.perthousand = 8240;
    e1.peseta = 8359;
    e1.pfsquare = 13194;
    e1.phabengali = 2475;
    e1.phadeva = 2347;
    e1.phagujarati = 2731;
    e1.phagurmukhi = 2603;
    e1.phi = 966;
    e1.phi1 = 981;
    e1.phieuphacirclekorean = 12922;
    e1.phieuphaparenkorean = 12826;
    e1.phieuphcirclekorean = 12908;
    e1.phieuphkorean = 12621;
    e1.phieuphparenkorean = 12812;
    e1.philatin = 632;
    e1.phinthuthai = 3642;
    e1.phisymbolgreek = 981;
    e1.phook = 421;
    e1.phophanthai = 3614;
    e1.phophungthai = 3612;
    e1.phosamphaothai = 3616;
    e1.pi = 960;
    e1.pieupacirclekorean = 12915;
    e1.pieupaparenkorean = 12819;
    e1.pieupcieuckorean = 12662;
    e1.pieupcirclekorean = 12901;
    e1.pieupkiyeokkorean = 12658;
    e1.pieupkorean = 12610;
    e1.pieupparenkorean = 12805;
    e1.pieupsioskiyeokkorean = 12660;
    e1.pieupsioskorean = 12612;
    e1.pieupsiostikeutkorean = 12661;
    e1.pieupthieuthkorean = 12663;
    e1.pieuptikeutkorean = 12659;
    e1.pihiragana = 12404;
    e1.pikatakana = 12500;
    e1.pisymbolgreek = 982;
    e1.piwrarmenian = 1411;
    e1.planckover2pi = 8463;
    e1.planckover2pi1 = 8463;
    e1.plus = 43;
    e1.plusbelowcmb = 799;
    e1.pluscircle = 8853;
    e1.plusminus = 177;
    e1.plusmod = 726;
    e1.plusmonospace = 65291;
    e1.plussmall = 65122;
    e1.plussuperior = 8314;
    e1.pmonospace = 65360;
    e1.pmsquare = 13272;
    e1.pohiragana = 12413;
    e1.pointingindexdownwhite = 9759;
    e1.pointingindexleftwhite = 9756;
    e1.pointingindexrightwhite = 9758;
    e1.pointingindexupwhite = 9757;
    e1.pokatakana = 12509;
    e1.poplathai = 3611;
    e1.postalmark = 12306;
    e1.postalmarkface = 12320;
    e1.pparen = 9387;
    e1.precedes = 8826;
    e1.prescription = 8478;
    e1.primemod = 697;
    e1.primereversed = 8245;
    e1.product = 8719;
    e1.projective = 8965;
    e1.prolongedkana = 12540;
    e1.propellor = 8984;
    e1.propersubset = 8834;
    e1.propersuperset = 8835;
    e1.proportion = 8759;
    e1.proportional = 8733;
    e1.psi = 968;
    e1.psicyrillic = 1137;
    e1.psilipneumatacyrilliccmb = 1158;
    e1.pssquare = 13232;
    e1.puhiragana = 12407;
    e1.pukatakana = 12503;
    e1.pvsquare = 13236;
    e1.pwsquare = 13242;
    e1.q = 113;
    e1.qadeva = 2392;
    e1.qadmahebrew = 1448;
    e1.qafarabic = 1602;
    e1.qaffinalarabic = 65238;
    e1.qafinitialarabic = 65239;
    e1.qafmedialarabic = 65240;
    e1.qamats = 1464;
    e1.qamats10 = 1464;
    e1.qamats1a = 1464;
    e1.qamats1c = 1464;
    e1.qamats27 = 1464;
    e1.qamats29 = 1464;
    e1.qamats33 = 1464;
    e1.qamatsde = 1464;
    e1.qamatshebrew = 1464;
    e1.qamatsnarrowhebrew = 1464;
    e1.qamatsqatanhebrew = 1464;
    e1.qamatsqatannarrowhebrew = 1464;
    e1.qamatsqatanquarterhebrew = 1464;
    e1.qamatsqatanwidehebrew = 1464;
    e1.qamatsquarterhebrew = 1464;
    e1.qamatswidehebrew = 1464;
    e1.qarneyparahebrew = 1439;
    e1.qbopomofo = 12561;
    e1.qcircle = 9440;
    e1.qhook = 672;
    e1.qmonospace = 65361;
    e1.qof = 1511;
    e1.qofdagesh = 64327;
    e1.qofdageshhebrew = 64327;
    e1.qofhebrew = 1511;
    e1.qparen = 9388;
    e1.quarternote = 9833;
    e1.qubuts = 1467;
    e1.qubuts18 = 1467;
    e1.qubuts25 = 1467;
    e1.qubuts31 = 1467;
    e1.qubutshebrew = 1467;
    e1.qubutsnarrowhebrew = 1467;
    e1.qubutsquarterhebrew = 1467;
    e1.qubutswidehebrew = 1467;
    e1.question = 63;
    e1.questionarabic = 1567;
    e1.questionarmenian = 1374;
    e1.questiondown = 191;
    e1.questiondownsmall = 63423;
    e1.questiongreek = 894;
    e1.questionmonospace = 65311;
    e1.questionsmall = 63295;
    e1.quotedbl = 34;
    e1.quotedblbase = 8222;
    e1.quotedblleft = 8220;
    e1.quotedblmonospace = 65282;
    e1.quotedblprime = 12318;
    e1.quotedblprimereversed = 12317;
    e1.quotedblright = 8221;
    e1.quoteleft = 8216;
    e1.quoteleftreversed = 8219;
    e1.quotereversed = 8219;
    e1.quoteright = 8217;
    e1.quoterightn = 329;
    e1.quotesinglbase = 8218;
    e1.quotesingle = 39;
    e1.quotesinglemonospace = 65287;
    e1.r = 114;
    e1.raarmenian = 1404;
    e1.rabengali = 2480;
    e1.racute = 341;
    e1.radeva = 2352;
    e1.radical = 8730;
    e1.radicalex = 63717;
    e1.radoverssquare = 13230;
    e1.radoverssquaredsquare = 13231;
    e1.radsquare = 13229;
    e1.rafe = 1471;
    e1.rafehebrew = 1471;
    e1.ragujarati = 2736;
    e1.ragurmukhi = 2608;
    e1.rahiragana = 12425;
    e1.rakatakana = 12521;
    e1.rakatakanahalfwidth = 65431;
    e1.ralowerdiagonalbengali = 2545;
    e1.ramiddlediagonalbengali = 2544;
    e1.ramshorn = 612;
    e1.ratio = 8758;
    e1.rbopomofo = 12566;
    e1.rcaron = 345;
    e1.rcedilla = 343;
    e1.rcircle = 9441;
    e1.rcommaaccent = 343;
    e1.rdblgrave = 529;
    e1.rdotaccent = 7769;
    e1.rdotbelow = 7771;
    e1.rdotbelowmacron = 7773;
    e1.referencemark = 8251;
    e1.reflexsubset = 8838;
    e1.reflexsuperset = 8839;
    e1.registered = 174;
    e1.registersans = 63720;
    e1.registerserif = 63194;
    e1.reharabic = 1585;
    e1.reharmenian = 1408;
    e1.rehfinalarabic = 65198;
    e1.rehiragana = 12428;
    e1.rekatakana = 12524;
    e1.rekatakanahalfwidth = 65434;
    e1.resh = 1512;
    e1.reshdageshhebrew = 64328;
    e1.reshhebrew = 1512;
    e1.reversedtilde = 8765;
    e1.reviahebrew = 1431;
    e1.reviamugrashhebrew = 1431;
    e1.revlogicalnot = 8976;
    e1.rfishhook = 638;
    e1.rfishhookreversed = 639;
    e1.rhabengali = 2525;
    e1.rhadeva = 2397;
    e1.rho = 961;
    e1.rhook = 637;
    e1.rhookturned = 635;
    e1.rhookturnedsuperior = 693;
    e1.rhosymbolgreek = 1009;
    e1.rhotichookmod = 734;
    e1.rieulacirclekorean = 12913;
    e1.rieulaparenkorean = 12817;
    e1.rieulcirclekorean = 12899;
    e1.rieulhieuhkorean = 12608;
    e1.rieulkiyeokkorean = 12602;
    e1.rieulkiyeoksioskorean = 12649;
    e1.rieulkorean = 12601;
    e1.rieulmieumkorean = 12603;
    e1.rieulpansioskorean = 12652;
    e1.rieulparenkorean = 12803;
    e1.rieulphieuphkorean = 12607;
    e1.rieulpieupkorean = 12604;
    e1.rieulpieupsioskorean = 12651;
    e1.rieulsioskorean = 12605;
    e1.rieulthieuthkorean = 12606;
    e1.rieultikeutkorean = 12650;
    e1.rieulyeorinhieuhkorean = 12653;
    e1.rightangle = 8735;
    e1.righttackbelowcmb = 793;
    e1.righttriangle = 8895;
    e1.rihiragana = 12426;
    e1.rikatakana = 12522;
    e1.rikatakanahalfwidth = 65432;
    e1.ring = 730;
    e1.ringbelowcmb = 805;
    e1.ringcmb = 778;
    e1.ringhalfleft = 703;
    e1.ringhalfleftarmenian = 1369;
    e1.ringhalfleftbelowcmb = 796;
    e1.ringhalfleftcentered = 723;
    e1.ringhalfright = 702;
    e1.ringhalfrightbelowcmb = 825;
    e1.ringhalfrightcentered = 722;
    e1.rinvertedbreve = 531;
    e1.rittorusquare = 13137;
    e1.rlinebelow = 7775;
    e1.rlongleg = 636;
    e1.rlonglegturned = 634;
    e1.rmonospace = 65362;
    e1.rohiragana = 12429;
    e1.rokatakana = 12525;
    e1.rokatakanahalfwidth = 65435;
    e1.roruathai = 3619;
    e1.rparen = 9389;
    e1.rrabengali = 2524;
    e1.rradeva = 2353;
    e1.rragurmukhi = 2652;
    e1.rreharabic = 1681;
    e1.rrehfinalarabic = 64397;
    e1.rrvocalicbengali = 2528;
    e1.rrvocalicdeva = 2400;
    e1.rrvocalicgujarati = 2784;
    e1.rrvocalicvowelsignbengali = 2500;
    e1.rrvocalicvowelsigndeva = 2372;
    e1.rrvocalicvowelsigngujarati = 2756;
    e1.rsuperior = 63217;
    e1.rtblock = 9616;
    e1.rturned = 633;
    e1.rturnedsuperior = 692;
    e1.ruhiragana = 12427;
    e1.rukatakana = 12523;
    e1.rukatakanahalfwidth = 65433;
    e1.rupeemarkbengali = 2546;
    e1.rupeesignbengali = 2547;
    e1.rupiah = 63197;
    e1.ruthai = 3620;
    e1.rvocalicbengali = 2443;
    e1.rvocalicdeva = 2315;
    e1.rvocalicgujarati = 2699;
    e1.rvocalicvowelsignbengali = 2499;
    e1.rvocalicvowelsigndeva = 2371;
    e1.rvocalicvowelsigngujarati = 2755;
    e1.s = 115;
    e1.sabengali = 2488;
    e1.sacute = 347;
    e1.sacutedotaccent = 7781;
    e1.sadarabic = 1589;
    e1.sadeva = 2360;
    e1.sadfinalarabic = 65210;
    e1.sadinitialarabic = 65211;
    e1.sadmedialarabic = 65212;
    e1.sagujarati = 2744;
    e1.sagurmukhi = 2616;
    e1.sahiragana = 12373;
    e1.sakatakana = 12469;
    e1.sakatakanahalfwidth = 65403;
    e1.sallallahoualayhewasallamarabic = 65018;
    e1.samekh = 1505;
    e1.samekhdagesh = 64321;
    e1.samekhdageshhebrew = 64321;
    e1.samekhhebrew = 1505;
    e1.saraaathai = 3634;
    e1.saraaethai = 3649;
    e1.saraaimaimalaithai = 3652;
    e1.saraaimaimuanthai = 3651;
    e1.saraamthai = 3635;
    e1.saraathai = 3632;
    e1.saraethai = 3648;
    e1.saraiileftthai = 63622;
    e1.saraiithai = 3637;
    e1.saraileftthai = 63621;
    e1.saraithai = 3636;
    e1.saraothai = 3650;
    e1.saraueeleftthai = 63624;
    e1.saraueethai = 3639;
    e1.saraueleftthai = 63623;
    e1.sarauethai = 3638;
    e1.sarauthai = 3640;
    e1.sarauuthai = 3641;
    e1.sbopomofo = 12569;
    e1.scaron = 353;
    e1.scarondotaccent = 7783;
    e1.scedilla = 351;
    e1.schwa = 601;
    e1.schwacyrillic = 1241;
    e1.schwadieresiscyrillic = 1243;
    e1.schwahook = 602;
    e1.scircle = 9442;
    e1.scircumflex = 349;
    e1.scommaaccent = 537;
    e1.sdotaccent = 7777;
    e1.sdotbelow = 7779;
    e1.sdotbelowdotaccent = 7785;
    e1.seagullbelowcmb = 828;
    e1.second = 8243;
    e1.secondtonechinese = 714;
    e1.section = 167;
    e1.seenarabic = 1587;
    e1.seenfinalarabic = 65202;
    e1.seeninitialarabic = 65203;
    e1.seenmedialarabic = 65204;
    e1.segol = 1462;
    e1.segol13 = 1462;
    e1.segol1f = 1462;
    e1.segol2c = 1462;
    e1.segolhebrew = 1462;
    e1.segolnarrowhebrew = 1462;
    e1.segolquarterhebrew = 1462;
    e1.segoltahebrew = 1426;
    e1.segolwidehebrew = 1462;
    e1.seharmenian = 1405;
    e1.sehiragana = 12379;
    e1.sekatakana = 12475;
    e1.sekatakanahalfwidth = 65406;
    e1.semicolon = 59;
    e1.semicolonarabic = 1563;
    e1.semicolonmonospace = 65307;
    e1.semicolonsmall = 65108;
    e1.semivoicedmarkkana = 12444;
    e1.semivoicedmarkkanahalfwidth = 65439;
    e1.sentisquare = 13090;
    e1.sentosquare = 13091;
    e1.seven = 55;
    e1.sevenarabic = 1639;
    e1.sevenbengali = 2541;
    e1.sevencircle = 9318;
    e1.sevencircleinversesansserif = 10128;
    e1.sevendeva = 2413;
    e1.seveneighths = 8542;
    e1.sevengujarati = 2797;
    e1.sevengurmukhi = 2669;
    e1.sevenhackarabic = 1639;
    e1.sevenhangzhou = 12327;
    e1.sevenideographicparen = 12838;
    e1.seveninferior = 8327;
    e1.sevenmonospace = 65303;
    e1.sevenoldstyle = 63287;
    e1.sevenparen = 9338;
    e1.sevenperiod = 9358;
    e1.sevenpersian = 1783;
    e1.sevenroman = 8566;
    e1.sevensuperior = 8311;
    e1.seventeencircle = 9328;
    e1.seventeenparen = 9348;
    e1.seventeenperiod = 9368;
    e1.seventhai = 3671;
    e1.sfthyphen = 173;
    e1.shaarmenian = 1399;
    e1.shabengali = 2486;
    e1.shacyrillic = 1096;
    e1.shaddaarabic = 1617;
    e1.shaddadammaarabic = 64609;
    e1.shaddadammatanarabic = 64606;
    e1.shaddafathaarabic = 64608;
    e1.shaddakasraarabic = 64610;
    e1.shaddakasratanarabic = 64607;
    e1.shade = 9618;
    e1.shadedark = 9619;
    e1.shadelight = 9617;
    e1.shademedium = 9618;
    e1.shadeva = 2358;
    e1.shagujarati = 2742;
    e1.shagurmukhi = 2614;
    e1.shalshelethebrew = 1427;
    e1.shbopomofo = 12565;
    e1.shchacyrillic = 1097;
    e1.sheenarabic = 1588;
    e1.sheenfinalarabic = 65206;
    e1.sheeninitialarabic = 65207;
    e1.sheenmedialarabic = 65208;
    e1.sheicoptic = 995;
    e1.sheqel = 8362;
    e1.sheqelhebrew = 8362;
    e1.sheva = 1456;
    e1.sheva115 = 1456;
    e1.sheva15 = 1456;
    e1.sheva22 = 1456;
    e1.sheva2e = 1456;
    e1.shevahebrew = 1456;
    e1.shevanarrowhebrew = 1456;
    e1.shevaquarterhebrew = 1456;
    e1.shevawidehebrew = 1456;
    e1.shhacyrillic = 1211;
    e1.shimacoptic = 1005;
    e1.shin = 1513;
    e1.shindagesh = 64329;
    e1.shindageshhebrew = 64329;
    e1.shindageshshindot = 64300;
    e1.shindageshshindothebrew = 64300;
    e1.shindageshsindot = 64301;
    e1.shindageshsindothebrew = 64301;
    e1.shindothebrew = 1473;
    e1.shinhebrew = 1513;
    e1.shinshindot = 64298;
    e1.shinshindothebrew = 64298;
    e1.shinsindot = 64299;
    e1.shinsindothebrew = 64299;
    e1.shook = 642;
    e1.sigma = 963;
    e1.sigma1 = 962;
    e1.sigmafinal = 962;
    e1.sigmalunatesymbolgreek = 1010;
    e1.sihiragana = 12375;
    e1.sikatakana = 12471;
    e1.sikatakanahalfwidth = 65404;
    e1.siluqhebrew = 1469;
    e1.siluqlefthebrew = 1469;
    e1.similar = 8764;
    e1.sindothebrew = 1474;
    e1.siosacirclekorean = 12916;
    e1.siosaparenkorean = 12820;
    e1.sioscieuckorean = 12670;
    e1.sioscirclekorean = 12902;
    e1.sioskiyeokkorean = 12666;
    e1.sioskorean = 12613;
    e1.siosnieunkorean = 12667;
    e1.siosparenkorean = 12806;
    e1.siospieupkorean = 12669;
    e1.siostikeutkorean = 12668;
    e1.six = 54;
    e1.sixarabic = 1638;
    e1.sixbengali = 2540;
    e1.sixcircle = 9317;
    e1.sixcircleinversesansserif = 10127;
    e1.sixdeva = 2412;
    e1.sixgujarati = 2796;
    e1.sixgurmukhi = 2668;
    e1.sixhackarabic = 1638;
    e1.sixhangzhou = 12326;
    e1.sixideographicparen = 12837;
    e1.sixinferior = 8326;
    e1.sixmonospace = 65302;
    e1.sixoldstyle = 63286;
    e1.sixparen = 9337;
    e1.sixperiod = 9357;
    e1.sixpersian = 1782;
    e1.sixroman = 8565;
    e1.sixsuperior = 8310;
    e1.sixteencircle = 9327;
    e1.sixteencurrencydenominatorbengali = 2553;
    e1.sixteenparen = 9347;
    e1.sixteenperiod = 9367;
    e1.sixthai = 3670;
    e1.slash = 47;
    e1.slashmonospace = 65295;
    e1.slong = 383;
    e1.slongdotaccent = 7835;
    e1.smileface = 9786;
    e1.smonospace = 65363;
    e1.sofpasuqhebrew = 1475;
    e1.softhyphen = 173;
    e1.softsigncyrillic = 1100;
    e1.sohiragana = 12381;
    e1.sokatakana = 12477;
    e1.sokatakanahalfwidth = 65407;
    e1.soliduslongoverlaycmb = 824;
    e1.solidusshortoverlaycmb = 823;
    e1.sorusithai = 3625;
    e1.sosalathai = 3624;
    e1.sosothai = 3595;
    e1.sosuathai = 3626;
    e1.space = 32;
    e1.spacehackarabic = 32;
    e1.spade = 9824;
    e1.spadesuitblack = 9824;
    e1.spadesuitwhite = 9828;
    e1.sparen = 9390;
    e1.squarebelowcmb = 827;
    e1.squarecc = 13252;
    e1.squarecm = 13213;
    e1.squarediagonalcrosshatchfill = 9641;
    e1.squarehorizontalfill = 9636;
    e1.squarekg = 13199;
    e1.squarekm = 13214;
    e1.squarekmcapital = 13262;
    e1.squareln = 13265;
    e1.squarelog = 13266;
    e1.squaremg = 13198;
    e1.squaremil = 13269;
    e1.squaremm = 13212;
    e1.squaremsquared = 13217;
    e1.squareorthogonalcrosshatchfill = 9638;
    e1.squareupperlefttolowerrightfill = 9639;
    e1.squareupperrighttolowerleftfill = 9640;
    e1.squareverticalfill = 9637;
    e1.squarewhitewithsmallblack = 9635;
    e1.srsquare = 13275;
    e1.ssabengali = 2487;
    e1.ssadeva = 2359;
    e1.ssagujarati = 2743;
    e1.ssangcieuckorean = 12617;
    e1.ssanghieuhkorean = 12677;
    e1.ssangieungkorean = 12672;
    e1.ssangkiyeokkorean = 12594;
    e1.ssangnieunkorean = 12645;
    e1.ssangpieupkorean = 12611;
    e1.ssangsioskorean = 12614;
    e1.ssangtikeutkorean = 12600;
    e1.ssuperior = 63218;
    e1.sterling = 163;
    e1.sterlingmonospace = 65505;
    e1.strokelongoverlaycmb = 822;
    e1.strokeshortoverlaycmb = 821;
    e1.subset = 8834;
    e1.subsetnotequal = 8842;
    e1.subsetorequal = 8838;
    e1.succeeds = 8827;
    e1.suchthat = 8715;
    e1.suhiragana = 12377;
    e1.sukatakana = 12473;
    e1.sukatakanahalfwidth = 65405;
    e1.sukunarabic = 1618;
    e1.summation = 8721;
    e1.sun = 9788;
    e1.superset = 8835;
    e1.supersetnotequal = 8843;
    e1.supersetorequal = 8839;
    e1.svsquare = 13276;
    e1.syouwaerasquare = 13180;
    e1.t = 116;
    e1.tabengali = 2468;
    e1.tackdown = 8868;
    e1.tackleft = 8867;
    e1.tadeva = 2340;
    e1.tagujarati = 2724;
    e1.tagurmukhi = 2596;
    e1.taharabic = 1591;
    e1.tahfinalarabic = 65218;
    e1.tahinitialarabic = 65219;
    e1.tahiragana = 12383;
    e1.tahmedialarabic = 65220;
    e1.taisyouerasquare = 13181;
    e1.takatakana = 12479;
    e1.takatakanahalfwidth = 65408;
    e1.tatweelarabic = 1600;
    e1.tau = 964;
    e1.tav = 1514;
    e1.tavdages = 64330;
    e1.tavdagesh = 64330;
    e1.tavdageshhebrew = 64330;
    e1.tavhebrew = 1514;
    e1.tbar = 359;
    e1.tbopomofo = 12554;
    e1.tcaron = 357;
    e1.tccurl = 680;
    e1.tcedilla = 355;
    e1.tcheharabic = 1670;
    e1.tchehfinalarabic = 64379;
    e1.tchehinitialarabic = 64380;
    e1.tchehmedialarabic = 64381;
    e1.tcircle = 9443;
    e1.tcircumflexbelow = 7793;
    e1.tcommaaccent = 355;
    e1.tdieresis = 7831;
    e1.tdotaccent = 7787;
    e1.tdotbelow = 7789;
    e1.tecyrillic = 1090;
    e1.tedescendercyrillic = 1197;
    e1.teharabic = 1578;
    e1.tehfinalarabic = 65174;
    e1.tehhahinitialarabic = 64674;
    e1.tehhahisolatedarabic = 64524;
    e1.tehinitialarabic = 65175;
    e1.tehiragana = 12390;
    e1.tehjeeminitialarabic = 64673;
    e1.tehjeemisolatedarabic = 64523;
    e1.tehmarbutaarabic = 1577;
    e1.tehmarbutafinalarabic = 65172;
    e1.tehmedialarabic = 65176;
    e1.tehmeeminitialarabic = 64676;
    e1.tehmeemisolatedarabic = 64526;
    e1.tehnoonfinalarabic = 64627;
    e1.tekatakana = 12486;
    e1.tekatakanahalfwidth = 65411;
    e1.telephone = 8481;
    e1.telephoneblack = 9742;
    e1.telishagedolahebrew = 1440;
    e1.telishaqetanahebrew = 1449;
    e1.tencircle = 9321;
    e1.tenideographicparen = 12841;
    e1.tenparen = 9341;
    e1.tenperiod = 9361;
    e1.tenroman = 8569;
    e1.tesh = 679;
    e1.tet = 1496;
    e1.tetdagesh = 64312;
    e1.tetdageshhebrew = 64312;
    e1.tethebrew = 1496;
    e1.tetsecyrillic = 1205;
    e1.tevirhebrew = 1435;
    e1.tevirlefthebrew = 1435;
    e1.thabengali = 2469;
    e1.thadeva = 2341;
    e1.thagujarati = 2725;
    e1.thagurmukhi = 2597;
    e1.thalarabic = 1584;
    e1.thalfinalarabic = 65196;
    e1.thanthakhatlowleftthai = 63640;
    e1.thanthakhatlowrightthai = 63639;
    e1.thanthakhatthai = 3660;
    e1.thanthakhatupperleftthai = 63638;
    e1.theharabic = 1579;
    e1.thehfinalarabic = 65178;
    e1.thehinitialarabic = 65179;
    e1.thehmedialarabic = 65180;
    e1.thereexists = 8707;
    e1.therefore = 8756;
    e1.theta = 952;
    e1.theta1 = 977;
    e1.thetasymbolgreek = 977;
    e1.thieuthacirclekorean = 12921;
    e1.thieuthaparenkorean = 12825;
    e1.thieuthcirclekorean = 12907;
    e1.thieuthkorean = 12620;
    e1.thieuthparenkorean = 12811;
    e1.thirteencircle = 9324;
    e1.thirteenparen = 9344;
    e1.thirteenperiod = 9364;
    e1.thonangmonthothai = 3601;
    e1.thook = 429;
    e1.thophuthaothai = 3602;
    e1.thorn = 254;
    e1.thothahanthai = 3607;
    e1.thothanthai = 3600;
    e1.thothongthai = 3608;
    e1.thothungthai = 3606;
    e1.thousandcyrillic = 1154;
    e1.thousandsseparatorarabic = 1644;
    e1.thousandsseparatorpersian = 1644;
    e1.three = 51;
    e1.threearabic = 1635;
    e1.threebengali = 2537;
    e1.threecircle = 9314;
    e1.threecircleinversesansserif = 10124;
    e1.threedeva = 2409;
    e1.threeeighths = 8540;
    e1.threegujarati = 2793;
    e1.threegurmukhi = 2665;
    e1.threehackarabic = 1635;
    e1.threehangzhou = 12323;
    e1.threeideographicparen = 12834;
    e1.threeinferior = 8323;
    e1.threemonospace = 65299;
    e1.threenumeratorbengali = 2550;
    e1.threeoldstyle = 63283;
    e1.threeparen = 9334;
    e1.threeperiod = 9354;
    e1.threepersian = 1779;
    e1.threequarters = 190;
    e1.threequartersemdash = 63198;
    e1.threeroman = 8562;
    e1.threesuperior = 179;
    e1.threethai = 3667;
    e1.thzsquare = 13204;
    e1.tihiragana = 12385;
    e1.tikatakana = 12481;
    e1.tikatakanahalfwidth = 65409;
    e1.tikeutacirclekorean = 12912;
    e1.tikeutaparenkorean = 12816;
    e1.tikeutcirclekorean = 12898;
    e1.tikeutkorean = 12599;
    e1.tikeutparenkorean = 12802;
    e1.tilde = 732;
    e1.tildebelowcmb = 816;
    e1.tildecmb = 771;
    e1.tildecomb = 771;
    e1.tildedoublecmb = 864;
    e1.tildeoperator = 8764;
    e1.tildeoverlaycmb = 820;
    e1.tildeverticalcmb = 830;
    e1.timescircle = 8855;
    e1.tipehahebrew = 1430;
    e1.tipehalefthebrew = 1430;
    e1.tippigurmukhi = 2672;
    e1.titlocyrilliccmb = 1155;
    e1.tiwnarmenian = 1407;
    e1.tlinebelow = 7791;
    e1.tmonospace = 65364;
    e1.toarmenian = 1385;
    e1.tohiragana = 12392;
    e1.tokatakana = 12488;
    e1.tokatakanahalfwidth = 65412;
    e1.tonebarextrahighmod = 741;
    e1.tonebarextralowmod = 745;
    e1.tonebarhighmod = 742;
    e1.tonebarlowmod = 744;
    e1.tonebarmidmod = 743;
    e1.tonefive = 445;
    e1.tonesix = 389;
    e1.tonetwo = 424;
    e1.tonos = 900;
    e1.tonsquare = 13095;
    e1.topatakthai = 3599;
    e1.tortoiseshellbracketleft = 12308;
    e1.tortoiseshellbracketleftsmall = 65117;
    e1.tortoiseshellbracketleftvertical = 65081;
    e1.tortoiseshellbracketright = 12309;
    e1.tortoiseshellbracketrightsmall = 65118;
    e1.tortoiseshellbracketrightvertical = 65082;
    e1.totaothai = 3605;
    e1.tpalatalhook = 427;
    e1.tparen = 9391;
    e1.trademark = 8482;
    e1.trademarksans = 63722;
    e1.trademarkserif = 63195;
    e1.tretroflexhook = 648;
    e1.triagdn = 9660;
    e1.triaglf = 9668;
    e1.triagrt = 9658;
    e1.triagup = 9650;
    e1.ts = 678;
    e1.tsadi = 1510;
    e1.tsadidagesh = 64326;
    e1.tsadidageshhebrew = 64326;
    e1.tsadihebrew = 1510;
    e1.tsecyrillic = 1094;
    e1.tsere = 1461;
    e1.tsere12 = 1461;
    e1.tsere1e = 1461;
    e1.tsere2b = 1461;
    e1.tserehebrew = 1461;
    e1.tserenarrowhebrew = 1461;
    e1.tserequarterhebrew = 1461;
    e1.tserewidehebrew = 1461;
    e1.tshecyrillic = 1115;
    e1.tsuperior = 63219;
    e1.ttabengali = 2463;
    e1.ttadeva = 2335;
    e1.ttagujarati = 2719;
    e1.ttagurmukhi = 2591;
    e1.tteharabic = 1657;
    e1.ttehfinalarabic = 64359;
    e1.ttehinitialarabic = 64360;
    e1.ttehmedialarabic = 64361;
    e1.tthabengali = 2464;
    e1.tthadeva = 2336;
    e1.tthagujarati = 2720;
    e1.tthagurmukhi = 2592;
    e1.tturned = 647;
    e1.tuhiragana = 12388;
    e1.tukatakana = 12484;
    e1.tukatakanahalfwidth = 65410;
    e1.tusmallhiragana = 12387;
    e1.tusmallkatakana = 12483;
    e1.tusmallkatakanahalfwidth = 65391;
    e1.twelvecircle = 9323;
    e1.twelveparen = 9343;
    e1.twelveperiod = 9363;
    e1.twelveroman = 8571;
    e1.twentycircle = 9331;
    e1.twentyhangzhou = 21316;
    e1.twentyparen = 9351;
    e1.twentyperiod = 9371;
    e1.two = 50;
    e1.twoarabic = 1634;
    e1.twobengali = 2536;
    e1.twocircle = 9313;
    e1.twocircleinversesansserif = 10123;
    e1.twodeva = 2408;
    e1.twodotenleader = 8229;
    e1.twodotleader = 8229;
    e1.twodotleadervertical = 65072;
    e1.twogujarati = 2792;
    e1.twogurmukhi = 2664;
    e1.twohackarabic = 1634;
    e1.twohangzhou = 12322;
    e1.twoideographicparen = 12833;
    e1.twoinferior = 8322;
    e1.twomonospace = 65298;
    e1.twonumeratorbengali = 2549;
    e1.twooldstyle = 63282;
    e1.twoparen = 9333;
    e1.twoperiod = 9353;
    e1.twopersian = 1778;
    e1.tworoman = 8561;
    e1.twostroke = 443;
    e1.twosuperior = 178;
    e1.twothai = 3666;
    e1.twothirds = 8532;
    e1.u = 117;
    e1.uacute = 250;
    e1.ubar = 649;
    e1.ubengali = 2441;
    e1.ubopomofo = 12584;
    e1.ubreve = 365;
    e1.ucaron = 468;
    e1.ucircle = 9444;
    e1.ucircumflex = 251;
    e1.ucircumflexbelow = 7799;
    e1.ucyrillic = 1091;
    e1.udattadeva = 2385;
    e1.udblacute = 369;
    e1.udblgrave = 533;
    e1.udeva = 2313;
    e1.udieresis = 252;
    e1.udieresisacute = 472;
    e1.udieresisbelow = 7795;
    e1.udieresiscaron = 474;
    e1.udieresiscyrillic = 1265;
    e1.udieresisgrave = 476;
    e1.udieresismacron = 470;
    e1.udotbelow = 7909;
    e1.ugrave = 249;
    e1.ugujarati = 2697;
    e1.ugurmukhi = 2569;
    e1.uhiragana = 12358;
    e1.uhookabove = 7911;
    e1.uhorn = 432;
    e1.uhornacute = 7913;
    e1.uhorndotbelow = 7921;
    e1.uhorngrave = 7915;
    e1.uhornhookabove = 7917;
    e1.uhorntilde = 7919;
    e1.uhungarumlaut = 369;
    e1.uhungarumlautcyrillic = 1267;
    e1.uinvertedbreve = 535;
    e1.ukatakana = 12454;
    e1.ukatakanahalfwidth = 65395;
    e1.ukcyrillic = 1145;
    e1.ukorean = 12636;
    e1.umacron = 363;
    e1.umacroncyrillic = 1263;
    e1.umacrondieresis = 7803;
    e1.umatragurmukhi = 2625;
    e1.umonospace = 65365;
    e1.underscore = 95;
    e1.underscoredbl = 8215;
    e1.underscoremonospace = 65343;
    e1.underscorevertical = 65075;
    e1.underscorewavy = 65103;
    e1.union = 8746;
    e1.universal = 8704;
    e1.uogonek = 371;
    e1.uparen = 9392;
    e1.upblock = 9600;
    e1.upperdothebrew = 1476;
    e1.upsilon = 965;
    e1.upsilondieresis = 971;
    e1.upsilondieresistonos = 944;
    e1.upsilonlatin = 650;
    e1.upsilontonos = 973;
    e1.uptackbelowcmb = 797;
    e1.uptackmod = 724;
    e1.uragurmukhi = 2675;
    e1.uring = 367;
    e1.ushortcyrillic = 1118;
    e1.usmallhiragana = 12357;
    e1.usmallkatakana = 12453;
    e1.usmallkatakanahalfwidth = 65385;
    e1.ustraightcyrillic = 1199;
    e1.ustraightstrokecyrillic = 1201;
    e1.utilde = 361;
    e1.utildeacute = 7801;
    e1.utildebelow = 7797;
    e1.uubengali = 2442;
    e1.uudeva = 2314;
    e1.uugujarati = 2698;
    e1.uugurmukhi = 2570;
    e1.uumatragurmukhi = 2626;
    e1.uuvowelsignbengali = 2498;
    e1.uuvowelsigndeva = 2370;
    e1.uuvowelsigngujarati = 2754;
    e1.uvowelsignbengali = 2497;
    e1.uvowelsigndeva = 2369;
    e1.uvowelsigngujarati = 2753;
    e1.v = 118;
    e1.vadeva = 2357;
    e1.vagujarati = 2741;
    e1.vagurmukhi = 2613;
    e1.vakatakana = 12535;
    e1.vav = 1493;
    e1.vavdagesh = 64309;
    e1.vavdagesh65 = 64309;
    e1.vavdageshhebrew = 64309;
    e1.vavhebrew = 1493;
    e1.vavholam = 64331;
    e1.vavholamhebrew = 64331;
    e1.vavvavhebrew = 1520;
    e1.vavyodhebrew = 1521;
    e1.vcircle = 9445;
    e1.vdotbelow = 7807;
    e1.vecyrillic = 1074;
    e1.veharabic = 1700;
    e1.vehfinalarabic = 64363;
    e1.vehinitialarabic = 64364;
    e1.vehmedialarabic = 64365;
    e1.vekatakana = 12537;
    e1.venus = 9792;
    e1.verticalbar = 124;
    e1.verticallineabovecmb = 781;
    e1.verticallinebelowcmb = 809;
    e1.verticallinelowmod = 716;
    e1.verticallinemod = 712;
    e1.vewarmenian = 1406;
    e1.vhook = 651;
    e1.vikatakana = 12536;
    e1.viramabengali = 2509;
    e1.viramadeva = 2381;
    e1.viramagujarati = 2765;
    e1.visargabengali = 2435;
    e1.visargadeva = 2307;
    e1.visargagujarati = 2691;
    e1.vmonospace = 65366;
    e1.voarmenian = 1400;
    e1.voicediterationhiragana = 12446;
    e1.voicediterationkatakana = 12542;
    e1.voicedmarkkana = 12443;
    e1.voicedmarkkanahalfwidth = 65438;
    e1.vokatakana = 12538;
    e1.vparen = 9393;
    e1.vtilde = 7805;
    e1.vturned = 652;
    e1.vuhiragana = 12436;
    e1.vukatakana = 12532;
    e1.w = 119;
    e1.wacute = 7811;
    e1.waekorean = 12633;
    e1.wahiragana = 12431;
    e1.wakatakana = 12527;
    e1.wakatakanahalfwidth = 65436;
    e1.wakorean = 12632;
    e1.wasmallhiragana = 12430;
    e1.wasmallkatakana = 12526;
    e1.wattosquare = 13143;
    e1.wavedash = 12316;
    e1.wavyunderscorevertical = 65076;
    e1.wawarabic = 1608;
    e1.wawfinalarabic = 65262;
    e1.wawhamzaabovearabic = 1572;
    e1.wawhamzaabovefinalarabic = 65158;
    e1.wbsquare = 13277;
    e1.wcircle = 9446;
    e1.wcircumflex = 373;
    e1.wdieresis = 7813;
    e1.wdotaccent = 7815;
    e1.wdotbelow = 7817;
    e1.wehiragana = 12433;
    e1.weierstrass = 8472;
    e1.wekatakana = 12529;
    e1.wekorean = 12638;
    e1.weokorean = 12637;
    e1.wgrave = 7809;
    e1.whitebullet = 9702;
    e1.whitecircle = 9675;
    e1.whitecircleinverse = 9689;
    e1.whitecornerbracketleft = 12302;
    e1.whitecornerbracketleftvertical = 65091;
    e1.whitecornerbracketright = 12303;
    e1.whitecornerbracketrightvertical = 65092;
    e1.whitediamond = 9671;
    e1.whitediamondcontainingblacksmalldiamond = 9672;
    e1.whitedownpointingsmalltriangle = 9663;
    e1.whitedownpointingtriangle = 9661;
    e1.whiteleftpointingsmalltriangle = 9667;
    e1.whiteleftpointingtriangle = 9665;
    e1.whitelenticularbracketleft = 12310;
    e1.whitelenticularbracketright = 12311;
    e1.whiterightpointingsmalltriangle = 9657;
    e1.whiterightpointingtriangle = 9655;
    e1.whitesmallsquare = 9643;
    e1.whitesmilingface = 9786;
    e1.whitesquare = 9633;
    e1.whitestar = 9734;
    e1.whitetelephone = 9743;
    e1.whitetortoiseshellbracketleft = 12312;
    e1.whitetortoiseshellbracketright = 12313;
    e1.whiteuppointingsmalltriangle = 9653;
    e1.whiteuppointingtriangle = 9651;
    e1.wihiragana = 12432;
    e1.wikatakana = 12528;
    e1.wikorean = 12639;
    e1.wmonospace = 65367;
    e1.wohiragana = 12434;
    e1.wokatakana = 12530;
    e1.wokatakanahalfwidth = 65382;
    e1.won = 8361;
    e1.wonmonospace = 65510;
    e1.wowaenthai = 3623;
    e1.wparen = 9394;
    e1.wring = 7832;
    e1.wsuperior = 695;
    e1.wturned = 653;
    e1.wynn = 447;
    e1.x = 120;
    e1.xabovecmb = 829;
    e1.xbopomofo = 12562;
    e1.xcircle = 9447;
    e1.xdieresis = 7821;
    e1.xdotaccent = 7819;
    e1.xeharmenian = 1389;
    e1.xi = 958;
    e1.xmonospace = 65368;
    e1.xparen = 9395;
    e1.xsuperior = 739;
    e1.y = 121;
    e1.yaadosquare = 13134;
    e1.yabengali = 2479;
    e1.yacute = 253;
    e1.yadeva = 2351;
    e1.yaekorean = 12626;
    e1.yagujarati = 2735;
    e1.yagurmukhi = 2607;
    e1.yahiragana = 12420;
    e1.yakatakana = 12516;
    e1.yakatakanahalfwidth = 65428;
    e1.yakorean = 12625;
    e1.yamakkanthai = 3662;
    e1.yasmallhiragana = 12419;
    e1.yasmallkatakana = 12515;
    e1.yasmallkatakanahalfwidth = 65388;
    e1.yatcyrillic = 1123;
    e1.ycircle = 9448;
    e1.ycircumflex = 375;
    e1.ydieresis = 255;
    e1.ydotaccent = 7823;
    e1.ydotbelow = 7925;
    e1.yeharabic = 1610;
    e1.yehbarreearabic = 1746;
    e1.yehbarreefinalarabic = 64431;
    e1.yehfinalarabic = 65266;
    e1.yehhamzaabovearabic = 1574;
    e1.yehhamzaabovefinalarabic = 65162;
    e1.yehhamzaaboveinitialarabic = 65163;
    e1.yehhamzaabovemedialarabic = 65164;
    e1.yehinitialarabic = 65267;
    e1.yehmedialarabic = 65268;
    e1.yehmeeminitialarabic = 64733;
    e1.yehmeemisolatedarabic = 64600;
    e1.yehnoonfinalarabic = 64660;
    e1.yehthreedotsbelowarabic = 1745;
    e1.yekorean = 12630;
    e1.yen = 165;
    e1.yenmonospace = 65509;
    e1.yeokorean = 12629;
    e1.yeorinhieuhkorean = 12678;
    e1.yerahbenyomohebrew = 1450;
    e1.yerahbenyomolefthebrew = 1450;
    e1.yericyrillic = 1099;
    e1.yerudieresiscyrillic = 1273;
    e1.yesieungkorean = 12673;
    e1.yesieungpansioskorean = 12675;
    e1.yesieungsioskorean = 12674;
    e1.yetivhebrew = 1434;
    e1.ygrave = 7923;
    e1.yhook = 436;
    e1.yhookabove = 7927;
    e1.yiarmenian = 1397;
    e1.yicyrillic = 1111;
    e1.yikorean = 12642;
    e1.yinyang = 9775;
    e1.yiwnarmenian = 1410;
    e1.ymonospace = 65369;
    e1.yod = 1497;
    e1.yoddagesh = 64313;
    e1.yoddageshhebrew = 64313;
    e1.yodhebrew = 1497;
    e1.yodyodhebrew = 1522;
    e1.yodyodpatahhebrew = 64287;
    e1.yohiragana = 12424;
    e1.yoikorean = 12681;
    e1.yokatakana = 12520;
    e1.yokatakanahalfwidth = 65430;
    e1.yokorean = 12635;
    e1.yosmallhiragana = 12423;
    e1.yosmallkatakana = 12519;
    e1.yosmallkatakanahalfwidth = 65390;
    e1.yotgreek = 1011;
    e1.yoyaekorean = 12680;
    e1.yoyakorean = 12679;
    e1.yoyakthai = 3618;
    e1.yoyingthai = 3597;
    e1.yparen = 9396;
    e1.ypogegrammeni = 890;
    e1.ypogegrammenigreekcmb = 837;
    e1.yr = 422;
    e1.yring = 7833;
    e1.ysuperior = 696;
    e1.ytilde = 7929;
    e1.yturned = 654;
    e1.yuhiragana = 12422;
    e1.yuikorean = 12684;
    e1.yukatakana = 12518;
    e1.yukatakanahalfwidth = 65429;
    e1.yukorean = 12640;
    e1.yusbigcyrillic = 1131;
    e1.yusbigiotifiedcyrillic = 1133;
    e1.yuslittlecyrillic = 1127;
    e1.yuslittleiotifiedcyrillic = 1129;
    e1.yusmallhiragana = 12421;
    e1.yusmallkatakana = 12517;
    e1.yusmallkatakanahalfwidth = 65389;
    e1.yuyekorean = 12683;
    e1.yuyeokorean = 12682;
    e1.yyabengali = 2527;
    e1.yyadeva = 2399;
    e1.z = 122;
    e1.zaarmenian = 1382;
    e1.zacute = 378;
    e1.zadeva = 2395;
    e1.zagurmukhi = 2651;
    e1.zaharabic = 1592;
    e1.zahfinalarabic = 65222;
    e1.zahinitialarabic = 65223;
    e1.zahiragana = 12374;
    e1.zahmedialarabic = 65224;
    e1.zainarabic = 1586;
    e1.zainfinalarabic = 65200;
    e1.zakatakana = 12470;
    e1.zaqefgadolhebrew = 1429;
    e1.zaqefqatanhebrew = 1428;
    e1.zarqahebrew = 1432;
    e1.zayin = 1494;
    e1.zayindagesh = 64310;
    e1.zayindageshhebrew = 64310;
    e1.zayinhebrew = 1494;
    e1.zbopomofo = 12567;
    e1.zcaron = 382;
    e1.zcircle = 9449;
    e1.zcircumflex = 7825;
    e1.zcurl = 657;
    e1.zdot = 380;
    e1.zdotaccent = 380;
    e1.zdotbelow = 7827;
    e1.zecyrillic = 1079;
    e1.zedescendercyrillic = 1177;
    e1.zedieresiscyrillic = 1247;
    e1.zehiragana = 12380;
    e1.zekatakana = 12476;
    e1.zero = 48;
    e1.zeroarabic = 1632;
    e1.zerobengali = 2534;
    e1.zerodeva = 2406;
    e1.zerogujarati = 2790;
    e1.zerogurmukhi = 2662;
    e1.zerohackarabic = 1632;
    e1.zeroinferior = 8320;
    e1.zeromonospace = 65296;
    e1.zerooldstyle = 63280;
    e1.zeropersian = 1776;
    e1.zerosuperior = 8304;
    e1.zerothai = 3664;
    e1.zerowidthjoiner = 65279;
    e1.zerowidthnonjoiner = 8204;
    e1.zerowidthspace = 8203;
    e1.zeta = 950;
    e1.zhbopomofo = 12563;
    e1.zhearmenian = 1386;
    e1.zhebrevecyrillic = 1218;
    e1.zhecyrillic = 1078;
    e1.zhedescendercyrillic = 1175;
    e1.zhedieresiscyrillic = 1245;
    e1.zihiragana = 12376;
    e1.zikatakana = 12472;
    e1.zinorhebrew = 1454;
    e1.zlinebelow = 7829;
    e1.zmonospace = 65370;
    e1.zohiragana = 12382;
    e1.zokatakana = 12478;
    e1.zparen = 9397;
    e1.zretroflexhook = 656;
    e1.zstroke = 438;
    e1.zuhiragana = 12378;
    e1.zukatakana = 12474;
    e1[".notdef"] = 0;
    e1.angbracketleftbig = 9001;
    e1.angbracketleftBig = 9001;
    e1.angbracketleftbigg = 9001;
    e1.angbracketleftBigg = 9001;
    e1.angbracketrightBig = 9002;
    e1.angbracketrightbig = 9002;
    e1.angbracketrightBigg = 9002;
    e1.angbracketrightbigg = 9002;
    e1.arrowhookleft = 8618;
    e1.arrowhookright = 8617;
    e1.arrowlefttophalf = 8636;
    e1.arrowleftbothalf = 8637;
    e1.arrownortheast = 8599;
    e1.arrownorthwest = 8598;
    e1.arrowrighttophalf = 8640;
    e1.arrowrightbothalf = 8641;
    e1.arrowsoutheast = 8600;
    e1.arrowsouthwest = 8601;
    e1.backslashbig = 8726;
    e1.backslashBig = 8726;
    e1.backslashBigg = 8726;
    e1.backslashbigg = 8726;
    e1.bardbl = 8214;
    e1.bracehtipdownleft = 65079;
    e1.bracehtipdownright = 65079;
    e1.bracehtipupleft = 65080;
    e1.bracehtipupright = 65080;
    e1.braceleftBig = 123;
    e1.braceleftbig = 123;
    e1.braceleftbigg = 123;
    e1.braceleftBigg = 123;
    e1.bracerightBig = 125;
    e1.bracerightbig = 125;
    e1.bracerightbigg = 125;
    e1.bracerightBigg = 125;
    e1.bracketleftbig = 91;
    e1.bracketleftBig = 91;
    e1.bracketleftbigg = 91;
    e1.bracketleftBigg = 91;
    e1.bracketrightBig = 93;
    e1.bracketrightbig = 93;
    e1.bracketrightbigg = 93;
    e1.bracketrightBigg = 93;
    e1.ceilingleftbig = 8968;
    e1.ceilingleftBig = 8968;
    e1.ceilingleftBigg = 8968;
    e1.ceilingleftbigg = 8968;
    e1.ceilingrightbig = 8969;
    e1.ceilingrightBig = 8969;
    e1.ceilingrightbigg = 8969;
    e1.ceilingrightBigg = 8969;
    e1.circledotdisplay = 8857;
    e1.circledottext = 8857;
    e1.circlemultiplydisplay = 8855;
    e1.circlemultiplytext = 8855;
    e1.circleplusdisplay = 8853;
    e1.circleplustext = 8853;
    e1.contintegraldisplay = 8750;
    e1.contintegraltext = 8750;
    e1.coproductdisplay = 8720;
    e1.coproducttext = 8720;
    e1.floorleftBig = 8970;
    e1.floorleftbig = 8970;
    e1.floorleftbigg = 8970;
    e1.floorleftBigg = 8970;
    e1.floorrightbig = 8971;
    e1.floorrightBig = 8971;
    e1.floorrightBigg = 8971;
    e1.floorrightbigg = 8971;
    e1.hatwide = 770;
    e1.hatwider = 770;
    e1.hatwidest = 770;
    e1.intercal = 7488;
    e1.integraldisplay = 8747;
    e1.integraltext = 8747;
    e1.intersectiondisplay = 8898;
    e1.intersectiontext = 8898;
    e1.logicalanddisplay = 8743;
    e1.logicalandtext = 8743;
    e1.logicalordisplay = 8744;
    e1.logicalortext = 8744;
    e1.parenleftBig = 40;
    e1.parenleftbig = 40;
    e1.parenleftBigg = 40;
    e1.parenleftbigg = 40;
    e1.parenrightBig = 41;
    e1.parenrightbig = 41;
    e1.parenrightBigg = 41;
    e1.parenrightbigg = 41;
    e1.prime = 8242;
    e1.productdisplay = 8719;
    e1.producttext = 8719;
    e1.radicalbig = 8730;
    e1.radicalBig = 8730;
    e1.radicalBigg = 8730;
    e1.radicalbigg = 8730;
    e1.radicalbt = 8730;
    e1.radicaltp = 8730;
    e1.radicalvertex = 8730;
    e1.slashbig = 47;
    e1.slashBig = 47;
    e1.slashBigg = 47;
    e1.slashbigg = 47;
    e1.summationdisplay = 8721;
    e1.summationtext = 8721;
    e1.tildewide = 732;
    e1.tildewider = 732;
    e1.tildewidest = 732;
    e1.uniondisplay = 8899;
    e1.unionmultidisplay = 8846;
    e1.unionmultitext = 8846;
    e1.unionsqdisplay = 8852;
    e1.unionsqtext = 8852;
    e1.uniontext = 8899;
    e1.vextenddouble = 8741;
    e1.vextendsingle = 8739;
}), Di = getLookupTableFactory(function(e1) {
    e1.space = 32;
    e1.a1 = 9985;
    e1.a2 = 9986;
    e1.a202 = 9987;
    e1.a3 = 9988;
    e1.a4 = 9742;
    e1.a5 = 9990;
    e1.a119 = 9991;
    e1.a118 = 9992;
    e1.a117 = 9993;
    e1.a11 = 9755;
    e1.a12 = 9758;
    e1.a13 = 9996;
    e1.a14 = 9997;
    e1.a15 = 9998;
    e1.a16 = 9999;
    e1.a105 = 1e4;
    e1.a17 = 10001;
    e1.a18 = 10002;
    e1.a19 = 10003;
    e1.a20 = 10004;
    e1.a21 = 10005;
    e1.a22 = 10006;
    e1.a23 = 10007;
    e1.a24 = 10008;
    e1.a25 = 10009;
    e1.a26 = 10010;
    e1.a27 = 10011;
    e1.a28 = 10012;
    e1.a6 = 10013;
    e1.a7 = 10014;
    e1.a8 = 10015;
    e1.a9 = 10016;
    e1.a10 = 10017;
    e1.a29 = 10018;
    e1.a30 = 10019;
    e1.a31 = 10020;
    e1.a32 = 10021;
    e1.a33 = 10022;
    e1.a34 = 10023;
    e1.a35 = 9733;
    e1.a36 = 10025;
    e1.a37 = 10026;
    e1.a38 = 10027;
    e1.a39 = 10028;
    e1.a40 = 10029;
    e1.a41 = 10030;
    e1.a42 = 10031;
    e1.a43 = 10032;
    e1.a44 = 10033;
    e1.a45 = 10034;
    e1.a46 = 10035;
    e1.a47 = 10036;
    e1.a48 = 10037;
    e1.a49 = 10038;
    e1.a50 = 10039;
    e1.a51 = 10040;
    e1.a52 = 10041;
    e1.a53 = 10042;
    e1.a54 = 10043;
    e1.a55 = 10044;
    e1.a56 = 10045;
    e1.a57 = 10046;
    e1.a58 = 10047;
    e1.a59 = 10048;
    e1.a60 = 10049;
    e1.a61 = 10050;
    e1.a62 = 10051;
    e1.a63 = 10052;
    e1.a64 = 10053;
    e1.a65 = 10054;
    e1.a66 = 10055;
    e1.a67 = 10056;
    e1.a68 = 10057;
    e1.a69 = 10058;
    e1.a70 = 10059;
    e1.a71 = 9679;
    e1.a72 = 10061;
    e1.a73 = 9632;
    e1.a74 = 10063;
    e1.a203 = 10064;
    e1.a75 = 10065;
    e1.a204 = 10066;
    e1.a76 = 9650;
    e1.a77 = 9660;
    e1.a78 = 9670;
    e1.a79 = 10070;
    e1.a81 = 9687;
    e1.a82 = 10072;
    e1.a83 = 10073;
    e1.a84 = 10074;
    e1.a97 = 10075;
    e1.a98 = 10076;
    e1.a99 = 10077;
    e1.a100 = 10078;
    e1.a101 = 10081;
    e1.a102 = 10082;
    e1.a103 = 10083;
    e1.a104 = 10084;
    e1.a106 = 10085;
    e1.a107 = 10086;
    e1.a108 = 10087;
    e1.a112 = 9827;
    e1.a111 = 9830;
    e1.a110 = 9829;
    e1.a109 = 9824;
    e1.a120 = 9312;
    e1.a121 = 9313;
    e1.a122 = 9314;
    e1.a123 = 9315;
    e1.a124 = 9316;
    e1.a125 = 9317;
    e1.a126 = 9318;
    e1.a127 = 9319;
    e1.a128 = 9320;
    e1.a129 = 9321;
    e1.a130 = 10102;
    e1.a131 = 10103;
    e1.a132 = 10104;
    e1.a133 = 10105;
    e1.a134 = 10106;
    e1.a135 = 10107;
    e1.a136 = 10108;
    e1.a137 = 10109;
    e1.a138 = 10110;
    e1.a139 = 10111;
    e1.a140 = 10112;
    e1.a141 = 10113;
    e1.a142 = 10114;
    e1.a143 = 10115;
    e1.a144 = 10116;
    e1.a145 = 10117;
    e1.a146 = 10118;
    e1.a147 = 10119;
    e1.a148 = 10120;
    e1.a149 = 10121;
    e1.a150 = 10122;
    e1.a151 = 10123;
    e1.a152 = 10124;
    e1.a153 = 10125;
    e1.a154 = 10126;
    e1.a155 = 10127;
    e1.a156 = 10128;
    e1.a157 = 10129;
    e1.a158 = 10130;
    e1.a159 = 10131;
    e1.a160 = 10132;
    e1.a161 = 8594;
    e1.a163 = 8596;
    e1.a164 = 8597;
    e1.a196 = 10136;
    e1.a165 = 10137;
    e1.a192 = 10138;
    e1.a166 = 10139;
    e1.a167 = 10140;
    e1.a168 = 10141;
    e1.a169 = 10142;
    e1.a170 = 10143;
    e1.a171 = 10144;
    e1.a172 = 10145;
    e1.a173 = 10146;
    e1.a162 = 10147;
    e1.a174 = 10148;
    e1.a175 = 10149;
    e1.a176 = 10150;
    e1.a177 = 10151;
    e1.a178 = 10152;
    e1.a179 = 10153;
    e1.a193 = 10154;
    e1.a180 = 10155;
    e1.a199 = 10156;
    e1.a181 = 10157;
    e1.a200 = 10158;
    e1.a182 = 10159;
    e1.a201 = 10161;
    e1.a183 = 10162;
    e1.a184 = 10163;
    e1.a197 = 10164;
    e1.a185 = 10165;
    e1.a194 = 10166;
    e1.a198 = 10167;
    e1.a186 = 10168;
    e1.a195 = 10169;
    e1.a187 = 10170;
    e1.a188 = 10171;
    e1.a189 = 10172;
    e1.a190 = 10173;
    e1.a191 = 10174;
    e1.a89 = 10088;
    e1.a90 = 10089;
    e1.a93 = 10090;
    e1.a94 = 10091;
    e1.a91 = 10092;
    e1.a92 = 10093;
    e1.a205 = 10094;
    e1.a85 = 10095;
    e1.a206 = 10096;
    e1.a86 = 10097;
    e1.a87 = 10098;
    e1.a88 = 10099;
    e1.a95 = 10100;
    e1.a96 = 10101;
    e1[".notdef"] = 0;
}), bi = getLookupTableFactory(function(e1) {
    e1[63721] = 169;
    e1[63193] = 169;
    e1[63720] = 174;
    e1[63194] = 174;
    e1[63722] = 8482;
    e1[63195] = 8482;
    e1[63729] = 9127;
    e1[63730] = 9128;
    e1[63731] = 9129;
    e1[63740] = 9131;
    e1[63741] = 9132;
    e1[63742] = 9133;
    e1[63726] = 9121;
    e1[63727] = 9122;
    e1[63728] = 9123;
    e1[63737] = 9124;
    e1[63738] = 9125;
    e1[63739] = 9126;
    e1[63723] = 9115;
    e1[63724] = 9116;
    e1[63725] = 9117;
    e1[63734] = 9118;
    e1[63735] = 9119;
    e1[63736] = 9120;
});
function getUnicodeForGlyph(e1, t) {
    let i = t[e1];
    if (void 0 !== i) return i;
    if (!e1) return -1;
    if ("u" === e1[0]) {
        const t = e1.length;
        let a;
        if (7 === t && "n" === e1[1] && "i" === e1[2]) a = e1.substring(3);
        else {
            if (!(t >= 5 && t <= 7)) return -1;
            a = e1.substring(1);
        }
        if (a === a.toUpperCase()) {
            i = parseInt(a, 16);
            if (i >= 0) return i;
        }
    }
    return -1;
}
const Fi = [
    [
        0,
        127
    ],
    [
        128,
        255
    ],
    [
        256,
        383
    ],
    [
        384,
        591
    ],
    [
        592,
        687,
        7424,
        7551,
        7552,
        7615
    ],
    [
        688,
        767,
        42752,
        42783
    ],
    [
        768,
        879,
        7616,
        7679
    ],
    [
        880,
        1023
    ],
    [
        11392,
        11519
    ],
    [
        1024,
        1279,
        1280,
        1327,
        11744,
        11775,
        42560,
        42655
    ],
    [
        1328,
        1423
    ],
    [
        1424,
        1535
    ],
    [
        42240,
        42559
    ],
    [
        1536,
        1791,
        1872,
        1919
    ],
    [
        1984,
        2047
    ],
    [
        2304,
        2431
    ],
    [
        2432,
        2559
    ],
    [
        2560,
        2687
    ],
    [
        2688,
        2815
    ],
    [
        2816,
        2943
    ],
    [
        2944,
        3071
    ],
    [
        3072,
        3199
    ],
    [
        3200,
        3327
    ],
    [
        3328,
        3455
    ],
    [
        3584,
        3711
    ],
    [
        3712,
        3839
    ],
    [
        4256,
        4351,
        11520,
        11567
    ],
    [
        6912,
        7039
    ],
    [
        4352,
        4607
    ],
    [
        7680,
        7935,
        11360,
        11391,
        42784,
        43007
    ],
    [
        7936,
        8191
    ],
    [
        8192,
        8303,
        11776,
        11903
    ],
    [
        8304,
        8351
    ],
    [
        8352,
        8399
    ],
    [
        8400,
        8447
    ],
    [
        8448,
        8527
    ],
    [
        8528,
        8591
    ],
    [
        8592,
        8703,
        10224,
        10239,
        10496,
        10623,
        11008,
        11263
    ],
    [
        8704,
        8959,
        10752,
        11007,
        10176,
        10223,
        10624,
        10751
    ],
    [
        8960,
        9215
    ],
    [
        9216,
        9279
    ],
    [
        9280,
        9311
    ],
    [
        9312,
        9471
    ],
    [
        9472,
        9599
    ],
    [
        9600,
        9631
    ],
    [
        9632,
        9727
    ],
    [
        9728,
        9983
    ],
    [
        9984,
        10175
    ],
    [
        12288,
        12351
    ],
    [
        12352,
        12447
    ],
    [
        12448,
        12543,
        12784,
        12799
    ],
    [
        12544,
        12591,
        12704,
        12735
    ],
    [
        12592,
        12687
    ],
    [
        43072,
        43135
    ],
    [
        12800,
        13055
    ],
    [
        13056,
        13311
    ],
    [
        44032,
        55215
    ],
    [
        55296,
        57343
    ],
    [
        67840,
        67871
    ],
    [
        19968,
        40959,
        11904,
        12031,
        12032,
        12255,
        12272,
        12287,
        13312,
        19903,
        131072,
        173791,
        12688,
        12703
    ],
    [
        57344,
        63743
    ],
    [
        12736,
        12783,
        63744,
        64255,
        194560,
        195103
    ],
    [
        64256,
        64335
    ],
    [
        64336,
        65023
    ],
    [
        65056,
        65071
    ],
    [
        65040,
        65055
    ],
    [
        65104,
        65135
    ],
    [
        65136,
        65279
    ],
    [
        65280,
        65519
    ],
    [
        65520,
        65535
    ],
    [
        3840,
        4095
    ],
    [
        1792,
        1871
    ],
    [
        1920,
        1983
    ],
    [
        3456,
        3583
    ],
    [
        4096,
        4255
    ],
    [
        4608,
        4991,
        4992,
        5023,
        11648,
        11743
    ],
    [
        5024,
        5119
    ],
    [
        5120,
        5759
    ],
    [
        5760,
        5791
    ],
    [
        5792,
        5887
    ],
    [
        6016,
        6143
    ],
    [
        6144,
        6319
    ],
    [
        10240,
        10495
    ],
    [
        40960,
        42127
    ],
    [
        5888,
        5919,
        5920,
        5951,
        5952,
        5983,
        5984,
        6015
    ],
    [
        66304,
        66351
    ],
    [
        66352,
        66383
    ],
    [
        66560,
        66639
    ],
    [
        118784,
        119039,
        119040,
        119295,
        119296,
        119375
    ],
    [
        119808,
        120831
    ],
    [
        1044480,
        1048573
    ],
    [
        65024,
        65039,
        917760,
        917999
    ],
    [
        917504,
        917631
    ],
    [
        6400,
        6479
    ],
    [
        6480,
        6527
    ],
    [
        6528,
        6623
    ],
    [
        6656,
        6687
    ],
    [
        11264,
        11359
    ],
    [
        11568,
        11647
    ],
    [
        19904,
        19967
    ],
    [
        43008,
        43055
    ],
    [
        65536,
        65663,
        65664,
        65791,
        65792,
        65855
    ],
    [
        65856,
        65935
    ],
    [
        66432,
        66463
    ],
    [
        66464,
        66527
    ],
    [
        66640,
        66687
    ],
    [
        66688,
        66735
    ],
    [
        67584,
        67647
    ],
    [
        68096,
        68191
    ],
    [
        119552,
        119647
    ],
    [
        73728,
        74751,
        74752,
        74879
    ],
    [
        119648,
        119679
    ],
    [
        7040,
        7103
    ],
    [
        7168,
        7247
    ],
    [
        7248,
        7295
    ],
    [
        43136,
        43231
    ],
    [
        43264,
        43311
    ],
    [
        43312,
        43359
    ],
    [
        43520,
        43615
    ],
    [
        65936,
        65999
    ],
    [
        66e3,
        66047
    ],
    [
        66208,
        66271,
        66176,
        66207,
        67872,
        67903
    ],
    [
        127024,
        127135,
        126976,
        127023
    ]
];
function getUnicodeRangeFor(e1, t = -1) {
    if (-1 !== t) {
        const i = Fi[t];
        for(let a = 0, s = i.length; a < s; a += 2)if (e1 >= i[a] && e1 <= i[a + 1]) return t;
    }
    for(let t = 0, i = Fi.length; t < i; t++){
        const i = Fi[t];
        for(let a = 0, s = i.length; a < s; a += 2)if (e1 >= i[a] && e1 <= i[a + 1]) return t;
    }
    return -1;
}
const Si = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), ki = new Map;
const Ri = !0, Ni = 1, Gi = 2, Mi = 4, xi = 32, Hi = [
    ".notdef",
    ".null",
    "nonmarkingreturn",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "nonbreakingspace",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "Lslash",
    "lslash",
    "Scaron",
    "scaron",
    "Zcaron",
    "zcaron",
    "brokenbar",
    "Eth",
    "eth",
    "Yacute",
    "yacute",
    "Thorn",
    "thorn",
    "minus",
    "multiply",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "onehalf",
    "onequarter",
    "threequarters",
    "franc",
    "Gbreve",
    "gbreve",
    "Idotaccent",
    "Scedilla",
    "scedilla",
    "Cacute",
    "cacute",
    "Ccaron",
    "ccaron",
    "dcroat"
];
function recoverGlyphName(e1, t) {
    if (void 0 !== t[e1]) return e1;
    const i = getUnicodeForGlyph(e1, t);
    if (-1 !== i) {
        for(const e1 in t)if (t[e1] === i) return e1;
    }
    info("Unable to recover a standard glyph name for: " + e1);
    return e1;
}
function type1FontGlyphMapping(e1, t, i) {
    const a = Object.create(null);
    let s, r, n;
    const g = !!(e1.flags & Mi);
    if (e1.isInternalFont) {
        n = t;
        for(r = 0; r < n.length; r++){
            s = i.indexOf(n[r]);
            a[r] = s >= 0 ? s : 0;
        }
    } else if (e1.baseEncodingName) {
        n = getEncoding(e1.baseEncodingName);
        for(r = 0; r < n.length; r++){
            s = i.indexOf(n[r]);
            a[r] = s >= 0 ? s : 0;
        }
    } else if (g) for(r in t)a[r] = t[r];
    else {
        n = hi;
        for(r = 0; r < n.length; r++){
            s = i.indexOf(n[r]);
            a[r] = s >= 0 ? s : 0;
        }
    }
    const o = e1.differences;
    let c;
    if (o) for(r in o){
        const e1 = o[r];
        s = i.indexOf(e1);
        if (-1 === s) {
            c || (c = wi());
            const t = recoverGlyphName(e1, c);
            t !== e1 && (s = i.indexOf(t));
        }
        a[r] = s >= 0 ? s : 0;
    }
    return a;
}
function normalizeFontName(e1) {
    return e1.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
const Ji = getLookupTableFactory((e1)=>{
    e1[8211] = 65074;
    e1[8212] = 65073;
    e1[8229] = 65072;
    e1[8230] = 65049;
    e1[12289] = 65041;
    e1[12290] = 65042;
    e1[12296] = 65087;
    e1[12297] = 65088;
    e1[12298] = 65085;
    e1[12299] = 65086;
    e1[12300] = 65089;
    e1[12301] = 65090;
    e1[12302] = 65091;
    e1[12303] = 65092;
    e1[12304] = 65083;
    e1[12305] = 65084;
    e1[12308] = 65081;
    e1[12309] = 65082;
    e1[12310] = 65047;
    e1[12311] = 65048;
    e1[65103] = 65076;
    e1[65281] = 65045;
    e1[65288] = 65077;
    e1[65289] = 65078;
    e1[65292] = 65040;
    e1[65306] = 65043;
    e1[65307] = 65044;
    e1[65311] = 65046;
    e1[65339] = 65095;
    e1[65341] = 65096;
    e1[65343] = 65075;
    e1[65371] = 65079;
    e1[65373] = 65080;
}), Yi = getLookupTableFactory(function(e1) {
    e1["Times-Roman"] = "Times-Roman";
    e1.Helvetica = "Helvetica";
    e1.Courier = "Courier";
    e1.Symbol = "Symbol";
    e1["Times-Bold"] = "Times-Bold";
    e1["Helvetica-Bold"] = "Helvetica-Bold";
    e1["Courier-Bold"] = "Courier-Bold";
    e1.ZapfDingbats = "ZapfDingbats";
    e1["Times-Italic"] = "Times-Italic";
    e1["Helvetica-Oblique"] = "Helvetica-Oblique";
    e1["Courier-Oblique"] = "Courier-Oblique";
    e1["Times-BoldItalic"] = "Times-BoldItalic";
    e1["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
    e1["Courier-BoldOblique"] = "Courier-BoldOblique";
    e1.ArialNarrow = "Helvetica";
    e1["ArialNarrow-Bold"] = "Helvetica-Bold";
    e1["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
    e1["ArialNarrow-Italic"] = "Helvetica-Oblique";
    e1.ArialBlack = "Helvetica";
    e1["ArialBlack-Bold"] = "Helvetica-Bold";
    e1["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
    e1["ArialBlack-Italic"] = "Helvetica-Oblique";
    e1["Arial-Black"] = "Helvetica";
    e1["Arial-Black-Bold"] = "Helvetica-Bold";
    e1["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Arial-Black-Italic"] = "Helvetica-Oblique";
    e1.Arial = "Helvetica";
    e1["Arial-Bold"] = "Helvetica-Bold";
    e1["Arial-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Arial-Italic"] = "Helvetica-Oblique";
    e1.ArialMT = "Helvetica";
    e1["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
    e1["Arial-BoldMT"] = "Helvetica-Bold";
    e1["Arial-ItalicMT"] = "Helvetica-Oblique";
    e1["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Arial-BoldMT-Bold"] = "Helvetica-Bold";
    e1["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
    e1.ArialUnicodeMS = "Helvetica";
    e1["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
    e1["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
    e1["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
    e1["Courier-BoldItalic"] = "Courier-BoldOblique";
    e1["Courier-Italic"] = "Courier-Oblique";
    e1.CourierNew = "Courier";
    e1["CourierNew-Bold"] = "Courier-Bold";
    e1["CourierNew-BoldItalic"] = "Courier-BoldOblique";
    e1["CourierNew-Italic"] = "Courier-Oblique";
    e1["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
    e1["CourierNewPS-BoldMT"] = "Courier-Bold";
    e1["CourierNewPS-ItalicMT"] = "Courier-Oblique";
    e1.CourierNewPSMT = "Courier";
    e1["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Helvetica-Italic"] = "Helvetica-Oblique";
    e1["HelveticaLTStd-Bold"] = "Helvetica-Bold";
    e1["Symbol-Bold"] = "Symbol";
    e1["Symbol-BoldItalic"] = "Symbol";
    e1["Symbol-Italic"] = "Symbol";
    e1.TimesNewRoman = "Times-Roman";
    e1["TimesNewRoman-Bold"] = "Times-Bold";
    e1["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
    e1["TimesNewRoman-Italic"] = "Times-Italic";
    e1.TimesNewRomanPS = "Times-Roman";
    e1["TimesNewRomanPS-Bold"] = "Times-Bold";
    e1["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
    e1["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
    e1["TimesNewRomanPS-BoldMT"] = "Times-Bold";
    e1["TimesNewRomanPS-Italic"] = "Times-Italic";
    e1["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
    e1.TimesNewRomanPSMT = "Times-Roman";
    e1["TimesNewRomanPSMT-Bold"] = "Times-Bold";
    e1["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
    e1["TimesNewRomanPSMT-Italic"] = "Times-Italic";
}), vi = getLookupTableFactory(function(e1) {
    e1.Courier = "FoxitFixed.pfb";
    e1["Courier-Bold"] = "FoxitFixedBold.pfb";
    e1["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
    e1["Courier-Oblique"] = "FoxitFixedItalic.pfb";
    e1.Helvetica = "LiberationSans-Regular.ttf";
    e1["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
    e1["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
    e1["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
    e1["Times-Roman"] = "FoxitSerif.pfb";
    e1["Times-Bold"] = "FoxitSerifBold.pfb";
    e1["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
    e1["Times-Italic"] = "FoxitSerifItalic.pfb";
    e1.Symbol = "FoxitSymbol.pfb";
    e1.ZapfDingbats = "FoxitDingbats.pfb";
    e1["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
    e1["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
    e1["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
    e1["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
}), Ki = getLookupTableFactory(function(e1) {
    e1.Calibri = "Helvetica";
    e1["Calibri-Bold"] = "Helvetica-Bold";
    e1["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Calibri-Italic"] = "Helvetica-Oblique";
    e1.CenturyGothic = "Helvetica";
    e1["CenturyGothic-Bold"] = "Helvetica-Bold";
    e1["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
    e1["CenturyGothic-Italic"] = "Helvetica-Oblique";
    e1.ComicSansMS = "Comic Sans MS";
    e1["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
    e1["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
    e1["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
    e1.GillSansMT = "Helvetica";
    e1["GillSansMT-Bold"] = "Helvetica-Bold";
    e1["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique";
    e1["GillSansMT-Italic"] = "Helvetica-Oblique";
    e1.Impact = "Helvetica";
    e1["ItcSymbol-Bold"] = "Helvetica-Bold";
    e1["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
    e1["ItcSymbol-Book"] = "Helvetica";
    e1["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
    e1["ItcSymbol-Medium"] = "Helvetica";
    e1["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
    e1.LucidaConsole = "Courier";
    e1["LucidaConsole-Bold"] = "Courier-Bold";
    e1["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
    e1["LucidaConsole-Italic"] = "Courier-Oblique";
    e1["LucidaSans-Demi"] = "Helvetica-Bold";
    e1["MS-Gothic"] = "MS Gothic";
    e1["MS-Gothic-Bold"] = "MS Gothic-Bold";
    e1["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
    e1["MS-Gothic-Italic"] = "MS Gothic-Italic";
    e1["MS-Mincho"] = "MS Mincho";
    e1["MS-Mincho-Bold"] = "MS Mincho-Bold";
    e1["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
    e1["MS-Mincho-Italic"] = "MS Mincho-Italic";
    e1["MS-PGothic"] = "MS PGothic";
    e1["MS-PGothic-Bold"] = "MS PGothic-Bold";
    e1["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
    e1["MS-PGothic-Italic"] = "MS PGothic-Italic";
    e1["MS-PMincho"] = "MS PMincho";
    e1["MS-PMincho-Bold"] = "MS PMincho-Bold";
    e1["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
    e1["MS-PMincho-Italic"] = "MS PMincho-Italic";
    e1.NuptialScript = "Times-Italic";
    e1.SegoeUISymbol = "Helvetica";
}), Ti = getLookupTableFactory(function(e1) {
    e1["Adobe Jenson"] = !0;
    e1["Adobe Text"] = !0;
    e1.Albertus = !0;
    e1.Aldus = !0;
    e1.Alexandria = !0;
    e1.Algerian = !0;
    e1["American Typewriter"] = !0;
    e1.Antiqua = !0;
    e1.Apex = !0;
    e1.Arno = !0;
    e1.Aster = !0;
    e1.Aurora = !0;
    e1.Baskerville = !0;
    e1.Bell = !0;
    e1.Bembo = !0;
    e1["Bembo Schoolbook"] = !0;
    e1.Benguiat = !0;
    e1["Berkeley Old Style"] = !0;
    e1["Bernhard Modern"] = !0;
    e1["Berthold City"] = !0;
    e1.Bodoni = !0;
    e1["Bauer Bodoni"] = !0;
    e1["Book Antiqua"] = !0;
    e1.Bookman = !0;
    e1["Bordeaux Roman"] = !0;
    e1["Californian FB"] = !0;
    e1.Calisto = !0;
    e1.Calvert = !0;
    e1.Capitals = !0;
    e1.Cambria = !0;
    e1.Cartier = !0;
    e1.Caslon = !0;
    e1.Catull = !0;
    e1.Centaur = !0;
    e1["Century Old Style"] = !0;
    e1["Century Schoolbook"] = !0;
    e1.Chaparral = !0;
    e1["Charis SIL"] = !0;
    e1.Cheltenham = !0;
    e1["Cholla Slab"] = !0;
    e1.Clarendon = !0;
    e1.Clearface = !0;
    e1.Cochin = !0;
    e1.Colonna = !0;
    e1["Computer Modern"] = !0;
    e1["Concrete Roman"] = !0;
    e1.Constantia = !0;
    e1["Cooper Black"] = !0;
    e1.Corona = !0;
    e1.Ecotype = !0;
    e1.Egyptienne = !0;
    e1.Elephant = !0;
    e1.Excelsior = !0;
    e1.Fairfield = !0;
    e1["FF Scala"] = !0;
    e1.Folkard = !0;
    e1.Footlight = !0;
    e1.FreeSerif = !0;
    e1["Friz Quadrata"] = !0;
    e1.Garamond = !0;
    e1.Gentium = !0;
    e1.Georgia = !0;
    e1.Gloucester = !0;
    e1["Goudy Old Style"] = !0;
    e1["Goudy Schoolbook"] = !0;
    e1["Goudy Pro Font"] = !0;
    e1.Granjon = !0;
    e1["Guardian Egyptian"] = !0;
    e1.Heather = !0;
    e1.Hercules = !0;
    e1["High Tower Text"] = !0;
    e1.Hiroshige = !0;
    e1["Hoefler Text"] = !0;
    e1["Humana Serif"] = !0;
    e1.Imprint = !0;
    e1["Ionic No. 5"] = !0;
    e1.Janson = !0;
    e1.Joanna = !0;
    e1.Korinna = !0;
    e1.Lexicon = !0;
    e1.LiberationSerif = !0;
    e1["Liberation Serif"] = !0;
    e1["Linux Libertine"] = !0;
    e1.Literaturnaya = !0;
    e1.Lucida = !0;
    e1["Lucida Bright"] = !0;
    e1.Melior = !0;
    e1.Memphis = !0;
    e1.Miller = !0;
    e1.Minion = !0;
    e1.Modern = !0;
    e1["Mona Lisa"] = !0;
    e1["Mrs Eaves"] = !0;
    e1["MS Serif"] = !0;
    e1["Museo Slab"] = !0;
    e1["New York"] = !0;
    e1["Nimbus Roman"] = !0;
    e1["NPS Rawlinson Roadway"] = !0;
    e1.NuptialScript = !0;
    e1.Palatino = !0;
    e1.Perpetua = !0;
    e1.Plantin = !0;
    e1["Plantin Schoolbook"] = !0;
    e1.Playbill = !0;
    e1["Poor Richard"] = !0;
    e1["Rawlinson Roadway"] = !0;
    e1.Renault = !0;
    e1.Requiem = !0;
    e1.Rockwell = !0;
    e1.Roman = !0;
    e1["Rotis Serif"] = !0;
    e1.Sabon = !0;
    e1.Scala = !0;
    e1.Seagull = !0;
    e1.Sistina = !0;
    e1.Souvenir = !0;
    e1.STIX = !0;
    e1["Stone Informal"] = !0;
    e1["Stone Serif"] = !0;
    e1.Sylfaen = !0;
    e1.Times = !0;
    e1.Trajan = !0;
    e1["TrinitÃ©"] = !0;
    e1["Trump Mediaeval"] = !0;
    e1.Utopia = !0;
    e1["Vale Type"] = !0;
    e1["Bitstream Vera"] = !0;
    e1["Vera Serif"] = !0;
    e1.Versailles = !0;
    e1.Wanted = !0;
    e1.Weiss = !0;
    e1["Wide Latin"] = !0;
    e1.Windsor = !0;
    e1.XITS = !0;
}), qi = getLookupTableFactory(function(e1) {
    e1.Dingbats = !0;
    e1.Symbol = !0;
    e1.ZapfDingbats = !0;
    e1.Wingdings = !0;
    e1["Wingdings-Bold"] = !0;
    e1["Wingdings-Regular"] = !0;
}), Oi = getLookupTableFactory(function(e1) {
    e1[2] = 10;
    e1[3] = 32;
    e1[4] = 33;
    e1[5] = 34;
    e1[6] = 35;
    e1[7] = 36;
    e1[8] = 37;
    e1[9] = 38;
    e1[10] = 39;
    e1[11] = 40;
    e1[12] = 41;
    e1[13] = 42;
    e1[14] = 43;
    e1[15] = 44;
    e1[16] = 45;
    e1[17] = 46;
    e1[18] = 47;
    e1[19] = 48;
    e1[20] = 49;
    e1[21] = 50;
    e1[22] = 51;
    e1[23] = 52;
    e1[24] = 53;
    e1[25] = 54;
    e1[26] = 55;
    e1[27] = 56;
    e1[28] = 57;
    e1[29] = 58;
    e1[30] = 894;
    e1[31] = 60;
    e1[32] = 61;
    e1[33] = 62;
    e1[34] = 63;
    e1[35] = 64;
    e1[36] = 65;
    e1[37] = 66;
    e1[38] = 67;
    e1[39] = 68;
    e1[40] = 69;
    e1[41] = 70;
    e1[42] = 71;
    e1[43] = 72;
    e1[44] = 73;
    e1[45] = 74;
    e1[46] = 75;
    e1[47] = 76;
    e1[48] = 77;
    e1[49] = 78;
    e1[50] = 79;
    e1[51] = 80;
    e1[52] = 81;
    e1[53] = 82;
    e1[54] = 83;
    e1[55] = 84;
    e1[56] = 85;
    e1[57] = 86;
    e1[58] = 87;
    e1[59] = 88;
    e1[60] = 89;
    e1[61] = 90;
    e1[62] = 91;
    e1[63] = 92;
    e1[64] = 93;
    e1[65] = 94;
    e1[66] = 95;
    e1[67] = 96;
    e1[68] = 97;
    e1[69] = 98;
    e1[70] = 99;
    e1[71] = 100;
    e1[72] = 101;
    e1[73] = 102;
    e1[74] = 103;
    e1[75] = 104;
    e1[76] = 105;
    e1[77] = 106;
    e1[78] = 107;
    e1[79] = 108;
    e1[80] = 109;
    e1[81] = 110;
    e1[82] = 111;
    e1[83] = 112;
    e1[84] = 113;
    e1[85] = 114;
    e1[86] = 115;
    e1[87] = 116;
    e1[88] = 117;
    e1[89] = 118;
    e1[90] = 119;
    e1[91] = 120;
    e1[92] = 121;
    e1[93] = 122;
    e1[94] = 123;
    e1[95] = 124;
    e1[96] = 125;
    e1[97] = 126;
    e1[98] = 196;
    e1[99] = 197;
    e1[100] = 199;
    e1[101] = 201;
    e1[102] = 209;
    e1[103] = 214;
    e1[104] = 220;
    e1[105] = 225;
    e1[106] = 224;
    e1[107] = 226;
    e1[108] = 228;
    e1[109] = 227;
    e1[110] = 229;
    e1[111] = 231;
    e1[112] = 233;
    e1[113] = 232;
    e1[114] = 234;
    e1[115] = 235;
    e1[116] = 237;
    e1[117] = 236;
    e1[118] = 238;
    e1[119] = 239;
    e1[120] = 241;
    e1[121] = 243;
    e1[122] = 242;
    e1[123] = 244;
    e1[124] = 246;
    e1[125] = 245;
    e1[126] = 250;
    e1[127] = 249;
    e1[128] = 251;
    e1[129] = 252;
    e1[130] = 8224;
    e1[131] = 176;
    e1[132] = 162;
    e1[133] = 163;
    e1[134] = 167;
    e1[135] = 8226;
    e1[136] = 182;
    e1[137] = 223;
    e1[138] = 174;
    e1[139] = 169;
    e1[140] = 8482;
    e1[141] = 180;
    e1[142] = 168;
    e1[143] = 8800;
    e1[144] = 198;
    e1[145] = 216;
    e1[146] = 8734;
    e1[147] = 177;
    e1[148] = 8804;
    e1[149] = 8805;
    e1[150] = 165;
    e1[151] = 181;
    e1[152] = 8706;
    e1[153] = 8721;
    e1[154] = 8719;
    e1[156] = 8747;
    e1[157] = 170;
    e1[158] = 186;
    e1[159] = 8486;
    e1[160] = 230;
    e1[161] = 248;
    e1[162] = 191;
    e1[163] = 161;
    e1[164] = 172;
    e1[165] = 8730;
    e1[166] = 402;
    e1[167] = 8776;
    e1[168] = 8710;
    e1[169] = 171;
    e1[170] = 187;
    e1[171] = 8230;
    e1[179] = 8220;
    e1[180] = 8221;
    e1[181] = 8216;
    e1[182] = 8217;
    e1[200] = 193;
    e1[203] = 205;
    e1[207] = 211;
    e1[210] = 218;
    e1[223] = 711;
    e1[224] = 321;
    e1[225] = 322;
    e1[226] = 352;
    e1[227] = 353;
    e1[228] = 381;
    e1[229] = 382;
    e1[233] = 221;
    e1[234] = 253;
    e1[252] = 263;
    e1[253] = 268;
    e1[254] = 269;
    e1[258] = 258;
    e1[260] = 260;
    e1[261] = 261;
    e1[265] = 280;
    e1[266] = 281;
    e1[267] = 282;
    e1[268] = 283;
    e1[269] = 313;
    e1[275] = 323;
    e1[276] = 324;
    e1[278] = 328;
    e1[283] = 344;
    e1[284] = 345;
    e1[285] = 346;
    e1[286] = 347;
    e1[292] = 367;
    e1[295] = 377;
    e1[296] = 378;
    e1[298] = 380;
    e1[305] = 963;
    e1[306] = 964;
    e1[307] = 966;
    e1[308] = 8215;
    e1[309] = 8252;
    e1[310] = 8319;
    e1[311] = 8359;
    e1[312] = 8592;
    e1[313] = 8593;
    e1[337] = 9552;
    e1[493] = 1039;
    e1[494] = 1040;
    e1[672] = 1488;
    e1[673] = 1489;
    e1[674] = 1490;
    e1[675] = 1491;
    e1[676] = 1492;
    e1[677] = 1493;
    e1[678] = 1494;
    e1[679] = 1495;
    e1[680] = 1496;
    e1[681] = 1497;
    e1[682] = 1498;
    e1[683] = 1499;
    e1[684] = 1500;
    e1[685] = 1501;
    e1[686] = 1502;
    e1[687] = 1503;
    e1[688] = 1504;
    e1[689] = 1505;
    e1[690] = 1506;
    e1[691] = 1507;
    e1[692] = 1508;
    e1[693] = 1509;
    e1[694] = 1510;
    e1[695] = 1511;
    e1[696] = 1512;
    e1[697] = 1513;
    e1[698] = 1514;
    e1[705] = 1524;
    e1[706] = 8362;
    e1[710] = 64288;
    e1[711] = 64298;
    e1[759] = 1617;
    e1[761] = 1776;
    e1[763] = 1778;
    e1[775] = 1652;
    e1[777] = 1764;
    e1[778] = 1780;
    e1[779] = 1781;
    e1[780] = 1782;
    e1[782] = 771;
    e1[783] = 64726;
    e1[786] = 8363;
    e1[788] = 8532;
    e1[790] = 768;
    e1[791] = 769;
    e1[792] = 768;
    e1[795] = 803;
    e1[797] = 64336;
    e1[798] = 64337;
    e1[799] = 64342;
    e1[800] = 64343;
    e1[801] = 64344;
    e1[802] = 64345;
    e1[803] = 64362;
    e1[804] = 64363;
    e1[805] = 64364;
    e1[2424] = 7821;
    e1[2425] = 7822;
    e1[2426] = 7823;
    e1[2427] = 7824;
    e1[2428] = 7825;
    e1[2429] = 7826;
    e1[2430] = 7827;
    e1[2433] = 7682;
    e1[2678] = 8045;
    e1[2679] = 8046;
    e1[2830] = 1552;
    e1[2838] = 686;
    e1[2840] = 751;
    e1[2842] = 753;
    e1[2843] = 754;
    e1[2844] = 755;
    e1[2846] = 757;
    e1[2856] = 767;
    e1[2857] = 848;
    e1[2858] = 849;
    e1[2862] = 853;
    e1[2863] = 854;
    e1[2864] = 855;
    e1[2865] = 861;
    e1[2866] = 862;
    e1[2906] = 7460;
    e1[2908] = 7462;
    e1[2909] = 7463;
    e1[2910] = 7464;
    e1[2912] = 7466;
    e1[2913] = 7467;
    e1[2914] = 7468;
    e1[2916] = 7470;
    e1[2917] = 7471;
    e1[2918] = 7472;
    e1[2920] = 7474;
    e1[2921] = 7475;
    e1[2922] = 7476;
    e1[2924] = 7478;
    e1[2925] = 7479;
    e1[2926] = 7480;
    e1[2928] = 7482;
    e1[2929] = 7483;
    e1[2930] = 7484;
    e1[2932] = 7486;
    e1[2933] = 7487;
    e1[2934] = 7488;
    e1[2936] = 7490;
    e1[2937] = 7491;
    e1[2938] = 7492;
    e1[2940] = 7494;
    e1[2941] = 7495;
    e1[2942] = 7496;
    e1[2944] = 7498;
    e1[2946] = 7500;
    e1[2948] = 7502;
    e1[2950] = 7504;
    e1[2951] = 7505;
    e1[2952] = 7506;
    e1[2954] = 7508;
    e1[2955] = 7509;
    e1[2956] = 7510;
    e1[2958] = 7512;
    e1[2959] = 7513;
    e1[2960] = 7514;
    e1[2962] = 7516;
    e1[2963] = 7517;
    e1[2964] = 7518;
    e1[2966] = 7520;
    e1[2967] = 7521;
    e1[2968] = 7522;
    e1[2970] = 7524;
    e1[2971] = 7525;
    e1[2972] = 7526;
    e1[2974] = 7528;
    e1[2975] = 7529;
    e1[2976] = 7530;
    e1[2978] = 1537;
    e1[2979] = 1538;
    e1[2980] = 1539;
    e1[2982] = 1549;
    e1[2983] = 1551;
    e1[2984] = 1552;
    e1[2986] = 1554;
    e1[2987] = 1555;
    e1[2988] = 1556;
    e1[2990] = 1623;
    e1[2991] = 1624;
    e1[2995] = 1775;
    e1[2999] = 1791;
    e1[3002] = 64290;
    e1[3003] = 64291;
    e1[3004] = 64292;
    e1[3006] = 64294;
    e1[3007] = 64295;
    e1[3008] = 64296;
    e1[3011] = 1900;
    e1[3014] = 8223;
    e1[3015] = 8244;
    e1[3017] = 7532;
    e1[3018] = 7533;
    e1[3019] = 7534;
    e1[3075] = 7590;
    e1[3076] = 7591;
    e1[3079] = 7594;
    e1[3080] = 7595;
    e1[3083] = 7598;
    e1[3084] = 7599;
    e1[3087] = 7602;
    e1[3088] = 7603;
    e1[3091] = 7606;
    e1[3092] = 7607;
    e1[3095] = 7610;
    e1[3096] = 7611;
    e1[3099] = 7614;
    e1[3100] = 7615;
    e1[3103] = 7618;
    e1[3104] = 7619;
    e1[3107] = 8337;
    e1[3108] = 8338;
    e1[3116] = 1884;
    e1[3119] = 1885;
    e1[3120] = 1885;
    e1[3123] = 1886;
    e1[3124] = 1886;
    e1[3127] = 1887;
    e1[3128] = 1887;
    e1[3131] = 1888;
    e1[3132] = 1888;
    e1[3135] = 1889;
    e1[3136] = 1889;
    e1[3139] = 1890;
    e1[3140] = 1890;
    e1[3143] = 1891;
    e1[3144] = 1891;
    e1[3147] = 1892;
    e1[3148] = 1892;
    e1[3153] = 580;
    e1[3154] = 581;
    e1[3157] = 584;
    e1[3158] = 585;
    e1[3161] = 588;
    e1[3162] = 589;
    e1[3165] = 891;
    e1[3166] = 892;
    e1[3169] = 1274;
    e1[3170] = 1275;
    e1[3173] = 1278;
    e1[3174] = 1279;
    e1[3181] = 7622;
    e1[3182] = 7623;
    e1[3282] = 11799;
    e1[3316] = 578;
    e1[3379] = 42785;
    e1[3393] = 1159;
    e1[3416] = 8377;
}), Pi = getLookupTableFactory(function(e1) {
    e1[227] = 322;
    e1[264] = 261;
    e1[291] = 346;
}), Wi = getLookupTableFactory(function(e1) {
    e1[1] = 32;
    e1[4] = 65;
    e1[5] = 192;
    e1[6] = 193;
    e1[9] = 196;
    e1[17] = 66;
    e1[18] = 67;
    e1[21] = 268;
    e1[24] = 68;
    e1[28] = 69;
    e1[29] = 200;
    e1[30] = 201;
    e1[32] = 282;
    e1[38] = 70;
    e1[39] = 71;
    e1[44] = 72;
    e1[47] = 73;
    e1[48] = 204;
    e1[49] = 205;
    e1[58] = 74;
    e1[60] = 75;
    e1[62] = 76;
    e1[68] = 77;
    e1[69] = 78;
    e1[75] = 79;
    e1[76] = 210;
    e1[80] = 214;
    e1[87] = 80;
    e1[89] = 81;
    e1[90] = 82;
    e1[92] = 344;
    e1[94] = 83;
    e1[97] = 352;
    e1[100] = 84;
    e1[104] = 85;
    e1[109] = 220;
    e1[115] = 86;
    e1[116] = 87;
    e1[121] = 88;
    e1[122] = 89;
    e1[124] = 221;
    e1[127] = 90;
    e1[129] = 381;
    e1[258] = 97;
    e1[259] = 224;
    e1[260] = 225;
    e1[263] = 228;
    e1[268] = 261;
    e1[271] = 98;
    e1[272] = 99;
    e1[273] = 263;
    e1[275] = 269;
    e1[282] = 100;
    e1[286] = 101;
    e1[287] = 232;
    e1[288] = 233;
    e1[290] = 283;
    e1[295] = 281;
    e1[296] = 102;
    e1[336] = 103;
    e1[346] = 104;
    e1[349] = 105;
    e1[350] = 236;
    e1[351] = 237;
    e1[361] = 106;
    e1[364] = 107;
    e1[367] = 108;
    e1[371] = 322;
    e1[373] = 109;
    e1[374] = 110;
    e1[381] = 111;
    e1[382] = 242;
    e1[383] = 243;
    e1[386] = 246;
    e1[393] = 112;
    e1[395] = 113;
    e1[396] = 114;
    e1[398] = 345;
    e1[400] = 115;
    e1[401] = 347;
    e1[403] = 353;
    e1[410] = 116;
    e1[437] = 117;
    e1[442] = 252;
    e1[448] = 118;
    e1[449] = 119;
    e1[454] = 120;
    e1[455] = 121;
    e1[457] = 253;
    e1[460] = 122;
    e1[462] = 382;
    e1[463] = 380;
    e1[853] = 44;
    e1[855] = 58;
    e1[856] = 46;
    e1[876] = 47;
    e1[878] = 45;
    e1[882] = 45;
    e1[894] = 40;
    e1[895] = 41;
    e1[896] = 91;
    e1[897] = 93;
    e1[923] = 64;
    e1[1004] = 48;
    e1[1005] = 49;
    e1[1006] = 50;
    e1[1007] = 51;
    e1[1008] = 52;
    e1[1009] = 53;
    e1[1010] = 54;
    e1[1011] = 55;
    e1[1012] = 56;
    e1[1013] = 57;
    e1[1081] = 37;
    e1[1085] = 43;
    e1[1086] = 45;
});
function getStandardFontName(e1) {
    const t = normalizeFontName(e1);
    return Yi()[t];
}
function isKnownFontName(e1) {
    const t = normalizeFontName(e1);
    return !!(Yi()[t] || Ki()[t] || Ti()[t] || qi()[t]);
}
class ToUnicodeMap {
    constructor(e1 = []){
        this._map = e1;
    }
    get length() {
        return this._map.length;
    }
    forEach(e1) {
        for(const t in this._map)e1(t, this._map[t].codePointAt(0));
    }
    has(e1) {
        return void 0 !== this._map[e1];
    }
    get(e1) {
        return this._map[e1];
    }
    charCodeOf(e1) {
        const t = this._map;
        if (t.length <= 65536) return t.indexOf(e1);
        for(const i in t)if (t[i] === e1) return 0 | i;
        return -1;
    }
    amend(e1) {
        for(const t in e1)this._map[t] = e1[t];
    }
}
class IdentityToUnicodeMap {
    constructor(e1, t){
        this.firstChar = e1;
        this.lastChar = t;
    }
    get length() {
        return this.lastChar + 1 - this.firstChar;
    }
    forEach(e1) {
        for(let t = this.firstChar, i = this.lastChar; t <= i; t++)e1(t, t);
    }
    has(e1) {
        return this.firstChar <= e1 && e1 <= this.lastChar;
    }
    get(e1) {
        if (this.firstChar <= e1 && e1 <= this.lastChar) return String.fromCharCode(e1);
    }
    charCodeOf(e1) {
        return Number.isInteger(e1) && e1 >= this.firstChar && e1 <= this.lastChar ? e1 : -1;
    }
    amend(e1) {
        unreachable("Should not call amend()");
    }
}
class CFFFont {
    constructor(e1, t){
        this.properties = t;
        const i = new CFFParser(e1, t, Ri);
        this.cff = i.parse();
        this.cff.duplicateFirstGlyph();
        const a = new CFFCompiler(this.cff);
        this.seacs = this.cff.seacs;
        try {
            this.data = a.compile();
        } catch  {
            warn("Failed to compile font " + t.loadedName);
            this.data = e1;
        }
        this._createBuiltInEncoding();
    }
    get numGlyphs() {
        return this.cff.charStrings.count;
    }
    getCharset() {
        return this.cff.charset.charset;
    }
    getGlyphMapping() {
        const e1 = this.cff, t = this.properties, { cidToGidMap: i, cMap: a } = t, s = e1.charset.charset;
        let r, n;
        if (t.composite) {
            let t, g;
            if (i?.length > 0) {
                t = Object.create(null);
                for(let e1 = 0, a = i.length; e1 < a; e1++){
                    const a = i[e1];
                    void 0 !== a && (t[a] = e1);
                }
            }
            r = Object.create(null);
            if (e1.isCIDFont) for(n = 0; n < s.length; n++){
                const e1 = s[n];
                g = a.charCodeOf(e1);
                void 0 !== t?.[g] && (g = t[g]);
                r[g] = n;
            }
            else for(n = 0; n < e1.charStrings.count; n++){
                g = a.charCodeOf(n);
                r[g] = n;
            }
            return r;
        }
        let g = e1.encoding ? e1.encoding.encoding : null;
        t.isInternalFont && (g = t.defaultEncoding);
        r = type1FontGlyphMapping(t, g, s);
        return r;
    }
    hasGlyphId(e1) {
        return this.cff.hasGlyphId(e1);
    }
    _createBuiltInEncoding() {
        const { charset: e1, encoding: t } = this.cff;
        if (!e1 || !t) return;
        const i = e1.charset, a = t.encoding, s = [];
        for(const e1 in a){
            const t = a[e1];
            if (t >= 0) {
                const a = i[t];
                a && (s[e1] = a);
            }
        }
        s.length > 0 && (this.properties.builtInEncoding = s);
    }
}
function getUint32(e1, t) {
    return (e1[t] << 24 | e1[t + 1] << 16 | e1[t + 2] << 8 | e1[t + 3]) >>> 0;
}
function getUint16(e1, t) {
    return e1[t] << 8 | e1[t + 1];
}
function getInt16(e1, t) {
    return (e1[t] << 24 | e1[t + 1] << 16) >> 16;
}
function getInt8(e1, t) {
    return e1[t] << 24 >> 24;
}
function getFloat214(e1, t) {
    return getInt16(e1, t) / 16384;
}
function getSubroutineBias(e1) {
    const t = e1.length;
    let i = 32768;
    t < 1240 ? i = 107 : t < 33900 && (i = 1131);
    return i;
}
function parseCmap(e1, t, i) {
    const a = 1 === getUint16(e1, t + 2) ? getUint32(e1, t + 8) : getUint32(e1, t + 16), s = getUint16(e1, t + a);
    let r, n, g;
    if (4 === s) {
        getUint16(e1, t + a + 2);
        const i = getUint16(e1, t + a + 6) >> 1;
        n = t + a + 14;
        r = [];
        for(g = 0; g < i; g++, n += 2)r[g] = {
            end: getUint16(e1, n)
        };
        n += 2;
        for(g = 0; g < i; g++, n += 2)r[g].start = getUint16(e1, n);
        for(g = 0; g < i; g++, n += 2)r[g].idDelta = getUint16(e1, n);
        for(g = 0; g < i; g++, n += 2){
            let t = getUint16(e1, n);
            if (0 !== t) {
                r[g].ids = [];
                for(let i = 0, a = r[g].end - r[g].start + 1; i < a; i++){
                    r[g].ids[i] = getUint16(e1, n + t);
                    t += 2;
                }
            }
        }
        return r;
    }
    if (12 === s) {
        const i = getUint32(e1, t + a + 12);
        n = t + a + 16;
        r = [];
        for(g = 0; g < i; g++){
            t = getUint32(e1, n);
            r.push({
                start: t,
                end: getUint32(e1, n + 4),
                idDelta: getUint32(e1, n + 8) - t
            });
            n += 12;
        }
        return r;
    }
    throw new FormatError(`unsupported cmap: ${s}`);
}
function parseCff(e1, t, i, a) {
    const s = new CFFParser(new Stream(e1, t, i - t), {}, a).parse();
    return {
        glyphs: s.charStrings.objects,
        subrs: s.topDict.privateDict?.subrsIndex?.objects,
        gsubrs: s.globalSubrIndex?.objects,
        isCFFCIDFont: s.isCIDFont,
        fdSelect: s.fdSelect,
        fdArray: s.fdArray
    };
}
function lookupCmap(e1, t) {
    const i = t.codePointAt(0);
    let a = 0, s = 0, r = e1.length - 1;
    for(; s < r;){
        const t = s + r + 1 >> 1;
        i < e1[t].start ? r = t - 1 : s = t;
    }
    e1[s].start <= i && i <= e1[s].end && (a = e1[s].idDelta + (e1[s].ids ? e1[s].ids[i - e1[s].start] : i) & 65535);
    return {
        charCode: i,
        glyphId: a
    };
}
function compileGlyf(e1, t, i) {
    function moveTo(e1, i) {
        t.add("M", [
            e1,
            i
        ]);
    }
    function lineTo(e1, i) {
        t.add("L", [
            e1,
            i
        ]);
    }
    function quadraticCurveTo(e1, i, a, s) {
        t.add("Q", [
            e1,
            i,
            a,
            s
        ]);
    }
    let a = 0;
    const s = getInt16(e1, a);
    let r, n = 0, g = 0;
    a += 10;
    if (s < 0) do {
        r = getUint16(e1, a);
        const s = getUint16(e1, a + 2);
        a += 4;
        let o, c;
        if (1 & r) {
            if (2 & r) {
                o = getInt16(e1, a);
                c = getInt16(e1, a + 2);
            } else {
                o = getUint16(e1, a);
                c = getUint16(e1, a + 2);
            }
            a += 4;
        } else if (2 & r) {
            o = getInt8(e1, a++);
            c = getInt8(e1, a++);
        } else {
            o = e1[a++];
            c = e1[a++];
        }
        if (2 & r) {
            n = o;
            g = c;
        } else {
            n = 0;
            g = 0;
        }
        let C = 1, h = 1, l = 0, Q = 0;
        if (8 & r) {
            C = h = getFloat214(e1, a);
            a += 2;
        } else if (64 & r) {
            C = getFloat214(e1, a);
            h = getFloat214(e1, a + 2);
            a += 4;
        } else if (128 & r) {
            C = getFloat214(e1, a);
            l = getFloat214(e1, a + 2);
            Q = getFloat214(e1, a + 4);
            h = getFloat214(e1, a + 6);
            a += 8;
        }
        const E = i.glyphs[s];
        if (E) {
            t.save();
            t.transform([
                C,
                l,
                Q,
                h,
                n,
                g
            ]);
            compileGlyf(E, t, i);
            t.restore();
        }
    }while (32 & r)
    else {
        const t = [];
        let i, o;
        for(i = 0; i < s; i++){
            t.push(getUint16(e1, a));
            a += 2;
        }
        a += 2 + getUint16(e1, a);
        const c = t.at(-1) + 1, C = [];
        for(; C.length < c;){
            r = e1[a++];
            let t = 1;
            8 & r && (t += e1[a++]);
            for(; t-- > 0;)C.push({
                flags: r
            });
        }
        for(i = 0; i < c; i++){
            switch(18 & C[i].flags){
                case 0:
                    n += getInt16(e1, a);
                    a += 2;
                    break;
                case 2:
                    n -= e1[a++];
                    break;
                case 18:
                    n += e1[a++];
            }
            C[i].x = n;
        }
        for(i = 0; i < c; i++){
            switch(36 & C[i].flags){
                case 0:
                    g += getInt16(e1, a);
                    a += 2;
                    break;
                case 4:
                    g -= e1[a++];
                    break;
                case 36:
                    g += e1[a++];
            }
            C[i].y = g;
        }
        let h = 0;
        for(a = 0; a < s; a++){
            const e1 = t[a], s = C.slice(h, e1 + 1);
            if (1 & s[0].flags) s.push(s[0]);
            else if (1 & s.at(-1).flags) s.unshift(s.at(-1));
            else {
                const e1 = {
                    flags: 1,
                    x: (s[0].x + s.at(-1).x) / 2,
                    y: (s[0].y + s.at(-1).y) / 2
                };
                s.unshift(e1);
                s.push(e1);
            }
            moveTo(s[0].x, s[0].y);
            for(i = 1, o = s.length; i < o; i++)if (1 & s[i].flags) lineTo(s[i].x, s[i].y);
            else if (1 & s[i + 1].flags) {
                quadraticCurveTo(s[i].x, s[i].y, s[i + 1].x, s[i + 1].y);
                i++;
            } else quadraticCurveTo(s[i].x, s[i].y, (s[i].x + s[i + 1].x) / 2, (s[i].y + s[i + 1].y) / 2);
            h = e1 + 1;
        }
    }
}
function compileCharString(e1, t, i, a) {
    function moveTo(e1, i) {
        t.add("M", [
            e1,
            i
        ]);
    }
    function lineTo(e1, i) {
        t.add("L", [
            e1,
            i
        ]);
    }
    function bezierCurveTo(e1, i, a, s, r, n) {
        t.add("C", [
            e1,
            i,
            a,
            s,
            r,
            n
        ]);
    }
    const s = [];
    let r = 0, n = 0, g = 0;
    !function parse(e1) {
        let o = 0;
        for(; o < e1.length;){
            let c, C, h, l, Q, E, u, d, f, p = !1, m = e1[o++];
            switch(m){
                case 1:
                case 3:
                case 18:
                case 23:
                    g += s.length >> 1;
                    p = !0;
                    break;
                case 4:
                    n += s.pop();
                    moveTo(r, n);
                    p = !0;
                    break;
                case 5:
                    for(; s.length > 0;){
                        r += s.shift();
                        n += s.shift();
                        lineTo(r, n);
                    }
                    break;
                case 6:
                    for(; s.length > 0;){
                        r += s.shift();
                        lineTo(r, n);
                        if (0 === s.length) break;
                        n += s.shift();
                        lineTo(r, n);
                    }
                    break;
                case 7:
                    for(; s.length > 0;){
                        n += s.shift();
                        lineTo(r, n);
                        if (0 === s.length) break;
                        r += s.shift();
                        lineTo(r, n);
                    }
                    break;
                case 8:
                    for(; s.length > 0;){
                        c = r + s.shift();
                        h = n + s.shift();
                        C = c + s.shift();
                        l = h + s.shift();
                        r = C + s.shift();
                        n = l + s.shift();
                        bezierCurveTo(c, h, C, l, r, n);
                    }
                    break;
                case 10:
                    d = s.pop();
                    f = null;
                    if (i.isCFFCIDFont) {
                        const e1 = i.fdSelect.getFDIndex(a);
                        if (e1 >= 0 && e1 < i.fdArray.length) {
                            const t = i.fdArray[e1];
                            let a;
                            t.privateDict?.subrsIndex && (a = t.privateDict.subrsIndex.objects);
                            if (a) {
                                d += getSubroutineBias(a);
                                f = a[d];
                            }
                        } else warn("Invalid fd index for glyph index.");
                    } else f = i.subrs[d + i.subrsBias];
                    f && parse(f);
                    break;
                case 11:
                    return;
                case 12:
                    m = e1[o++];
                    switch(m){
                        case 34:
                            c = r + s.shift();
                            C = c + s.shift();
                            Q = n + s.shift();
                            r = C + s.shift();
                            bezierCurveTo(c, n, C, Q, r, Q);
                            c = r + s.shift();
                            C = c + s.shift();
                            r = C + s.shift();
                            bezierCurveTo(c, Q, C, n, r, n);
                            break;
                        case 35:
                            c = r + s.shift();
                            h = n + s.shift();
                            C = c + s.shift();
                            l = h + s.shift();
                            r = C + s.shift();
                            n = l + s.shift();
                            bezierCurveTo(c, h, C, l, r, n);
                            c = r + s.shift();
                            h = n + s.shift();
                            C = c + s.shift();
                            l = h + s.shift();
                            r = C + s.shift();
                            n = l + s.shift();
                            bezierCurveTo(c, h, C, l, r, n);
                            s.pop();
                            break;
                        case 36:
                            c = r + s.shift();
                            Q = n + s.shift();
                            C = c + s.shift();
                            E = Q + s.shift();
                            r = C + s.shift();
                            bezierCurveTo(c, Q, C, E, r, E);
                            c = r + s.shift();
                            C = c + s.shift();
                            u = E + s.shift();
                            r = C + s.shift();
                            bezierCurveTo(c, E, C, u, r, n);
                            break;
                        case 37:
                            const e2 = r, t1 = n;
                            c = r + s.shift();
                            h = n + s.shift();
                            C = c + s.shift();
                            l = h + s.shift();
                            r = C + s.shift();
                            n = l + s.shift();
                            bezierCurveTo(c, h, C, l, r, n);
                            c = r + s.shift();
                            h = n + s.shift();
                            C = c + s.shift();
                            l = h + s.shift();
                            r = C;
                            n = l;
                            Math.abs(r - e2) > Math.abs(n - t1) ? r += s.shift() : n += s.shift();
                            bezierCurveTo(c, h, C, l, r, n);
                            break;
                        default:
                            throw new FormatError(`unknown operator: 12 ${m}`);
                    }
                    break;
                case 14:
                    if (s.length >= 4) {
                        const e1 = s.pop(), a = s.pop();
                        n = s.pop();
                        r = s.pop();
                        t.save();
                        t.translate(r, n);
                        let g = lookupCmap(i.cmap, String.fromCharCode(i.glyphNameMap[hi[e1]]));
                        compileCharString(i.glyphs[g.glyphId], t, i, g.glyphId);
                        t.restore();
                        g = lookupCmap(i.cmap, String.fromCharCode(i.glyphNameMap[hi[a]]));
                        compileCharString(i.glyphs[g.glyphId], t, i, g.glyphId);
                    }
                    return;
                case 19:
                case 20:
                    g += s.length >> 1;
                    o += g + 7 >> 3;
                    p = !0;
                    break;
                case 21:
                    n += s.pop();
                    r += s.pop();
                    moveTo(r, n);
                    p = !0;
                    break;
                case 22:
                    r += s.pop();
                    moveTo(r, n);
                    p = !0;
                    break;
                case 24:
                    for(; s.length > 2;){
                        c = r + s.shift();
                        h = n + s.shift();
                        C = c + s.shift();
                        l = h + s.shift();
                        r = C + s.shift();
                        n = l + s.shift();
                        bezierCurveTo(c, h, C, l, r, n);
                    }
                    r += s.shift();
                    n += s.shift();
                    lineTo(r, n);
                    break;
                case 25:
                    for(; s.length > 6;){
                        r += s.shift();
                        n += s.shift();
                        lineTo(r, n);
                    }
                    c = r + s.shift();
                    h = n + s.shift();
                    C = c + s.shift();
                    l = h + s.shift();
                    r = C + s.shift();
                    n = l + s.shift();
                    bezierCurveTo(c, h, C, l, r, n);
                    break;
                case 26:
                    s.length % 2 && (r += s.shift());
                    for(; s.length > 0;){
                        c = r;
                        h = n + s.shift();
                        C = c + s.shift();
                        l = h + s.shift();
                        r = C;
                        n = l + s.shift();
                        bezierCurveTo(c, h, C, l, r, n);
                    }
                    break;
                case 27:
                    s.length % 2 && (n += s.shift());
                    for(; s.length > 0;){
                        c = r + s.shift();
                        h = n;
                        C = c + s.shift();
                        l = h + s.shift();
                        r = C + s.shift();
                        n = l;
                        bezierCurveTo(c, h, C, l, r, n);
                    }
                    break;
                case 28:
                    s.push((e1[o] << 24 | e1[o + 1] << 16) >> 16);
                    o += 2;
                    break;
                case 29:
                    d = s.pop() + i.gsubrsBias;
                    f = i.gsubrs[d];
                    f && parse(f);
                    break;
                case 30:
                    for(; s.length > 0;){
                        c = r;
                        h = n + s.shift();
                        C = c + s.shift();
                        l = h + s.shift();
                        r = C + s.shift();
                        n = l + (1 === s.length ? s.shift() : 0);
                        bezierCurveTo(c, h, C, l, r, n);
                        if (0 === s.length) break;
                        c = r + s.shift();
                        h = n;
                        C = c + s.shift();
                        l = h + s.shift();
                        n = l + s.shift();
                        r = C + (1 === s.length ? s.shift() : 0);
                        bezierCurveTo(c, h, C, l, r, n);
                    }
                    break;
                case 31:
                    for(; s.length > 0;){
                        c = r + s.shift();
                        h = n;
                        C = c + s.shift();
                        l = h + s.shift();
                        n = l + s.shift();
                        r = C + (1 === s.length ? s.shift() : 0);
                        bezierCurveTo(c, h, C, l, r, n);
                        if (0 === s.length) break;
                        c = r;
                        h = n + s.shift();
                        C = c + s.shift();
                        l = h + s.shift();
                        r = C + s.shift();
                        n = l + (1 === s.length ? s.shift() : 0);
                        bezierCurveTo(c, h, C, l, r, n);
                    }
                    break;
                default:
                    if (m < 32) throw new FormatError(`unknown operator: ${m}`);
                    if (m < 247) s.push(m - 139);
                    else if (m < 251) s.push(256 * (m - 247) + e1[o++] + 108);
                    else if (m < 255) s.push(256 * -(m - 251) - e1[o++] - 108);
                    else {
                        s.push((e1[o] << 24 | e1[o + 1] << 16 | e1[o + 2] << 8 | e1[o + 3]) / 65536);
                        o += 4;
                    }
            }
            p && (s.length = 0);
        }
    }(e1);
}
class Commands {
    cmds = [];
    transformStack = [];
    currentTransform = [
        1,
        0,
        0,
        1,
        0,
        0
    ];
    add(e1, t) {
        if (t) {
            const [i, a, s, r, n, g] = this.currentTransform;
            for(let e1 = 0, o = t.length; e1 < o; e1 += 2){
                const o = t[e1], c = t[e1 + 1];
                t[e1] = i * o + s * c + n;
                t[e1 + 1] = a * o + r * c + g;
            }
            this.cmds.push(`${e1}${t.join(" ")}`);
        } else this.cmds.push(e1);
    }
    transform(e1) {
        this.currentTransform = Util.transform(this.currentTransform, e1);
    }
    translate(e1, t) {
        this.transform([
            1,
            0,
            0,
            1,
            e1,
            t
        ]);
    }
    save() {
        this.transformStack.push(this.currentTransform.slice());
    }
    restore() {
        this.currentTransform = this.transformStack.pop() || [
            1,
            0,
            0,
            1,
            0,
            0
        ];
    }
    getSVG() {
        return this.cmds.join("");
    }
}
class CompiledFont {
    constructor(e1){
        this.fontMatrix = e1;
        this.compiledGlyphs = Object.create(null);
        this.compiledCharCodeToGlyphId = Object.create(null);
    }
    getPathJs(e1) {
        const { charCode: t, glyphId: i } = lookupCmap(this.cmap, e1);
        let a, s = this.compiledGlyphs[i];
        if (void 0 === s) {
            try {
                s = this.compileGlyph(this.glyphs[i], i);
            } catch (e1) {
                s = "";
                a = e1;
            }
            this.compiledGlyphs[i] = s;
        }
        this.compiledCharCodeToGlyphId[t] ??= i;
        if (a) throw a;
        return s;
    }
    compileGlyph(e1, t) {
        if (!e1?.length || 14 === e1[0]) return "";
        let i = this.fontMatrix;
        if (this.isCFFCIDFont) {
            const e1 = this.fdSelect.getFDIndex(t);
            if (e1 >= 0 && e1 < this.fdArray.length) {
                i = this.fdArray[e1].getByName("FontMatrix") || a;
            } else warn("Invalid fd index for glyph index.");
        }
        assert(isNumberArray(i, 6), "Expected a valid fontMatrix.");
        const s = new Commands;
        s.transform(i.slice());
        this.compileGlyphImpl(e1, s, t);
        s.add("Z");
        return s.getSVG();
    }
    compileGlyphImpl() {
        unreachable("Children classes should implement this.");
    }
    hasBuiltPath(e1) {
        const { charCode: t, glyphId: i } = lookupCmap(this.cmap, e1);
        return void 0 !== this.compiledGlyphs[i] && void 0 !== this.compiledCharCodeToGlyphId[t];
    }
}
class TrueTypeCompiled extends CompiledFont {
    constructor(e1, t, i){
        super(i || [
            488e-6,
            0,
            0,
            488e-6,
            0,
            0
        ]);
        this.glyphs = e1;
        this.cmap = t;
    }
    compileGlyphImpl(e1, t) {
        compileGlyf(e1, t, this);
    }
}
class Type2Compiled extends CompiledFont {
    constructor(e1, t, i){
        super(i || [
            .001,
            0,
            0,
            .001,
            0,
            0
        ]);
        this.glyphs = e1.glyphs;
        this.gsubrs = e1.gsubrs || [];
        this.subrs = e1.subrs || [];
        this.cmap = t;
        this.glyphNameMap = wi();
        this.gsubrsBias = getSubroutineBias(this.gsubrs);
        this.subrsBias = getSubroutineBias(this.subrs);
        this.isCFFCIDFont = e1.isCFFCIDFont;
        this.fdSelect = e1.fdSelect;
        this.fdArray = e1.fdArray;
    }
    compileGlyphImpl(e1, t, i) {
        compileCharString(e1, t, this, i);
    }
}
class FontRendererFactory {
    static create(e1, t) {
        const i = new Uint8Array(e1.data);
        let a, s, r, n, g, o;
        const c = getUint16(i, 4);
        for(let e1 = 0, C = 12; e1 < c; e1++, C += 16){
            const e1 = bytesToString(i.subarray(C, C + 4)), c = getUint32(i, C + 8), h = getUint32(i, C + 12);
            switch(e1){
                case "cmap":
                    a = parseCmap(i, c);
                    break;
                case "glyf":
                    s = i.subarray(c, c + h);
                    break;
                case "loca":
                    r = i.subarray(c, c + h);
                    break;
                case "head":
                    o = getUint16(i, c + 18);
                    g = getUint16(i, c + 50);
                    break;
                case "CFF ":
                    n = parseCff(i, c, c + h, t);
            }
        }
        if (s) {
            const t = o ? [
                1 / o,
                0,
                0,
                1 / o,
                0,
                0
            ] : e1.fontMatrix;
            return new TrueTypeCompiled(function parseGlyfTable(e1, t, i) {
                let a, s;
                if (i) {
                    a = 4;
                    s = getUint32;
                } else {
                    a = 2;
                    s = (e1, t)=>2 * getUint16(e1, t);
                }
                const r = [];
                let n = s(t, 0);
                for(let i = a; i < t.length; i += a){
                    const a = s(t, i);
                    r.push(e1.subarray(n, a));
                    n = a;
                }
                return r;
            }(s, r, g), a, t);
        }
        return new Type2Compiled(n, a, e1.fontMatrix);
    }
}
const ji = getLookupTableFactory(function(e1) {
    e1.Courier = 600;
    e1["Courier-Bold"] = 600;
    e1["Courier-BoldOblique"] = 600;
    e1["Courier-Oblique"] = 600;
    e1.Helvetica = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.exclam = 278;
        e1.quotedbl = 355;
        e1.numbersign = 556;
        e1.dollar = 556;
        e1.percent = 889;
        e1.ampersand = 667;
        e1.quoteright = 222;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 389;
        e1.plus = 584;
        e1.comma = 278;
        e1.hyphen = 333;
        e1.period = 278;
        e1.slash = 278;
        e1.zero = 556;
        e1.one = 556;
        e1.two = 556;
        e1.three = 556;
        e1.four = 556;
        e1.five = 556;
        e1.six = 556;
        e1.seven = 556;
        e1.eight = 556;
        e1.nine = 556;
        e1.colon = 278;
        e1.semicolon = 278;
        e1.less = 584;
        e1.equal = 584;
        e1.greater = 584;
        e1.question = 556;
        e1.at = 1015;
        e1.A = 667;
        e1.B = 667;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 722;
        e1.I = 278;
        e1.J = 500;
        e1.K = 667;
        e1.L = 556;
        e1.M = 833;
        e1.N = 722;
        e1.O = 778;
        e1.P = 667;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 667;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 944;
        e1.X = 667;
        e1.Y = 667;
        e1.Z = 611;
        e1.bracketleft = 278;
        e1.backslash = 278;
        e1.bracketright = 278;
        e1.asciicircum = 469;
        e1.underscore = 556;
        e1.quoteleft = 222;
        e1.a = 556;
        e1.b = 556;
        e1.c = 500;
        e1.d = 556;
        e1.e = 556;
        e1.f = 278;
        e1.g = 556;
        e1.h = 556;
        e1.i = 222;
        e1.j = 222;
        e1.k = 500;
        e1.l = 222;
        e1.m = 833;
        e1.n = 556;
        e1.o = 556;
        e1.p = 556;
        e1.q = 556;
        e1.r = 333;
        e1.s = 500;
        e1.t = 278;
        e1.u = 556;
        e1.v = 500;
        e1.w = 722;
        e1.x = 500;
        e1.y = 500;
        e1.z = 500;
        e1.braceleft = 334;
        e1.bar = 260;
        e1.braceright = 334;
        e1.asciitilde = 584;
        e1.exclamdown = 333;
        e1.cent = 556;
        e1.sterling = 556;
        e1.fraction = 167;
        e1.yen = 556;
        e1.florin = 556;
        e1.section = 556;
        e1.currency = 556;
        e1.quotesingle = 191;
        e1.quotedblleft = 333;
        e1.guillemotleft = 556;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 500;
        e1.fl = 500;
        e1.endash = 556;
        e1.dagger = 556;
        e1.daggerdbl = 556;
        e1.periodcentered = 278;
        e1.paragraph = 537;
        e1.bullet = 350;
        e1.quotesinglbase = 222;
        e1.quotedblbase = 333;
        e1.quotedblright = 333;
        e1.guillemotright = 556;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 611;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 370;
        e1.Lslash = 556;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 365;
        e1.ae = 889;
        e1.dotlessi = 278;
        e1.lslash = 222;
        e1.oslash = 611;
        e1.oe = 944;
        e1.germandbls = 611;
        e1.Idieresis = 278;
        e1.eacute = 556;
        e1.abreve = 556;
        e1.uhungarumlaut = 556;
        e1.ecaron = 556;
        e1.Ydieresis = 667;
        e1.divide = 584;
        e1.Yacute = 667;
        e1.Acircumflex = 667;
        e1.aacute = 556;
        e1.Ucircumflex = 722;
        e1.yacute = 500;
        e1.scommaaccent = 500;
        e1.ecircumflex = 556;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 556;
        e1.Uacute = 722;
        e1.uogonek = 556;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 737;
        e1.Emacron = 667;
        e1.ccaron = 500;
        e1.aring = 556;
        e1.Ncommaaccent = 722;
        e1.lacute = 222;
        e1.agrave = 556;
        e1.Tcommaaccent = 611;
        e1.Cacute = 722;
        e1.atilde = 556;
        e1.Edotaccent = 667;
        e1.scaron = 500;
        e1.scedilla = 500;
        e1.iacute = 278;
        e1.lozenge = 471;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 556;
        e1.acircumflex = 556;
        e1.Amacron = 667;
        e1.rcaron = 333;
        e1.ccedilla = 500;
        e1.Zdotaccent = 611;
        e1.Thorn = 667;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 667;
        e1.dcaron = 643;
        e1.Umacron = 722;
        e1.uring = 556;
        e1.threesuperior = 333;
        e1.Ograve = 778;
        e1.Agrave = 667;
        e1.Abreve = 667;
        e1.multiply = 584;
        e1.uacute = 556;
        e1.Tcaron = 611;
        e1.partialdiff = 476;
        e1.ydieresis = 500;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 556;
        e1.edieresis = 556;
        e1.cacute = 500;
        e1.nacute = 556;
        e1.umacron = 556;
        e1.Ncaron = 722;
        e1.Iacute = 278;
        e1.plusminus = 584;
        e1.brokenbar = 260;
        e1.registered = 737;
        e1.Gbreve = 778;
        e1.Idotaccent = 278;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 333;
        e1.omacron = 556;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 222;
        e1.tcaron = 317;
        e1.eogonek = 556;
        e1.Uogonek = 722;
        e1.Aacute = 667;
        e1.Adieresis = 667;
        e1.egrave = 556;
        e1.zacute = 500;
        e1.iogonek = 222;
        e1.Oacute = 778;
        e1.oacute = 556;
        e1.amacron = 556;
        e1.sacute = 500;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 556;
        e1.twosuperior = 333;
        e1.Odieresis = 778;
        e1.mu = 556;
        e1.igrave = 278;
        e1.ohungarumlaut = 556;
        e1.Eogonek = 667;
        e1.dcroat = 556;
        e1.threequarters = 834;
        e1.Scedilla = 667;
        e1.lcaron = 299;
        e1.Kcommaaccent = 667;
        e1.Lacute = 556;
        e1.trademark = 1e3;
        e1.edotaccent = 556;
        e1.Igrave = 278;
        e1.Imacron = 278;
        e1.Lcaron = 556;
        e1.onehalf = 834;
        e1.lessequal = 549;
        e1.ocircumflex = 556;
        e1.ntilde = 556;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 556;
        e1.gbreve = 556;
        e1.onequarter = 834;
        e1.Scaron = 667;
        e1.Scommaaccent = 667;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 556;
        e1.Ccaron = 722;
        e1.ugrave = 556;
        e1.radical = 453;
        e1.Dcaron = 722;
        e1.rcommaaccent = 333;
        e1.Ntilde = 722;
        e1.otilde = 556;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 556;
        e1.Atilde = 667;
        e1.Aogonek = 667;
        e1.Aring = 667;
        e1.Otilde = 778;
        e1.zdotaccent = 500;
        e1.Ecaron = 667;
        e1.Iogonek = 278;
        e1.kcommaaccent = 500;
        e1.minus = 584;
        e1.Icircumflex = 278;
        e1.ncaron = 556;
        e1.tcommaaccent = 278;
        e1.logicalnot = 584;
        e1.odieresis = 556;
        e1.udieresis = 556;
        e1.notequal = 549;
        e1.gcommaaccent = 556;
        e1.eth = 556;
        e1.zcaron = 500;
        e1.ncommaaccent = 556;
        e1.onesuperior = 333;
        e1.imacron = 278;
        e1.Euro = 556;
    });
    e1["Helvetica-Bold"] = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.exclam = 333;
        e1.quotedbl = 474;
        e1.numbersign = 556;
        e1.dollar = 556;
        e1.percent = 889;
        e1.ampersand = 722;
        e1.quoteright = 278;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 389;
        e1.plus = 584;
        e1.comma = 278;
        e1.hyphen = 333;
        e1.period = 278;
        e1.slash = 278;
        e1.zero = 556;
        e1.one = 556;
        e1.two = 556;
        e1.three = 556;
        e1.four = 556;
        e1.five = 556;
        e1.six = 556;
        e1.seven = 556;
        e1.eight = 556;
        e1.nine = 556;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 584;
        e1.equal = 584;
        e1.greater = 584;
        e1.question = 611;
        e1.at = 975;
        e1.A = 722;
        e1.B = 722;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 722;
        e1.I = 278;
        e1.J = 556;
        e1.K = 722;
        e1.L = 611;
        e1.M = 833;
        e1.N = 722;
        e1.O = 778;
        e1.P = 667;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 667;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 944;
        e1.X = 667;
        e1.Y = 667;
        e1.Z = 611;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 584;
        e1.underscore = 556;
        e1.quoteleft = 278;
        e1.a = 556;
        e1.b = 611;
        e1.c = 556;
        e1.d = 611;
        e1.e = 556;
        e1.f = 333;
        e1.g = 611;
        e1.h = 611;
        e1.i = 278;
        e1.j = 278;
        e1.k = 556;
        e1.l = 278;
        e1.m = 889;
        e1.n = 611;
        e1.o = 611;
        e1.p = 611;
        e1.q = 611;
        e1.r = 389;
        e1.s = 556;
        e1.t = 333;
        e1.u = 611;
        e1.v = 556;
        e1.w = 778;
        e1.x = 556;
        e1.y = 556;
        e1.z = 500;
        e1.braceleft = 389;
        e1.bar = 280;
        e1.braceright = 389;
        e1.asciitilde = 584;
        e1.exclamdown = 333;
        e1.cent = 556;
        e1.sterling = 556;
        e1.fraction = 167;
        e1.yen = 556;
        e1.florin = 556;
        e1.section = 556;
        e1.currency = 556;
        e1.quotesingle = 238;
        e1.quotedblleft = 500;
        e1.guillemotleft = 556;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 611;
        e1.fl = 611;
        e1.endash = 556;
        e1.dagger = 556;
        e1.daggerdbl = 556;
        e1.periodcentered = 278;
        e1.paragraph = 556;
        e1.bullet = 350;
        e1.quotesinglbase = 278;
        e1.quotedblbase = 500;
        e1.quotedblright = 500;
        e1.guillemotright = 556;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 611;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 370;
        e1.Lslash = 611;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 365;
        e1.ae = 889;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 611;
        e1.oe = 944;
        e1.germandbls = 611;
        e1.Idieresis = 278;
        e1.eacute = 556;
        e1.abreve = 556;
        e1.uhungarumlaut = 611;
        e1.ecaron = 556;
        e1.Ydieresis = 667;
        e1.divide = 584;
        e1.Yacute = 667;
        e1.Acircumflex = 722;
        e1.aacute = 556;
        e1.Ucircumflex = 722;
        e1.yacute = 556;
        e1.scommaaccent = 556;
        e1.ecircumflex = 556;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 556;
        e1.Uacute = 722;
        e1.uogonek = 611;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 737;
        e1.Emacron = 667;
        e1.ccaron = 556;
        e1.aring = 556;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 556;
        e1.Tcommaaccent = 611;
        e1.Cacute = 722;
        e1.atilde = 556;
        e1.Edotaccent = 667;
        e1.scaron = 556;
        e1.scedilla = 556;
        e1.iacute = 278;
        e1.lozenge = 494;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 611;
        e1.acircumflex = 556;
        e1.Amacron = 722;
        e1.rcaron = 389;
        e1.ccedilla = 556;
        e1.Zdotaccent = 611;
        e1.Thorn = 667;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 667;
        e1.dcaron = 743;
        e1.Umacron = 722;
        e1.uring = 611;
        e1.threesuperior = 333;
        e1.Ograve = 778;
        e1.Agrave = 722;
        e1.Abreve = 722;
        e1.multiply = 584;
        e1.uacute = 611;
        e1.Tcaron = 611;
        e1.partialdiff = 494;
        e1.ydieresis = 556;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 556;
        e1.edieresis = 556;
        e1.cacute = 556;
        e1.nacute = 611;
        e1.umacron = 611;
        e1.Ncaron = 722;
        e1.Iacute = 278;
        e1.plusminus = 584;
        e1.brokenbar = 280;
        e1.registered = 737;
        e1.Gbreve = 778;
        e1.Idotaccent = 278;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 389;
        e1.omacron = 611;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 278;
        e1.tcaron = 389;
        e1.eogonek = 556;
        e1.Uogonek = 722;
        e1.Aacute = 722;
        e1.Adieresis = 722;
        e1.egrave = 556;
        e1.zacute = 500;
        e1.iogonek = 278;
        e1.Oacute = 778;
        e1.oacute = 611;
        e1.amacron = 556;
        e1.sacute = 556;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 611;
        e1.twosuperior = 333;
        e1.Odieresis = 778;
        e1.mu = 611;
        e1.igrave = 278;
        e1.ohungarumlaut = 611;
        e1.Eogonek = 667;
        e1.dcroat = 611;
        e1.threequarters = 834;
        e1.Scedilla = 667;
        e1.lcaron = 400;
        e1.Kcommaaccent = 722;
        e1.Lacute = 611;
        e1.trademark = 1e3;
        e1.edotaccent = 556;
        e1.Igrave = 278;
        e1.Imacron = 278;
        e1.Lcaron = 611;
        e1.onehalf = 834;
        e1.lessequal = 549;
        e1.ocircumflex = 611;
        e1.ntilde = 611;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 556;
        e1.gbreve = 611;
        e1.onequarter = 834;
        e1.Scaron = 667;
        e1.Scommaaccent = 667;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 611;
        e1.Ccaron = 722;
        e1.ugrave = 611;
        e1.radical = 549;
        e1.Dcaron = 722;
        e1.rcommaaccent = 389;
        e1.Ntilde = 722;
        e1.otilde = 611;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 611;
        e1.Atilde = 722;
        e1.Aogonek = 722;
        e1.Aring = 722;
        e1.Otilde = 778;
        e1.zdotaccent = 500;
        e1.Ecaron = 667;
        e1.Iogonek = 278;
        e1.kcommaaccent = 556;
        e1.minus = 584;
        e1.Icircumflex = 278;
        e1.ncaron = 611;
        e1.tcommaaccent = 333;
        e1.logicalnot = 584;
        e1.odieresis = 611;
        e1.udieresis = 611;
        e1.notequal = 549;
        e1.gcommaaccent = 611;
        e1.eth = 611;
        e1.zcaron = 500;
        e1.ncommaaccent = 611;
        e1.onesuperior = 333;
        e1.imacron = 278;
        e1.Euro = 556;
    });
    e1["Helvetica-BoldOblique"] = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.exclam = 333;
        e1.quotedbl = 474;
        e1.numbersign = 556;
        e1.dollar = 556;
        e1.percent = 889;
        e1.ampersand = 722;
        e1.quoteright = 278;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 389;
        e1.plus = 584;
        e1.comma = 278;
        e1.hyphen = 333;
        e1.period = 278;
        e1.slash = 278;
        e1.zero = 556;
        e1.one = 556;
        e1.two = 556;
        e1.three = 556;
        e1.four = 556;
        e1.five = 556;
        e1.six = 556;
        e1.seven = 556;
        e1.eight = 556;
        e1.nine = 556;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 584;
        e1.equal = 584;
        e1.greater = 584;
        e1.question = 611;
        e1.at = 975;
        e1.A = 722;
        e1.B = 722;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 722;
        e1.I = 278;
        e1.J = 556;
        e1.K = 722;
        e1.L = 611;
        e1.M = 833;
        e1.N = 722;
        e1.O = 778;
        e1.P = 667;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 667;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 944;
        e1.X = 667;
        e1.Y = 667;
        e1.Z = 611;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 584;
        e1.underscore = 556;
        e1.quoteleft = 278;
        e1.a = 556;
        e1.b = 611;
        e1.c = 556;
        e1.d = 611;
        e1.e = 556;
        e1.f = 333;
        e1.g = 611;
        e1.h = 611;
        e1.i = 278;
        e1.j = 278;
        e1.k = 556;
        e1.l = 278;
        e1.m = 889;
        e1.n = 611;
        e1.o = 611;
        e1.p = 611;
        e1.q = 611;
        e1.r = 389;
        e1.s = 556;
        e1.t = 333;
        e1.u = 611;
        e1.v = 556;
        e1.w = 778;
        e1.x = 556;
        e1.y = 556;
        e1.z = 500;
        e1.braceleft = 389;
        e1.bar = 280;
        e1.braceright = 389;
        e1.asciitilde = 584;
        e1.exclamdown = 333;
        e1.cent = 556;
        e1.sterling = 556;
        e1.fraction = 167;
        e1.yen = 556;
        e1.florin = 556;
        e1.section = 556;
        e1.currency = 556;
        e1.quotesingle = 238;
        e1.quotedblleft = 500;
        e1.guillemotleft = 556;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 611;
        e1.fl = 611;
        e1.endash = 556;
        e1.dagger = 556;
        e1.daggerdbl = 556;
        e1.periodcentered = 278;
        e1.paragraph = 556;
        e1.bullet = 350;
        e1.quotesinglbase = 278;
        e1.quotedblbase = 500;
        e1.quotedblright = 500;
        e1.guillemotright = 556;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 611;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 370;
        e1.Lslash = 611;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 365;
        e1.ae = 889;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 611;
        e1.oe = 944;
        e1.germandbls = 611;
        e1.Idieresis = 278;
        e1.eacute = 556;
        e1.abreve = 556;
        e1.uhungarumlaut = 611;
        e1.ecaron = 556;
        e1.Ydieresis = 667;
        e1.divide = 584;
        e1.Yacute = 667;
        e1.Acircumflex = 722;
        e1.aacute = 556;
        e1.Ucircumflex = 722;
        e1.yacute = 556;
        e1.scommaaccent = 556;
        e1.ecircumflex = 556;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 556;
        e1.Uacute = 722;
        e1.uogonek = 611;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 737;
        e1.Emacron = 667;
        e1.ccaron = 556;
        e1.aring = 556;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 556;
        e1.Tcommaaccent = 611;
        e1.Cacute = 722;
        e1.atilde = 556;
        e1.Edotaccent = 667;
        e1.scaron = 556;
        e1.scedilla = 556;
        e1.iacute = 278;
        e1.lozenge = 494;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 611;
        e1.acircumflex = 556;
        e1.Amacron = 722;
        e1.rcaron = 389;
        e1.ccedilla = 556;
        e1.Zdotaccent = 611;
        e1.Thorn = 667;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 667;
        e1.dcaron = 743;
        e1.Umacron = 722;
        e1.uring = 611;
        e1.threesuperior = 333;
        e1.Ograve = 778;
        e1.Agrave = 722;
        e1.Abreve = 722;
        e1.multiply = 584;
        e1.uacute = 611;
        e1.Tcaron = 611;
        e1.partialdiff = 494;
        e1.ydieresis = 556;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 556;
        e1.edieresis = 556;
        e1.cacute = 556;
        e1.nacute = 611;
        e1.umacron = 611;
        e1.Ncaron = 722;
        e1.Iacute = 278;
        e1.plusminus = 584;
        e1.brokenbar = 280;
        e1.registered = 737;
        e1.Gbreve = 778;
        e1.Idotaccent = 278;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 389;
        e1.omacron = 611;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 278;
        e1.tcaron = 389;
        e1.eogonek = 556;
        e1.Uogonek = 722;
        e1.Aacute = 722;
        e1.Adieresis = 722;
        e1.egrave = 556;
        e1.zacute = 500;
        e1.iogonek = 278;
        e1.Oacute = 778;
        e1.oacute = 611;
        e1.amacron = 556;
        e1.sacute = 556;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 611;
        e1.twosuperior = 333;
        e1.Odieresis = 778;
        e1.mu = 611;
        e1.igrave = 278;
        e1.ohungarumlaut = 611;
        e1.Eogonek = 667;
        e1.dcroat = 611;
        e1.threequarters = 834;
        e1.Scedilla = 667;
        e1.lcaron = 400;
        e1.Kcommaaccent = 722;
        e1.Lacute = 611;
        e1.trademark = 1e3;
        e1.edotaccent = 556;
        e1.Igrave = 278;
        e1.Imacron = 278;
        e1.Lcaron = 611;
        e1.onehalf = 834;
        e1.lessequal = 549;
        e1.ocircumflex = 611;
        e1.ntilde = 611;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 556;
        e1.gbreve = 611;
        e1.onequarter = 834;
        e1.Scaron = 667;
        e1.Scommaaccent = 667;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 611;
        e1.Ccaron = 722;
        e1.ugrave = 611;
        e1.radical = 549;
        e1.Dcaron = 722;
        e1.rcommaaccent = 389;
        e1.Ntilde = 722;
        e1.otilde = 611;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 611;
        e1.Atilde = 722;
        e1.Aogonek = 722;
        e1.Aring = 722;
        e1.Otilde = 778;
        e1.zdotaccent = 500;
        e1.Ecaron = 667;
        e1.Iogonek = 278;
        e1.kcommaaccent = 556;
        e1.minus = 584;
        e1.Icircumflex = 278;
        e1.ncaron = 611;
        e1.tcommaaccent = 333;
        e1.logicalnot = 584;
        e1.odieresis = 611;
        e1.udieresis = 611;
        e1.notequal = 549;
        e1.gcommaaccent = 611;
        e1.eth = 611;
        e1.zcaron = 500;
        e1.ncommaaccent = 611;
        e1.onesuperior = 333;
        e1.imacron = 278;
        e1.Euro = 556;
    });
    e1["Helvetica-Oblique"] = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.exclam = 278;
        e1.quotedbl = 355;
        e1.numbersign = 556;
        e1.dollar = 556;
        e1.percent = 889;
        e1.ampersand = 667;
        e1.quoteright = 222;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 389;
        e1.plus = 584;
        e1.comma = 278;
        e1.hyphen = 333;
        e1.period = 278;
        e1.slash = 278;
        e1.zero = 556;
        e1.one = 556;
        e1.two = 556;
        e1.three = 556;
        e1.four = 556;
        e1.five = 556;
        e1.six = 556;
        e1.seven = 556;
        e1.eight = 556;
        e1.nine = 556;
        e1.colon = 278;
        e1.semicolon = 278;
        e1.less = 584;
        e1.equal = 584;
        e1.greater = 584;
        e1.question = 556;
        e1.at = 1015;
        e1.A = 667;
        e1.B = 667;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 722;
        e1.I = 278;
        e1.J = 500;
        e1.K = 667;
        e1.L = 556;
        e1.M = 833;
        e1.N = 722;
        e1.O = 778;
        e1.P = 667;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 667;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 944;
        e1.X = 667;
        e1.Y = 667;
        e1.Z = 611;
        e1.bracketleft = 278;
        e1.backslash = 278;
        e1.bracketright = 278;
        e1.asciicircum = 469;
        e1.underscore = 556;
        e1.quoteleft = 222;
        e1.a = 556;
        e1.b = 556;
        e1.c = 500;
        e1.d = 556;
        e1.e = 556;
        e1.f = 278;
        e1.g = 556;
        e1.h = 556;
        e1.i = 222;
        e1.j = 222;
        e1.k = 500;
        e1.l = 222;
        e1.m = 833;
        e1.n = 556;
        e1.o = 556;
        e1.p = 556;
        e1.q = 556;
        e1.r = 333;
        e1.s = 500;
        e1.t = 278;
        e1.u = 556;
        e1.v = 500;
        e1.w = 722;
        e1.x = 500;
        e1.y = 500;
        e1.z = 500;
        e1.braceleft = 334;
        e1.bar = 260;
        e1.braceright = 334;
        e1.asciitilde = 584;
        e1.exclamdown = 333;
        e1.cent = 556;
        e1.sterling = 556;
        e1.fraction = 167;
        e1.yen = 556;
        e1.florin = 556;
        e1.section = 556;
        e1.currency = 556;
        e1.quotesingle = 191;
        e1.quotedblleft = 333;
        e1.guillemotleft = 556;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 500;
        e1.fl = 500;
        e1.endash = 556;
        e1.dagger = 556;
        e1.daggerdbl = 556;
        e1.periodcentered = 278;
        e1.paragraph = 537;
        e1.bullet = 350;
        e1.quotesinglbase = 222;
        e1.quotedblbase = 333;
        e1.quotedblright = 333;
        e1.guillemotright = 556;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 611;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 370;
        e1.Lslash = 556;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 365;
        e1.ae = 889;
        e1.dotlessi = 278;
        e1.lslash = 222;
        e1.oslash = 611;
        e1.oe = 944;
        e1.germandbls = 611;
        e1.Idieresis = 278;
        e1.eacute = 556;
        e1.abreve = 556;
        e1.uhungarumlaut = 556;
        e1.ecaron = 556;
        e1.Ydieresis = 667;
        e1.divide = 584;
        e1.Yacute = 667;
        e1.Acircumflex = 667;
        e1.aacute = 556;
        e1.Ucircumflex = 722;
        e1.yacute = 500;
        e1.scommaaccent = 500;
        e1.ecircumflex = 556;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 556;
        e1.Uacute = 722;
        e1.uogonek = 556;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 737;
        e1.Emacron = 667;
        e1.ccaron = 500;
        e1.aring = 556;
        e1.Ncommaaccent = 722;
        e1.lacute = 222;
        e1.agrave = 556;
        e1.Tcommaaccent = 611;
        e1.Cacute = 722;
        e1.atilde = 556;
        e1.Edotaccent = 667;
        e1.scaron = 500;
        e1.scedilla = 500;
        e1.iacute = 278;
        e1.lozenge = 471;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 556;
        e1.acircumflex = 556;
        e1.Amacron = 667;
        e1.rcaron = 333;
        e1.ccedilla = 500;
        e1.Zdotaccent = 611;
        e1.Thorn = 667;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 667;
        e1.dcaron = 643;
        e1.Umacron = 722;
        e1.uring = 556;
        e1.threesuperior = 333;
        e1.Ograve = 778;
        e1.Agrave = 667;
        e1.Abreve = 667;
        e1.multiply = 584;
        e1.uacute = 556;
        e1.Tcaron = 611;
        e1.partialdiff = 476;
        e1.ydieresis = 500;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 556;
        e1.edieresis = 556;
        e1.cacute = 500;
        e1.nacute = 556;
        e1.umacron = 556;
        e1.Ncaron = 722;
        e1.Iacute = 278;
        e1.plusminus = 584;
        e1.brokenbar = 260;
        e1.registered = 737;
        e1.Gbreve = 778;
        e1.Idotaccent = 278;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 333;
        e1.omacron = 556;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 222;
        e1.tcaron = 317;
        e1.eogonek = 556;
        e1.Uogonek = 722;
        e1.Aacute = 667;
        e1.Adieresis = 667;
        e1.egrave = 556;
        e1.zacute = 500;
        e1.iogonek = 222;
        e1.Oacute = 778;
        e1.oacute = 556;
        e1.amacron = 556;
        e1.sacute = 500;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 556;
        e1.twosuperior = 333;
        e1.Odieresis = 778;
        e1.mu = 556;
        e1.igrave = 278;
        e1.ohungarumlaut = 556;
        e1.Eogonek = 667;
        e1.dcroat = 556;
        e1.threequarters = 834;
        e1.Scedilla = 667;
        e1.lcaron = 299;
        e1.Kcommaaccent = 667;
        e1.Lacute = 556;
        e1.trademark = 1e3;
        e1.edotaccent = 556;
        e1.Igrave = 278;
        e1.Imacron = 278;
        e1.Lcaron = 556;
        e1.onehalf = 834;
        e1.lessequal = 549;
        e1.ocircumflex = 556;
        e1.ntilde = 556;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 556;
        e1.gbreve = 556;
        e1.onequarter = 834;
        e1.Scaron = 667;
        e1.Scommaaccent = 667;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 556;
        e1.Ccaron = 722;
        e1.ugrave = 556;
        e1.radical = 453;
        e1.Dcaron = 722;
        e1.rcommaaccent = 333;
        e1.Ntilde = 722;
        e1.otilde = 556;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 556;
        e1.Atilde = 667;
        e1.Aogonek = 667;
        e1.Aring = 667;
        e1.Otilde = 778;
        e1.zdotaccent = 500;
        e1.Ecaron = 667;
        e1.Iogonek = 278;
        e1.kcommaaccent = 500;
        e1.minus = 584;
        e1.Icircumflex = 278;
        e1.ncaron = 556;
        e1.tcommaaccent = 278;
        e1.logicalnot = 584;
        e1.odieresis = 556;
        e1.udieresis = 556;
        e1.notequal = 549;
        e1.gcommaaccent = 556;
        e1.eth = 556;
        e1.zcaron = 500;
        e1.ncommaaccent = 556;
        e1.onesuperior = 333;
        e1.imacron = 278;
        e1.Euro = 556;
    });
    e1.Symbol = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 333;
        e1.universal = 713;
        e1.numbersign = 500;
        e1.existential = 549;
        e1.percent = 833;
        e1.ampersand = 778;
        e1.suchthat = 439;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asteriskmath = 500;
        e1.plus = 549;
        e1.comma = 250;
        e1.minus = 549;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 278;
        e1.semicolon = 278;
        e1.less = 549;
        e1.equal = 549;
        e1.greater = 549;
        e1.question = 444;
        e1.congruent = 549;
        e1.Alpha = 722;
        e1.Beta = 667;
        e1.Chi = 722;
        e1.Delta = 612;
        e1.Epsilon = 611;
        e1.Phi = 763;
        e1.Gamma = 603;
        e1.Eta = 722;
        e1.Iota = 333;
        e1.theta1 = 631;
        e1.Kappa = 722;
        e1.Lambda = 686;
        e1.Mu = 889;
        e1.Nu = 722;
        e1.Omicron = 722;
        e1.Pi = 768;
        e1.Theta = 741;
        e1.Rho = 556;
        e1.Sigma = 592;
        e1.Tau = 611;
        e1.Upsilon = 690;
        e1.sigma1 = 439;
        e1.Omega = 768;
        e1.Xi = 645;
        e1.Psi = 795;
        e1.Zeta = 611;
        e1.bracketleft = 333;
        e1.therefore = 863;
        e1.bracketright = 333;
        e1.perpendicular = 658;
        e1.underscore = 500;
        e1.radicalex = 500;
        e1.alpha = 631;
        e1.beta = 549;
        e1.chi = 549;
        e1.delta = 494;
        e1.epsilon = 439;
        e1.phi = 521;
        e1.gamma = 411;
        e1.eta = 603;
        e1.iota = 329;
        e1.phi1 = 603;
        e1.kappa = 549;
        e1.lambda = 549;
        e1.mu = 576;
        e1.nu = 521;
        e1.omicron = 549;
        e1.pi = 549;
        e1.theta = 521;
        e1.rho = 549;
        e1.sigma = 603;
        e1.tau = 439;
        e1.upsilon = 576;
        e1.omega1 = 713;
        e1.omega = 686;
        e1.xi = 493;
        e1.psi = 686;
        e1.zeta = 494;
        e1.braceleft = 480;
        e1.bar = 200;
        e1.braceright = 480;
        e1.similar = 549;
        e1.Euro = 750;
        e1.Upsilon1 = 620;
        e1.minute = 247;
        e1.lessequal = 549;
        e1.fraction = 167;
        e1.infinity = 713;
        e1.florin = 500;
        e1.club = 753;
        e1.diamond = 753;
        e1.heart = 753;
        e1.spade = 753;
        e1.arrowboth = 1042;
        e1.arrowleft = 987;
        e1.arrowup = 603;
        e1.arrowright = 987;
        e1.arrowdown = 603;
        e1.degree = 400;
        e1.plusminus = 549;
        e1.second = 411;
        e1.greaterequal = 549;
        e1.multiply = 549;
        e1.proportional = 713;
        e1.partialdiff = 494;
        e1.bullet = 460;
        e1.divide = 549;
        e1.notequal = 549;
        e1.equivalence = 549;
        e1.approxequal = 549;
        e1.ellipsis = 1e3;
        e1.arrowvertex = 603;
        e1.arrowhorizex = 1e3;
        e1.carriagereturn = 658;
        e1.aleph = 823;
        e1.Ifraktur = 686;
        e1.Rfraktur = 795;
        e1.weierstrass = 987;
        e1.circlemultiply = 768;
        e1.circleplus = 768;
        e1.emptyset = 823;
        e1.intersection = 768;
        e1.union = 768;
        e1.propersuperset = 713;
        e1.reflexsuperset = 713;
        e1.notsubset = 713;
        e1.propersubset = 713;
        e1.reflexsubset = 713;
        e1.element = 713;
        e1.notelement = 713;
        e1.angle = 768;
        e1.gradient = 713;
        e1.registerserif = 790;
        e1.copyrightserif = 790;
        e1.trademarkserif = 890;
        e1.product = 823;
        e1.radical = 549;
        e1.dotmath = 250;
        e1.logicalnot = 713;
        e1.logicaland = 603;
        e1.logicalor = 603;
        e1.arrowdblboth = 1042;
        e1.arrowdblleft = 987;
        e1.arrowdblup = 603;
        e1.arrowdblright = 987;
        e1.arrowdbldown = 603;
        e1.lozenge = 494;
        e1.angleleft = 329;
        e1.registersans = 790;
        e1.copyrightsans = 790;
        e1.trademarksans = 786;
        e1.summation = 713;
        e1.parenlefttp = 384;
        e1.parenleftex = 384;
        e1.parenleftbt = 384;
        e1.bracketlefttp = 384;
        e1.bracketleftex = 384;
        e1.bracketleftbt = 384;
        e1.bracelefttp = 494;
        e1.braceleftmid = 494;
        e1.braceleftbt = 494;
        e1.braceex = 494;
        e1.angleright = 329;
        e1.integral = 274;
        e1.integraltp = 686;
        e1.integralex = 686;
        e1.integralbt = 686;
        e1.parenrighttp = 384;
        e1.parenrightex = 384;
        e1.parenrightbt = 384;
        e1.bracketrighttp = 384;
        e1.bracketrightex = 384;
        e1.bracketrightbt = 384;
        e1.bracerighttp = 494;
        e1.bracerightmid = 494;
        e1.bracerightbt = 494;
        e1.apple = 790;
    });
    e1["Times-Roman"] = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 333;
        e1.quotedbl = 408;
        e1.numbersign = 500;
        e1.dollar = 500;
        e1.percent = 833;
        e1.ampersand = 778;
        e1.quoteright = 333;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 500;
        e1.plus = 564;
        e1.comma = 250;
        e1.hyphen = 333;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 278;
        e1.semicolon = 278;
        e1.less = 564;
        e1.equal = 564;
        e1.greater = 564;
        e1.question = 444;
        e1.at = 921;
        e1.A = 722;
        e1.B = 667;
        e1.C = 667;
        e1.D = 722;
        e1.E = 611;
        e1.F = 556;
        e1.G = 722;
        e1.H = 722;
        e1.I = 333;
        e1.J = 389;
        e1.K = 722;
        e1.L = 611;
        e1.M = 889;
        e1.N = 722;
        e1.O = 722;
        e1.P = 556;
        e1.Q = 722;
        e1.R = 667;
        e1.S = 556;
        e1.T = 611;
        e1.U = 722;
        e1.V = 722;
        e1.W = 944;
        e1.X = 722;
        e1.Y = 722;
        e1.Z = 611;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 469;
        e1.underscore = 500;
        e1.quoteleft = 333;
        e1.a = 444;
        e1.b = 500;
        e1.c = 444;
        e1.d = 500;
        e1.e = 444;
        e1.f = 333;
        e1.g = 500;
        e1.h = 500;
        e1.i = 278;
        e1.j = 278;
        e1.k = 500;
        e1.l = 278;
        e1.m = 778;
        e1.n = 500;
        e1.o = 500;
        e1.p = 500;
        e1.q = 500;
        e1.r = 333;
        e1.s = 389;
        e1.t = 278;
        e1.u = 500;
        e1.v = 500;
        e1.w = 722;
        e1.x = 500;
        e1.y = 500;
        e1.z = 444;
        e1.braceleft = 480;
        e1.bar = 200;
        e1.braceright = 480;
        e1.asciitilde = 541;
        e1.exclamdown = 333;
        e1.cent = 500;
        e1.sterling = 500;
        e1.fraction = 167;
        e1.yen = 500;
        e1.florin = 500;
        e1.section = 500;
        e1.currency = 500;
        e1.quotesingle = 180;
        e1.quotedblleft = 444;
        e1.guillemotleft = 500;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 556;
        e1.fl = 556;
        e1.endash = 500;
        e1.dagger = 500;
        e1.daggerdbl = 500;
        e1.periodcentered = 250;
        e1.paragraph = 453;
        e1.bullet = 350;
        e1.quotesinglbase = 333;
        e1.quotedblbase = 444;
        e1.quotedblright = 444;
        e1.guillemotright = 500;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 444;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 889;
        e1.ordfeminine = 276;
        e1.Lslash = 611;
        e1.Oslash = 722;
        e1.OE = 889;
        e1.ordmasculine = 310;
        e1.ae = 667;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 500;
        e1.oe = 722;
        e1.germandbls = 500;
        e1.Idieresis = 333;
        e1.eacute = 444;
        e1.abreve = 444;
        e1.uhungarumlaut = 500;
        e1.ecaron = 444;
        e1.Ydieresis = 722;
        e1.divide = 564;
        e1.Yacute = 722;
        e1.Acircumflex = 722;
        e1.aacute = 444;
        e1.Ucircumflex = 722;
        e1.yacute = 500;
        e1.scommaaccent = 389;
        e1.ecircumflex = 444;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 444;
        e1.Uacute = 722;
        e1.uogonek = 500;
        e1.Edieresis = 611;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 760;
        e1.Emacron = 611;
        e1.ccaron = 444;
        e1.aring = 444;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 444;
        e1.Tcommaaccent = 611;
        e1.Cacute = 667;
        e1.atilde = 444;
        e1.Edotaccent = 611;
        e1.scaron = 389;
        e1.scedilla = 389;
        e1.iacute = 278;
        e1.lozenge = 471;
        e1.Rcaron = 667;
        e1.Gcommaaccent = 722;
        e1.ucircumflex = 500;
        e1.acircumflex = 444;
        e1.Amacron = 722;
        e1.rcaron = 333;
        e1.ccedilla = 444;
        e1.Zdotaccent = 611;
        e1.Thorn = 556;
        e1.Omacron = 722;
        e1.Racute = 667;
        e1.Sacute = 556;
        e1.dcaron = 588;
        e1.Umacron = 722;
        e1.uring = 500;
        e1.threesuperior = 300;
        e1.Ograve = 722;
        e1.Agrave = 722;
        e1.Abreve = 722;
        e1.multiply = 564;
        e1.uacute = 500;
        e1.Tcaron = 611;
        e1.partialdiff = 476;
        e1.ydieresis = 500;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 611;
        e1.adieresis = 444;
        e1.edieresis = 444;
        e1.cacute = 444;
        e1.nacute = 500;
        e1.umacron = 500;
        e1.Ncaron = 722;
        e1.Iacute = 333;
        e1.plusminus = 564;
        e1.brokenbar = 200;
        e1.registered = 760;
        e1.Gbreve = 722;
        e1.Idotaccent = 333;
        e1.summation = 600;
        e1.Egrave = 611;
        e1.racute = 333;
        e1.omacron = 500;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 667;
        e1.lcommaaccent = 278;
        e1.tcaron = 326;
        e1.eogonek = 444;
        e1.Uogonek = 722;
        e1.Aacute = 722;
        e1.Adieresis = 722;
        e1.egrave = 444;
        e1.zacute = 444;
        e1.iogonek = 278;
        e1.Oacute = 722;
        e1.oacute = 500;
        e1.amacron = 444;
        e1.sacute = 389;
        e1.idieresis = 278;
        e1.Ocircumflex = 722;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 500;
        e1.twosuperior = 300;
        e1.Odieresis = 722;
        e1.mu = 500;
        e1.igrave = 278;
        e1.ohungarumlaut = 500;
        e1.Eogonek = 611;
        e1.dcroat = 500;
        e1.threequarters = 750;
        e1.Scedilla = 556;
        e1.lcaron = 344;
        e1.Kcommaaccent = 722;
        e1.Lacute = 611;
        e1.trademark = 980;
        e1.edotaccent = 444;
        e1.Igrave = 333;
        e1.Imacron = 333;
        e1.Lcaron = 611;
        e1.onehalf = 750;
        e1.lessequal = 549;
        e1.ocircumflex = 500;
        e1.ntilde = 500;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 611;
        e1.emacron = 444;
        e1.gbreve = 500;
        e1.onequarter = 750;
        e1.Scaron = 556;
        e1.Scommaaccent = 556;
        e1.Ohungarumlaut = 722;
        e1.degree = 400;
        e1.ograve = 500;
        e1.Ccaron = 667;
        e1.ugrave = 500;
        e1.radical = 453;
        e1.Dcaron = 722;
        e1.rcommaaccent = 333;
        e1.Ntilde = 722;
        e1.otilde = 500;
        e1.Rcommaaccent = 667;
        e1.Lcommaaccent = 611;
        e1.Atilde = 722;
        e1.Aogonek = 722;
        e1.Aring = 722;
        e1.Otilde = 722;
        e1.zdotaccent = 444;
        e1.Ecaron = 611;
        e1.Iogonek = 333;
        e1.kcommaaccent = 500;
        e1.minus = 564;
        e1.Icircumflex = 333;
        e1.ncaron = 500;
        e1.tcommaaccent = 278;
        e1.logicalnot = 564;
        e1.odieresis = 500;
        e1.udieresis = 500;
        e1.notequal = 549;
        e1.gcommaaccent = 500;
        e1.eth = 500;
        e1.zcaron = 444;
        e1.ncommaaccent = 500;
        e1.onesuperior = 300;
        e1.imacron = 278;
        e1.Euro = 500;
    });
    e1["Times-Bold"] = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 333;
        e1.quotedbl = 555;
        e1.numbersign = 500;
        e1.dollar = 500;
        e1.percent = 1e3;
        e1.ampersand = 833;
        e1.quoteright = 333;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 500;
        e1.plus = 570;
        e1.comma = 250;
        e1.hyphen = 333;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 570;
        e1.equal = 570;
        e1.greater = 570;
        e1.question = 500;
        e1.at = 930;
        e1.A = 722;
        e1.B = 667;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 778;
        e1.I = 389;
        e1.J = 500;
        e1.K = 778;
        e1.L = 667;
        e1.M = 944;
        e1.N = 722;
        e1.O = 778;
        e1.P = 611;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 556;
        e1.T = 667;
        e1.U = 722;
        e1.V = 722;
        e1.W = 1e3;
        e1.X = 722;
        e1.Y = 722;
        e1.Z = 667;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 581;
        e1.underscore = 500;
        e1.quoteleft = 333;
        e1.a = 500;
        e1.b = 556;
        e1.c = 444;
        e1.d = 556;
        e1.e = 444;
        e1.f = 333;
        e1.g = 500;
        e1.h = 556;
        e1.i = 278;
        e1.j = 333;
        e1.k = 556;
        e1.l = 278;
        e1.m = 833;
        e1.n = 556;
        e1.o = 500;
        e1.p = 556;
        e1.q = 556;
        e1.r = 444;
        e1.s = 389;
        e1.t = 333;
        e1.u = 556;
        e1.v = 500;
        e1.w = 722;
        e1.x = 500;
        e1.y = 500;
        e1.z = 444;
        e1.braceleft = 394;
        e1.bar = 220;
        e1.braceright = 394;
        e1.asciitilde = 520;
        e1.exclamdown = 333;
        e1.cent = 500;
        e1.sterling = 500;
        e1.fraction = 167;
        e1.yen = 500;
        e1.florin = 500;
        e1.section = 500;
        e1.currency = 500;
        e1.quotesingle = 278;
        e1.quotedblleft = 500;
        e1.guillemotleft = 500;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 556;
        e1.fl = 556;
        e1.endash = 500;
        e1.dagger = 500;
        e1.daggerdbl = 500;
        e1.periodcentered = 250;
        e1.paragraph = 540;
        e1.bullet = 350;
        e1.quotesinglbase = 333;
        e1.quotedblbase = 500;
        e1.quotedblright = 500;
        e1.guillemotright = 500;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 500;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 300;
        e1.Lslash = 667;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 330;
        e1.ae = 722;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 500;
        e1.oe = 722;
        e1.germandbls = 556;
        e1.Idieresis = 389;
        e1.eacute = 444;
        e1.abreve = 500;
        e1.uhungarumlaut = 556;
        e1.ecaron = 444;
        e1.Ydieresis = 722;
        e1.divide = 570;
        e1.Yacute = 722;
        e1.Acircumflex = 722;
        e1.aacute = 500;
        e1.Ucircumflex = 722;
        e1.yacute = 500;
        e1.scommaaccent = 389;
        e1.ecircumflex = 444;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 500;
        e1.Uacute = 722;
        e1.uogonek = 556;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 747;
        e1.Emacron = 667;
        e1.ccaron = 444;
        e1.aring = 500;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 500;
        e1.Tcommaaccent = 667;
        e1.Cacute = 722;
        e1.atilde = 500;
        e1.Edotaccent = 667;
        e1.scaron = 389;
        e1.scedilla = 389;
        e1.iacute = 278;
        e1.lozenge = 494;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 556;
        e1.acircumflex = 500;
        e1.Amacron = 722;
        e1.rcaron = 444;
        e1.ccedilla = 444;
        e1.Zdotaccent = 667;
        e1.Thorn = 611;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 556;
        e1.dcaron = 672;
        e1.Umacron = 722;
        e1.uring = 556;
        e1.threesuperior = 300;
        e1.Ograve = 778;
        e1.Agrave = 722;
        e1.Abreve = 722;
        e1.multiply = 570;
        e1.uacute = 556;
        e1.Tcaron = 667;
        e1.partialdiff = 494;
        e1.ydieresis = 500;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 500;
        e1.edieresis = 444;
        e1.cacute = 444;
        e1.nacute = 556;
        e1.umacron = 556;
        e1.Ncaron = 722;
        e1.Iacute = 389;
        e1.plusminus = 570;
        e1.brokenbar = 220;
        e1.registered = 747;
        e1.Gbreve = 778;
        e1.Idotaccent = 389;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 444;
        e1.omacron = 500;
        e1.Zacute = 667;
        e1.Zcaron = 667;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 278;
        e1.tcaron = 416;
        e1.eogonek = 444;
        e1.Uogonek = 722;
        e1.Aacute = 722;
        e1.Adieresis = 722;
        e1.egrave = 444;
        e1.zacute = 444;
        e1.iogonek = 278;
        e1.Oacute = 778;
        e1.oacute = 500;
        e1.amacron = 500;
        e1.sacute = 389;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 556;
        e1.twosuperior = 300;
        e1.Odieresis = 778;
        e1.mu = 556;
        e1.igrave = 278;
        e1.ohungarumlaut = 500;
        e1.Eogonek = 667;
        e1.dcroat = 556;
        e1.threequarters = 750;
        e1.Scedilla = 556;
        e1.lcaron = 394;
        e1.Kcommaaccent = 778;
        e1.Lacute = 667;
        e1.trademark = 1e3;
        e1.edotaccent = 444;
        e1.Igrave = 389;
        e1.Imacron = 389;
        e1.Lcaron = 667;
        e1.onehalf = 750;
        e1.lessequal = 549;
        e1.ocircumflex = 500;
        e1.ntilde = 556;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 444;
        e1.gbreve = 500;
        e1.onequarter = 750;
        e1.Scaron = 556;
        e1.Scommaaccent = 556;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 500;
        e1.Ccaron = 722;
        e1.ugrave = 556;
        e1.radical = 549;
        e1.Dcaron = 722;
        e1.rcommaaccent = 444;
        e1.Ntilde = 722;
        e1.otilde = 500;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 667;
        e1.Atilde = 722;
        e1.Aogonek = 722;
        e1.Aring = 722;
        e1.Otilde = 778;
        e1.zdotaccent = 444;
        e1.Ecaron = 667;
        e1.Iogonek = 389;
        e1.kcommaaccent = 556;
        e1.minus = 570;
        e1.Icircumflex = 389;
        e1.ncaron = 556;
        e1.tcommaaccent = 333;
        e1.logicalnot = 570;
        e1.odieresis = 500;
        e1.udieresis = 556;
        e1.notequal = 549;
        e1.gcommaaccent = 500;
        e1.eth = 500;
        e1.zcaron = 444;
        e1.ncommaaccent = 556;
        e1.onesuperior = 300;
        e1.imacron = 278;
        e1.Euro = 500;
    });
    e1["Times-BoldItalic"] = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 389;
        e1.quotedbl = 555;
        e1.numbersign = 500;
        e1.dollar = 500;
        e1.percent = 833;
        e1.ampersand = 778;
        e1.quoteright = 333;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 500;
        e1.plus = 570;
        e1.comma = 250;
        e1.hyphen = 333;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 570;
        e1.equal = 570;
        e1.greater = 570;
        e1.question = 500;
        e1.at = 832;
        e1.A = 667;
        e1.B = 667;
        e1.C = 667;
        e1.D = 722;
        e1.E = 667;
        e1.F = 667;
        e1.G = 722;
        e1.H = 778;
        e1.I = 389;
        e1.J = 500;
        e1.K = 667;
        e1.L = 611;
        e1.M = 889;
        e1.N = 722;
        e1.O = 722;
        e1.P = 611;
        e1.Q = 722;
        e1.R = 667;
        e1.S = 556;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 889;
        e1.X = 667;
        e1.Y = 611;
        e1.Z = 611;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 570;
        e1.underscore = 500;
        e1.quoteleft = 333;
        e1.a = 500;
        e1.b = 500;
        e1.c = 444;
        e1.d = 500;
        e1.e = 444;
        e1.f = 333;
        e1.g = 500;
        e1.h = 556;
        e1.i = 278;
        e1.j = 278;
        e1.k = 500;
        e1.l = 278;
        e1.m = 778;
        e1.n = 556;
        e1.o = 500;
        e1.p = 500;
        e1.q = 500;
        e1.r = 389;
        e1.s = 389;
        e1.t = 278;
        e1.u = 556;
        e1.v = 444;
        e1.w = 667;
        e1.x = 500;
        e1.y = 444;
        e1.z = 389;
        e1.braceleft = 348;
        e1.bar = 220;
        e1.braceright = 348;
        e1.asciitilde = 570;
        e1.exclamdown = 389;
        e1.cent = 500;
        e1.sterling = 500;
        e1.fraction = 167;
        e1.yen = 500;
        e1.florin = 500;
        e1.section = 500;
        e1.currency = 500;
        e1.quotesingle = 278;
        e1.quotedblleft = 500;
        e1.guillemotleft = 500;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 556;
        e1.fl = 556;
        e1.endash = 500;
        e1.dagger = 500;
        e1.daggerdbl = 500;
        e1.periodcentered = 250;
        e1.paragraph = 500;
        e1.bullet = 350;
        e1.quotesinglbase = 333;
        e1.quotedblbase = 500;
        e1.quotedblright = 500;
        e1.guillemotright = 500;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 500;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 944;
        e1.ordfeminine = 266;
        e1.Lslash = 611;
        e1.Oslash = 722;
        e1.OE = 944;
        e1.ordmasculine = 300;
        e1.ae = 722;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 500;
        e1.oe = 722;
        e1.germandbls = 500;
        e1.Idieresis = 389;
        e1.eacute = 444;
        e1.abreve = 500;
        e1.uhungarumlaut = 556;
        e1.ecaron = 444;
        e1.Ydieresis = 611;
        e1.divide = 570;
        e1.Yacute = 611;
        e1.Acircumflex = 667;
        e1.aacute = 500;
        e1.Ucircumflex = 722;
        e1.yacute = 444;
        e1.scommaaccent = 389;
        e1.ecircumflex = 444;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 500;
        e1.Uacute = 722;
        e1.uogonek = 556;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 747;
        e1.Emacron = 667;
        e1.ccaron = 444;
        e1.aring = 500;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 500;
        e1.Tcommaaccent = 611;
        e1.Cacute = 667;
        e1.atilde = 500;
        e1.Edotaccent = 667;
        e1.scaron = 389;
        e1.scedilla = 389;
        e1.iacute = 278;
        e1.lozenge = 494;
        e1.Rcaron = 667;
        e1.Gcommaaccent = 722;
        e1.ucircumflex = 556;
        e1.acircumflex = 500;
        e1.Amacron = 667;
        e1.rcaron = 389;
        e1.ccedilla = 444;
        e1.Zdotaccent = 611;
        e1.Thorn = 611;
        e1.Omacron = 722;
        e1.Racute = 667;
        e1.Sacute = 556;
        e1.dcaron = 608;
        e1.Umacron = 722;
        e1.uring = 556;
        e1.threesuperior = 300;
        e1.Ograve = 722;
        e1.Agrave = 667;
        e1.Abreve = 667;
        e1.multiply = 570;
        e1.uacute = 556;
        e1.Tcaron = 611;
        e1.partialdiff = 494;
        e1.ydieresis = 444;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 500;
        e1.edieresis = 444;
        e1.cacute = 444;
        e1.nacute = 556;
        e1.umacron = 556;
        e1.Ncaron = 722;
        e1.Iacute = 389;
        e1.plusminus = 570;
        e1.brokenbar = 220;
        e1.registered = 747;
        e1.Gbreve = 722;
        e1.Idotaccent = 389;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 389;
        e1.omacron = 500;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 667;
        e1.lcommaaccent = 278;
        e1.tcaron = 366;
        e1.eogonek = 444;
        e1.Uogonek = 722;
        e1.Aacute = 667;
        e1.Adieresis = 667;
        e1.egrave = 444;
        e1.zacute = 389;
        e1.iogonek = 278;
        e1.Oacute = 722;
        e1.oacute = 500;
        e1.amacron = 500;
        e1.sacute = 389;
        e1.idieresis = 278;
        e1.Ocircumflex = 722;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 500;
        e1.twosuperior = 300;
        e1.Odieresis = 722;
        e1.mu = 576;
        e1.igrave = 278;
        e1.ohungarumlaut = 500;
        e1.Eogonek = 667;
        e1.dcroat = 500;
        e1.threequarters = 750;
        e1.Scedilla = 556;
        e1.lcaron = 382;
        e1.Kcommaaccent = 667;
        e1.Lacute = 611;
        e1.trademark = 1e3;
        e1.edotaccent = 444;
        e1.Igrave = 389;
        e1.Imacron = 389;
        e1.Lcaron = 611;
        e1.onehalf = 750;
        e1.lessequal = 549;
        e1.ocircumflex = 500;
        e1.ntilde = 556;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 444;
        e1.gbreve = 500;
        e1.onequarter = 750;
        e1.Scaron = 556;
        e1.Scommaaccent = 556;
        e1.Ohungarumlaut = 722;
        e1.degree = 400;
        e1.ograve = 500;
        e1.Ccaron = 667;
        e1.ugrave = 556;
        e1.radical = 549;
        e1.Dcaron = 722;
        e1.rcommaaccent = 389;
        e1.Ntilde = 722;
        e1.otilde = 500;
        e1.Rcommaaccent = 667;
        e1.Lcommaaccent = 611;
        e1.Atilde = 667;
        e1.Aogonek = 667;
        e1.Aring = 667;
        e1.Otilde = 722;
        e1.zdotaccent = 389;
        e1.Ecaron = 667;
        e1.Iogonek = 389;
        e1.kcommaaccent = 500;
        e1.minus = 606;
        e1.Icircumflex = 389;
        e1.ncaron = 556;
        e1.tcommaaccent = 278;
        e1.logicalnot = 606;
        e1.odieresis = 500;
        e1.udieresis = 556;
        e1.notequal = 549;
        e1.gcommaaccent = 500;
        e1.eth = 500;
        e1.zcaron = 389;
        e1.ncommaaccent = 556;
        e1.onesuperior = 300;
        e1.imacron = 278;
        e1.Euro = 500;
    });
    e1["Times-Italic"] = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 333;
        e1.quotedbl = 420;
        e1.numbersign = 500;
        e1.dollar = 500;
        e1.percent = 833;
        e1.ampersand = 778;
        e1.quoteright = 333;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 500;
        e1.plus = 675;
        e1.comma = 250;
        e1.hyphen = 333;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 675;
        e1.equal = 675;
        e1.greater = 675;
        e1.question = 500;
        e1.at = 920;
        e1.A = 611;
        e1.B = 611;
        e1.C = 667;
        e1.D = 722;
        e1.E = 611;
        e1.F = 611;
        e1.G = 722;
        e1.H = 722;
        e1.I = 333;
        e1.J = 444;
        e1.K = 667;
        e1.L = 556;
        e1.M = 833;
        e1.N = 667;
        e1.O = 722;
        e1.P = 611;
        e1.Q = 722;
        e1.R = 611;
        e1.S = 500;
        e1.T = 556;
        e1.U = 722;
        e1.V = 611;
        e1.W = 833;
        e1.X = 611;
        e1.Y = 556;
        e1.Z = 556;
        e1.bracketleft = 389;
        e1.backslash = 278;
        e1.bracketright = 389;
        e1.asciicircum = 422;
        e1.underscore = 500;
        e1.quoteleft = 333;
        e1.a = 500;
        e1.b = 500;
        e1.c = 444;
        e1.d = 500;
        e1.e = 444;
        e1.f = 278;
        e1.g = 500;
        e1.h = 500;
        e1.i = 278;
        e1.j = 278;
        e1.k = 444;
        e1.l = 278;
        e1.m = 722;
        e1.n = 500;
        e1.o = 500;
        e1.p = 500;
        e1.q = 500;
        e1.r = 389;
        e1.s = 389;
        e1.t = 278;
        e1.u = 500;
        e1.v = 444;
        e1.w = 667;
        e1.x = 444;
        e1.y = 444;
        e1.z = 389;
        e1.braceleft = 400;
        e1.bar = 275;
        e1.braceright = 400;
        e1.asciitilde = 541;
        e1.exclamdown = 389;
        e1.cent = 500;
        e1.sterling = 500;
        e1.fraction = 167;
        e1.yen = 500;
        e1.florin = 500;
        e1.section = 500;
        e1.currency = 500;
        e1.quotesingle = 214;
        e1.quotedblleft = 556;
        e1.guillemotleft = 500;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 500;
        e1.fl = 500;
        e1.endash = 500;
        e1.dagger = 500;
        e1.daggerdbl = 500;
        e1.periodcentered = 250;
        e1.paragraph = 523;
        e1.bullet = 350;
        e1.quotesinglbase = 333;
        e1.quotedblbase = 556;
        e1.quotedblright = 556;
        e1.guillemotright = 500;
        e1.ellipsis = 889;
        e1.perthousand = 1e3;
        e1.questiondown = 500;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 889;
        e1.AE = 889;
        e1.ordfeminine = 276;
        e1.Lslash = 556;
        e1.Oslash = 722;
        e1.OE = 944;
        e1.ordmasculine = 310;
        e1.ae = 667;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 500;
        e1.oe = 667;
        e1.germandbls = 500;
        e1.Idieresis = 333;
        e1.eacute = 444;
        e1.abreve = 500;
        e1.uhungarumlaut = 500;
        e1.ecaron = 444;
        e1.Ydieresis = 556;
        e1.divide = 675;
        e1.Yacute = 556;
        e1.Acircumflex = 611;
        e1.aacute = 500;
        e1.Ucircumflex = 722;
        e1.yacute = 444;
        e1.scommaaccent = 389;
        e1.ecircumflex = 444;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 500;
        e1.Uacute = 722;
        e1.uogonek = 500;
        e1.Edieresis = 611;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 760;
        e1.Emacron = 611;
        e1.ccaron = 444;
        e1.aring = 500;
        e1.Ncommaaccent = 667;
        e1.lacute = 278;
        e1.agrave = 500;
        e1.Tcommaaccent = 556;
        e1.Cacute = 667;
        e1.atilde = 500;
        e1.Edotaccent = 611;
        e1.scaron = 389;
        e1.scedilla = 389;
        e1.iacute = 278;
        e1.lozenge = 471;
        e1.Rcaron = 611;
        e1.Gcommaaccent = 722;
        e1.ucircumflex = 500;
        e1.acircumflex = 500;
        e1.Amacron = 611;
        e1.rcaron = 389;
        e1.ccedilla = 444;
        e1.Zdotaccent = 556;
        e1.Thorn = 611;
        e1.Omacron = 722;
        e1.Racute = 611;
        e1.Sacute = 500;
        e1.dcaron = 544;
        e1.Umacron = 722;
        e1.uring = 500;
        e1.threesuperior = 300;
        e1.Ograve = 722;
        e1.Agrave = 611;
        e1.Abreve = 611;
        e1.multiply = 675;
        e1.uacute = 500;
        e1.Tcaron = 556;
        e1.partialdiff = 476;
        e1.ydieresis = 444;
        e1.Nacute = 667;
        e1.icircumflex = 278;
        e1.Ecircumflex = 611;
        e1.adieresis = 500;
        e1.edieresis = 444;
        e1.cacute = 444;
        e1.nacute = 500;
        e1.umacron = 500;
        e1.Ncaron = 667;
        e1.Iacute = 333;
        e1.plusminus = 675;
        e1.brokenbar = 275;
        e1.registered = 760;
        e1.Gbreve = 722;
        e1.Idotaccent = 333;
        e1.summation = 600;
        e1.Egrave = 611;
        e1.racute = 389;
        e1.omacron = 500;
        e1.Zacute = 556;
        e1.Zcaron = 556;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 667;
        e1.lcommaaccent = 278;
        e1.tcaron = 300;
        e1.eogonek = 444;
        e1.Uogonek = 722;
        e1.Aacute = 611;
        e1.Adieresis = 611;
        e1.egrave = 444;
        e1.zacute = 389;
        e1.iogonek = 278;
        e1.Oacute = 722;
        e1.oacute = 500;
        e1.amacron = 500;
        e1.sacute = 389;
        e1.idieresis = 278;
        e1.Ocircumflex = 722;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 500;
        e1.twosuperior = 300;
        e1.Odieresis = 722;
        e1.mu = 500;
        e1.igrave = 278;
        e1.ohungarumlaut = 500;
        e1.Eogonek = 611;
        e1.dcroat = 500;
        e1.threequarters = 750;
        e1.Scedilla = 500;
        e1.lcaron = 300;
        e1.Kcommaaccent = 667;
        e1.Lacute = 556;
        e1.trademark = 980;
        e1.edotaccent = 444;
        e1.Igrave = 333;
        e1.Imacron = 333;
        e1.Lcaron = 611;
        e1.onehalf = 750;
        e1.lessequal = 549;
        e1.ocircumflex = 500;
        e1.ntilde = 500;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 611;
        e1.emacron = 444;
        e1.gbreve = 500;
        e1.onequarter = 750;
        e1.Scaron = 500;
        e1.Scommaaccent = 500;
        e1.Ohungarumlaut = 722;
        e1.degree = 400;
        e1.ograve = 500;
        e1.Ccaron = 667;
        e1.ugrave = 500;
        e1.radical = 453;
        e1.Dcaron = 722;
        e1.rcommaaccent = 389;
        e1.Ntilde = 667;
        e1.otilde = 500;
        e1.Rcommaaccent = 611;
        e1.Lcommaaccent = 556;
        e1.Atilde = 611;
        e1.Aogonek = 611;
        e1.Aring = 611;
        e1.Otilde = 722;
        e1.zdotaccent = 389;
        e1.Ecaron = 611;
        e1.Iogonek = 333;
        e1.kcommaaccent = 444;
        e1.minus = 675;
        e1.Icircumflex = 333;
        e1.ncaron = 500;
        e1.tcommaaccent = 278;
        e1.logicalnot = 675;
        e1.odieresis = 500;
        e1.udieresis = 500;
        e1.notequal = 549;
        e1.gcommaaccent = 500;
        e1.eth = 500;
        e1.zcaron = 389;
        e1.ncommaaccent = 500;
        e1.onesuperior = 300;
        e1.imacron = 278;
        e1.Euro = 500;
    });
    e1.ZapfDingbats = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.a1 = 974;
        e1.a2 = 961;
        e1.a202 = 974;
        e1.a3 = 980;
        e1.a4 = 719;
        e1.a5 = 789;
        e1.a119 = 790;
        e1.a118 = 791;
        e1.a117 = 690;
        e1.a11 = 960;
        e1.a12 = 939;
        e1.a13 = 549;
        e1.a14 = 855;
        e1.a15 = 911;
        e1.a16 = 933;
        e1.a105 = 911;
        e1.a17 = 945;
        e1.a18 = 974;
        e1.a19 = 755;
        e1.a20 = 846;
        e1.a21 = 762;
        e1.a22 = 761;
        e1.a23 = 571;
        e1.a24 = 677;
        e1.a25 = 763;
        e1.a26 = 760;
        e1.a27 = 759;
        e1.a28 = 754;
        e1.a6 = 494;
        e1.a7 = 552;
        e1.a8 = 537;
        e1.a9 = 577;
        e1.a10 = 692;
        e1.a29 = 786;
        e1.a30 = 788;
        e1.a31 = 788;
        e1.a32 = 790;
        e1.a33 = 793;
        e1.a34 = 794;
        e1.a35 = 816;
        e1.a36 = 823;
        e1.a37 = 789;
        e1.a38 = 841;
        e1.a39 = 823;
        e1.a40 = 833;
        e1.a41 = 816;
        e1.a42 = 831;
        e1.a43 = 923;
        e1.a44 = 744;
        e1.a45 = 723;
        e1.a46 = 749;
        e1.a47 = 790;
        e1.a48 = 792;
        e1.a49 = 695;
        e1.a50 = 776;
        e1.a51 = 768;
        e1.a52 = 792;
        e1.a53 = 759;
        e1.a54 = 707;
        e1.a55 = 708;
        e1.a56 = 682;
        e1.a57 = 701;
        e1.a58 = 826;
        e1.a59 = 815;
        e1.a60 = 789;
        e1.a61 = 789;
        e1.a62 = 707;
        e1.a63 = 687;
        e1.a64 = 696;
        e1.a65 = 689;
        e1.a66 = 786;
        e1.a67 = 787;
        e1.a68 = 713;
        e1.a69 = 791;
        e1.a70 = 785;
        e1.a71 = 791;
        e1.a72 = 873;
        e1.a73 = 761;
        e1.a74 = 762;
        e1.a203 = 762;
        e1.a75 = 759;
        e1.a204 = 759;
        e1.a76 = 892;
        e1.a77 = 892;
        e1.a78 = 788;
        e1.a79 = 784;
        e1.a81 = 438;
        e1.a82 = 138;
        e1.a83 = 277;
        e1.a84 = 415;
        e1.a97 = 392;
        e1.a98 = 392;
        e1.a99 = 668;
        e1.a100 = 668;
        e1.a89 = 390;
        e1.a90 = 390;
        e1.a93 = 317;
        e1.a94 = 317;
        e1.a91 = 276;
        e1.a92 = 276;
        e1.a205 = 509;
        e1.a85 = 509;
        e1.a206 = 410;
        e1.a86 = 410;
        e1.a87 = 234;
        e1.a88 = 234;
        e1.a95 = 334;
        e1.a96 = 334;
        e1.a101 = 732;
        e1.a102 = 544;
        e1.a103 = 544;
        e1.a104 = 910;
        e1.a106 = 667;
        e1.a107 = 760;
        e1.a108 = 760;
        e1.a112 = 776;
        e1.a111 = 595;
        e1.a110 = 694;
        e1.a109 = 626;
        e1.a120 = 788;
        e1.a121 = 788;
        e1.a122 = 788;
        e1.a123 = 788;
        e1.a124 = 788;
        e1.a125 = 788;
        e1.a126 = 788;
        e1.a127 = 788;
        e1.a128 = 788;
        e1.a129 = 788;
        e1.a130 = 788;
        e1.a131 = 788;
        e1.a132 = 788;
        e1.a133 = 788;
        e1.a134 = 788;
        e1.a135 = 788;
        e1.a136 = 788;
        e1.a137 = 788;
        e1.a138 = 788;
        e1.a139 = 788;
        e1.a140 = 788;
        e1.a141 = 788;
        e1.a142 = 788;
        e1.a143 = 788;
        e1.a144 = 788;
        e1.a145 = 788;
        e1.a146 = 788;
        e1.a147 = 788;
        e1.a148 = 788;
        e1.a149 = 788;
        e1.a150 = 788;
        e1.a151 = 788;
        e1.a152 = 788;
        e1.a153 = 788;
        e1.a154 = 788;
        e1.a155 = 788;
        e1.a156 = 788;
        e1.a157 = 788;
        e1.a158 = 788;
        e1.a159 = 788;
        e1.a160 = 894;
        e1.a161 = 838;
        e1.a163 = 1016;
        e1.a164 = 458;
        e1.a196 = 748;
        e1.a165 = 924;
        e1.a192 = 748;
        e1.a166 = 918;
        e1.a167 = 927;
        e1.a168 = 928;
        e1.a169 = 928;
        e1.a170 = 834;
        e1.a171 = 873;
        e1.a172 = 828;
        e1.a173 = 924;
        e1.a162 = 924;
        e1.a174 = 917;
        e1.a175 = 930;
        e1.a176 = 931;
        e1.a177 = 463;
        e1.a178 = 883;
        e1.a179 = 836;
        e1.a193 = 836;
        e1.a180 = 867;
        e1.a199 = 867;
        e1.a181 = 696;
        e1.a200 = 696;
        e1.a182 = 874;
        e1.a201 = 874;
        e1.a183 = 760;
        e1.a184 = 946;
        e1.a197 = 771;
        e1.a185 = 865;
        e1.a194 = 771;
        e1.a198 = 888;
        e1.a186 = 967;
        e1.a195 = 888;
        e1.a187 = 831;
        e1.a188 = 873;
        e1.a189 = 927;
        e1.a190 = 970;
        e1.a191 = 918;
    });
}), Xi = getLookupTableFactory(function(e1) {
    e1.Courier = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: -426
    };
    e1["Courier-Bold"] = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: 439
    };
    e1["Courier-Oblique"] = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: 426
    };
    e1["Courier-BoldOblique"] = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: 426
    };
    e1.Helvetica = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 523
    };
    e1["Helvetica-Bold"] = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 532
    };
    e1["Helvetica-Oblique"] = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 523
    };
    e1["Helvetica-BoldOblique"] = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 532
    };
    e1["Times-Roman"] = {
        ascent: 683,
        descent: -217,
        capHeight: 662,
        xHeight: 450
    };
    e1["Times-Bold"] = {
        ascent: 683,
        descent: -217,
        capHeight: 676,
        xHeight: 461
    };
    e1["Times-Italic"] = {
        ascent: 683,
        descent: -217,
        capHeight: 653,
        xHeight: 441
    };
    e1["Times-BoldItalic"] = {
        ascent: 683,
        descent: -217,
        capHeight: 669,
        xHeight: 462
    };
    e1.Symbol = {
        ascent: Math.NaN,
        descent: Math.NaN,
        capHeight: Math.NaN,
        xHeight: Math.NaN
    };
    e1.ZapfDingbats = {
        ascent: Math.NaN,
        descent: Math.NaN,
        capHeight: Math.NaN,
        xHeight: Math.NaN
    };
});
class GlyfTable {
    constructor({ glyfTable: e1, isGlyphLocationsLong: t, locaTable: i, numGlyphs: a }){
        this.glyphs = [];
        const s = new DataView(i.buffer, i.byteOffset, i.byteLength), r = new DataView(e1.buffer, e1.byteOffset, e1.byteLength), n = t ? 4 : 2;
        let g = t ? s.getUint32(0) : 2 * s.getUint16(0), o = 0;
        for(let e1 = 0; e1 < a; e1++){
            o += n;
            const e1 = t ? s.getUint32(o) : 2 * s.getUint16(o);
            if (e1 === g) {
                this.glyphs.push(new Glyph({}));
                continue;
            }
            const i = Glyph.parse(g, r);
            this.glyphs.push(i);
            g = e1;
        }
    }
    getSize() {
        return this.glyphs.reduce((e1, t)=>e1 + (t.getSize() + 3 & -4), 0);
    }
    write() {
        const e1 = this.getSize(), t = new DataView(new ArrayBuffer(e1)), i = e1 > 131070, a = i ? 4 : 2, s = new DataView(new ArrayBuffer((this.glyphs.length + 1) * a));
        i ? s.setUint32(0, 0) : s.setUint16(0, 0);
        let r = 0, n = 0;
        for (const e1 of this.glyphs){
            r += e1.write(r, t);
            r = r + 3 & -4;
            n += a;
            i ? s.setUint32(n, r) : s.setUint16(n, r >> 1);
        }
        return {
            isLocationLong: i,
            loca: new Uint8Array(s.buffer),
            glyf: new Uint8Array(t.buffer)
        };
    }
    scale(e1) {
        for(let t = 0, i = this.glyphs.length; t < i; t++)this.glyphs[t].scale(e1[t]);
    }
}
class Glyph {
    constructor({ header: e1 = null, simple: t = null, composites: i = null }){
        this.header = e1;
        this.simple = t;
        this.composites = i;
    }
    static parse(e1, t) {
        const [i, a] = GlyphHeader.parse(e1, t);
        e1 += i;
        if (a.numberOfContours < 0) {
            const i = [];
            for(;;){
                const [a, s] = CompositeGlyph.parse(e1, t);
                e1 += a;
                i.push(s);
                if (!(32 & s.flags)) break;
            }
            return new Glyph({
                header: a,
                composites: i
            });
        }
        const s = SimpleGlyph.parse(e1, t, a.numberOfContours);
        return new Glyph({
            header: a,
            simple: s
        });
    }
    getSize() {
        if (!this.header) return 0;
        const e1 = this.simple ? this.simple.getSize() : this.composites.reduce((e1, t)=>e1 + t.getSize(), 0);
        return this.header.getSize() + e1;
    }
    write(e1, t) {
        if (!this.header) return 0;
        const i = e1;
        e1 += this.header.write(e1, t);
        if (this.simple) e1 += this.simple.write(e1, t);
        else for (const i of this.composites)e1 += i.write(e1, t);
        return e1 - i;
    }
    scale(e1) {
        if (!this.header) return;
        const t = (this.header.xMin + this.header.xMax) / 2;
        this.header.scale(t, e1);
        if (this.simple) this.simple.scale(t, e1);
        else for (const i of this.composites)i.scale(t, e1);
    }
}
class GlyphHeader {
    constructor({ numberOfContours: e1, xMin: t, yMin: i, xMax: a, yMax: s }){
        this.numberOfContours = e1;
        this.xMin = t;
        this.yMin = i;
        this.xMax = a;
        this.yMax = s;
    }
    static parse(e1, t) {
        return [
            10,
            new GlyphHeader({
                numberOfContours: t.getInt16(e1),
                xMin: t.getInt16(e1 + 2),
                yMin: t.getInt16(e1 + 4),
                xMax: t.getInt16(e1 + 6),
                yMax: t.getInt16(e1 + 8)
            })
        ];
    }
    getSize() {
        return 10;
    }
    write(e1, t) {
        t.setInt16(e1, this.numberOfContours);
        t.setInt16(e1 + 2, this.xMin);
        t.setInt16(e1 + 4, this.yMin);
        t.setInt16(e1 + 6, this.xMax);
        t.setInt16(e1 + 8, this.yMax);
        return 10;
    }
    scale(e1, t) {
        this.xMin = Math.round(e1 + (this.xMin - e1) * t);
        this.xMax = Math.round(e1 + (this.xMax - e1) * t);
    }
}
class Contour {
    constructor({ flags: e1, xCoordinates: t, yCoordinates: i }){
        this.xCoordinates = t;
        this.yCoordinates = i;
        this.flags = e1;
    }
}
class SimpleGlyph {
    constructor({ contours: e1, instructions: t }){
        this.contours = e1;
        this.instructions = t;
    }
    static parse(e1, t, i) {
        const a = [];
        for(let s = 0; s < i; s++){
            const i = t.getUint16(e1);
            e1 += 2;
            a.push(i);
        }
        const s = a[i - 1] + 1, r = t.getUint16(e1);
        e1 += 2;
        const n = new Uint8Array(t).slice(e1, e1 + r);
        e1 += r;
        const g = [];
        for(let i = 0; i < s; e1++, i++){
            let a = t.getUint8(e1);
            g.push(a);
            if (8 & a) {
                const s = t.getUint8(++e1);
                a ^= 8;
                for(let e1 = 0; e1 < s; e1++)g.push(a);
                i += s;
            }
        }
        const o = [];
        let c = [], C = [], h = [];
        const l = [];
        let Q = 0, E = 0;
        for(let i = 0; i < s; i++){
            const s = g[i];
            if (2 & s) {
                const i = t.getUint8(e1++);
                E += 16 & s ? i : -i;
                c.push(E);
            } else if (16 & s) c.push(E);
            else {
                E += t.getInt16(e1);
                e1 += 2;
                c.push(E);
            }
            if (a[Q] === i) {
                Q++;
                o.push(c);
                c = [];
            }
        }
        E = 0;
        Q = 0;
        for(let i = 0; i < s; i++){
            const s = g[i];
            if (4 & s) {
                const i = t.getUint8(e1++);
                E += 32 & s ? i : -i;
                C.push(E);
            } else if (32 & s) C.push(E);
            else {
                E += t.getInt16(e1);
                e1 += 2;
                C.push(E);
            }
            h.push(1 & s | 64 & s);
            if (a[Q] === i) {
                c = o[Q];
                Q++;
                l.push(new Contour({
                    flags: h,
                    xCoordinates: c,
                    yCoordinates: C
                }));
                C = [];
                h = [];
            }
        }
        return new SimpleGlyph({
            contours: l,
            instructions: n
        });
    }
    getSize() {
        let e1 = 2 * this.contours.length + 2 + this.instructions.length, t = 0, i = 0;
        for (const a of this.contours){
            e1 += a.flags.length;
            for(let s = 0, r = a.xCoordinates.length; s < r; s++){
                const r = a.xCoordinates[s], n = a.yCoordinates[s];
                let g = Math.abs(r - t);
                g > 255 ? e1 += 2 : g > 0 && (e1 += 1);
                t = r;
                g = Math.abs(n - i);
                g > 255 ? e1 += 2 : g > 0 && (e1 += 1);
                i = n;
            }
        }
        return e1;
    }
    write(e1, t) {
        const i = e1, a = [], s = [], r = [];
        let n = 0, g = 0;
        for (const i of this.contours){
            for(let e1 = 0, t = i.xCoordinates.length; e1 < t; e1++){
                let t = i.flags[e1];
                const o = i.xCoordinates[e1];
                let c = o - n;
                if (0 === c) {
                    t |= 16;
                    a.push(0);
                } else {
                    const e1 = Math.abs(c);
                    if (e1 <= 255) {
                        t |= c >= 0 ? 18 : 2;
                        a.push(e1);
                    } else a.push(c);
                }
                n = o;
                const C = i.yCoordinates[e1];
                c = C - g;
                if (0 === c) {
                    t |= 32;
                    s.push(0);
                } else {
                    const e1 = Math.abs(c);
                    if (e1 <= 255) {
                        t |= c >= 0 ? 36 : 4;
                        s.push(e1);
                    } else s.push(c);
                }
                g = C;
                r.push(t);
            }
            t.setUint16(e1, a.length - 1);
            e1 += 2;
        }
        t.setUint16(e1, this.instructions.length);
        e1 += 2;
        if (this.instructions.length) {
            new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e1);
            e1 += this.instructions.length;
        }
        for (const i of r)t.setUint8(e1++, i);
        for(let i = 0, s = a.length; i < s; i++){
            const s = a[i], n = r[i];
            if (2 & n) t.setUint8(e1++, s);
            else if (!(16 & n)) {
                t.setInt16(e1, s);
                e1 += 2;
            }
        }
        for(let i = 0, a = s.length; i < a; i++){
            const a = s[i], n = r[i];
            if (4 & n) t.setUint8(e1++, a);
            else if (!(32 & n)) {
                t.setInt16(e1, a);
                e1 += 2;
            }
        }
        return e1 - i;
    }
    scale(e1, t) {
        for (const i of this.contours)if (0 !== i.xCoordinates.length) for(let a = 0, s = i.xCoordinates.length; a < s; a++)i.xCoordinates[a] = Math.round(e1 + (i.xCoordinates[a] - e1) * t);
    }
}
class CompositeGlyph {
    constructor({ flags: e1, glyphIndex: t, argument1: i, argument2: a, transf: s, instructions: r }){
        this.flags = e1;
        this.glyphIndex = t;
        this.argument1 = i;
        this.argument2 = a;
        this.transf = s;
        this.instructions = r;
    }
    static parse(e1, t) {
        const i = e1, a = [];
        let s = t.getUint16(e1);
        const r = t.getUint16(e1 + 2);
        e1 += 4;
        let n, g;
        if (1 & s) {
            if (2 & s) {
                n = t.getInt16(e1);
                g = t.getInt16(e1 + 2);
            } else {
                n = t.getUint16(e1);
                g = t.getUint16(e1 + 2);
            }
            e1 += 4;
            s ^= 1;
        } else {
            if (2 & s) {
                n = t.getInt8(e1);
                g = t.getInt8(e1 + 1);
            } else {
                n = t.getUint8(e1);
                g = t.getUint8(e1 + 1);
            }
            e1 += 2;
        }
        if (8 & s) {
            a.push(t.getUint16(e1));
            e1 += 2;
        } else if (64 & s) {
            a.push(t.getUint16(e1), t.getUint16(e1 + 2));
            e1 += 4;
        } else if (128 & s) {
            a.push(t.getUint16(e1), t.getUint16(e1 + 2), t.getUint16(e1 + 4), t.getUint16(e1 + 6));
            e1 += 8;
        }
        let o = null;
        if (256 & s) {
            const i = t.getUint16(e1);
            e1 += 2;
            o = new Uint8Array(t).slice(e1, e1 + i);
            e1 += i;
        }
        return [
            e1 - i,
            new CompositeGlyph({
                flags: s,
                glyphIndex: r,
                argument1: n,
                argument2: g,
                transf: a,
                instructions: o
            })
        ];
    }
    getSize() {
        let e1 = 4 + 2 * this.transf.length;
        256 & this.flags && (e1 += 2 + this.instructions.length);
        e1 += 2;
        2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e1 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e1 += 2);
        return e1;
    }
    write(e1, t) {
        const i = e1;
        2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1);
        t.setUint16(e1, this.flags);
        t.setUint16(e1 + 2, this.glyphIndex);
        e1 += 4;
        if (1 & this.flags) {
            if (2 & this.flags) {
                t.setInt16(e1, this.argument1);
                t.setInt16(e1 + 2, this.argument2);
            } else {
                t.setUint16(e1, this.argument1);
                t.setUint16(e1 + 2, this.argument2);
            }
            e1 += 4;
        } else {
            t.setUint8(e1, this.argument1);
            t.setUint8(e1 + 1, this.argument2);
            e1 += 2;
        }
        if (256 & this.flags) {
            t.setUint16(e1, this.instructions.length);
            e1 += 2;
            if (this.instructions.length) {
                new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e1);
                e1 += this.instructions.length;
            }
        }
        return e1 - i;
    }
    scale(e1, t) {}
}
function writeInt16(e1, t, i) {
    e1[t] = i >> 8 & 255;
    e1[t + 1] = 255 & i;
}
function writeInt32(e1, t, i) {
    e1[t] = i >> 24 & 255;
    e1[t + 1] = i >> 16 & 255;
    e1[t + 2] = i >> 8 & 255;
    e1[t + 3] = 255 & i;
}
function writeData(e1, t, i) {
    if (i instanceof Uint8Array) e1.set(i, t);
    else if ("string" == typeof i) for(let a = 0, s = i.length; a < s; a++)e1[t++] = 255 & i.charCodeAt(a);
    else for (const a of i)e1[t++] = 255 & a;
}
class OpenTypeFileBuilder {
    constructor(e1){
        this.sfnt = e1;
        this.tables = Object.create(null);
    }
    static getSearchParams(e1, t) {
        let i = 1, a = 0;
        for(; (i ^ e1) > i;){
            i <<= 1;
            a++;
        }
        const s = i * t;
        return {
            range: s,
            entry: a,
            rangeShift: t * e1 - s
        };
    }
    toArray() {
        let e1 = this.sfnt;
        const t = this.tables, i = Object.keys(t);
        i.sort();
        const a = i.length;
        let s, r, n, g, o, c = 12 + 16 * a;
        const C = [
            c
        ];
        for(s = 0; s < a; s++){
            g = t[i[s]];
            c += (g.length + 3 & -4) >>> 0;
            C.push(c);
        }
        const h = new Uint8Array(c);
        for(s = 0; s < a; s++){
            g = t[i[s]];
            writeData(h, C[s], g);
        }
        "true" === e1 && (e1 = string32(65536));
        h[0] = 255 & e1.charCodeAt(0);
        h[1] = 255 & e1.charCodeAt(1);
        h[2] = 255 & e1.charCodeAt(2);
        h[3] = 255 & e1.charCodeAt(3);
        writeInt16(h, 4, a);
        const l = OpenTypeFileBuilder.getSearchParams(a, 16);
        writeInt16(h, 6, l.range);
        writeInt16(h, 8, l.entry);
        writeInt16(h, 10, l.rangeShift);
        c = 12;
        for(s = 0; s < a; s++){
            o = i[s];
            h[c] = 255 & o.charCodeAt(0);
            h[c + 1] = 255 & o.charCodeAt(1);
            h[c + 2] = 255 & o.charCodeAt(2);
            h[c + 3] = 255 & o.charCodeAt(3);
            let e1 = 0;
            for(r = C[s], n = C[s + 1]; r < n; r += 4){
                e1 = e1 + readUint32(h, r) >>> 0;
            }
            writeInt32(h, c + 4, e1);
            writeInt32(h, c + 8, C[s]);
            writeInt32(h, c + 12, t[o].length);
            c += 16;
        }
        return h;
    }
    addTable(e1, t) {
        if (e1 in this.tables) throw new Error("Table " + e1 + " already exists");
        this.tables[e1] = t;
    }
}
const Zi = [
    4
], Vi = [
    5
], zi = [
    6
], _i = [
    7
], $i = [
    8
], Aa = [
    12,
    35
], ea = [
    14
], ta = [
    21
], ia = [
    22
], aa = [
    30
], sa = [
    31
];
class Type1CharString {
    constructor(){
        this.width = 0;
        this.lsb = 0;
        this.flexing = !1;
        this.output = [];
        this.stack = [];
    }
    convert(e1, t, i) {
        const a = e1.length;
        let s, r, n, g = !1;
        for(let o = 0; o < a; o++){
            let a = e1[o];
            if (a < 32) {
                12 === a && (a = (a << 8) + e1[++o]);
                switch(a){
                    case 1:
                    case 3:
                    case 9:
                    case 3072:
                    case 3073:
                    case 3074:
                    case 3105:
                        this.stack = [];
                        break;
                    case 4:
                        if (this.flexing) {
                            if (this.stack.length < 1) {
                                g = !0;
                                break;
                            }
                            const e1 = this.stack.pop();
                            this.stack.push(0, e1);
                            break;
                        }
                        g = this.executeCommand(1, Zi);
                        break;
                    case 5:
                        g = this.executeCommand(2, Vi);
                        break;
                    case 6:
                        g = this.executeCommand(1, zi);
                        break;
                    case 7:
                        g = this.executeCommand(1, _i);
                        break;
                    case 8:
                        g = this.executeCommand(6, $i);
                        break;
                    case 10:
                        if (this.stack.length < 1) {
                            g = !0;
                            break;
                        }
                        n = this.stack.pop();
                        if (!t[n]) {
                            g = !0;
                            break;
                        }
                        g = this.convert(t[n], t, i);
                        break;
                    case 11:
                        return g;
                    case 13:
                        if (this.stack.length < 2) {
                            g = !0;
                            break;
                        }
                        s = this.stack.pop();
                        r = this.stack.pop();
                        this.lsb = r;
                        this.width = s;
                        this.stack.push(s, r);
                        g = this.executeCommand(2, ia);
                        break;
                    case 14:
                        this.output.push(ea[0]);
                        break;
                    case 21:
                        if (this.flexing) break;
                        g = this.executeCommand(2, ta);
                        break;
                    case 22:
                        if (this.flexing) {
                            this.stack.push(0);
                            break;
                        }
                        g = this.executeCommand(1, ia);
                        break;
                    case 30:
                        g = this.executeCommand(4, aa);
                        break;
                    case 31:
                        g = this.executeCommand(4, sa);
                        break;
                    case 3078:
                        if (i) {
                            const e1 = this.stack.at(-5);
                            this.seac = this.stack.splice(-4, 4);
                            this.seac[0] += this.lsb - e1;
                            g = this.executeCommand(0, ea);
                        } else g = this.executeCommand(4, ea);
                        break;
                    case 3079:
                        if (this.stack.length < 4) {
                            g = !0;
                            break;
                        }
                        this.stack.pop();
                        s = this.stack.pop();
                        const e2 = this.stack.pop();
                        r = this.stack.pop();
                        this.lsb = r;
                        this.width = s;
                        this.stack.push(s, r, e2);
                        g = this.executeCommand(3, ta);
                        break;
                    case 3084:
                        if (this.stack.length < 2) {
                            g = !0;
                            break;
                        }
                        const o1 = this.stack.pop(), c = this.stack.pop();
                        this.stack.push(c / o1);
                        break;
                    case 3088:
                        if (this.stack.length < 2) {
                            g = !0;
                            break;
                        }
                        n = this.stack.pop();
                        const C = this.stack.pop();
                        if (0 === n && 3 === C) {
                            const e1 = this.stack.splice(-17, 17);
                            this.stack.push(e1[2] + e1[0], e1[3] + e1[1], e1[4], e1[5], e1[6], e1[7], e1[8], e1[9], e1[10], e1[11], e1[12], e1[13], e1[14]);
                            g = this.executeCommand(13, Aa, !0);
                            this.flexing = !1;
                            this.stack.push(e1[15], e1[16]);
                        } else 1 === n && 0 === C && (this.flexing = !0);
                        break;
                    case 3089:
                        break;
                    default:
                        warn('Unknown type 1 charstring command of "' + a + '"');
                }
                if (g) break;
            } else {
                a <= 246 ? a -= 139 : a = a <= 250 ? 256 * (a - 247) + e1[++o] + 108 : a <= 254 ? -256 * (a - 251) - e1[++o] - 108 : (255 & e1[++o]) << 24 | (255 & e1[++o]) << 16 | (255 & e1[++o]) << 8 | 255 & e1[++o];
                this.stack.push(a);
            }
        }
        return g;
    }
    executeCommand(e1, t, i) {
        const a = this.stack.length;
        if (e1 > a) return !0;
        const s = a - e1;
        for(let e1 = s; e1 < a; e1++){
            let t = this.stack[e1];
            if (Number.isInteger(t)) this.output.push(28, t >> 8 & 255, 255 & t);
            else {
                t = 65536 * t | 0;
                this.output.push(255, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t);
            }
        }
        this.output.push(...t);
        i ? this.stack.splice(s, e1) : this.stack.length = 0;
        return !1;
    }
}
function isHexDigit(e1) {
    return e1 >= 48 && e1 <= 57 || e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102;
}
function decrypt(e1, t, i) {
    if (i >= e1.length) return new Uint8Array(0);
    let a, s, r = 0 | t;
    for(a = 0; a < i; a++)r = 52845 * (e1[a] + r) + 22719 & 65535;
    const n = e1.length - i, g = new Uint8Array(n);
    for(a = i, s = 0; s < n; a++, s++){
        const t = e1[a];
        g[s] = t ^ r >> 8;
        r = 52845 * (t + r) + 22719 & 65535;
    }
    return g;
}
function isSpecial(e1) {
    return 47 === e1 || 91 === e1 || 93 === e1 || 123 === e1 || 125 === e1 || 40 === e1 || 41 === e1;
}
class Type1Parser {
    constructor(e1, t, i){
        if (t) {
            const t = e1.getBytes(), i = !((isHexDigit(t[0]) || isWhiteSpace(t[0])) && isHexDigit(t[1]) && isHexDigit(t[2]) && isHexDigit(t[3]) && isHexDigit(t[4]) && isHexDigit(t[5]) && isHexDigit(t[6]) && isHexDigit(t[7]));
            e1 = new Stream(i ? decrypt(t, 55665, 4) : function decryptAscii(e1, t, i) {
                let a = 0 | t;
                const s = e1.length, r = new Uint8Array(s >>> 1);
                let n, g;
                for(n = 0, g = 0; n < s; n++){
                    const t = e1[n];
                    if (!isHexDigit(t)) continue;
                    n++;
                    let i;
                    for(; n < s && !isHexDigit(i = e1[n]);)n++;
                    if (n < s) {
                        const e1 = parseInt(String.fromCharCode(t, i), 16);
                        r[g++] = e1 ^ a >> 8;
                        a = 52845 * (e1 + a) + 22719 & 65535;
                    }
                }
                return r.slice(i, g);
            }(t, 55665, 4));
        }
        this.seacAnalysisEnabled = !!i;
        this.stream = e1;
        this.nextChar();
    }
    readNumberArray() {
        this.getToken();
        const e1 = [];
        for(;;){
            const t = this.getToken();
            if (null === t || "]" === t || "}" === t) break;
            e1.push(parseFloat(t || 0));
        }
        return e1;
    }
    readNumber() {
        const e1 = this.getToken();
        return parseFloat(e1 || 0);
    }
    readInt() {
        const e1 = this.getToken();
        return 0 | parseInt(e1 || 0, 10);
    }
    readBoolean() {
        return "true" === this.getToken() ? 1 : 0;
    }
    nextChar() {
        return this.currentChar = this.stream.getByte();
    }
    prevChar() {
        this.stream.skip(-2);
        return this.currentChar = this.stream.getByte();
    }
    getToken() {
        let e1 = !1, t = this.currentChar;
        for(;;){
            if (-1 === t) return null;
            if (e1) 10 !== t && 13 !== t || (e1 = !1);
            else if (37 === t) e1 = !0;
            else if (!isWhiteSpace(t)) break;
            t = this.nextChar();
        }
        if (isSpecial(t)) {
            this.nextChar();
            return String.fromCharCode(t);
        }
        let i = "";
        do {
            i += String.fromCharCode(t);
            t = this.nextChar();
        }while (t >= 0 && !isWhiteSpace(t) && !isSpecial(t))
        return i;
    }
    readCharStrings(e1, t) {
        return -1 === t ? e1 : decrypt(e1, 4330, t);
    }
    extractFontProgram(e1) {
        const t = this.stream, i = [], a = [], s = Object.create(null);
        s.lenIV = 4;
        const r = {
            subrs: [],
            charstrings: [],
            properties: {
                privateData: s
            }
        };
        let n, g, o, c;
        for(; null !== (n = this.getToken());)if ("/" === n) {
            n = this.getToken();
            switch(n){
                case "CharStrings":
                    this.getToken();
                    this.getToken();
                    this.getToken();
                    this.getToken();
                    for(;;){
                        n = this.getToken();
                        if (null === n || "end" === n) break;
                        if ("/" !== n) continue;
                        const e1 = this.getToken();
                        g = this.readInt();
                        this.getToken();
                        o = g > 0 ? t.getBytes(g) : new Uint8Array(0);
                        c = r.properties.privateData.lenIV;
                        const i = this.readCharStrings(o, c);
                        this.nextChar();
                        n = this.getToken();
                        "noaccess" === n ? this.getToken() : "/" === n && this.prevChar();
                        a.push({
                            glyph: e1,
                            encoded: i
                        });
                    }
                    break;
                case "Subrs":
                    this.readInt();
                    this.getToken();
                    for(; "dup" === this.getToken();){
                        const e1 = this.readInt();
                        g = this.readInt();
                        this.getToken();
                        o = g > 0 ? t.getBytes(g) : new Uint8Array(0);
                        c = r.properties.privateData.lenIV;
                        const a = this.readCharStrings(o, c);
                        this.nextChar();
                        n = this.getToken();
                        "noaccess" === n && this.getToken();
                        i[e1] = a;
                    }
                    break;
                case "BlueValues":
                case "OtherBlues":
                case "FamilyBlues":
                case "FamilyOtherBlues":
                    const e1 = this.readNumberArray();
                    e1.length > 0 && e1.length, 0;
                    break;
                case "StemSnapH":
                case "StemSnapV":
                    r.properties.privateData[n] = this.readNumberArray();
                    break;
                case "StdHW":
                case "StdVW":
                    r.properties.privateData[n] = this.readNumberArray()[0];
                    break;
                case "BlueShift":
                case "lenIV":
                case "BlueFuzz":
                case "BlueScale":
                case "LanguageGroup":
                    r.properties.privateData[n] = this.readNumber();
                    break;
                case "ExpansionFactor":
                    r.properties.privateData[n] = this.readNumber() || .06;
                    break;
                case "ForceBold":
                    r.properties.privateData[n] = this.readBoolean();
            }
        }
        for (const { encoded: t, glyph: s } of a){
            const a = new Type1CharString, n = a.convert(t, i, this.seacAnalysisEnabled);
            let g = a.output;
            n && (g = [
                14
            ]);
            const o = {
                glyphName: s,
                charstring: g,
                width: a.width,
                lsb: a.lsb,
                seac: a.seac
            };
            ".notdef" === s ? r.charstrings.unshift(o) : r.charstrings.push(o);
            if (e1.builtInEncoding) {
                const t = e1.builtInEncoding.indexOf(s);
                t > -1 && void 0 === e1.widths[t] && t >= e1.firstChar && t <= e1.lastChar && (e1.widths[t] = a.width);
            }
        }
        return r;
    }
    extractFontHeader(e1) {
        let t;
        for(; null !== (t = this.getToken());)if ("/" === t) {
            t = this.getToken();
            switch(t){
                case "FontMatrix":
                    const i = this.readNumberArray();
                    e1.fontMatrix = i;
                    break;
                case "Encoding":
                    const a = this.getToken();
                    let s;
                    if (/^\d+$/.test(a)) {
                        s = [];
                        const e1 = 0 | parseInt(a, 10);
                        this.getToken();
                        for(let i = 0; i < e1; i++){
                            t = this.getToken();
                            for(; "dup" !== t && "def" !== t;){
                                t = this.getToken();
                                if (null === t) return;
                            }
                            if ("def" === t) break;
                            const e1 = this.readInt();
                            this.getToken();
                            const i = this.getToken();
                            s[e1] = i;
                            this.getToken();
                        }
                    } else s = getEncoding(a);
                    e1.builtInEncoding = s;
                    break;
                case "FontBBox":
                    const r = this.readNumberArray();
                    e1.ascent = Math.max(r[3], r[1]);
                    e1.descent = Math.min(r[1], r[3]);
                    e1.ascentScaled = !0;
            }
        }
    }
}
function findBlock(e1, t, i) {
    const a = e1.length, s = t.length, r = a - s;
    let n = i, g = !1;
    for(; n < r;){
        let i = 0;
        for(; i < s && e1[n + i] === t[i];)i++;
        if (i >= s) {
            n += i;
            for(; n < a && isWhiteSpace(e1[n]);)n++;
            g = !0;
            break;
        }
        n++;
    }
    return {
        found: g,
        length: n
    };
}
class Type1Font {
    constructor(e1, t, i){
        let a = i.length1, s = i.length2, r = t.peekBytes(6);
        const n = 128 === r[0] && 1 === r[1];
        if (n) {
            t.skip(6);
            a = r[5] << 24 | r[4] << 16 | r[3] << 8 | r[2];
        }
        const g = function getHeaderBlock(e1, t) {
            const i = [
                101,
                101,
                120,
                101,
                99
            ], a = e1.pos;
            let s, r, n, g;
            try {
                s = e1.getBytes(t);
                r = s.length;
            } catch  {}
            if (r === t) {
                n = findBlock(s, i, t - 2 * i.length);
                if (n.found && n.length === t) return {
                    stream: new Stream(s),
                    length: t
                };
            }
            warn('Invalid "Length1" property in Type1 font -- trying to recover.');
            e1.pos = a;
            for(;;){
                n = findBlock(e1.peekBytes(2048), i, 0);
                if (0 === n.length) break;
                e1.pos += n.length;
                if (n.found) {
                    g = e1.pos - a;
                    break;
                }
            }
            e1.pos = a;
            if (g) return {
                stream: new Stream(e1.getBytes(g)),
                length: g
            };
            warn('Unable to recover "Length1" property in Type1 font -- using as is.');
            return {
                stream: new Stream(e1.getBytes(t)),
                length: t
            };
        }(t, a);
        new Type1Parser(g.stream, !1, Ri).extractFontHeader(i);
        if (n) {
            r = t.getBytes(6);
            s = r[5] << 24 | r[4] << 16 | r[3] << 8 | r[2];
        }
        const o = function getEexecBlock(e1, t) {
            const i = e1.getBytes();
            if (0 === i.length) throw new FormatError("getEexecBlock - no font program found.");
            return {
                stream: new Stream(i),
                length: i.length
            };
        }(t), c = new Type1Parser(o.stream, !0, Ri).extractFontProgram(i);
        for(const e1 in c.properties)i[e1] = c.properties[e1];
        const C = c.charstrings, h = this.getType2Charstrings(C), l = this.getType2Subrs(c.subrs);
        this.charstrings = C;
        this.data = this.wrap(e1, h, this.charstrings, l, i);
        this.seacs = this.getSeacs(c.charstrings);
    }
    get numGlyphs() {
        return this.charstrings.length + 1;
    }
    getCharset() {
        const e1 = [
            ".notdef"
        ];
        for (const { glyphName: t } of this.charstrings)e1.push(t);
        return e1;
    }
    getGlyphMapping(e1) {
        const t = this.charstrings;
        if (e1.composite) {
            const i = Object.create(null);
            for(let a = 0, s = t.length; a < s; a++){
                i[e1.cMap.charCodeOf(a)] = a + 1;
            }
            return i;
        }
        const i = [
            ".notdef"
        ];
        let a, s;
        for(s = 0; s < t.length; s++)i.push(t[s].glyphName);
        const r = e1.builtInEncoding;
        if (r) {
            a = Object.create(null);
            for(const e1 in r){
                s = i.indexOf(r[e1]);
                s >= 0 && (a[e1] = s);
            }
        }
        return type1FontGlyphMapping(e1, a, i);
    }
    hasGlyphId(e1) {
        if (e1 < 0 || e1 >= this.numGlyphs) return !1;
        if (0 === e1) return !0;
        return this.charstrings[e1 - 1].charstring.length > 0;
    }
    getSeacs(e1) {
        const t = [];
        for(let i = 0, a = e1.length; i < a; i++){
            const a = e1[i];
            a.seac && (t[i + 1] = a.seac);
        }
        return t;
    }
    getType2Charstrings(e1) {
        const t = [];
        for (const i of e1)t.push(i.charstring);
        return t;
    }
    getType2Subrs(e1) {
        let t = 0;
        const i = e1.length;
        t = i < 1133 ? 107 : i < 33769 ? 1131 : 32768;
        const a = [];
        let s;
        for(s = 0; s < t; s++)a.push([
            11
        ]);
        for(s = 0; s < i; s++)a.push(e1[s]);
        return a;
    }
    wrap(e1, t, i, a, s) {
        const r = new CFF;
        r.header = new CFFHeader(1, 0, 4, 4);
        r.names = [
            e1
        ];
        const n = new CFFTopDict;
        n.setByName("version", 391);
        n.setByName("Notice", 392);
        n.setByName("FullName", 393);
        n.setByName("FamilyName", 394);
        n.setByName("Weight", 395);
        n.setByName("Encoding", null);
        n.setByName("FontMatrix", s.fontMatrix);
        n.setByName("FontBBox", s.bbox);
        n.setByName("charset", null);
        n.setByName("CharStrings", null);
        n.setByName("Private", null);
        r.topDict = n;
        const g = new CFFStrings;
        g.add("Version 0.11");
        g.add("See original notice");
        g.add(e1);
        g.add(e1);
        g.add("Medium");
        r.strings = g;
        r.globalSubrIndex = new CFFIndex;
        const o = t.length, c = [
            ".notdef"
        ];
        let C, h;
        for(C = 0; C < o; C++){
            const e1 = i[C].glyphName;
            -1 === Ei.indexOf(e1) && g.add(e1);
            c.push(e1);
        }
        r.charset = new CFFCharset(!1, 0, c);
        const l = new CFFIndex;
        l.add([
            139,
            14
        ]);
        for(C = 0; C < o; C++)l.add(t[C]);
        r.charStrings = l;
        const Q = new CFFPrivateDict;
        Q.setByName("Subrs", null);
        const E = [
            "BlueValues",
            "OtherBlues",
            "FamilyBlues",
            "FamilyOtherBlues",
            "StemSnapH",
            "StemSnapV",
            "BlueShift",
            "BlueFuzz",
            "BlueScale",
            "LanguageGroup",
            "ExpansionFactor",
            "ForceBold",
            "StdHW",
            "StdVW"
        ];
        for(C = 0, h = E.length; C < h; C++){
            const e1 = E[C];
            if (!(e1 in s.privateData)) continue;
            const t = s.privateData[e1];
            if (Array.isArray(t)) for(let e1 = t.length - 1; e1 > 0; e1--)t[e1] -= t[e1 - 1];
            Q.setByName(e1, t);
        }
        r.topDict.privateDict = Q;
        const u = new CFFIndex;
        for(C = 0, h = a.length; C < h; C++)u.add(a[C]);
        Q.subrsIndex = u;
        return new CFFCompiler(r).compile();
    }
}
const ra = [
    [
        57344,
        63743
    ],
    [
        1048576,
        1114109
    ]
], na = 1e3, ga = [
    "ascent",
    "bbox",
    "black",
    "bold",
    "charProcOperatorList",
    "composite",
    "cssFontInfo",
    "data",
    "defaultVMetrics",
    "defaultWidth",
    "descent",
    "fallbackName",
    "fontMatrix",
    "isInvalidPDFjsFont",
    "isType3Font",
    "italic",
    "loadedName",
    "mimetype",
    "missingFile",
    "name",
    "remeasure",
    "subtype",
    "systemFontInfo",
    "type",
    "vertical"
], oa = [
    "cMap",
    "defaultEncoding",
    "differences",
    "isMonospace",
    "isSerifFont",
    "isSymbolicFont",
    "seacMap",
    "toFontChar",
    "toUnicode",
    "vmetrics",
    "widths"
];
function adjustWidths(e1) {
    if (!e1.fontMatrix) return;
    if (e1.fontMatrix[0] === a[0]) return;
    const t = .001 / e1.fontMatrix[0], i = e1.widths;
    for(const e1 in i)i[e1] *= t;
    e1.defaultWidth *= t;
}
function amendFallbackToUnicode(e1) {
    if (!e1.fallbackToUnicode) return;
    if (e1.toUnicode instanceof IdentityToUnicodeMap) return;
    const t = [];
    for(const i in e1.fallbackToUnicode)e1.toUnicode.has(i) || (t[i] = e1.fallbackToUnicode[i]);
    t.length > 0 && e1.toUnicode.amend(t);
}
class fonts_Glyph {
    constructor(e1, t, i, a, s, r, n, g, o){
        this.originalCharCode = e1;
        this.fontChar = t;
        this.unicode = i;
        this.accent = a;
        this.width = s;
        this.vmetric = r;
        this.operatorListId = n;
        this.isSpace = g;
        this.isInFont = o;
    }
    get category() {
        return shadow(this, "category", function getCharUnicodeCategory(e1) {
            const t = ki.get(e1);
            if (t) return t;
            const i = e1.match(Si), a = {
                isWhitespace: !!i?.[1],
                isZeroWidthDiacritic: !!i?.[2],
                isInvisibleFormatMark: !!i?.[3]
            };
            ki.set(e1, a);
            return a;
        }(this.unicode), !0);
    }
}
function int16(e1, t) {
    return (e1 << 8) + t;
}
function writeSignedInt16(e1, t, i) {
    e1[t + 1] = i;
    e1[t] = i >>> 8;
}
function signedInt16(e1, t) {
    const i = (e1 << 8) + t;
    return 32768 & i ? i - 65536 : i;
}
function string16(e1) {
    return String.fromCharCode(e1 >> 8 & 255, 255 & e1);
}
function safeString16(e1) {
    e1 > 32767 ? e1 = 32767 : e1 < -32768 && (e1 = -32768);
    return String.fromCharCode(e1 >> 8 & 255, 255 & e1);
}
function isTrueTypeCollectionFile(e1) {
    return "ttcf" === bytesToString(e1.peekBytes(4));
}
function getFontFileType(e1, { type: t, subtype: i, composite: a }) {
    let s, r;
    if (function isTrueTypeFile(e1) {
        const t = e1.peekBytes(4);
        return 65536 === readUint32(t, 0) || "true" === bytesToString(t);
    }(e1) || isTrueTypeCollectionFile(e1)) s = a ? "CIDFontType2" : "TrueType";
    else if (function isOpenTypeFile(e1) {
        return "OTTO" === bytesToString(e1.peekBytes(4));
    }(e1)) s = a ? "CIDFontType2" : "OpenType";
    else if (function isType1File(e1) {
        const t = e1.peekBytes(2);
        return 37 === t[0] && 33 === t[1] || 128 === t[0] && 1 === t[1];
    }(e1)) s = a ? "CIDFontType0" : "MMType1" === t ? "MMType1" : "Type1";
    else if (function isCFFFile(e1) {
        const t = e1.peekBytes(4);
        return t[0] >= 1 && t[3] >= 1 && t[3] <= 4;
    }(e1)) if (a) {
        s = "CIDFontType0";
        r = "CIDFontType0C";
    } else {
        s = "MMType1" === t ? "MMType1" : "Type1";
        r = "Type1C";
    }
    else {
        warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
        s = t;
        r = i;
    }
    return [
        s,
        r
    ];
}
function applyStandardFontGlyphMap(e1, t) {
    for(const i in t)e1[+i] = t[i];
}
function buildToFontChar(e1, t, i) {
    const a = [];
    let s;
    for(let i = 0, r = e1.length; i < r; i++){
        s = getUnicodeForGlyph(e1[i], t);
        -1 !== s && (a[i] = s);
    }
    for(const e1 in i){
        s = getUnicodeForGlyph(i[e1], t);
        -1 !== s && (a[+e1] = s);
    }
    return a;
}
function isMacNameRecord(e1) {
    return 1 === e1.platform && 0 === e1.encoding && 0 === e1.language;
}
function isWinNameRecord(e1) {
    return 3 === e1.platform && 1 === e1.encoding && 1033 === e1.language;
}
function convertCidString(e1, t, i = !1) {
    switch(t.length){
        case 1:
            return t.charCodeAt(0);
        case 2:
            return t.charCodeAt(0) << 8 | t.charCodeAt(1);
    }
    const a = `Unsupported CID string (charCode ${e1}): "${t}".`;
    if (i) throw new FormatError(a);
    warn(a);
    return t;
}
function adjustMapping(e1, t, i, a) {
    const s = Object.create(null), r = new Map, n = [], g = new Set;
    let o = 0;
    let c = ra[o][0], C = ra[o][1];
    for(const l in e1){
        let Q = e1[l];
        if (!t(Q)) continue;
        if (c > C) {
            o++;
            if (o >= ra.length) {
                warn("Ran out of space in font private use area.");
                break;
            }
            c = ra[o][0];
            C = ra[o][1];
        }
        const E = c++;
        0 === Q && (Q = i);
        let u = a.get(l);
        "string" == typeof u && (u = u.codePointAt(0));
        if (u && !(h = u, ra[0][0] <= h && h <= ra[0][1] || ra[1][0] <= h && h <= ra[1][1]) && !g.has(Q)) {
            r.set(u, Q);
            g.add(Q);
        }
        s[E] = Q;
        n[l] = E;
    }
    var h;
    return {
        toFontChar: n,
        charCodeToGlyphId: s,
        toUnicodeExtraMap: r,
        nextAvailableFontCharCode: c
    };
}
function createCmapTable(e1, t, i) {
    const a = function getRanges(e1, t, i) {
        const a = [];
        for(const t in e1)e1[t] >= i || a.push({
            fontCharCode: 0 | t,
            glyphId: e1[t]
        });
        if (t) for (const [e1, s] of t)s >= i || a.push({
            fontCharCode: e1,
            glyphId: s
        });
        0 === a.length && a.push({
            fontCharCode: 0,
            glyphId: 0
        });
        a.sort(function fontGetRangesSort(e1, t) {
            return e1.fontCharCode - t.fontCharCode;
        });
        const s = [], r = a.length;
        for(let e1 = 0; e1 < r;){
            const t = a[e1].fontCharCode, i = [
                a[e1].glyphId
            ];
            ++e1;
            let n = t;
            for(; e1 < r && n + 1 === a[e1].fontCharCode;){
                i.push(a[e1].glyphId);
                ++n;
                ++e1;
                if (65535 === n) break;
            }
            s.push([
                t,
                n,
                i
            ]);
        }
        return s;
    }(e1, t, i), s = a.at(-1)[1] > 65535 ? 2 : 1;
    let r, n, g, o, c = "\0\0" + string16(s) + "\0\0" + string32(4 + 8 * s);
    for(r = a.length - 1; r >= 0 && !(a[r][0] <= 65535); --r);
    const C = r + 1;
    a[r][0] < 65535 && 65535 === a[r][1] && (a[r][1] = 65534);
    const h = a[r][1] < 65535 ? 1 : 0, l = C + h, Q = OpenTypeFileBuilder.getSearchParams(l, 2);
    let E, u, d, f, p = "", m = "", y = "", w = "", D = "", b = 0;
    for(r = 0, n = C; r < n; r++){
        E = a[r];
        u = E[0];
        d = E[1];
        p += string16(u);
        m += string16(d);
        f = E[2];
        let e1 = !0;
        for(g = 1, o = f.length; g < o; ++g)if (f[g] !== f[g - 1] + 1) {
            e1 = !1;
            break;
        }
        if (e1) {
            y += string16(f[0] - u & 65535);
            w += string16(0);
        } else {
            const e1 = 2 * (l - r) + 2 * b;
            b += d - u + 1;
            y += string16(0);
            w += string16(e1);
            for(g = 0, o = f.length; g < o; ++g)D += string16(f[g]);
        }
    }
    if (h > 0) {
        m += "Ã¿Ã¿";
        p += "Ã¿Ã¿";
        y += "\0";
        w += "\0\0";
    }
    const F = "\0\0" + string16(2 * l) + string16(Q.range) + string16(Q.entry) + string16(Q.rangeShift) + m + "\0\0" + p + y + w + D;
    let S = "", k = "";
    if (s > 1) {
        c += "\0\0\n" + string32(4 + 8 * s + 4 + F.length);
        S = "";
        for(r = 0, n = a.length; r < n; r++){
            E = a[r];
            u = E[0];
            f = E[2];
            let e1 = f[0];
            for(g = 1, o = f.length; g < o; ++g)if (f[g] !== f[g - 1] + 1) {
                d = E[0] + g - 1;
                S += string32(u) + string32(d) + string32(e1);
                u = d + 1;
                e1 = f[g];
            }
            S += string32(u) + string32(E[1]) + string32(e1);
        }
        k = "\0\f\0\0" + string32(S.length + 16) + "\0\0\0\0" + string32(S.length / 12);
    }
    return c + "\0" + string16(F.length + 4) + F + k + S;
}
function createOS2Table(e1, t, i) {
    i ||= {
        unitsPerEm: 0,
        yMax: 0,
        yMin: 0,
        ascent: 0,
        descent: 0
    };
    let a = 0, s = 0, r = 0, n = 0, g = null, o = 0, c = -1;
    if (t) {
        for(let e1 in t){
            e1 |= 0;
            (g > e1 || !g) && (g = e1);
            o < e1 && (o = e1);
            c = getUnicodeRangeFor(e1, c);
            if (c < 32) a |= 1 << c;
            else if (c < 64) s |= 1 << c - 32;
            else if (c < 96) r |= 1 << c - 64;
            else {
                if (!(c < 123)) throw new FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
                n |= 1 << c - 96;
            }
        }
        o > 65535 && (o = 65535);
    } else {
        g = 0;
        o = 255;
    }
    const C = e1.bbox || [
        0,
        0,
        0,
        0
    ], h = i.unitsPerEm || (e1.fontMatrix ? 1 / Math.max(...e1.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), l = e1.ascentScaled ? 1 : h / na, Q = i.ascent || Math.round(l * (e1.ascent || C[3]));
    let E = i.descent || Math.round(l * (e1.descent || C[1]));
    E > 0 && e1.descent > 0 && C[1] < 0 && (E = -E);
    const u = i.yMax || Q, d = -i.yMin || -E;
    return "\0$Ã´\0\0\0ÂÂ»\0\0\0ÂÂÂ»\0\0Ã\x001\0\0\0\0" + String.fromCharCode(e1.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32(a) + string32(s) + string32(r) + string32(n) + "*21*" + string16(e1.italicAngle ? 1 : 0) + string16(g || e1.firstChar) + string16(o || e1.lastChar) + string16(Q) + string16(E) + "\0d" + string16(u) + string16(d) + "\0\0\0\0\0\0\0\0" + string16(e1.xHeight) + string16(e1.capHeight) + string16(0) + string16(g || e1.firstChar) + "\0";
}
function createPostTable(e1) {
    return "\0\0\0" + string32(Math.floor(65536 * e1.italicAngle)) + "\0\0\0\0" + string32(e1.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(e1) {
    return e1.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(e1, t) {
    t || (t = [
        [],
        []
    ]);
    const i = [
        t[0][0] || "Original licence",
        t[0][1] || e1,
        t[0][2] || "Unknown",
        t[0][3] || "uniqueID",
        t[0][4] || e1,
        t[0][5] || "Version 0.11",
        t[0][6] || createPostscriptName(e1),
        t[0][7] || "Unknown",
        t[0][8] || "Unknown",
        t[0][9] || "Unknown"
    ], a = [];
    let s, r, n, g, o;
    for(s = 0, r = i.length; s < r; s++){
        o = t[1][s] || i[s];
        const e1 = [];
        for(n = 0, g = o.length; n < g; n++)e1.push(string16(o.charCodeAt(n)));
        a.push(e1.join(""));
    }
    const c = [
        i,
        a
    ], C = [
        "\0",
        "\0"
    ], h = [
        "\0\0",
        "\0"
    ], l = [
        "\0\0",
        "\t"
    ], Q = i.length * C.length;
    let E = "\0\0" + string16(Q) + string16(12 * Q + 6), u = 0;
    for(s = 0, r = C.length; s < r; s++){
        const e1 = c[s];
        for(n = 0, g = e1.length; n < g; n++){
            o = e1[n];
            E += C[s] + h[s] + l[s] + string16(n) + string16(o.length) + string16(u);
            u += o.length;
        }
    }
    E += i.join("") + a.join("");
    return E;
}
class Font {
    constructor(e1, t, i){
        this.name = e1;
        this.psName = null;
        this.mimetype = null;
        this.disableFontFace = !1;
        this.loadedName = i.loadedName;
        this.isType3Font = i.isType3Font;
        this.missingFile = !1;
        this.cssFontInfo = i.cssFontInfo;
        this._charsCache = Object.create(null);
        this._glyphCache = Object.create(null);
        let a = !!(i.flags & Gi);
        if (!a && !i.isSimulatedFlags) {
            const t = e1.replaceAll(/[,_]/g, "-").split("-", 1)[0], i = Ti();
            for (const e1 of t.split("+"))if (i[e1]) {
                a = !0;
                break;
            }
        }
        this.isSerifFont = a;
        this.isSymbolicFont = !!(i.flags & Mi);
        this.isMonospace = !!(i.flags & Ni);
        let { type: s, subtype: r } = i;
        this.type = s;
        this.subtype = r;
        this.systemFontInfo = i.systemFontInfo;
        const n = e1.match(/^InvalidPDFjsFont_(.*)_\d+$/);
        this.isInvalidPDFjsFont = !!n;
        this.isInvalidPDFjsFont ? this.fallbackName = n[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif";
        if (this.systemFontInfo?.guessFallback) {
            this.systemFontInfo.guessFallback = !1;
            this.systemFontInfo.css += `,${this.fallbackName}`;
        }
        this.differences = i.differences;
        this.widths = i.widths;
        this.defaultWidth = i.defaultWidth;
        this.composite = i.composite;
        this.cMap = i.cMap;
        this.capHeight = i.capHeight / na;
        this.ascent = i.ascent / na;
        this.descent = i.descent / na;
        this.lineHeight = this.ascent - this.descent;
        this.fontMatrix = i.fontMatrix;
        this.bbox = i.bbox;
        this.defaultEncoding = i.defaultEncoding;
        this.toUnicode = i.toUnicode;
        this.toFontChar = [];
        if ("Type3" === i.type) {
            for(let e1 = 0; e1 < 256; e1++)this.toFontChar[e1] = this.differences[e1] || i.defaultEncoding[e1];
            return;
        }
        this.cidEncoding = i.cidEncoding || "";
        this.vertical = !!i.vertical;
        if (this.vertical) {
            this.vmetrics = i.vmetrics;
            this.defaultVMetrics = i.defaultVMetrics;
        }
        if (!t || t.isEmpty) {
            t && warn('Font file is empty in "' + e1 + '" (' + this.loadedName + ")");
            this.fallbackToSystemFont(i);
            return;
        }
        [s, r] = getFontFileType(t, i);
        s === this.type && r === this.subtype || info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s}/${r}.`);
        let g;
        try {
            switch(s){
                case "MMType1":
                    info("MMType1 font (" + e1 + "), falling back to Type1.");
                case "Type1":
                case "CIDFontType0":
                    this.mimetype = "font/opentype";
                    const a = "Type1C" === r || "CIDFontType0C" === r ? new CFFFont(t, i) : new Type1Font(e1, t, i);
                    adjustWidths(i);
                    g = this.convert(e1, a, i);
                    break;
                case "OpenType":
                case "TrueType":
                case "CIDFontType2":
                    this.mimetype = "font/opentype";
                    g = this.checkAndRepair(e1, t, i);
                    if (this.isOpenType) {
                        adjustWidths(i);
                        s = "OpenType";
                    }
                    break;
                default:
                    throw new FormatError(`Font ${s} is not supported`);
            }
        } catch (e1) {
            warn(e1);
            this.fallbackToSystemFont(i);
            return;
        }
        amendFallbackToUnicode(i);
        this.data = g;
        this.type = s;
        this.subtype = r;
        this.fontMatrix = i.fontMatrix;
        this.widths = i.widths;
        this.defaultWidth = i.defaultWidth;
        this.toUnicode = i.toUnicode;
        this.seacMap = i.seacMap;
    }
    get renderer() {
        return shadow(this, "renderer", FontRendererFactory.create(this, Ri));
    }
    exportData(e1 = !1) {
        const t = e1 ? [
            ...ga,
            ...oa
        ] : ga, i = Object.create(null);
        let a, s;
        for (a of t){
            s = this[a];
            void 0 !== s && (i[a] = s);
        }
        return i;
    }
    fallbackToSystemFont(e1) {
        this.missingFile = !0;
        const { name: t, type: i } = this;
        let a = normalizeFontName(t);
        const s = Yi(), r = Ki(), n = !!s[a], g = !(!r[a] || !s[r[a]]);
        a = s[a] || r[a] || a;
        const o = Xi()[a];
        if (o) {
            isNaN(this.ascent) && (this.ascent = o.ascent / na);
            isNaN(this.descent) && (this.descent = o.descent / na);
            isNaN(this.capHeight) && (this.capHeight = o.capHeight / na);
        }
        this.bold = /bold/gi.test(a);
        this.italic = /oblique|italic/gi.test(a);
        this.black = /Black/g.test(t);
        const c = /Narrow/g.test(t);
        this.remeasure = (!n || c) && Object.keys(this.widths).length > 0;
        if ((n || g) && "CIDFontType2" === i && this.cidEncoding.startsWith("Identity-")) {
            const i = e1.cidToGidMap, a = [];
            applyStandardFontGlyphMap(a, Oi());
            /Arial-?Black/i.test(t) ? applyStandardFontGlyphMap(a, Pi()) : /Calibri/i.test(t) && applyStandardFontGlyphMap(a, Wi());
            if (i) {
                for(const e1 in a){
                    const t = a[e1];
                    void 0 !== i[t] && (a[+e1] = i[t]);
                }
                i.length !== this.toUnicode.length && e1.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function(e1, t) {
                    const s = a[e1];
                    void 0 === i[s] && (a[+e1] = t);
                });
            }
            this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(e1, t) {
                a[+e1] = t;
            });
            this.toFontChar = a;
            this.toUnicode = new ToUnicodeMap(a);
        } else if (/Symbol/i.test(a)) this.toFontChar = buildToFontChar(Bi, wi(), this.differences);
        else if (/Dingbats/i.test(a)) this.toFontChar = buildToFontChar(Qi, Di(), this.differences);
        else if (n || g) {
            const e1 = buildToFontChar(this.defaultEncoding, wi(), this.differences);
            "CIDFontType2" !== i || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(t, i) {
                e1[+t] = i;
            });
            this.toFontChar = e1;
        } else {
            const e1 = wi(), i = [];
            this.toUnicode.forEach((t, a)=>{
                if (!this.composite) {
                    const i = getUnicodeForGlyph(this.differences[t] || this.defaultEncoding[t], e1);
                    -1 !== i && (a = i);
                }
                i[+t] = a;
            });
            this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t) && applyStandardFontGlyphMap(i, Oi());
            this.toFontChar = i;
        }
        amendFallbackToUnicode(e1);
        this.loadedName = a.split("-", 1)[0];
    }
    checkAndRepair(e1, t, i) {
        const a = [
            "OS/2",
            "cmap",
            "head",
            "hhea",
            "hmtx",
            "maxp",
            "name",
            "post",
            "loca",
            "glyf",
            "fpgm",
            "prep",
            "cvt ",
            "CFF "
        ];
        function readTables(e1, t) {
            const i = Object.create(null);
            i["OS/2"] = null;
            i.cmap = null;
            i.head = null;
            i.hhea = null;
            i.hmtx = null;
            i.maxp = null;
            i.name = null;
            i.post = null;
            for(let s = 0; s < t; s++){
                const t = readTableEntry(e1);
                a.includes(t.tag) && 0 !== t.length && (i[t.tag] = t);
            }
            return i;
        }
        function readTableEntry(e1) {
            const t = e1.getString(4), i = e1.getInt32() >>> 0, a = e1.getInt32() >>> 0, s = e1.getInt32() >>> 0, r = e1.pos;
            e1.pos = e1.start || 0;
            e1.skip(a);
            const n = e1.getBytes(s);
            e1.pos = r;
            if ("head" === t) {
                n[8] = n[9] = n[10] = n[11] = 0;
                n[17] |= 32;
            }
            return {
                tag: t,
                checksum: i,
                length: s,
                offset: a,
                data: n
            };
        }
        function readOpenTypeHeader(e1) {
            return {
                version: e1.getString(4),
                numTables: e1.getUint16(),
                searchRange: e1.getUint16(),
                entrySelector: e1.getUint16(),
                rangeShift: e1.getUint16()
            };
        }
        function sanitizeGlyph(e1, t, i, a, s, r) {
            const n = {
                length: 0,
                sizeOfInstructions: 0
            };
            if (t < 0 || t >= e1.length || i > e1.length || i - t <= 12) return n;
            const g = e1.subarray(t, i), o = signedInt16(g[2], g[3]), c = signedInt16(g[4], g[5]), C = signedInt16(g[6], g[7]), h = signedInt16(g[8], g[9]);
            if (o > C) {
                writeSignedInt16(g, 2, C);
                writeSignedInt16(g, 6, o);
            }
            if (c > h) {
                writeSignedInt16(g, 4, h);
                writeSignedInt16(g, 8, c);
            }
            const l = signedInt16(g[0], g[1]);
            if (l < 0) {
                if (l < -1) return n;
                a.set(g, s);
                n.length = g.length;
                return n;
            }
            let Q, E = 10, u = 0;
            for(Q = 0; Q < l; Q++){
                u = (g[E] << 8 | g[E + 1]) + 1;
                E += 2;
            }
            const d = E, f = g[E] << 8 | g[E + 1];
            n.sizeOfInstructions = f;
            E += 2 + f;
            const p = E;
            let m = 0;
            for(Q = 0; Q < u; Q++){
                const e1 = g[E++];
                192 & e1 && (g[E - 1] = 63 & e1);
                let t = 2;
                2 & e1 ? t = 1 : 16 & e1 && (t = 0);
                let i = 2;
                4 & e1 ? i = 1 : 32 & e1 && (i = 0);
                const a = t + i;
                m += a;
                if (8 & e1) {
                    const e1 = g[E++];
                    0 === e1 && (g[E - 1] ^= 8);
                    Q += e1;
                    m += e1 * a;
                }
            }
            if (0 === m) return n;
            let y = E + m;
            if (y > g.length) return n;
            if (!r && f > 0) {
                a.set(g.subarray(0, d), s);
                a.set([
                    0,
                    0
                ], s + d);
                a.set(g.subarray(p, y), s + d + 2);
                y -= f;
                g.length - y > 3 && (y = y + 3 & -4);
                n.length = y;
                return n;
            }
            if (g.length - y > 3) {
                y = y + 3 & -4;
                a.set(g.subarray(0, y), s);
                n.length = y;
                return n;
            }
            a.set(g, s);
            n.length = g.length;
            return n;
        }
        function readNameTable(e1) {
            const i = (t.start || 0) + e1.offset;
            t.pos = i;
            const a = [
                [],
                []
            ], s = [], r = e1.length, n = i + r;
            if (0 !== t.getUint16() || r < 6) return [
                a,
                s
            ];
            const g = t.getUint16(), o = t.getUint16();
            let c, C;
            for(c = 0; c < g && t.pos + 12 <= n; c++){
                const e1 = {
                    platform: t.getUint16(),
                    encoding: t.getUint16(),
                    language: t.getUint16(),
                    name: t.getUint16(),
                    length: t.getUint16(),
                    offset: t.getUint16()
                };
                (isMacNameRecord(e1) || isWinNameRecord(e1)) && s.push(e1);
            }
            for(c = 0, C = s.length; c < C; c++){
                const e1 = s[c];
                if (e1.length <= 0) continue;
                const r = i + o + e1.offset;
                if (r + e1.length > n) continue;
                t.pos = r;
                const g = e1.name;
                if (e1.encoding) {
                    let i = "";
                    for(let a = 0, s = e1.length; a < s; a += 2)i += String.fromCharCode(t.getUint16());
                    a[1][g] = i;
                } else a[0][g] = t.getString(e1.length);
            }
            return [
                a,
                s
            ];
        }
        const s = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            -2,
            -2,
            -2,
            -2,
            0,
            0,
            -2,
            -5,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            0,
            -1,
            0,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -999,
            0,
            1,
            0,
            -1,
            -2,
            0,
            -1,
            -2,
            -1,
            -1,
            0,
            -1,
            -1,
            0,
            0,
            -999,
            -999,
            -1,
            -1,
            -1,
            -1,
            -2,
            -999,
            -2,
            -2,
            -999,
            0,
            -2,
            -2,
            0,
            0,
            -2,
            0,
            -2,
            0,
            0,
            0,
            -2,
            -1,
            -1,
            1,
            1,
            0,
            0,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            0,
            -1,
            0,
            -1,
            -1,
            0,
            -999,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            -2,
            -999,
            -999,
            -999,
            -999,
            -999,
            -1,
            -1,
            -2,
            -2,
            0,
            0,
            0,
            0,
            -1,
            -1,
            -999,
            -2,
            -2,
            0,
            0,
            -1,
            -2,
            -2,
            0,
            0,
            0,
            -1,
            -1,
            -1,
            -2
        ];
        function sanitizeTTProgram(e1, t) {
            let i, a, r, n, g, o = e1.data, c = 0, C = 0, h = 0;
            const l = [], Q = [], E = [];
            let u = t.tooComplexToFollowFunctions, d = !1, f = 0, p = 0;
            for(let e1 = o.length; c < e1;){
                const e1 = o[c++];
                if (64 === e1) {
                    a = o[c++];
                    if (d || p) c += a;
                    else for(i = 0; i < a; i++)l.push(o[c++]);
                } else if (65 === e1) {
                    a = o[c++];
                    if (d || p) c += 2 * a;
                    else for(i = 0; i < a; i++){
                        r = o[c++];
                        l.push(r << 8 | o[c++]);
                    }
                } else if (176 == (248 & e1)) {
                    a = e1 - 176 + 1;
                    if (d || p) c += a;
                    else for(i = 0; i < a; i++)l.push(o[c++]);
                } else if (184 == (248 & e1)) {
                    a = e1 - 184 + 1;
                    if (d || p) c += 2 * a;
                    else for(i = 0; i < a; i++){
                        r = o[c++];
                        l.push(signedInt16(r, o[c++]));
                    }
                } else if (43 !== e1 || u) if (44 !== e1 || u) {
                    if (45 === e1) if (d) {
                        d = !1;
                        C = c;
                    } else {
                        g = Q.pop();
                        if (!g) {
                            warn("TT: ENDF bad stack");
                            t.hintsValid = !1;
                            return;
                        }
                        n = E.pop();
                        o = g.data;
                        c = g.i;
                        t.functionsStackDeltas[n] = l.length - g.stackTop;
                    }
                    else if (137 === e1) {
                        if (d || p) {
                            warn("TT: nested IDEFs not allowed");
                            u = !0;
                        }
                        d = !0;
                        h = c;
                    } else if (88 === e1) ++f;
                    else if (27 === e1) p = f;
                    else if (89 === e1) {
                        p === f && (p = 0);
                        --f;
                    } else if (28 === e1 && !d && !p) {
                        const e1 = l.at(-1);
                        e1 > 0 && (c += e1 - 1);
                    }
                } else {
                    if (d || p) {
                        warn("TT: nested FDEFs not allowed");
                        u = !0;
                    }
                    d = !0;
                    h = c;
                    n = l.pop();
                    t.functionsDefined[n] = {
                        data: o,
                        i: c
                    };
                }
                else if (!d && !p) {
                    n = l.at(-1);
                    if (isNaN(n)) info("TT: CALL empty stack (or invalid entry).");
                    else {
                        t.functionsUsed[n] = !0;
                        if (n in t.functionsStackDeltas) {
                            const e1 = l.length + t.functionsStackDeltas[n];
                            if (e1 < 0) {
                                warn("TT: CALL invalid functions stack delta.");
                                t.hintsValid = !1;
                                return;
                            }
                            l.length = e1;
                        } else if (n in t.functionsDefined && !E.includes(n)) {
                            Q.push({
                                data: o,
                                i: c,
                                stackTop: l.length - 1
                            });
                            E.push(n);
                            g = t.functionsDefined[n];
                            if (!g) {
                                warn("TT: CALL non-existent function");
                                t.hintsValid = !1;
                                return;
                            }
                            o = g.data;
                            c = g.i;
                        }
                    }
                }
                if (!d && !p) {
                    let t = 0;
                    e1 <= 142 ? t = s[e1] : e1 >= 192 && e1 <= 223 ? t = -1 : e1 >= 224 && (t = -2);
                    if (e1 >= 113 && e1 <= 117) {
                        a = l.pop();
                        isNaN(a) || (t = 2 * -a);
                    }
                    for(; t < 0 && l.length > 0;){
                        l.pop();
                        t++;
                    }
                    for(; t > 0;){
                        l.push(NaN);
                        t--;
                    }
                }
            }
            t.tooComplexToFollowFunctions = u;
            const m = [
                o
            ];
            c > o.length && m.push(new Uint8Array(c - o.length));
            if (h > C) {
                warn("TT: complementing a missing function tail");
                m.push(new Uint8Array([
                    34,
                    45
                ]));
            }
            !function foldTTTable(e1, t) {
                if (t.length > 1) {
                    let i, a, s = 0;
                    for(i = 0, a = t.length; i < a; i++)s += t[i].length;
                    s = s + 3 & -4;
                    const r = new Uint8Array(s);
                    let n = 0;
                    for(i = 0, a = t.length; i < a; i++){
                        r.set(t[i], n);
                        n += t[i].length;
                    }
                    e1.data = r;
                    e1.length = s;
                }
            }(e1, m);
        }
        let r, n, g, o;
        if (isTrueTypeCollectionFile(t = new Stream(new Uint8Array(t.getBytes())))) {
            const e1 = function readTrueTypeCollectionData(e1, t) {
                const { numFonts: i, offsetTable: a } = function readTrueTypeCollectionHeader(e1) {
                    const t = e1.getString(4);
                    assert("ttcf" === t, "Must be a TrueType Collection font.");
                    const i = e1.getUint16(), a = e1.getUint16(), s = e1.getInt32() >>> 0, r = [];
                    for(let t = 0; t < s; t++)r.push(e1.getInt32() >>> 0);
                    const n = {
                        ttcTag: t,
                        majorVersion: i,
                        minorVersion: a,
                        numFonts: s,
                        offsetTable: r
                    };
                    switch(i){
                        case 1:
                            return n;
                        case 2:
                            n.dsigTag = e1.getInt32() >>> 0;
                            n.dsigLength = e1.getInt32() >>> 0;
                            n.dsigOffset = e1.getInt32() >>> 0;
                            return n;
                    }
                    throw new FormatError(`Invalid TrueType Collection majorVersion: ${i}.`);
                }(e1), s = t.split("+");
                let r;
                for(let n = 0; n < i; n++){
                    e1.pos = (e1.start || 0) + a[n];
                    const i = readOpenTypeHeader(e1), g = readTables(e1, i.numTables);
                    if (!g.name) throw new FormatError('TrueType Collection font must contain a "name" table.');
                    const [o] = readNameTable(g.name);
                    for(let e1 = 0, a = o.length; e1 < a; e1++)for(let a = 0, n = o[e1].length; a < n; a++){
                        const n = o[e1][a]?.replaceAll(/\s/g, "");
                        if (n) {
                            if (n === t) return {
                                header: i,
                                tables: g
                            };
                            if (!(s.length < 2)) for (const e1 of s)n === e1 && (r = {
                                name: e1,
                                header: i,
                                tables: g
                            });
                        }
                    }
                }
                if (r) {
                    warn(`TrueType Collection does not contain "${t}" font, falling back to "${r.name}" font instead.`);
                    return {
                        header: r.header,
                        tables: r.tables
                    };
                }
                throw new FormatError(`TrueType Collection does not contain "${t}" font.`);
            }(t, this.name);
            r = e1.header;
            n = e1.tables;
        } else {
            r = readOpenTypeHeader(t);
            n = readTables(t, r.numTables);
        }
        const c = !n["CFF "];
        if (c) {
            if (!n.loca) throw new FormatError('Required "loca" table is not found');
            if (!n.glyf) {
                warn('Required "glyf" table is not found -- trying to recover.');
                n.glyf = {
                    tag: "glyf",
                    data: new Uint8Array(0)
                };
            }
            this.isOpenType = !1;
        } else {
            const t = i.composite && (i.cidToGidMap?.length > 0 || !(i.cMap instanceof IdentityCMap));
            if ("OTTO" === r.version && !t || !n.head || !n.hhea || !n.maxp || !n.post) {
                o = new Stream(n["CFF "].data);
                g = new CFFFont(o, i);
                adjustWidths(i);
                return this.convert(e1, g, i);
            }
            delete n.glyf;
            delete n.loca;
            delete n.fpgm;
            delete n.prep;
            delete n["cvt "];
            this.isOpenType = !0;
        }
        if (!n.maxp) throw new FormatError('Required "maxp" table is not found');
        t.pos = (t.start || 0) + n.maxp.offset;
        let C = t.getInt32();
        const h = t.getUint16();
        if (65536 !== C && 20480 !== C) {
            if (6 === n.maxp.length) C = 20480;
            else {
                if (!(n.maxp.length >= 32)) throw new FormatError('"maxp" table has a wrong version number');
                C = 65536;
            }
            !function writeUint32(e1, t, i) {
                e1[t + 3] = 255 & i;
                e1[t + 2] = i >>> 8;
                e1[t + 1] = i >>> 16;
                e1[t] = i >>> 24;
            }(n.maxp.data, 0, C);
        }
        if (i.scaleFactors?.length === h && c) {
            const { scaleFactors: e1 } = i, t = int16(n.head.data[50], n.head.data[51]), a = new GlyfTable({
                glyfTable: n.glyf.data,
                isGlyphLocationsLong: t,
                locaTable: n.loca.data,
                numGlyphs: h
            });
            a.scale(e1);
            const { glyf: s, loca: r, isLocationLong: g } = a.write();
            n.glyf.data = s;
            n.loca.data = r;
            if (g !== !!t) {
                n.head.data[50] = 0;
                n.head.data[51] = g ? 1 : 0;
            }
            const o = n.hmtx.data;
            for(let t = 0; t < h; t++){
                const i = 4 * t, a = Math.round(e1[t] * int16(o[i], o[i + 1]));
                o[i] = a >> 8 & 255;
                o[i + 1] = 255 & a;
                writeSignedInt16(o, i + 2, Math.round(e1[t] * signedInt16(o[i + 2], o[i + 3])));
            }
        }
        let l = h + 1, Q = !0;
        if (l > 65535) {
            Q = !1;
            l = h;
            warn("Not enough space in glyfs to duplicate first glyph.");
        }
        let E = 0, u = 0;
        if (C >= 65536 && n.maxp.length >= 32) {
            t.pos += 8;
            if (t.getUint16() > 2) {
                n.maxp.data[14] = 0;
                n.maxp.data[15] = 2;
            }
            t.pos += 4;
            E = t.getUint16();
            t.pos += 4;
            u = t.getUint16();
        }
        n.maxp.data[4] = l >> 8;
        n.maxp.data[5] = 255 & l;
        const d = function sanitizeTTPrograms(e1, t, i, a) {
            const s = {
                functionsDefined: [],
                functionsUsed: [],
                functionsStackDeltas: [],
                tooComplexToFollowFunctions: !1,
                hintsValid: !0
            };
            e1 && sanitizeTTProgram(e1, s);
            t && sanitizeTTProgram(t, s);
            e1 && function checkInvalidFunctions(e1, t) {
                if (!e1.tooComplexToFollowFunctions) if (e1.functionsDefined.length > t) {
                    warn("TT: more functions defined than expected");
                    e1.hintsValid = !1;
                } else for(let i = 0, a = e1.functionsUsed.length; i < a; i++){
                    if (i > t) {
                        warn("TT: invalid function id: " + i);
                        e1.hintsValid = !1;
                        return;
                    }
                    if (e1.functionsUsed[i] && !e1.functionsDefined[i]) {
                        warn("TT: undefined function: " + i);
                        e1.hintsValid = !1;
                        return;
                    }
                }
            }(s, a);
            if (i && 1 & i.length) {
                const e1 = new Uint8Array(i.length + 1);
                e1.set(i.data);
                i.data = e1;
            }
            return s.hintsValid;
        }(n.fpgm, n.prep, n["cvt "], E);
        if (!d) {
            delete n.fpgm;
            delete n.prep;
            delete n["cvt "];
        }
        !function sanitizeMetrics(e1, t, i, a, s, r) {
            if (!t) {
                i && (i.data = null);
                return;
            }
            e1.pos = (e1.start || 0) + t.offset;
            e1.pos += 4;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            const n = e1.getUint16();
            e1.pos += 8;
            e1.pos += 2;
            let g = e1.getUint16();
            if (0 !== n) {
                if (!(2 & int16(a.data[44], a.data[45]))) {
                    t.data[22] = 0;
                    t.data[23] = 0;
                }
            }
            if (g > s) {
                info(`The numOfMetrics (${g}) should not be greater than the numGlyphs (${s}).`);
                g = s;
                t.data[34] = (65280 & g) >> 8;
                t.data[35] = 255 & g;
            }
            const o = s - g - (i.length - 4 * g >> 1);
            if (o > 0) {
                const e1 = new Uint8Array(i.length + 2 * o);
                e1.set(i.data);
                if (r) {
                    e1[i.length] = i.data[2];
                    e1[i.length + 1] = i.data[3];
                }
                i.data = e1;
            }
        }(t, n.hhea, n.hmtx, n.head, l, Q);
        if (!n.head) throw new FormatError('Required "head" table is not found');
        !function sanitizeHead(e1, t, i) {
            const a = e1.data, s = function int32(e1, t, i, a) {
                return (e1 << 24) + (t << 16) + (i << 8) + a;
            }(a[0], a[1], a[2], a[3]);
            if (s >> 16 != 1) {
                info("Attempting to fix invalid version in head table: " + s);
                a[0] = 0;
                a[1] = 1;
                a[2] = 0;
                a[3] = 0;
            }
            const r = int16(a[50], a[51]);
            if (r < 0 || r > 1) {
                info("Attempting to fix invalid indexToLocFormat in head table: " + r);
                const e1 = t + 1;
                if (i === e1 << 1) {
                    a[50] = 0;
                    a[51] = 0;
                } else {
                    if (i !== e1 << 2) throw new FormatError("Could not fix indexToLocFormat: " + r);
                    a[50] = 0;
                    a[51] = 1;
                }
            }
        }(n.head, h, c ? n.loca.length : 0);
        let f = Object.create(null);
        if (c) {
            const e1 = int16(n.head.data[50], n.head.data[51]), t = function sanitizeGlyphLocations(e1, t, i, a, s, r, n) {
                let g, o, c;
                if (a) {
                    g = 4;
                    o = function fontItemDecodeLong(e1, t) {
                        return e1[t] << 24 | e1[t + 1] << 16 | e1[t + 2] << 8 | e1[t + 3];
                    };
                    c = function fontItemEncodeLong(e1, t, i) {
                        e1[t] = i >>> 24 & 255;
                        e1[t + 1] = i >> 16 & 255;
                        e1[t + 2] = i >> 8 & 255;
                        e1[t + 3] = 255 & i;
                    };
                } else {
                    g = 2;
                    o = function fontItemDecode(e1, t) {
                        return e1[t] << 9 | e1[t + 1] << 1;
                    };
                    c = function fontItemEncode(e1, t, i) {
                        e1[t] = i >> 9 & 255;
                        e1[t + 1] = i >> 1 & 255;
                    };
                }
                const C = r ? i + 1 : i, h = g * (1 + C), l = new Uint8Array(h);
                l.set(e1.data.subarray(0, h));
                e1.data = l;
                const Q = t.data, E = Q.length, u = new Uint8Array(E);
                let d, f;
                const p = [];
                for(d = 0, f = 0; d < i + 1; d++, f += g){
                    let e1 = o(l, f);
                    e1 > E && (e1 = E);
                    p.push({
                        index: d,
                        offset: e1,
                        endOffset: 0
                    });
                }
                p.sort((e1, t)=>e1.offset - t.offset);
                for(d = 0; d < i; d++)p[d].endOffset = p[d + 1].offset;
                p.sort((e1, t)=>e1.index - t.index);
                for(d = 0; d < i; d++){
                    const { offset: e1, endOffset: t } = p[d];
                    if (0 !== e1 || 0 !== t) break;
                    const i = p[d + 1].offset;
                    if (0 !== i) {
                        p[d].endOffset = i;
                        break;
                    }
                }
                const m = p.at(-2);
                0 !== m.offset && 0 === m.endOffset && (m.endOffset = E);
                const y = Object.create(null);
                let w = 0;
                c(l, 0, w);
                for(d = 0, f = g; d < i; d++, f += g){
                    const e1 = sanitizeGlyph(Q, p[d].offset, p[d].endOffset, u, w, s), t = e1.length;
                    0 === t && (y[d] = !0);
                    e1.sizeOfInstructions > n && (n = e1.sizeOfInstructions);
                    w += t;
                    c(l, f, w);
                }
                if (0 === w) {
                    const e1 = new Uint8Array([
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        49,
                        0
                    ]);
                    for(d = 0, f = g; d < C; d++, f += g)c(l, f, e1.length);
                    t.data = e1;
                } else if (r) {
                    const i = o(l, g);
                    if (u.length > i + w) t.data = u.subarray(0, i + w);
                    else {
                        t.data = new Uint8Array(i + w);
                        t.data.set(u.subarray(0, w));
                    }
                    t.data.set(u.subarray(0, i), w);
                    c(e1.data, l.length - g, w + i);
                } else t.data = u.subarray(0, w);
                return {
                    missingGlyphs: y,
                    maxSizeOfInstructions: n
                };
            }(n.loca, n.glyf, h, e1, d, Q, u);
            f = t.missingGlyphs;
            if (C >= 65536 && n.maxp.length >= 32) {
                n.maxp.data[26] = t.maxSizeOfInstructions >> 8;
                n.maxp.data[27] = 255 & t.maxSizeOfInstructions;
            }
        }
        if (!n.hhea) throw new FormatError('Required "hhea" table is not found');
        if (0 === n.hhea.data[10] && 0 === n.hhea.data[11]) {
            n.hhea.data[10] = 255;
            n.hhea.data[11] = 255;
        }
        const p = {
            unitsPerEm: int16(n.head.data[18], n.head.data[19]),
            yMax: signedInt16(n.head.data[42], n.head.data[43]),
            yMin: signedInt16(n.head.data[38], n.head.data[39]),
            ascent: signedInt16(n.hhea.data[4], n.hhea.data[5]),
            descent: signedInt16(n.hhea.data[6], n.hhea.data[7]),
            lineGap: signedInt16(n.hhea.data[8], n.hhea.data[9])
        };
        this.ascent = p.ascent / p.unitsPerEm;
        this.descent = p.descent / p.unitsPerEm;
        this.lineGap = p.lineGap / p.unitsPerEm;
        if (this.cssFontInfo?.lineHeight) {
            this.lineHeight = this.cssFontInfo.metrics.lineHeight;
            this.lineGap = this.cssFontInfo.metrics.lineGap;
        } else this.lineHeight = this.ascent - this.descent + this.lineGap;
        n.post && function readPostScriptTable(e1, i, a) {
            const s = (t.start || 0) + e1.offset;
            t.pos = s;
            const r = s + e1.length, n = t.getInt32();
            t.skip(28);
            let g, o, c = !0;
            switch(n){
                case 65536:
                    g = Hi;
                    break;
                case 131072:
                    const e2 = t.getUint16();
                    if (e2 !== a) {
                        c = !1;
                        break;
                    }
                    const s1 = [];
                    for(o = 0; o < e2; ++o){
                        const e1 = t.getUint16();
                        if (e1 >= 32768) {
                            c = !1;
                            break;
                        }
                        s1.push(e1);
                    }
                    if (!c) break;
                    const C = [], h = [];
                    for(; t.pos < r;){
                        const e1 = t.getByte();
                        h.length = e1;
                        for(o = 0; o < e1; ++o)h[o] = String.fromCharCode(t.getByte());
                        C.push(h.join(""));
                    }
                    g = [];
                    for(o = 0; o < e2; ++o){
                        const e1 = s1[o];
                        e1 < 258 ? g.push(Hi[e1]) : g.push(C[e1 - 258]);
                    }
                    break;
                case 196608:
                    break;
                default:
                    warn("Unknown/unsupported post table version " + n);
                    c = !1;
                    i.defaultEncoding && (g = i.defaultEncoding);
            }
            i.glyphNames = g;
            return c;
        }(n.post, i, h);
        n.post = {
            tag: "post",
            data: createPostTable(i)
        };
        const m = Object.create(null);
        function hasGlyph(e1) {
            return !f[e1];
        }
        if (i.composite) {
            const e1 = i.cidToGidMap || [], t = 0 === e1.length;
            i.cMap.forEach(function(i, a) {
                "string" == typeof a && (a = convertCidString(i, a, !0));
                if (a > 65535) throw new FormatError("Max size of CID is 65,535");
                let s = -1;
                t ? s = a : void 0 !== e1[a] && (s = e1[a]);
                s >= 0 && s < h && hasGlyph(s) && (m[i] = s);
            });
        } else {
            const e1 = function readCmapTable(e1, t, i, a) {
                if (!e1) {
                    warn("No cmap table available.");
                    return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: !1
                    };
                }
                let s, r = (t.start || 0) + e1.offset;
                t.pos = r;
                t.skip(2);
                const n = t.getUint16();
                let g, o = !1;
                for(let e1 = 0; e1 < n; e1++){
                    const s = t.getUint16(), r = t.getUint16(), c = t.getInt32() >>> 0;
                    let C = !1;
                    if (g?.platformId !== s || g?.encodingId !== r) {
                        if (0 !== s || 0 !== r && 1 !== r && 3 !== r) if (1 === s && 0 === r) C = !0;
                        else if (3 !== s || 1 !== r || !a && g) {
                            if (i && 3 === s && 0 === r) {
                                C = !0;
                                let i = !0;
                                if (e1 < n - 1) {
                                    const e1 = t.peekBytes(2);
                                    int16(e1[0], e1[1]) < s && (i = !1);
                                }
                                i && (o = !0);
                            }
                        } else {
                            C = !0;
                            i || (o = !0);
                        }
                        else C = !0;
                        C && (g = {
                            platformId: s,
                            encodingId: r,
                            offset: c
                        });
                        if (o) break;
                    }
                }
                g && (t.pos = r + g.offset);
                if (!g || -1 === t.peekByte()) {
                    warn("Could not find a preferred cmap table.");
                    return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: !1
                    };
                }
                const c = t.getUint16();
                let C = !1;
                const h = [];
                let l, Q;
                if (0 === c) {
                    t.skip(4);
                    for(l = 0; l < 256; l++){
                        const e1 = t.getByte();
                        e1 && h.push({
                            charCode: l,
                            glyphId: e1
                        });
                    }
                    C = !0;
                } else if (2 === c) {
                    t.skip(4);
                    const e1 = [];
                    let i = 0;
                    for(let a = 0; a < 256; a++){
                        const a = t.getUint16() >> 3;
                        e1.push(a);
                        i = Math.max(a, i);
                    }
                    const a = [];
                    for(let e1 = 0; e1 <= i; e1++)a.push({
                        firstCode: t.getUint16(),
                        entryCount: t.getUint16(),
                        idDelta: signedInt16(t.getByte(), t.getByte()),
                        idRangePos: t.pos + t.getUint16()
                    });
                    for(let i = 0; i < 256; i++)if (0 === e1[i]) {
                        t.pos = a[0].idRangePos + 2 * i;
                        Q = t.getUint16();
                        h.push({
                            charCode: i,
                            glyphId: Q
                        });
                    } else {
                        const s = a[e1[i]];
                        for(l = 0; l < s.entryCount; l++){
                            const e1 = (i << 8) + l + s.firstCode;
                            t.pos = s.idRangePos + 2 * l;
                            Q = t.getUint16();
                            0 !== Q && (Q = (Q + s.idDelta) % 65536);
                            h.push({
                                charCode: e1,
                                glyphId: Q
                            });
                        }
                    }
                } else if (4 === c) {
                    t.skip(4);
                    const e1 = t.getUint16() >> 1;
                    t.skip(6);
                    const i = [];
                    let a;
                    for(a = 0; a < e1; a++)i.push({
                        end: t.getUint16()
                    });
                    t.skip(2);
                    for(a = 0; a < e1; a++)i[a].start = t.getUint16();
                    for(a = 0; a < e1; a++)i[a].delta = t.getUint16();
                    let n, g = 0;
                    for(a = 0; a < e1; a++){
                        s = i[a];
                        const r = t.getUint16();
                        if (r) {
                            n = (r >> 1) - (e1 - a);
                            s.offsetIndex = n;
                            g = Math.max(g, n + s.end - s.start + 1);
                        } else s.offsetIndex = -1;
                    }
                    const o = [];
                    for(l = 0; l < g; l++)o.push(t.getUint16());
                    for(a = 0; a < e1; a++){
                        s = i[a];
                        r = s.start;
                        const e1 = s.end, t = s.delta;
                        n = s.offsetIndex;
                        for(l = r; l <= e1; l++)if (65535 !== l) {
                            Q = n < 0 ? l : o[n + l - r];
                            Q = Q + t & 65535;
                            h.push({
                                charCode: l,
                                glyphId: Q
                            });
                        }
                    }
                } else if (6 === c) {
                    t.skip(4);
                    const e1 = t.getUint16(), i = t.getUint16();
                    for(l = 0; l < i; l++){
                        Q = t.getUint16();
                        const i = e1 + l;
                        h.push({
                            charCode: i,
                            glyphId: Q
                        });
                    }
                } else {
                    if (12 !== c) {
                        warn("cmap table has unsupported format: " + c);
                        return {
                            platformId: -1,
                            encodingId: -1,
                            mappings: [],
                            hasShortCmap: !1
                        };
                    }
                    {
                        t.skip(10);
                        const e1 = t.getInt32() >>> 0;
                        for(l = 0; l < e1; l++){
                            const e1 = t.getInt32() >>> 0, i = t.getInt32() >>> 0;
                            let a = t.getInt32() >>> 0;
                            for(let t = e1; t <= i; t++)h.push({
                                charCode: t,
                                glyphId: a++
                            });
                        }
                    }
                }
                h.sort(function(e1, t) {
                    return e1.charCode - t.charCode;
                });
                for(let e1 = 1; e1 < h.length; e1++)if (h[e1 - 1].charCode === h[e1].charCode) {
                    h.splice(e1, 1);
                    e1--;
                }
                return {
                    platformId: g.platformId,
                    encodingId: g.encodingId,
                    mappings: h,
                    hasShortCmap: C
                };
            }(n.cmap, t, this.isSymbolicFont, i.hasEncoding), a = e1.platformId, s = e1.encodingId, r = e1.mappings;
            let g = [], o = !1;
            !i.hasEncoding || "MacRomanEncoding" !== i.baseEncodingName && "WinAnsiEncoding" !== i.baseEncodingName || (g = getEncoding(i.baseEncodingName));
            if (i.hasEncoding && !this.isSymbolicFont && (3 === a && 1 === s || 1 === a && 0 === s)) {
                const e1 = wi();
                for(let t = 0; t < 256; t++){
                    let n;
                    n = void 0 !== this.differences[t] ? this.differences[t] : g.length && "" !== g[t] ? g[t] : hi[t];
                    if (!n) continue;
                    const o = recoverGlyphName(n, e1);
                    let c;
                    3 === a && 1 === s ? c = e1[o] : 1 === a && 0 === s && (c = Ci.indexOf(o));
                    if (void 0 === c) {
                        if (!i.glyphNames && i.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
                            const e1 = this.toUnicode.get(t);
                            e1 && (c = e1.codePointAt(0));
                        }
                        if (void 0 === c) continue;
                    }
                    for (const e1 of r)if (e1.charCode === c) {
                        m[t] = e1.glyphId;
                        break;
                    }
                }
            } else if (0 === a) {
                for (const e1 of r)m[e1.charCode] = e1.glyphId;
                o = !0;
            } else if (3 === a && 0 === s) for (const e1 of r){
                let t = e1.charCode;
                t >= 61440 && t <= 61695 && (t &= 255);
                m[t] = e1.glyphId;
            }
            else for (const e1 of r)m[e1.charCode] = e1.glyphId;
            if (i.glyphNames && (g.length || this.differences.length)) for(let e1 = 0; e1 < 256; ++e1){
                if (!o && void 0 !== m[e1]) continue;
                const t = this.differences[e1] || g[e1];
                if (!t) continue;
                const a = i.glyphNames.indexOf(t);
                a > 0 && hasGlyph(a) && (m[e1] = a);
            }
        }
        0 === m.length && (m[0] = 0);
        let y = l - 1;
        Q || (y = 0);
        if (!i.cssFontInfo) {
            const e1 = adjustMapping(m, hasGlyph, y, this.toUnicode);
            this.toFontChar = e1.toFontChar;
            n.cmap = {
                tag: "cmap",
                data: createCmapTable(e1.charCodeToGlyphId, e1.toUnicodeExtraMap, l)
            };
            n["OS/2"] && function validateOS2Table(e1, t) {
                t.pos = (t.start || 0) + e1.offset;
                const i = t.getUint16();
                t.skip(60);
                const a = t.getUint16();
                if (i < 4 && 768 & a) return !1;
                if (t.getUint16() > t.getUint16()) return !1;
                t.skip(6);
                if (0 === t.getUint16()) return !1;
                e1.data[8] = e1.data[9] = 0;
                return !0;
            }(n["OS/2"], t) || (n["OS/2"] = {
                tag: "OS/2",
                data: createOS2Table(i, e1.charCodeToGlyphId, p)
            });
        }
        if (!c) try {
            o = new Stream(n["CFF "].data);
            g = new CFFParser(o, i, Ri).parse();
            g.duplicateFirstGlyph();
            const e1 = new CFFCompiler(g);
            n["CFF "].data = e1.compile();
        } catch  {
            warn("Failed to compile font " + i.loadedName);
        }
        if (n.name) {
            const [t, a] = readNameTable(n.name);
            n.name.data = createNameTable(e1, t);
            this.psName = t[0][6] || null;
            i.composite || function adjustTrueTypeToUnicode(e1, t, i) {
                if (e1.isInternalFont) return;
                if (e1.hasIncludedToUnicodeMap) return;
                if (e1.hasEncoding) return;
                if (e1.toUnicode instanceof IdentityToUnicodeMap) return;
                if (!t) return;
                if (0 === i.length) return;
                if (e1.defaultEncoding === li) return;
                for (const e1 of i)if (!isWinNameRecord(e1)) return;
                const a = li, s = [], r = wi();
                for(const e1 in a){
                    const t = a[e1];
                    if ("" === t) continue;
                    const i = r[t];
                    void 0 !== i && (s[e1] = String.fromCharCode(i));
                }
                s.length > 0 && e1.toUnicode.amend(s);
            }(i, this.isSymbolicFont, a);
        } else n.name = {
            tag: "name",
            data: createNameTable(this.name)
        };
        const w = new OpenTypeFileBuilder(r.version);
        for(const e1 in n)w.addTable(e1, n[e1].data);
        return w.toArray();
    }
    convert(e1, t, i) {
        i.fixedPitch = !1;
        i.builtInEncoding && function adjustType1ToUnicode(e1, t) {
            if (e1.isInternalFont) return;
            if (e1.hasIncludedToUnicodeMap) return;
            if (t === e1.defaultEncoding) return;
            if (e1.toUnicode instanceof IdentityToUnicodeMap) return;
            const i = [], a = wi();
            for(const s in t){
                if (e1.hasEncoding && (e1.baseEncodingName || void 0 !== e1.differences[s])) continue;
                const r = getUnicodeForGlyph(t[s], a);
                -1 !== r && (i[s] = String.fromCharCode(r));
            }
            i.length > 0 && e1.toUnicode.amend(i);
        }(i, i.builtInEncoding);
        let s = 1;
        t instanceof CFFFont && (s = t.numGlyphs - 1);
        const r = t.getGlyphMapping(i);
        let n = null, g = r, o = null;
        if (!i.cssFontInfo) {
            n = adjustMapping(r, t.hasGlyphId.bind(t), s, this.toUnicode);
            this.toFontChar = n.toFontChar;
            g = n.charCodeToGlyphId;
            o = n.toUnicodeExtraMap;
        }
        const c = t.numGlyphs;
        function getCharCodes(e1, t) {
            let i = null;
            for(const a in e1)t === e1[a] && (i ||= []).push(0 | a);
            return i;
        }
        function createCharCode(e1, t) {
            for(const i in e1)if (t === e1[i]) return 0 | i;
            n.charCodeToGlyphId[n.nextAvailableFontCharCode] = t;
            return n.nextAvailableFontCharCode++;
        }
        const C = t.seacs;
        if (n && C?.length) {
            const e1 = i.fontMatrix || a, s = t.getCharset(), g = Object.create(null);
            for(let t in C){
                t |= 0;
                const i = C[t], a = hi[i[2]], o = hi[i[3]], c = s.indexOf(a), h = s.indexOf(o);
                if (c < 0 || h < 0) continue;
                const l = {
                    x: i[0] * e1[0] + i[1] * e1[2] + e1[4],
                    y: i[0] * e1[1] + i[1] * e1[3] + e1[5]
                }, Q = getCharCodes(r, t);
                if (Q) for (const e1 of Q){
                    const t = n.charCodeToGlyphId, i = createCharCode(t, c), a = createCharCode(t, h);
                    g[e1] = {
                        baseFontCharCode: i,
                        accentFontCharCode: a,
                        accentOffset: l
                    };
                }
            }
            i.seacMap = g;
        }
        const h = i.fontMatrix ? 1 / Math.max(...i.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, l = new OpenTypeFileBuilder("OTTO");
        l.addTable("CFF ", t.data);
        l.addTable("OS/2", createOS2Table(i, g));
        l.addTable("cmap", createCmapTable(g, o, c));
        l.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<Ãµ\0\0" + safeString16(h) + "\0\0\0\0Â\v~'\0\0\0\0Â\v~'\0\0" + safeString16(i.descent) + "Ã¿" + safeString16(i.ascent) + string16(i.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
        l.addTable("hhea", "\0\0\0" + safeString16(i.ascent) + safeString16(i.descent) + "\0\0Ã¿Ã¿\0\0\0\0\0\0" + safeString16(i.capHeight) + safeString16(Math.tan(i.italicAngle) * i.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(c));
        l.addTable("hmtx", function fontFieldsHmtx() {
            const e1 = t.charstrings, i = t.cff ? t.cff.widths : null;
            let a = "\0\0\0\0";
            for(let t = 1, s = c; t < s; t++){
                let s = 0;
                if (e1) {
                    const i = e1[t - 1];
                    s = "width" in i ? i.width : 0;
                } else i && (s = Math.ceil(i[t] || 0));
                a += string16(s) + string16(0);
            }
            return a;
        }());
        l.addTable("maxp", "\0\0P\0" + string16(c));
        l.addTable("name", createNameTable(e1));
        l.addTable("post", createPostTable(i));
        return l.toArray();
    }
    get _spaceWidth() {
        const e1 = [
            "space",
            "minus",
            "one",
            "i",
            "I"
        ];
        let t;
        for (const i of e1){
            if (i in this.widths) {
                t = this.widths[i];
                break;
            }
            const e1 = wi()[i];
            let a = 0;
            if (this.composite && this.cMap.contains(e1)) {
                a = this.cMap.lookup(e1);
                "string" == typeof a && (a = convertCidString(e1, a));
            }
            !a && this.toUnicode && (a = this.toUnicode.charCodeOf(e1));
            a <= 0 && (a = e1);
            t = this.widths[a];
            if (t) break;
        }
        return shadow(this, "_spaceWidth", t || this.defaultWidth);
    }
    _charToGlyph(e1, t = !1) {
        let i, a, s, r = this._glyphCache[e1];
        if (r?.isSpace === t) return r;
        let n = e1;
        if (this.cMap?.contains(e1)) {
            n = this.cMap.lookup(e1);
            "string" == typeof n && (n = convertCidString(e1, n));
        }
        a = this.widths[n];
        "number" != typeof a && (a = this.defaultWidth);
        const g = this.vmetrics?.[n];
        let o = this.toUnicode.get(e1) || e1;
        "number" == typeof o && (o = String.fromCharCode(o));
        let c = void 0 !== this.toFontChar[e1];
        i = this.toFontChar[e1] || e1;
        if (this.missingFile) {
            const t = this.differences[e1] || this.defaultEncoding[e1];
            if ((".notdef" === t || "" === t) && "Type1" === this.type) {
                i = 32;
                if ("" === t) {
                    a ||= this._spaceWidth;
                    o = String.fromCharCode(i);
                }
            }
            i = function mapSpecialUnicodeValues(e1) {
                return e1 >= 65520 && e1 <= 65535 ? 0 : e1 >= 62976 && e1 <= 63743 ? bi()[e1] || e1 : 173 === e1 ? 45 : e1;
            }(i);
        }
        this.isType3Font && (s = i);
        let C = null;
        if (this.seacMap?.[e1]) {
            c = !0;
            const t = this.seacMap[e1];
            i = t.baseFontCharCode;
            C = {
                fontChar: String.fromCodePoint(t.accentFontCharCode),
                offset: t.accentOffset
            };
        }
        let h = "";
        "number" == typeof i && (i <= 1114111 ? h = String.fromCodePoint(i) : warn(`charToGlyph - invalid fontCharCode: ${i}`));
        if (this.missingFile && this.vertical && 1 === h.length) {
            const e1 = Ji()[h.charCodeAt(0)];
            e1 && (h = o = String.fromCharCode(e1));
        }
        r = new fonts_Glyph(e1, h, o, C, a, g, s, t, c);
        return this._glyphCache[e1] = r;
    }
    charsToGlyphs(e1) {
        let t = this._charsCache[e1];
        if (t) return t;
        t = [];
        if (this.cMap) {
            const i = Object.create(null), a = e1.length;
            let s = 0;
            for(; s < a;){
                this.cMap.readCharCode(e1, s, i);
                const { charcode: a, length: r } = i;
                s += r;
                const n = this._charToGlyph(a, 1 === r && 32 === e1.charCodeAt(s - 1));
                t.push(n);
            }
        } else for(let i = 0, a = e1.length; i < a; ++i){
            const a = e1.charCodeAt(i), s = this._charToGlyph(a, 32 === a);
            t.push(s);
        }
        return this._charsCache[e1] = t;
    }
    getCharPositions(e1) {
        const t = [];
        if (this.cMap) {
            const i = Object.create(null);
            let a = 0;
            for(; a < e1.length;){
                this.cMap.readCharCode(e1, a, i);
                const s = i.length;
                t.push([
                    a,
                    a + s
                ]);
                a += s;
            }
        } else for(let i = 0, a = e1.length; i < a; ++i)t.push([
            i,
            i + 1
        ]);
        return t;
    }
    get glyphCacheValues() {
        return Object.values(this._glyphCache);
    }
    encodeString(e1) {
        const t = [], i = [], hasCurrentBufErrors = ()=>t.length % 2 == 1, a = this.toUnicode instanceof IdentityToUnicodeMap ? (e1)=>this.toUnicode.charCodeOf(e1) : (e1)=>this.toUnicode.charCodeOf(String.fromCodePoint(e1));
        for(let s = 0, r = e1.length; s < r; s++){
            const r = e1.codePointAt(s);
            r > 55295 && (r < 57344 || r > 65533) && s++;
            if (this.toUnicode) {
                const e1 = a(r);
                if (-1 !== e1) {
                    if (hasCurrentBufErrors()) {
                        t.push(i.join(""));
                        i.length = 0;
                    }
                    for(let t = (this.cMap ? this.cMap.getCharCodeLength(e1) : 1) - 1; t >= 0; t--)i.push(String.fromCharCode(e1 >> 8 * t & 255));
                    continue;
                }
            }
            if (!hasCurrentBufErrors()) {
                t.push(i.join(""));
                i.length = 0;
            }
            i.push(String.fromCodePoint(r));
        }
        t.push(i.join(""));
        return t;
    }
}
class ErrorFont {
    constructor(e1){
        this.error = e1;
        this.loadedName = "g_font_error";
        this.missingFile = !0;
    }
    charsToGlyphs() {
        return [];
    }
    encodeString(e1) {
        return [
            e1
        ];
    }
    exportData(e1 = !1) {
        return {
            error: this.error
        };
    }
}
const Ia = 2, ca = 3, Ca = 4, ha = 5, la = 6, Ba = 7;
class Pattern {
    constructor(){
        unreachable("Cannot initialize Pattern.");
    }
    static parseShading(e1, t, i, a, s) {
        const r = e1 instanceof BaseStream ? e1.dict : e1, n = r.get("ShadingType");
        try {
            switch(n){
                case Ia:
                case ca:
                    return new RadialAxialShading(r, t, i, a, s);
                case Ca:
                case ha:
                case la:
                case Ba:
                    return new MeshShading(e1, t, i, a, s);
                default:
                    throw new FormatError("Unsupported ShadingType: " + n);
            }
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(e1);
            return new DummyShading;
        }
    }
}
class BaseShading {
    static SMALL_NUMBER = 1e-6;
    getIR() {
        unreachable("Abstract method `getIR` called.");
    }
}
class RadialAxialShading extends BaseShading {
    constructor(e1, t, i, a, s){
        super();
        this.shadingType = e1.get("ShadingType");
        let r = 0;
        this.shadingType === Ia ? r = 4 : this.shadingType === ca && (r = 6);
        this.coordsArr = e1.getArray("Coords");
        if (!isNumberArray(this.coordsArr, r)) throw new FormatError("RadialAxialShading: Invalid /Coords array.");
        const n = ColorSpace.parse({
            cs: e1.getRaw("CS") || e1.getRaw("ColorSpace"),
            xref: t,
            resources: i,
            pdfFunctionFactory: a,
            localColorSpaceCache: s
        });
        this.bbox = lookupNormalRect(e1.getArray("BBox"), null);
        let g = 0, o = 1;
        const c = e1.getArray("Domain");
        isNumberArray(c, 2) && ([g, o] = c);
        let C = !1, h = !1;
        const l = e1.getArray("Extend");
        (function isBooleanArray(e1, t) {
            return Array.isArray(e1) && (null === t || e1.length === t) && e1.every((e1)=>"boolean" == typeof e1);
        })(l, 2) && ([C, h] = l);
        if (!(this.shadingType !== ca || C && h)) {
            const [e1, t, i, a, s, r] = this.coordsArr, n = Math.hypot(e1 - a, t - s);
            i <= r + n && r <= i + n && warn("Unsupported radial gradient.");
        }
        this.extendStart = C;
        this.extendEnd = h;
        const Q = e1.getRaw("Function"), E = a.createFromArray(Q), u = (o - g) / 840, d = this.colorStops = [];
        if (g >= o || u <= 0) {
            info("Bad shading domain.");
            return;
        }
        const f = new Float32Array(n.numComps), p = new Float32Array(1);
        let m, y = 0;
        p[0] = g;
        E(p, 0, f, 0);
        let w = n.getRgb(f, 0);
        const D = Util.makeHexColor(w[0], w[1], w[2]);
        d.push([
            0,
            D
        ]);
        let b = 1;
        p[0] = g + u;
        E(p, 0, f, 0);
        let F = n.getRgb(f, 0), S = F[0] - w[0] + 1, k = F[1] - w[1] + 1, R = F[2] - w[2] + 1, N = F[0] - w[0] - 1, G = F[1] - w[1] - 1, M = F[2] - w[2] - 1;
        for(let e1 = 2; e1 < 840; e1++){
            p[0] = g + e1 * u;
            E(p, 0, f, 0);
            m = n.getRgb(f, 0);
            const t = e1 - y;
            S = Math.min(S, (m[0] - w[0] + 1) / t);
            k = Math.min(k, (m[1] - w[1] + 1) / t);
            R = Math.min(R, (m[2] - w[2] + 1) / t);
            N = Math.max(N, (m[0] - w[0] - 1) / t);
            G = Math.max(G, (m[1] - w[1] - 1) / t);
            M = Math.max(M, (m[2] - w[2] - 1) / t);
            if (!(N <= S && G <= k && M <= R)) {
                const e1 = Util.makeHexColor(F[0], F[1], F[2]);
                d.push([
                    b / 840,
                    e1
                ]);
                S = m[0] - F[0] + 1;
                k = m[1] - F[1] + 1;
                R = m[2] - F[2] + 1;
                N = m[0] - F[0] - 1;
                G = m[1] - F[1] - 1;
                M = m[2] - F[2] - 1;
                y = b;
                w = F;
            }
            b = e1;
            F = m;
        }
        const U = Util.makeHexColor(F[0], F[1], F[2]);
        d.push([
            1,
            U
        ]);
        let x = "transparent";
        if (e1.has("Background")) {
            m = n.getRgb(e1.get("Background"), 0);
            x = Util.makeHexColor(m[0], m[1], m[2]);
        }
        if (!C) {
            d.unshift([
                0,
                x
            ]);
            d[1][0] += BaseShading.SMALL_NUMBER;
        }
        if (!h) {
            d.at(-1)[0] -= BaseShading.SMALL_NUMBER;
            d.push([
                1,
                x
            ]);
        }
        this.colorStops = d;
    }
    getIR() {
        const { coordsArr: e1, shadingType: t } = this;
        let i, a, s, r, n;
        if (t === Ia) {
            a = [
                e1[0],
                e1[1]
            ];
            s = [
                e1[2],
                e1[3]
            ];
            r = null;
            n = null;
            i = "axial";
        } else if (t === ca) {
            a = [
                e1[0],
                e1[1]
            ];
            s = [
                e1[3],
                e1[4]
            ];
            r = e1[2];
            n = e1[5];
            i = "radial";
        } else unreachable(`getPattern type unknown: ${t}`);
        return [
            "RadialAxial",
            i,
            this.bbox,
            this.colorStops,
            a,
            s,
            r,
            n
        ];
    }
}
class MeshStreamReader {
    constructor(e1, t){
        this.stream = e1;
        this.context = t;
        this.buffer = 0;
        this.bufferLength = 0;
        const i = t.numComps;
        this.tmpCompsBuf = new Float32Array(i);
        const a = t.colorSpace.numComps;
        this.tmpCsCompsBuf = t.colorFn ? new Float32Array(a) : this.tmpCompsBuf;
    }
    get hasData() {
        if (this.stream.end) return this.stream.pos < this.stream.end;
        if (this.bufferLength > 0) return !0;
        const e1 = this.stream.getByte();
        if (e1 < 0) return !1;
        this.buffer = e1;
        this.bufferLength = 8;
        return !0;
    }
    readBits(e1) {
        let t = this.buffer, i = this.bufferLength;
        if (32 === e1) {
            if (0 === i) return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
            t = t << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
            const e1 = this.stream.getByte();
            this.buffer = e1 & (1 << i) - 1;
            return (t << 8 - i | (255 & e1) >> i) >>> 0;
        }
        if (8 === e1 && 0 === i) return this.stream.getByte();
        for(; i < e1;){
            t = t << 8 | this.stream.getByte();
            i += 8;
        }
        i -= e1;
        this.bufferLength = i;
        this.buffer = t & (1 << i) - 1;
        return t >> i;
    }
    align() {
        this.buffer = 0;
        this.bufferLength = 0;
    }
    readFlag() {
        return this.readBits(this.context.bitsPerFlag);
    }
    readCoordinate() {
        const e1 = this.context.bitsPerCoordinate, t = this.readBits(e1), i = this.readBits(e1), a = this.context.decode, s = e1 < 32 ? 1 / ((1 << e1) - 1) : 2.3283064365386963e-10;
        return [
            t * s * (a[1] - a[0]) + a[0],
            i * s * (a[3] - a[2]) + a[2]
        ];
    }
    readComponents() {
        const e1 = this.context.numComps, t = this.context.bitsPerComponent, i = t < 32 ? 1 / ((1 << t) - 1) : 2.3283064365386963e-10, a = this.context.decode, s = this.tmpCompsBuf;
        for(let r = 0, n = 4; r < e1; r++, n += 2){
            const e1 = this.readBits(t);
            s[r] = e1 * i * (a[n + 1] - a[n]) + a[n];
        }
        const r = this.tmpCsCompsBuf;
        this.context.colorFn && this.context.colorFn(s, 0, r, 0);
        return this.context.colorSpace.getRgb(r, 0);
    }
}
let Qa = Object.create(null);
function getB(e1) {
    return Qa[e1] ||= function buildB(e1) {
        const t = [];
        for(let i = 0; i <= e1; i++){
            const a = i / e1, s = 1 - a;
            t.push(new Float32Array([
                s ** 3,
                3 * a * s ** 2,
                3 * a ** 2 * s,
                a ** 3
            ]));
        }
        return t;
    }(e1);
}
class MeshShading extends BaseShading {
    static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
    static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
    static TRIANGLE_DENSITY = 20;
    constructor(e1, t, i, a, s){
        super();
        if (!(e1 instanceof BaseStream)) throw new FormatError("Mesh data is not a stream");
        const r = e1.dict;
        this.shadingType = r.get("ShadingType");
        this.bbox = lookupNormalRect(r.getArray("BBox"), null);
        const n = ColorSpace.parse({
            cs: r.getRaw("CS") || r.getRaw("ColorSpace"),
            xref: t,
            resources: i,
            pdfFunctionFactory: a,
            localColorSpaceCache: s
        });
        this.background = r.has("Background") ? n.getRgb(r.get("Background"), 0) : null;
        const g = r.getRaw("Function"), o = g ? a.createFromArray(g) : null;
        this.coords = [];
        this.colors = [];
        this.figures = [];
        const c = {
            bitsPerCoordinate: r.get("BitsPerCoordinate"),
            bitsPerComponent: r.get("BitsPerComponent"),
            bitsPerFlag: r.get("BitsPerFlag"),
            decode: r.getArray("Decode"),
            colorFn: o,
            colorSpace: n,
            numComps: o ? 1 : n.numComps
        }, C = new MeshStreamReader(e1, c);
        let h = !1;
        switch(this.shadingType){
            case Ca:
                this._decodeType4Shading(C);
                break;
            case ha:
                const e2 = 0 | r.get("VerticesPerRow");
                if (e2 < 2) throw new FormatError("Invalid VerticesPerRow");
                this._decodeType5Shading(C, e2);
                break;
            case la:
                this._decodeType6Shading(C);
                h = !0;
                break;
            case Ba:
                this._decodeType7Shading(C);
                h = !0;
                break;
            default:
                unreachable("Unsupported mesh type.");
        }
        if (h) {
            this._updateBounds();
            for(let e1 = 0, t = this.figures.length; e1 < t; e1++)this._buildFigureFromPatch(e1);
        }
        this._updateBounds();
        this._packData();
    }
    _decodeType4Shading(e1) {
        const t = this.coords, i = this.colors, a = [], s = [];
        let r = 0;
        for(; e1.hasData;){
            const n = e1.readFlag(), g = e1.readCoordinate(), o = e1.readComponents();
            if (0 === r) {
                if (!(0 <= n && n <= 2)) throw new FormatError("Unknown type4 flag");
                switch(n){
                    case 0:
                        r = 3;
                        break;
                    case 1:
                        s.push(s.at(-2), s.at(-1));
                        r = 1;
                        break;
                    case 2:
                        s.push(s.at(-3), s.at(-1));
                        r = 1;
                }
                a.push(n);
            }
            s.push(t.length);
            t.push(g);
            i.push(o);
            r--;
            e1.align();
        }
        this.figures.push({
            type: "triangles",
            coords: new Int32Array(s),
            colors: new Int32Array(s)
        });
    }
    _decodeType5Shading(e1, t) {
        const i = this.coords, a = this.colors, s = [];
        for(; e1.hasData;){
            const t = e1.readCoordinate(), r = e1.readComponents();
            s.push(i.length);
            i.push(t);
            a.push(r);
        }
        this.figures.push({
            type: "lattice",
            coords: new Int32Array(s),
            colors: new Int32Array(s),
            verticesPerRow: t
        });
    }
    _decodeType6Shading(e1) {
        const t = this.coords, i = this.colors, a = new Int32Array(16), s = new Int32Array(4);
        for(; e1.hasData;){
            const r = e1.readFlag();
            if (!(0 <= r && r <= 3)) throw new FormatError("Unknown type6 flag");
            const n = t.length;
            for(let i = 0, a = 0 !== r ? 8 : 12; i < a; i++)t.push(e1.readCoordinate());
            const g = i.length;
            for(let t = 0, a = 0 !== r ? 2 : 4; t < a; t++)i.push(e1.readComponents());
            let o, c, C, h;
            switch(r){
                case 0:
                    a[12] = n + 3;
                    a[13] = n + 4;
                    a[14] = n + 5;
                    a[15] = n + 6;
                    a[8] = n + 2;
                    a[11] = n + 7;
                    a[4] = n + 1;
                    a[7] = n + 8;
                    a[0] = n;
                    a[1] = n + 11;
                    a[2] = n + 10;
                    a[3] = n + 9;
                    s[2] = g + 1;
                    s[3] = g + 2;
                    s[0] = g;
                    s[1] = g + 3;
                    break;
                case 1:
                    o = a[12];
                    c = a[13];
                    C = a[14];
                    h = a[15];
                    a[12] = h;
                    a[13] = n + 0;
                    a[14] = n + 1;
                    a[15] = n + 2;
                    a[8] = C;
                    a[11] = n + 3;
                    a[4] = c;
                    a[7] = n + 4;
                    a[0] = o;
                    a[1] = n + 7;
                    a[2] = n + 6;
                    a[3] = n + 5;
                    o = s[2];
                    c = s[3];
                    s[2] = c;
                    s[3] = g;
                    s[0] = o;
                    s[1] = g + 1;
                    break;
                case 2:
                    o = a[15];
                    c = a[11];
                    a[12] = a[3];
                    a[13] = n + 0;
                    a[14] = n + 1;
                    a[15] = n + 2;
                    a[8] = a[7];
                    a[11] = n + 3;
                    a[4] = c;
                    a[7] = n + 4;
                    a[0] = o;
                    a[1] = n + 7;
                    a[2] = n + 6;
                    a[3] = n + 5;
                    o = s[3];
                    s[2] = s[1];
                    s[3] = g;
                    s[0] = o;
                    s[1] = g + 1;
                    break;
                case 3:
                    a[12] = a[0];
                    a[13] = n + 0;
                    a[14] = n + 1;
                    a[15] = n + 2;
                    a[8] = a[1];
                    a[11] = n + 3;
                    a[4] = a[2];
                    a[7] = n + 4;
                    a[0] = a[3];
                    a[1] = n + 7;
                    a[2] = n + 6;
                    a[3] = n + 5;
                    s[2] = s[0];
                    s[3] = g;
                    s[0] = s[1];
                    s[1] = g + 1;
            }
            a[5] = t.length;
            t.push([
                (-4 * t[a[0]][0] - t[a[15]][0] + 6 * (t[a[4]][0] + t[a[1]][0]) - 2 * (t[a[12]][0] + t[a[3]][0]) + 3 * (t[a[13]][0] + t[a[7]][0])) / 9,
                (-4 * t[a[0]][1] - t[a[15]][1] + 6 * (t[a[4]][1] + t[a[1]][1]) - 2 * (t[a[12]][1] + t[a[3]][1]) + 3 * (t[a[13]][1] + t[a[7]][1])) / 9
            ]);
            a[6] = t.length;
            t.push([
                (-4 * t[a[3]][0] - t[a[12]][0] + 6 * (t[a[2]][0] + t[a[7]][0]) - 2 * (t[a[0]][0] + t[a[15]][0]) + 3 * (t[a[4]][0] + t[a[14]][0])) / 9,
                (-4 * t[a[3]][1] - t[a[12]][1] + 6 * (t[a[2]][1] + t[a[7]][1]) - 2 * (t[a[0]][1] + t[a[15]][1]) + 3 * (t[a[4]][1] + t[a[14]][1])) / 9
            ]);
            a[9] = t.length;
            t.push([
                (-4 * t[a[12]][0] - t[a[3]][0] + 6 * (t[a[8]][0] + t[a[13]][0]) - 2 * (t[a[0]][0] + t[a[15]][0]) + 3 * (t[a[11]][0] + t[a[1]][0])) / 9,
                (-4 * t[a[12]][1] - t[a[3]][1] + 6 * (t[a[8]][1] + t[a[13]][1]) - 2 * (t[a[0]][1] + t[a[15]][1]) + 3 * (t[a[11]][1] + t[a[1]][1])) / 9
            ]);
            a[10] = t.length;
            t.push([
                (-4 * t[a[15]][0] - t[a[0]][0] + 6 * (t[a[11]][0] + t[a[14]][0]) - 2 * (t[a[12]][0] + t[a[3]][0]) + 3 * (t[a[2]][0] + t[a[8]][0])) / 9,
                (-4 * t[a[15]][1] - t[a[0]][1] + 6 * (t[a[11]][1] + t[a[14]][1]) - 2 * (t[a[12]][1] + t[a[3]][1]) + 3 * (t[a[2]][1] + t[a[8]][1])) / 9
            ]);
            this.figures.push({
                type: "patch",
                coords: new Int32Array(a),
                colors: new Int32Array(s)
            });
        }
    }
    _decodeType7Shading(e1) {
        const t = this.coords, i = this.colors, a = new Int32Array(16), s = new Int32Array(4);
        for(; e1.hasData;){
            const r = e1.readFlag();
            if (!(0 <= r && r <= 3)) throw new FormatError("Unknown type7 flag");
            const n = t.length;
            for(let i = 0, a = 0 !== r ? 12 : 16; i < a; i++)t.push(e1.readCoordinate());
            const g = i.length;
            for(let t = 0, a = 0 !== r ? 2 : 4; t < a; t++)i.push(e1.readComponents());
            let o, c, C, h;
            switch(r){
                case 0:
                    a[12] = n + 3;
                    a[13] = n + 4;
                    a[14] = n + 5;
                    a[15] = n + 6;
                    a[8] = n + 2;
                    a[9] = n + 13;
                    a[10] = n + 14;
                    a[11] = n + 7;
                    a[4] = n + 1;
                    a[5] = n + 12;
                    a[6] = n + 15;
                    a[7] = n + 8;
                    a[0] = n;
                    a[1] = n + 11;
                    a[2] = n + 10;
                    a[3] = n + 9;
                    s[2] = g + 1;
                    s[3] = g + 2;
                    s[0] = g;
                    s[1] = g + 3;
                    break;
                case 1:
                    o = a[12];
                    c = a[13];
                    C = a[14];
                    h = a[15];
                    a[12] = h;
                    a[13] = n + 0;
                    a[14] = n + 1;
                    a[15] = n + 2;
                    a[8] = C;
                    a[9] = n + 9;
                    a[10] = n + 10;
                    a[11] = n + 3;
                    a[4] = c;
                    a[5] = n + 8;
                    a[6] = n + 11;
                    a[7] = n + 4;
                    a[0] = o;
                    a[1] = n + 7;
                    a[2] = n + 6;
                    a[3] = n + 5;
                    o = s[2];
                    c = s[3];
                    s[2] = c;
                    s[3] = g;
                    s[0] = o;
                    s[1] = g + 1;
                    break;
                case 2:
                    o = a[15];
                    c = a[11];
                    a[12] = a[3];
                    a[13] = n + 0;
                    a[14] = n + 1;
                    a[15] = n + 2;
                    a[8] = a[7];
                    a[9] = n + 9;
                    a[10] = n + 10;
                    a[11] = n + 3;
                    a[4] = c;
                    a[5] = n + 8;
                    a[6] = n + 11;
                    a[7] = n + 4;
                    a[0] = o;
                    a[1] = n + 7;
                    a[2] = n + 6;
                    a[3] = n + 5;
                    o = s[3];
                    s[2] = s[1];
                    s[3] = g;
                    s[0] = o;
                    s[1] = g + 1;
                    break;
                case 3:
                    a[12] = a[0];
                    a[13] = n + 0;
                    a[14] = n + 1;
                    a[15] = n + 2;
                    a[8] = a[1];
                    a[9] = n + 9;
                    a[10] = n + 10;
                    a[11] = n + 3;
                    a[4] = a[2];
                    a[5] = n + 8;
                    a[6] = n + 11;
                    a[7] = n + 4;
                    a[0] = a[3];
                    a[1] = n + 7;
                    a[2] = n + 6;
                    a[3] = n + 5;
                    s[2] = s[0];
                    s[3] = g;
                    s[0] = s[1];
                    s[1] = g + 1;
            }
            this.figures.push({
                type: "patch",
                coords: new Int32Array(a),
                colors: new Int32Array(s)
            });
        }
    }
    _buildFigureFromPatch(e1) {
        const t = this.figures[e1];
        assert("patch" === t.type, "Unexpected patch mesh figure");
        const i = this.coords, a = this.colors, s = t.coords, r = t.colors, n = Math.min(i[s[0]][0], i[s[3]][0], i[s[12]][0], i[s[15]][0]), g = Math.min(i[s[0]][1], i[s[3]][1], i[s[12]][1], i[s[15]][1]), o = Math.max(i[s[0]][0], i[s[3]][0], i[s[12]][0], i[s[15]][0]), c = Math.max(i[s[0]][1], i[s[3]][1], i[s[12]][1], i[s[15]][1]);
        let C = Math.ceil((o - n) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
        C = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, C));
        let h = Math.ceil((c - g) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
        h = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, h));
        const l = C + 1, Q = new Int32Array((h + 1) * l), E = new Int32Array((h + 1) * l);
        let u = 0;
        const d = new Uint8Array(3), f = new Uint8Array(3), p = a[r[0]], m = a[r[1]], y = a[r[2]], w = a[r[3]], D = getB(h), b = getB(C);
        for(let e1 = 0; e1 <= h; e1++){
            d[0] = (p[0] * (h - e1) + y[0] * e1) / h | 0;
            d[1] = (p[1] * (h - e1) + y[1] * e1) / h | 0;
            d[2] = (p[2] * (h - e1) + y[2] * e1) / h | 0;
            f[0] = (m[0] * (h - e1) + w[0] * e1) / h | 0;
            f[1] = (m[1] * (h - e1) + w[1] * e1) / h | 0;
            f[2] = (m[2] * (h - e1) + w[2] * e1) / h | 0;
            for(let t = 0; t <= C; t++, u++){
                if (!(0 !== e1 && e1 !== h || 0 !== t && t !== C)) continue;
                let r = 0, n = 0, g = 0;
                for(let a = 0; a <= 3; a++)for(let o = 0; o <= 3; o++, g++){
                    const c = D[e1][a] * b[t][o];
                    r += i[s[g]][0] * c;
                    n += i[s[g]][1] * c;
                }
                Q[u] = i.length;
                i.push([
                    r,
                    n
                ]);
                E[u] = a.length;
                const o = new Uint8Array(3);
                o[0] = (d[0] * (C - t) + f[0] * t) / C | 0;
                o[1] = (d[1] * (C - t) + f[1] * t) / C | 0;
                o[2] = (d[2] * (C - t) + f[2] * t) / C | 0;
                a.push(o);
            }
        }
        Q[0] = s[0];
        E[0] = r[0];
        Q[C] = s[3];
        E[C] = r[1];
        Q[l * h] = s[12];
        E[l * h] = r[2];
        Q[l * h + C] = s[15];
        E[l * h + C] = r[3];
        this.figures[e1] = {
            type: "lattice",
            coords: Q,
            colors: E,
            verticesPerRow: l
        };
    }
    _updateBounds() {
        let e1 = this.coords[0][0], t = this.coords[0][1], i = e1, a = t;
        for(let s = 1, r = this.coords.length; s < r; s++){
            const r = this.coords[s][0], n = this.coords[s][1];
            e1 = e1 > r ? r : e1;
            t = t > n ? n : t;
            i = i < r ? r : i;
            a = a < n ? n : a;
        }
        this.bounds = [
            e1,
            t,
            i,
            a
        ];
    }
    _packData() {
        let e1, t, i, a;
        const s = this.coords, r = new Float32Array(2 * s.length);
        for(e1 = 0, i = 0, t = s.length; e1 < t; e1++){
            const t = s[e1];
            r[i++] = t[0];
            r[i++] = t[1];
        }
        this.coords = r;
        const n = this.colors, g = new Uint8Array(3 * n.length);
        for(e1 = 0, i = 0, t = n.length; e1 < t; e1++){
            const t = n[e1];
            g[i++] = t[0];
            g[i++] = t[1];
            g[i++] = t[2];
        }
        this.colors = g;
        const o = this.figures;
        for(e1 = 0, t = o.length; e1 < t; e1++){
            const t = o[e1], s = t.coords, r = t.colors;
            for(i = 0, a = s.length; i < a; i++){
                s[i] *= 2;
                r[i] *= 3;
            }
        }
    }
    getIR() {
        const { bounds: e1 } = this;
        if (e1[2] - e1[0] == 0 || e1[3] - e1[1] == 0) throw new FormatError(`Invalid MeshShading bounds: [${e1}].`);
        return [
            "Mesh",
            this.shadingType,
            this.coords,
            this.colors,
            this.figures,
            e1,
            this.bbox,
            this.background
        ];
    }
}
class DummyShading extends BaseShading {
    getIR() {
        return [
            "Dummy"
        ];
    }
}
function getTilingPatternIR(e1, t, a) {
    const s = lookupMatrix(t.getArray("Matrix"), i), r = lookupNormalRect(t.getArray("BBox"), null);
    if (!r || r[2] - r[0] == 0 || r[3] - r[1] == 0) throw new FormatError("Invalid getTilingPatternIR /BBox array.");
    const n = t.get("XStep");
    if ("number" != typeof n) throw new FormatError("Invalid getTilingPatternIR /XStep value.");
    const g = t.get("YStep");
    if ("number" != typeof g) throw new FormatError("Invalid getTilingPatternIR /YStep value.");
    const o = t.get("PaintType");
    if (!Number.isInteger(o)) throw new FormatError("Invalid getTilingPatternIR /PaintType value.");
    const c = t.get("TilingType");
    if (!Number.isInteger(c)) throw new FormatError("Invalid getTilingPatternIR /TilingType value.");
    return [
        "TilingPattern",
        a,
        e1,
        s,
        r,
        n,
        g,
        o,
        c
    ];
}
const Ea = [
    1.3877,
    1,
    1,
    1,
    .97801,
    .92482,
    .89552,
    .91133,
    .81988,
    .97566,
    .98152,
    .93548,
    .93548,
    1.2798,
    .85284,
    .92794,
    1,
    .96134,
    1.54657,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .82845,
    .82845,
    .85284,
    .85284,
    .85284,
    .75859,
    .92138,
    .83908,
    .7762,
    .73293,
    .87289,
    .73133,
    .7514,
    .81921,
    .87356,
    .95958,
    .59526,
    .75727,
    .69225,
    1.04924,
    .9121,
    .86943,
    .79795,
    .88198,
    .77958,
    .70864,
    .81055,
    .90399,
    .88653,
    .96017,
    .82577,
    .77892,
    .78257,
    .97507,
    1.54657,
    .97507,
    .85284,
    .89552,
    .90176,
    .88762,
    .8785,
    .75241,
    .8785,
    .90518,
    .95015,
    .77618,
    .8785,
    .88401,
    .91916,
    .86304,
    .88401,
    .91488,
    .8785,
    .8801,
    .8785,
    .8785,
    .91343,
    .7173,
    1.04106,
    .8785,
    .85075,
    .95794,
    .82616,
    .85162,
    .79492,
    .88331,
    1.69808,
    .88331,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.7801,
    .89552,
    1.24487,
    1.13254,
    1.12401,
    .96839,
    .85284,
    .68787,
    .70645,
    .85592,
    .90747,
    1.01466,
    1.0088,
    .90323,
    1,
    1.07463,
    1,
    .91056,
    .75806,
    1.19118,
    .96839,
    .78864,
    .82845,
    .84133,
    .75859,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .77539,
    .73293,
    .73133,
    .73133,
    .73133,
    .73133,
    .95958,
    .95958,
    .95958,
    .95958,
    .88506,
    .9121,
    .86943,
    .86943,
    .86943,
    .86943,
    .86943,
    .85284,
    .87508,
    .90399,
    .90399,
    .90399,
    .90399,
    .77892,
    .79795,
    .90807,
    .88762,
    .88762,
    .88762,
    .88762,
    .88762,
    .88762,
    .8715,
    .75241,
    .90518,
    .90518,
    .90518,
    .90518,
    .88401,
    .88401,
    .88401,
    .88401,
    .8785,
    .8785,
    .8801,
    .8801,
    .8801,
    .8801,
    .8801,
    .90747,
    .89049,
    .8785,
    .8785,
    .8785,
    .8785,
    .85162,
    .8785,
    .85162,
    .83908,
    .88762,
    .83908,
    .88762,
    .83908,
    .88762,
    .73293,
    .75241,
    .73293,
    .75241,
    .73293,
    .75241,
    .73293,
    .75241,
    .87289,
    .83016,
    .88506,
    .93125,
    .73133,
    .90518,
    .73133,
    .90518,
    .73133,
    .90518,
    .73133,
    .90518,
    .73133,
    .90518,
    .81921,
    .77618,
    .81921,
    .77618,
    .81921,
    .77618,
    1,
    1,
    .87356,
    .8785,
    .91075,
    .89608,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .76229,
    .90167,
    .59526,
    .91916,
    1,
    1,
    .86304,
    .69225,
    .88401,
    1,
    1,
    .70424,
    .79468,
    .91926,
    .88175,
    .70823,
    .94903,
    .9121,
    .8785,
    1,
    1,
    .9121,
    .8785,
    .87802,
    .88656,
    .8785,
    .86943,
    .8801,
    .86943,
    .8801,
    .86943,
    .8801,
    .87402,
    .89291,
    .77958,
    .91343,
    1,
    1,
    .77958,
    .91343,
    .70864,
    .7173,
    .70864,
    .7173,
    .70864,
    .7173,
    .70864,
    .7173,
    1,
    1,
    .81055,
    .75841,
    .81055,
    1.06452,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .96017,
    .95794,
    .77892,
    .85162,
    .77892,
    .78257,
    .79492,
    .78257,
    .79492,
    .78257,
    .79492,
    .9297,
    .56892,
    .83908,
    .88762,
    .77539,
    .8715,
    .87508,
    .89049,
    1,
    1,
    .81055,
    1.04106,
    1.20528,
    1.20528,
    1,
    1.15543,
    .70674,
    .98387,
    .94721,
    1.33431,
    1.45894,
    .95161,
    1.06303,
    .83908,
    .80352,
    .57184,
    .6965,
    .56289,
    .82001,
    .56029,
    .81235,
    1.02988,
    .83908,
    .7762,
    .68156,
    .80367,
    .73133,
    .78257,
    .87356,
    .86943,
    .95958,
    .75727,
    .89019,
    1.04924,
    .9121,
    .7648,
    .86943,
    .87356,
    .79795,
    .78275,
    .81055,
    .77892,
    .9762,
    .82577,
    .99819,
    .84896,
    .95958,
    .77892,
    .96108,
    1.01407,
    .89049,
    1.02988,
    .94211,
    .96108,
    .8936,
    .84021,
    .87842,
    .96399,
    .79109,
    .89049,
    1.00813,
    1.02988,
    .86077,
    .87445,
    .92099,
    .84723,
    .86513,
    .8801,
    .75638,
    .85714,
    .78216,
    .79586,
    .87965,
    .94211,
    .97747,
    .78287,
    .97926,
    .84971,
    1.02988,
    .94211,
    .8801,
    .94211,
    .84971,
    .73133,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90264,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90518,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90548,
    1,
    1,
    1,
    1,
    1,
    1,
    .96017,
    .95794,
    .96017,
    .95794,
    .96017,
    .95794,
    .77892,
    .85162,
    1,
    1,
    .89552,
    .90527,
    1,
    .90363,
    .92794,
    .92794,
    .92794,
    .92794,
    .87012,
    .87012,
    .87012,
    .89552,
    .89552,
    1.42259,
    .71143,
    1.06152,
    1,
    1,
    1.03372,
    1.03372,
    .97171,
    1.4956,
    2.2807,
    .93835,
    .83406,
    .91133,
    .84107,
    .91133,
    1,
    1,
    1,
    .72021,
    1,
    1.23108,
    .83489,
    .88525,
    .88525,
    .81499,
    .90527,
    1.81055,
    .90527,
    1.81055,
    1.31006,
    1.53711,
    .94434,
    1.08696,
    1,
    .95018,
    .77192,
    .85284,
    .90747,
    1.17534,
    .69825,
    .9716,
    1.37077,
    .90747,
    .90747,
    .85356,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.08004,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90727,
    .90727,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], ua = {
    lineHeight: 1.2207,
    lineGap: .2207
}, da = [
    1.3877,
    1,
    1,
    1,
    .97801,
    .92482,
    .89552,
    .91133,
    .81988,
    .97566,
    .98152,
    .93548,
    .93548,
    1.2798,
    .85284,
    .92794,
    1,
    .96134,
    1.56239,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .82845,
    .82845,
    .85284,
    .85284,
    .85284,
    .75859,
    .92138,
    .83908,
    .7762,
    .71805,
    .87289,
    .73133,
    .7514,
    .81921,
    .87356,
    .95958,
    .59526,
    .75727,
    .69225,
    1.04924,
    .90872,
    .85938,
    .79795,
    .87068,
    .77958,
    .69766,
    .81055,
    .90399,
    .88653,
    .96068,
    .82577,
    .77892,
    .78257,
    .97507,
    1.529,
    .97507,
    .85284,
    .89552,
    .90176,
    .94908,
    .86411,
    .74012,
    .86411,
    .88323,
    .95015,
    .86411,
    .86331,
    .88401,
    .91916,
    .86304,
    .88401,
    .9039,
    .86331,
    .86331,
    .86411,
    .86411,
    .90464,
    .70852,
    1.04106,
    .86331,
    .84372,
    .95794,
    .82616,
    .84548,
    .79492,
    .88331,
    1.69808,
    .88331,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.7801,
    .89552,
    1.24487,
    1.13254,
    1.19129,
    .96839,
    .85284,
    .68787,
    .70645,
    .85592,
    .90747,
    1.01466,
    1.0088,
    .90323,
    1,
    1.07463,
    1,
    .91056,
    .75806,
    1.19118,
    .96839,
    .78864,
    .82845,
    .84133,
    .75859,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .77539,
    .71805,
    .73133,
    .73133,
    .73133,
    .73133,
    .95958,
    .95958,
    .95958,
    .95958,
    .88506,
    .90872,
    .85938,
    .85938,
    .85938,
    .85938,
    .85938,
    .85284,
    .87068,
    .90399,
    .90399,
    .90399,
    .90399,
    .77892,
    .79795,
    .90807,
    .94908,
    .94908,
    .94908,
    .94908,
    .94908,
    .94908,
    .85887,
    .74012,
    .88323,
    .88323,
    .88323,
    .88323,
    .88401,
    .88401,
    .88401,
    .88401,
    .8785,
    .86331,
    .86331,
    .86331,
    .86331,
    .86331,
    .86331,
    .90747,
    .89049,
    .86331,
    .86331,
    .86331,
    .86331,
    .84548,
    .86411,
    .84548,
    .83908,
    .94908,
    .83908,
    .94908,
    .83908,
    .94908,
    .71805,
    .74012,
    .71805,
    .74012,
    .71805,
    .74012,
    .71805,
    .74012,
    .87289,
    .79538,
    .88506,
    .92726,
    .73133,
    .88323,
    .73133,
    .88323,
    .73133,
    .88323,
    .73133,
    .88323,
    .73133,
    .88323,
    .81921,
    .86411,
    .81921,
    .86411,
    .81921,
    .86411,
    1,
    1,
    .87356,
    .86331,
    .91075,
    .8777,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .76467,
    .90167,
    .59526,
    .91916,
    1,
    1,
    .86304,
    .69225,
    .88401,
    1,
    1,
    .70424,
    .77312,
    .91926,
    .88175,
    .70823,
    .94903,
    .90872,
    .86331,
    1,
    1,
    .90872,
    .86331,
    .86906,
    .88116,
    .86331,
    .85938,
    .86331,
    .85938,
    .86331,
    .85938,
    .86331,
    .87402,
    .86549,
    .77958,
    .90464,
    1,
    1,
    .77958,
    .90464,
    .69766,
    .70852,
    .69766,
    .70852,
    .69766,
    .70852,
    .69766,
    .70852,
    1,
    1,
    .81055,
    .75841,
    .81055,
    1.06452,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .96068,
    .95794,
    .77892,
    .84548,
    .77892,
    .78257,
    .79492,
    .78257,
    .79492,
    .78257,
    .79492,
    .9297,
    .56892,
    .83908,
    .94908,
    .77539,
    .85887,
    .87068,
    .89049,
    1,
    1,
    .81055,
    1.04106,
    1.20528,
    1.20528,
    1,
    1.15543,
    .70088,
    .98387,
    .94721,
    1.33431,
    1.45894,
    .95161,
    1.48387,
    .83908,
    .80352,
    .57118,
    .6965,
    .56347,
    .79179,
    .55853,
    .80346,
    1.02988,
    .83908,
    .7762,
    .67174,
    .86036,
    .73133,
    .78257,
    .87356,
    .86441,
    .95958,
    .75727,
    .89019,
    1.04924,
    .90872,
    .74889,
    .85938,
    .87891,
    .79795,
    .7957,
    .81055,
    .77892,
    .97447,
    .82577,
    .97466,
    .87179,
    .95958,
    .77892,
    .94252,
    .95612,
    .8753,
    1.02988,
    .92733,
    .94252,
    .87411,
    .84021,
    .8728,
    .95612,
    .74081,
    .8753,
    1.02189,
    1.02988,
    .84814,
    .87445,
    .91822,
    .84723,
    .85668,
    .86331,
    .81344,
    .87581,
    .76422,
    .82046,
    .96057,
    .92733,
    .99375,
    .78022,
    .95452,
    .86015,
    1.02988,
    .92733,
    .86331,
    .92733,
    .86015,
    .73133,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90631,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .88323,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .85174,
    1,
    1,
    1,
    1,
    1,
    1,
    .96068,
    .95794,
    .96068,
    .95794,
    .96068,
    .95794,
    .77892,
    .84548,
    1,
    1,
    .89552,
    .90527,
    1,
    .90363,
    .92794,
    .92794,
    .92794,
    .89807,
    .87012,
    .87012,
    .87012,
    .89552,
    .89552,
    1.42259,
    .71094,
    1.06152,
    1,
    1,
    1.03372,
    1.03372,
    .97171,
    1.4956,
    2.2807,
    .92972,
    .83406,
    .91133,
    .83326,
    .91133,
    1,
    1,
    1,
    .72021,
    1,
    1.23108,
    .83489,
    .88525,
    .88525,
    .81499,
    .90616,
    1.81055,
    .90527,
    1.81055,
    1.3107,
    1.53711,
    .94434,
    1.08696,
    1,
    .95018,
    .77192,
    .85284,
    .90747,
    1.17534,
    .69825,
    .9716,
    1.37077,
    .90747,
    .90747,
    .85356,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.08004,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90727,
    .90727,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], fa = {
    lineHeight: 1.2207,
    lineGap: .2207
}, pa = [
    1.3877,
    1,
    1,
    1,
    1.17223,
    1.1293,
    .89552,
    .91133,
    .80395,
    1.02269,
    1.15601,
    .91056,
    .91056,
    1.2798,
    .85284,
    .89807,
    1,
    .90861,
    1.39543,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .96309,
    .96309,
    .85284,
    .85284,
    .85284,
    .83319,
    .88071,
    .8675,
    .81552,
    .72346,
    .85193,
    .73206,
    .7522,
    .81105,
    .86275,
    .90685,
    .6377,
    .77892,
    .75593,
    1.02638,
    .89249,
    .84118,
    .77452,
    .85374,
    .75186,
    .67789,
    .79776,
    .88844,
    .85066,
    .94309,
    .77818,
    .7306,
    .76659,
    1.10369,
    1.38313,
    1.10369,
    1.06139,
    .89552,
    .8739,
    .9245,
    .9245,
    .83203,
    .9245,
    .85865,
    1.09842,
    .9245,
    .9245,
    1.03297,
    1.07692,
    .90918,
    1.03297,
    .94959,
    .9245,
    .92274,
    .9245,
    .9245,
    1.02933,
    .77832,
    1.20562,
    .9245,
    .8916,
    .98986,
    .86621,
    .89453,
    .79004,
    .94152,
    1.77256,
    .94152,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.91729,
    .89552,
    1.17889,
    1.13254,
    1.16359,
    .92098,
    .85284,
    .68787,
    .71353,
    .84737,
    .90747,
    1.0088,
    1.0044,
    .87683,
    1,
    1.09091,
    1,
    .92229,
    .739,
    1.15642,
    .92098,
    .76288,
    .80504,
    .80972,
    .75859,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .76318,
    .72346,
    .73206,
    .73206,
    .73206,
    .73206,
    .90685,
    .90685,
    .90685,
    .90685,
    .86477,
    .89249,
    .84118,
    .84118,
    .84118,
    .84118,
    .84118,
    .85284,
    .84557,
    .88844,
    .88844,
    .88844,
    .88844,
    .7306,
    .77452,
    .86331,
    .9245,
    .9245,
    .9245,
    .9245,
    .9245,
    .9245,
    .84843,
    .83203,
    .85865,
    .85865,
    .85865,
    .85865,
    .82601,
    .82601,
    .82601,
    .82601,
    .94469,
    .9245,
    .92274,
    .92274,
    .92274,
    .92274,
    .92274,
    .90747,
    .86651,
    .9245,
    .9245,
    .9245,
    .9245,
    .89453,
    .9245,
    .89453,
    .8675,
    .9245,
    .8675,
    .9245,
    .8675,
    .9245,
    .72346,
    .83203,
    .72346,
    .83203,
    .72346,
    .83203,
    .72346,
    .83203,
    .85193,
    .8875,
    .86477,
    .99034,
    .73206,
    .85865,
    .73206,
    .85865,
    .73206,
    .85865,
    .73206,
    .85865,
    .73206,
    .85865,
    .81105,
    .9245,
    .81105,
    .9245,
    .81105,
    .9245,
    1,
    1,
    .86275,
    .9245,
    .90872,
    .93591,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    1.03297,
    .90685,
    .82601,
    .77896,
    1.05611,
    .6377,
    1.07692,
    1,
    1,
    .90918,
    .75593,
    1.03297,
    1,
    1,
    .76032,
    .9375,
    .98156,
    .93407,
    .77261,
    1.11429,
    .89249,
    .9245,
    1,
    1,
    .89249,
    .9245,
    .92534,
    .86698,
    .9245,
    .84118,
    .92274,
    .84118,
    .92274,
    .84118,
    .92274,
    .8667,
    .86291,
    .75186,
    1.02933,
    1,
    1,
    .75186,
    1.02933,
    .67789,
    .77832,
    .67789,
    .77832,
    .67789,
    .77832,
    .67789,
    .77832,
    1,
    1,
    .79776,
    .97655,
    .79776,
    1.23023,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .94309,
    .98986,
    .7306,
    .89453,
    .7306,
    .76659,
    .79004,
    .76659,
    .79004,
    .76659,
    .79004,
    1.09231,
    .54873,
    .8675,
    .9245,
    .76318,
    .84843,
    .84557,
    .86651,
    1,
    1,
    .79776,
    1.20562,
    1.18622,
    1.18622,
    1,
    1.1437,
    .67009,
    .96334,
    .93695,
    1.35191,
    1.40909,
    .95161,
    1.48387,
    .8675,
    .90861,
    .6192,
    .7363,
    .64824,
    .82411,
    .56321,
    .85696,
    1.23516,
    .8675,
    .81552,
    .7286,
    .84134,
    .73206,
    .76659,
    .86275,
    .84369,
    .90685,
    .77892,
    .85871,
    1.02638,
    .89249,
    .75828,
    .84118,
    .85984,
    .77452,
    .76466,
    .79776,
    .7306,
    .90782,
    .77818,
    .903,
    .87291,
    .90685,
    .7306,
    .99058,
    1.03667,
    .94635,
    1.23516,
    .9849,
    .99058,
    .92393,
    .8916,
    .942,
    1.03667,
    .75026,
    .94635,
    1.0297,
    1.23516,
    .90918,
    .94048,
    .98217,
    .89746,
    .84153,
    .92274,
    .82507,
    .88832,
    .84438,
    .88178,
    1.03525,
    .9849,
    1.00225,
    .78086,
    .97248,
    .89404,
    1.23516,
    .9849,
    .92274,
    .9849,
    .89404,
    .73206,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .89693,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .85865,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90933,
    1,
    1,
    1,
    1,
    1,
    1,
    .94309,
    .98986,
    .94309,
    .98986,
    .94309,
    .98986,
    .7306,
    .89453,
    1,
    1,
    .89552,
    .90527,
    1,
    .90186,
    1.12308,
    1.12308,
    1.12308,
    1.12308,
    1.2566,
    1.2566,
    1.2566,
    .89552,
    .89552,
    1.42259,
    .68994,
    1.03809,
    1,
    1,
    1.0176,
    1.0176,
    1.11523,
    1.4956,
    2.01462,
    .97858,
    .82616,
    .91133,
    .83437,
    .91133,
    1,
    1,
    1,
    .70508,
    1,
    1.23108,
    .79801,
    .84426,
    .84426,
    .774,
    .90572,
    1.81055,
    .90749,
    1.81055,
    1.28809,
    1.55469,
    .94434,
    1.07806,
    1,
    .97094,
    .7589,
    .85284,
    .90747,
    1.19658,
    .69825,
    .97622,
    1.33512,
    .90747,
    .90747,
    .85284,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.0336,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05859,
    1.05859,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], ma = {
    lineHeight: 1.2207,
    lineGap: .2207
}, ya = [
    1.3877,
    1,
    1,
    1,
    1.17223,
    1.1293,
    .89552,
    .91133,
    .80395,
    1.02269,
    1.15601,
    .91056,
    .91056,
    1.2798,
    .85284,
    .89807,
    1,
    .90861,
    1.39016,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .96309,
    .96309,
    .85284,
    .85284,
    .85284,
    .83319,
    .88071,
    .8675,
    .81552,
    .73834,
    .85193,
    .73206,
    .7522,
    .81105,
    .86275,
    .90685,
    .6377,
    .77892,
    .75593,
    1.02638,
    .89385,
    .85122,
    .77452,
    .86503,
    .75186,
    .68887,
    .79776,
    .88844,
    .85066,
    .94258,
    .77818,
    .7306,
    .76659,
    1.10369,
    1.39016,
    1.10369,
    1.06139,
    .89552,
    .8739,
    .86128,
    .94469,
    .8457,
    .94469,
    .89464,
    1.09842,
    .84636,
    .94469,
    1.03297,
    1.07692,
    .90918,
    1.03297,
    .95897,
    .94469,
    .9482,
    .94469,
    .94469,
    1.04692,
    .78223,
    1.20562,
    .94469,
    .90332,
    .98986,
    .86621,
    .90527,
    .79004,
    .94152,
    1.77256,
    .94152,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.91729,
    .89552,
    1.17889,
    1.13254,
    1.08707,
    .92098,
    .85284,
    .68787,
    .71353,
    .84737,
    .90747,
    1.0088,
    1.0044,
    .87683,
    1,
    1.09091,
    1,
    .92229,
    .739,
    1.15642,
    .92098,
    .76288,
    .80504,
    .80972,
    .75859,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .76318,
    .73834,
    .73206,
    .73206,
    .73206,
    .73206,
    .90685,
    .90685,
    .90685,
    .90685,
    .86477,
    .89385,
    .85122,
    .85122,
    .85122,
    .85122,
    .85122,
    .85284,
    .85311,
    .88844,
    .88844,
    .88844,
    .88844,
    .7306,
    .77452,
    .86331,
    .86128,
    .86128,
    .86128,
    .86128,
    .86128,
    .86128,
    .8693,
    .8457,
    .89464,
    .89464,
    .89464,
    .89464,
    .82601,
    .82601,
    .82601,
    .82601,
    .94469,
    .94469,
    .9482,
    .9482,
    .9482,
    .9482,
    .9482,
    .90747,
    .86651,
    .94469,
    .94469,
    .94469,
    .94469,
    .90527,
    .94469,
    .90527,
    .8675,
    .86128,
    .8675,
    .86128,
    .8675,
    .86128,
    .73834,
    .8457,
    .73834,
    .8457,
    .73834,
    .8457,
    .73834,
    .8457,
    .85193,
    .92454,
    .86477,
    .9921,
    .73206,
    .89464,
    .73206,
    .89464,
    .73206,
    .89464,
    .73206,
    .89464,
    .73206,
    .89464,
    .81105,
    .84636,
    .81105,
    .84636,
    .81105,
    .84636,
    1,
    1,
    .86275,
    .94469,
    .90872,
    .95786,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    1.03297,
    .90685,
    .82601,
    .77741,
    1.05611,
    .6377,
    1.07692,
    1,
    1,
    .90918,
    .75593,
    1.03297,
    1,
    1,
    .76032,
    .90452,
    .98156,
    1.11842,
    .77261,
    1.11429,
    .89385,
    .94469,
    1,
    1,
    .89385,
    .94469,
    .95877,
    .86901,
    .94469,
    .85122,
    .9482,
    .85122,
    .9482,
    .85122,
    .9482,
    .8667,
    .90016,
    .75186,
    1.04692,
    1,
    1,
    .75186,
    1.04692,
    .68887,
    .78223,
    .68887,
    .78223,
    .68887,
    .78223,
    .68887,
    .78223,
    1,
    1,
    .79776,
    .92188,
    .79776,
    1.23023,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .94258,
    .98986,
    .7306,
    .90527,
    .7306,
    .76659,
    .79004,
    .76659,
    .79004,
    .76659,
    .79004,
    1.09231,
    .54873,
    .8675,
    .86128,
    .76318,
    .8693,
    .85311,
    .86651,
    1,
    1,
    .79776,
    1.20562,
    1.18622,
    1.18622,
    1,
    1.1437,
    .67742,
    .96334,
    .93695,
    1.35191,
    1.40909,
    .95161,
    1.48387,
    .86686,
    .90861,
    .62267,
    .74359,
    .65649,
    .85498,
    .56963,
    .88254,
    1.23516,
    .8675,
    .81552,
    .75443,
    .84503,
    .73206,
    .76659,
    .86275,
    .85122,
    .90685,
    .77892,
    .85746,
    1.02638,
    .89385,
    .75657,
    .85122,
    .86275,
    .77452,
    .74171,
    .79776,
    .7306,
    .95165,
    .77818,
    .89772,
    .88831,
    .90685,
    .7306,
    .98142,
    1.02191,
    .96576,
    1.23516,
    .99018,
    .98142,
    .9236,
    .89258,
    .94035,
    1.02191,
    .78848,
    .96576,
    .9561,
    1.23516,
    .90918,
    .92578,
    .95424,
    .89746,
    .83969,
    .9482,
    .80113,
    .89442,
    .85208,
    .86155,
    .98022,
    .99018,
    1.00452,
    .81209,
    .99247,
    .89181,
    1.23516,
    .99018,
    .9482,
    .99018,
    .89181,
    .73206,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .88844,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .89464,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .96766,
    1,
    1,
    1,
    1,
    1,
    1,
    .94258,
    .98986,
    .94258,
    .98986,
    .94258,
    .98986,
    .7306,
    .90527,
    1,
    1,
    .89552,
    .90527,
    1,
    .90186,
    1.12308,
    1.12308,
    1.12308,
    1.12308,
    1.2566,
    1.2566,
    1.2566,
    .89552,
    .89552,
    1.42259,
    .69043,
    1.03809,
    1,
    1,
    1.0176,
    1.0176,
    1.11523,
    1.4956,
    2.01462,
    .99331,
    .82616,
    .91133,
    .84286,
    .91133,
    1,
    1,
    1,
    .70508,
    1,
    1.23108,
    .79801,
    .84426,
    .84426,
    .774,
    .90527,
    1.81055,
    .90527,
    1.81055,
    1.28809,
    1.55469,
    .94434,
    1.07806,
    1,
    .97094,
    .7589,
    .85284,
    .90747,
    1.19658,
    .69825,
    .97622,
    1.33512,
    .90747,
    .90747,
    .85356,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.0336,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05859,
    1.05859,
    1,
    1,
    1,
    1.07185,
    .99413,
    .96334,
    1.08065,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], wa = {
    lineHeight: 1.2207,
    lineGap: .2207
}, Da = [
    .76116,
    1,
    1,
    1.0006,
    .99998,
    .99974,
    .99973,
    .99973,
    .99982,
    .99977,
    1.00087,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.00003,
    1.00003,
    1.00003,
    1.00026,
    .9999,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    .99973,
    .99977,
    1.00026,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    .99998,
    1.0006,
    .99998,
    1.00003,
    .99973,
    .99998,
    .99973,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99998,
    1.00026,
    1.00026,
    1.0006,
    1.0006,
    .99973,
    1.0006,
    .99982,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99959,
    .99973,
    .99998,
    1.00026,
    .99973,
    1.00022,
    .99973,
    .99973,
    1,
    .99959,
    1.00077,
    .99959,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.00077,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .99973,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.06409,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    1.03374,
    .99977,
    1.00026,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00042,
    .99973,
    .99973,
    1.0006,
    .99977,
    .99973,
    .99973,
    1.00026,
    1.0006,
    1.00026,
    1.0006,
    1.00026,
    1.03828,
    1.00026,
    .99999,
    1.00026,
    1.0006,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .9993,
    .9998,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1,
    1.00016,
    .99977,
    .99959,
    .99977,
    .99959,
    .99977,
    .99959,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00026,
    .99998,
    1.00026,
    .8121,
    1.00026,
    .99998,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    1.0006,
    .99973,
    .99977,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    .99973,
    1.00026,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    1.00034,
    .99977,
    1,
    .99997,
    1.00026,
    1.00078,
    1.00036,
    .99973,
    1.00013,
    1.0006,
    .99977,
    .99977,
    .99988,
    .85148,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    .99977,
    1.00001,
    .99999,
    .99977,
    1.00069,
    1.00022,
    .99977,
    1.00001,
    .99984,
    1.00026,
    1.00001,
    1.00024,
    1.00001,
    .9999,
    1,
    1.0006,
    1.00001,
    1.00041,
    .99962,
    1.00026,
    1.0006,
    .99995,
    1.00041,
    .99942,
    .99973,
    .99927,
    1.00082,
    .99902,
    1.00026,
    1.00087,
    1.0006,
    1.00069,
    .99973,
    .99867,
    .99973,
    .9993,
    1.00026,
    1.00049,
    1.00056,
    1,
    .99988,
    .99935,
    .99995,
    .99954,
    1.00055,
    .99945,
    1.00032,
    1.0006,
    .99995,
    1.00026,
    .99995,
    1.00032,
    1.00001,
    1.00008,
    .99971,
    1.00019,
    .9994,
    1.00001,
    1.0006,
    1.00044,
    .99973,
    1.00023,
    1.00047,
    1,
    .99942,
    .99561,
    .99989,
    1.00035,
    .99977,
    1.00035,
    .99977,
    1.00019,
    .99944,
    1.00001,
    1.00021,
    .99926,
    1.00035,
    1.00035,
    .99942,
    1.00048,
    .99999,
    .99977,
    1.00022,
    1.00035,
    1.00001,
    .99977,
    1.00026,
    .99989,
    1.00057,
    1.00001,
    .99936,
    1.00052,
    1.00012,
    .99996,
    1.00043,
    1,
    1.00035,
    .9994,
    .99976,
    1.00035,
    .99973,
    1.00052,
    1.00041,
    1.00119,
    1.00037,
    .99973,
    1.00002,
    .99986,
    1.00041,
    1.00041,
    .99902,
    .9996,
    1.00034,
    .99999,
    1.00026,
    .99999,
    1.00026,
    .99973,
    1.00052,
    .99973,
    1,
    .99973,
    1.00041,
    1.00075,
    .9994,
    1.0003,
    .99999,
    1,
    1.00041,
    .99955,
    1,
    .99915,
    .99973,
    .99973,
    1.00026,
    1.00119,
    .99955,
    .99973,
    1.0006,
    .99911,
    1.0006,
    1.00026,
    .99972,
    1.00026,
    .99902,
    1.00041,
    .99973,
    .99999,
    1,
    1,
    1.00038,
    1.0005,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1,
    1,
    1,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00106,
    .99999,
    .99998,
    .99998,
    .99999,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1.00023,
    .99973,
    .99971,
    1.00047,
    1.00023,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99972,
    1,
    1.20985,
    1.39713,
    1.00003,
    1.00031,
    1.00015,
    1,
    .99561,
    1.00027,
    1.00031,
    1.00031,
    .99915,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99972,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99998,
    .99998,
    .99998,
    .99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], ba = {
    lineHeight: 1.2,
    lineGap: .2
}, Fa = [
    .76116,
    1,
    1,
    1.0006,
    .99998,
    .99974,
    .99973,
    .99973,
    .99982,
    .99977,
    1.00087,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.00003,
    1.00003,
    1.00003,
    1.00026,
    .9999,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    .99973,
    .99977,
    1.00026,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    .99998,
    1.0006,
    .99998,
    1.00003,
    .99973,
    .99998,
    .99973,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99998,
    1.00026,
    1.00026,
    1.0006,
    1.0006,
    .99973,
    1.0006,
    .99982,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99959,
    .99973,
    .99998,
    1.00026,
    .99973,
    1.00022,
    .99973,
    .99973,
    1,
    .99959,
    1.00077,
    .99959,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.00077,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .99973,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.06409,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    1.0044,
    .99977,
    1.00026,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99971,
    .99973,
    .99973,
    1.0006,
    .99977,
    .99973,
    .99973,
    1.00026,
    1.0006,
    1.00026,
    1.0006,
    1.00026,
    1.01011,
    1.00026,
    .99999,
    1.00026,
    1.0006,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .9993,
    .9998,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1,
    1.00016,
    .99977,
    .99959,
    .99977,
    .99959,
    .99977,
    .99959,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00026,
    .99998,
    1.00026,
    .8121,
    1.00026,
    .99998,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    1.0006,
    .99973,
    .99977,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    .99973,
    1.00026,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99977,
    1,
    1,
    1.00026,
    .99969,
    .99972,
    .99981,
    .9998,
    1.0006,
    .99977,
    .99977,
    1.00022,
    .91155,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    .99977,
    1.00001,
    .99999,
    .99977,
    .99966,
    1.00022,
    1.00032,
    1.00001,
    .99944,
    1.00026,
    1.00001,
    .99968,
    1.00001,
    1.00047,
    1,
    1.0006,
    1.00001,
    .99981,
    1.00101,
    1.00026,
    1.0006,
    .99948,
    .99981,
    1.00064,
    .99973,
    .99942,
    1.00101,
    1.00061,
    1.00026,
    1.00069,
    1.0006,
    1.00014,
    .99973,
    1.01322,
    .99973,
    1.00065,
    1.00026,
    1.00012,
    .99923,
    1,
    1.00064,
    1.00076,
    .99948,
    1.00055,
    1.00063,
    1.00007,
    .99943,
    1.0006,
    .99948,
    1.00026,
    .99948,
    .99943,
    1.00001,
    1.00001,
    1.00029,
    1.00038,
    1.00035,
    1.00001,
    1.0006,
    1.0006,
    .99973,
    .99978,
    1.00001,
    1.00057,
    .99989,
    .99967,
    .99964,
    .99967,
    .99977,
    .99999,
    .99977,
    1.00038,
    .99977,
    1.00001,
    .99973,
    1.00066,
    .99967,
    .99967,
    1.00041,
    .99998,
    .99999,
    .99977,
    1.00022,
    .99967,
    1.00001,
    .99977,
    1.00026,
    .99964,
    1.00031,
    1.00001,
    .99999,
    .99999,
    1,
    1.00023,
    1,
    1,
    .99999,
    1.00035,
    1.00001,
    .99999,
    .99973,
    .99977,
    .99999,
    1.00058,
    .99973,
    .99973,
    .99955,
    .9995,
    1.00026,
    1.00026,
    1.00032,
    .99989,
    1.00034,
    .99999,
    1.00026,
    1.00026,
    1.00026,
    .99973,
    .45998,
    .99973,
    1.00026,
    .99973,
    1.00001,
    .99999,
    .99982,
    .99994,
    .99996,
    1,
    1.00042,
    1.00044,
    1.00029,
    1.00023,
    .99973,
    .99973,
    1.00026,
    .99949,
    1.00002,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    .99975,
    1.00026,
    1.00026,
    1.00032,
    .98685,
    .99973,
    1.00026,
    1,
    1,
    .99966,
    1.00044,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1,
    1,
    1,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00106,
    .99999,
    .99998,
    .99998,
    .99999,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1,
    .99973,
    .99971,
    .99978,
    1,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1.00098,
    1,
    1,
    1,
    1.00049,
    1,
    1,
    .99972,
    1,
    1.20985,
    1.39713,
    1.00003,
    1.00031,
    1.00015,
    1,
    .99561,
    1.00027,
    1.00031,
    1.00031,
    .99915,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99972,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99998,
    .99998,
    .99998,
    .99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Sa = {
    lineHeight: 1.35,
    lineGap: .2
}, ka = [
    .76116,
    1,
    1,
    1.0006,
    1.0006,
    1.00006,
    .99973,
    .99973,
    .99982,
    1.00001,
    1.00043,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1,
    1.00003,
    1.00003,
    1.00003,
    .99973,
    .99987,
    1.00001,
    1.00001,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    1,
    1.00001,
    .99973,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    .99949,
    .99973,
    .99998,
    .99973,
    .99973,
    1,
    .99973,
    .99973,
    1.0006,
    .99973,
    .99973,
    .99924,
    .99924,
    1,
    .99924,
    .99999,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.0006,
    .99973,
    1,
    .99977,
    1,
    1,
    1,
    1.00005,
    1.0009,
    1.00005,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0009,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .9998,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    1,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.06409,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    1,
    .99973,
    1,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1.0288,
    .99977,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99924,
    1.0006,
    1.0006,
    .99946,
    1.00034,
    1,
    .99924,
    1.00001,
    1,
    1,
    .99973,
    .99924,
    .99973,
    .99924,
    .99973,
    1.06311,
    .99973,
    1.00024,
    .99973,
    .99924,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.00041,
    .9998,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1,
    1.00016,
    .99977,
    .99998,
    .99977,
    .99998,
    .99977,
    .99998,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00026,
    1.0006,
    1.00026,
    .89547,
    1.00026,
    1.0006,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.00016,
    .99977,
    1.00001,
    1,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    .99924,
    .99973,
    1.00001,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    1,
    1.00026,
    1.0006,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    1.00001,
    1,
    1.00054,
    .99977,
    1.00084,
    1.00007,
    .99973,
    1.00013,
    .99924,
    1.00001,
    1.00001,
    .99945,
    .91221,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    1.00001,
    1.00001,
    .99999,
    .99977,
    .99933,
    1.00022,
    1.00054,
    1.00001,
    1.00065,
    1.00026,
    1.00001,
    1.0001,
    1.00001,
    1.00052,
    1,
    1.0006,
    1.00001,
    .99945,
    .99897,
    .99968,
    .99924,
    1.00036,
    .99945,
    .99949,
    1,
    1.0006,
    .99897,
    .99918,
    .99968,
    .99911,
    .99924,
    1,
    .99962,
    1.01487,
    1,
    1.0005,
    .99973,
    1.00012,
    1.00043,
    1,
    .99995,
    .99994,
    1.00036,
    .99947,
    1.00019,
    1.00063,
    1.00025,
    .99924,
    1.00036,
    .99973,
    1.00036,
    1.00025,
    1.00001,
    1.00001,
    1.00027,
    1.0001,
    1.00068,
    1.00001,
    1.0006,
    1.0006,
    1,
    1.00008,
    .99957,
    .99972,
    .9994,
    .99954,
    .99975,
    1.00051,
    1.00001,
    1.00019,
    1.00001,
    1.0001,
    .99986,
    1.00001,
    1.00001,
    1.00038,
    .99954,
    .99954,
    .9994,
    1.00066,
    .99999,
    .99977,
    1.00022,
    1.00054,
    1.00001,
    .99977,
    1.00026,
    .99975,
    1.0001,
    1.00001,
    .99993,
    .9995,
    .99955,
    1.00016,
    .99978,
    .99974,
    1.00019,
    1.00022,
    .99955,
    1.00053,
    .99973,
    1.00089,
    1.00005,
    .99967,
    1.00048,
    .99973,
    1.00002,
    1.00034,
    .99973,
    .99973,
    .99964,
    1.00006,
    1.00066,
    .99947,
    .99973,
    .98894,
    .99973,
    1,
    .44898,
    1,
    .99946,
    1,
    1.00039,
    1.00082,
    .99991,
    .99991,
    .99985,
    1.00022,
    1.00023,
    1.00061,
    1.00006,
    .99966,
    .99973,
    .99973,
    .99973,
    1.00019,
    1.0008,
    1,
    .99924,
    .99924,
    .99924,
    .99983,
    1.00044,
    .99973,
    .99964,
    .98332,
    1,
    .99973,
    1,
    1,
    .99962,
    .99895,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00001,
    1,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    .99924,
    .99924,
    .99924,
    .99924,
    .99998,
    .99998,
    .99998,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00267,
    .99999,
    .99998,
    .99998,
    1,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1.00023,
    .99973,
    1.00423,
    .99925,
    .99999,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1.00049,
    1,
    1.00245,
    1,
    1,
    1,
    1,
    .96329,
    1,
    1.20985,
    1.39713,
    1.00003,
    .8254,
    1.00015,
    1,
    1.00035,
    1.00027,
    1.00031,
    1.00031,
    1.00003,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .95317,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99998,
    .99998,
    .99998,
    .99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ra = {
    lineHeight: 1.35,
    lineGap: .2
}, Na = [
    .76116,
    1,
    1,
    1.0006,
    1.0006,
    1.00006,
    .99973,
    .99973,
    .99982,
    1.00001,
    1.00043,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1,
    1.00003,
    1.00003,
    1.00003,
    .99973,
    .99987,
    1.00001,
    1.00001,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    1,
    1.00001,
    .99973,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    .99949,
    .99973,
    .99998,
    .99973,
    .99973,
    1,
    .99973,
    .99973,
    1.0006,
    .99973,
    .99973,
    .99924,
    .99924,
    1,
    .99924,
    .99999,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.0006,
    .99973,
    1,
    .99977,
    1,
    1,
    1,
    1.00005,
    1.0009,
    1.00005,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0009,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .9998,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    1,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.06409,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    1,
    .99973,
    1,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1.04596,
    .99977,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99924,
    1.0006,
    1.0006,
    1.00019,
    1.00034,
    1,
    .99924,
    1.00001,
    1,
    1,
    .99973,
    .99924,
    .99973,
    .99924,
    .99973,
    1.02572,
    .99973,
    1.00005,
    .99973,
    .99924,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99999,
    .9998,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1,
    1.00016,
    .99977,
    .99998,
    .99977,
    .99998,
    .99977,
    .99998,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00026,
    1.0006,
    1.00026,
    .84533,
    1.00026,
    1.0006,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.00016,
    .99977,
    1.00001,
    1,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    .99924,
    .99973,
    1.00001,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    1,
    1.00026,
    1.0006,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99928,
    1,
    .99977,
    1.00013,
    1.00055,
    .99947,
    .99945,
    .99941,
    .99924,
    1.00001,
    1.00001,
    1.0004,
    .91621,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    1.00001,
    1.00005,
    .99999,
    .99977,
    1.00015,
    1.00022,
    .99977,
    1.00001,
    .99973,
    1.00026,
    1.00001,
    1.00019,
    1.00001,
    .99946,
    1,
    1.0006,
    1.00001,
    .99978,
    1.00045,
    .99973,
    .99924,
    1.00023,
    .99978,
    .99966,
    1,
    1.00065,
    1.00045,
    1.00019,
    .99973,
    .99973,
    .99924,
    1,
    1,
    .96499,
    1,
    1.00055,
    .99973,
    1.00008,
    1.00027,
    1,
    .9997,
    .99995,
    1.00023,
    .99933,
    1.00019,
    1.00015,
    1.00031,
    .99924,
    1.00023,
    .99973,
    1.00023,
    1.00031,
    1.00001,
    .99928,
    1.00029,
    1.00092,
    1.00035,
    1.00001,
    1.0006,
    1.0006,
    1,
    .99988,
    .99975,
    1,
    1.00082,
    .99561,
    .9996,
    1.00035,
    1.00001,
    .99962,
    1.00001,
    1.00092,
    .99964,
    1.00001,
    .99963,
    .99999,
    1.00035,
    1.00035,
    1.00082,
    .99962,
    .99999,
    .99977,
    1.00022,
    1.00035,
    1.00001,
    .99977,
    1.00026,
    .9996,
    .99967,
    1.00001,
    1.00034,
    1.00074,
    1.00054,
    1.00053,
    1.00063,
    .99971,
    .99962,
    1.00035,
    .99975,
    .99977,
    .99973,
    1.00043,
    .99953,
    1.0007,
    .99915,
    .99973,
    1.00008,
    .99892,
    1.00073,
    1.00073,
    1.00114,
    .99915,
    1.00073,
    .99955,
    .99973,
    1.00092,
    .99973,
    1,
    .99998,
    1,
    1.0003,
    1,
    1.00043,
    1.00001,
    .99969,
    1.0003,
    1,
    1.00035,
    1.00001,
    .9995,
    1,
    1.00092,
    .99973,
    .99973,
    .99973,
    1.0007,
    .9995,
    1,
    .99924,
    1.0006,
    .99924,
    .99972,
    1.00062,
    .99973,
    1.00114,
    1.00073,
    1,
    .99955,
    1,
    1,
    1.00047,
    .99968,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00001,
    1,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    .99924,
    .99924,
    .99924,
    .99924,
    .99998,
    .99998,
    .99998,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00267,
    .99999,
    .99998,
    .99998,
    1,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1.00023,
    .99973,
    .99971,
    .99925,
    1.00023,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .96329,
    1,
    1.20985,
    1.39713,
    1.00003,
    .8254,
    1.00015,
    1,
    1.00035,
    1.00027,
    1.00031,
    1.00031,
    .99915,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .95317,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ga = {
    lineHeight: 1.2,
    lineGap: .2
}, Ma = [
    365,
    0,
    333,
    278,
    333,
    474,
    556,
    556,
    889,
    722,
    238,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    333,
    333,
    584,
    584,
    584,
    611,
    975,
    722,
    722,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    556,
    722,
    611,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    333,
    278,
    333,
    584,
    556,
    333,
    556,
    611,
    556,
    611,
    556,
    333,
    611,
    611,
    278,
    278,
    556,
    278,
    889,
    611,
    611,
    611,
    611,
    389,
    556,
    333,
    611,
    556,
    778,
    556,
    556,
    500,
    389,
    280,
    389,
    584,
    333,
    556,
    556,
    556,
    556,
    280,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    556,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    722,
    722,
    722,
    722,
    722,
    722,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    611,
    611,
    611,
    611,
    611,
    611,
    611,
    549,
    611,
    611,
    611,
    611,
    611,
    556,
    611,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    719,
    722,
    611,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    722,
    611,
    722,
    611,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    785,
    556,
    556,
    278,
    722,
    556,
    556,
    611,
    278,
    611,
    278,
    611,
    385,
    611,
    479,
    611,
    278,
    722,
    611,
    722,
    611,
    722,
    611,
    708,
    723,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    1e3,
    944,
    722,
    389,
    722,
    389,
    722,
    389,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    611,
    333,
    611,
    479,
    611,
    333,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    944,
    778,
    667,
    556,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    278,
    556,
    722,
    556,
    1e3,
    889,
    778,
    611,
    667,
    556,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    465,
    722,
    333,
    853,
    906,
    474,
    825,
    927,
    838,
    278,
    722,
    722,
    601,
    719,
    667,
    611,
    722,
    778,
    278,
    722,
    667,
    833,
    722,
    644,
    778,
    722,
    667,
    600,
    611,
    667,
    821,
    667,
    809,
    802,
    278,
    667,
    615,
    451,
    611,
    278,
    582,
    615,
    610,
    556,
    606,
    475,
    460,
    611,
    541,
    278,
    558,
    556,
    612,
    556,
    445,
    611,
    766,
    619,
    520,
    684,
    446,
    582,
    715,
    576,
    753,
    845,
    278,
    582,
    611,
    582,
    845,
    667,
    669,
    885,
    567,
    711,
    667,
    278,
    276,
    556,
    1094,
    1062,
    875,
    610,
    722,
    622,
    719,
    722,
    719,
    722,
    567,
    712,
    667,
    904,
    626,
    719,
    719,
    610,
    702,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    622,
    854,
    667,
    730,
    703,
    1005,
    1019,
    870,
    979,
    719,
    711,
    1031,
    719,
    556,
    618,
    615,
    417,
    635,
    556,
    709,
    497,
    615,
    615,
    500,
    635,
    740,
    604,
    611,
    604,
    611,
    556,
    490,
    556,
    875,
    556,
    615,
    581,
    833,
    844,
    729,
    854,
    615,
    552,
    854,
    583,
    556,
    556,
    611,
    417,
    552,
    556,
    278,
    281,
    278,
    969,
    906,
    611,
    500,
    615,
    556,
    604,
    778,
    611,
    487,
    447,
    944,
    778,
    944,
    778,
    944,
    778,
    667,
    556,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    278,
    278,
    278,
    278,
    500,
    500,
    500,
    556,
    556,
    350,
    1e3,
    1e3,
    240,
    479,
    333,
    333,
    604,
    333,
    167,
    396,
    556,
    556,
    1094,
    556,
    885,
    489,
    1115,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    722,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    611,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333
], Ua = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], xa = [
    365,
    0,
    333,
    278,
    333,
    474,
    556,
    556,
    889,
    722,
    238,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    333,
    333,
    584,
    584,
    584,
    611,
    975,
    722,
    722,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    556,
    722,
    611,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    333,
    278,
    333,
    584,
    556,
    333,
    556,
    611,
    556,
    611,
    556,
    333,
    611,
    611,
    278,
    278,
    556,
    278,
    889,
    611,
    611,
    611,
    611,
    389,
    556,
    333,
    611,
    556,
    778,
    556,
    556,
    500,
    389,
    280,
    389,
    584,
    333,
    556,
    556,
    556,
    556,
    280,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    556,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    722,
    722,
    722,
    722,
    722,
    722,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    611,
    611,
    611,
    611,
    611,
    611,
    611,
    549,
    611,
    611,
    611,
    611,
    611,
    556,
    611,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    740,
    722,
    611,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    722,
    611,
    722,
    611,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    782,
    556,
    556,
    278,
    722,
    556,
    556,
    611,
    278,
    611,
    278,
    611,
    396,
    611,
    479,
    611,
    278,
    722,
    611,
    722,
    611,
    722,
    611,
    708,
    723,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    1e3,
    944,
    722,
    389,
    722,
    389,
    722,
    389,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    611,
    333,
    611,
    479,
    611,
    333,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    944,
    778,
    667,
    556,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    278,
    556,
    722,
    556,
    1e3,
    889,
    778,
    611,
    667,
    556,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    722,
    333,
    854,
    906,
    473,
    844,
    930,
    847,
    278,
    722,
    722,
    610,
    671,
    667,
    611,
    722,
    778,
    278,
    722,
    667,
    833,
    722,
    657,
    778,
    718,
    667,
    590,
    611,
    667,
    822,
    667,
    829,
    781,
    278,
    667,
    620,
    479,
    611,
    278,
    591,
    620,
    621,
    556,
    610,
    479,
    492,
    611,
    558,
    278,
    566,
    556,
    603,
    556,
    450,
    611,
    712,
    605,
    532,
    664,
    409,
    591,
    704,
    578,
    773,
    834,
    278,
    591,
    611,
    591,
    834,
    667,
    667,
    886,
    614,
    719,
    667,
    278,
    278,
    556,
    1094,
    1042,
    854,
    622,
    719,
    677,
    719,
    722,
    708,
    722,
    614,
    722,
    667,
    927,
    643,
    719,
    719,
    615,
    687,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    677,
    781,
    667,
    729,
    708,
    979,
    989,
    854,
    1e3,
    708,
    719,
    1042,
    729,
    556,
    619,
    604,
    534,
    618,
    556,
    736,
    510,
    611,
    611,
    507,
    622,
    740,
    604,
    611,
    611,
    611,
    556,
    889,
    556,
    885,
    556,
    646,
    583,
    889,
    935,
    707,
    854,
    594,
    552,
    865,
    589,
    556,
    556,
    611,
    469,
    563,
    556,
    278,
    278,
    278,
    969,
    906,
    611,
    507,
    619,
    556,
    611,
    778,
    611,
    575,
    467,
    944,
    778,
    944,
    778,
    944,
    778,
    667,
    556,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    278,
    278,
    278,
    278,
    500,
    500,
    500,
    556,
    556,
    350,
    1e3,
    1e3,
    240,
    479,
    333,
    333,
    604,
    333,
    167,
    396,
    556,
    556,
    1104,
    556,
    885,
    516,
    1146,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    999,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    722,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    611,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333
], La = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Ha = [
    365,
    0,
    333,
    278,
    278,
    355,
    556,
    556,
    889,
    667,
    191,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    584,
    584,
    584,
    556,
    1015,
    667,
    667,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    500,
    667,
    556,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    278,
    278,
    278,
    469,
    556,
    333,
    556,
    556,
    500,
    556,
    556,
    278,
    556,
    556,
    222,
    222,
    500,
    222,
    833,
    556,
    556,
    556,
    556,
    333,
    500,
    278,
    556,
    500,
    722,
    500,
    500,
    500,
    334,
    260,
    334,
    584,
    333,
    556,
    556,
    556,
    556,
    260,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    537,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    667,
    667,
    667,
    667,
    667,
    667,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    500,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    549,
    611,
    556,
    556,
    556,
    556,
    500,
    556,
    500,
    667,
    556,
    667,
    556,
    667,
    556,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    625,
    722,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    722,
    556,
    722,
    556,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    222,
    278,
    278,
    733,
    444,
    500,
    222,
    667,
    500,
    500,
    556,
    222,
    556,
    222,
    556,
    281,
    556,
    400,
    556,
    222,
    722,
    556,
    722,
    556,
    722,
    556,
    615,
    723,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    1e3,
    944,
    722,
    333,
    722,
    333,
    722,
    333,
    667,
    500,
    667,
    500,
    667,
    500,
    667,
    500,
    611,
    278,
    611,
    354,
    611,
    278,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    944,
    722,
    667,
    500,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    222,
    556,
    667,
    556,
    1e3,
    889,
    778,
    611,
    667,
    500,
    611,
    278,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    667,
    278,
    789,
    846,
    389,
    794,
    865,
    775,
    222,
    667,
    667,
    570,
    671,
    667,
    611,
    722,
    778,
    278,
    667,
    667,
    833,
    722,
    648,
    778,
    725,
    667,
    600,
    611,
    667,
    837,
    667,
    831,
    761,
    278,
    667,
    570,
    439,
    555,
    222,
    550,
    570,
    571,
    500,
    556,
    439,
    463,
    555,
    542,
    222,
    500,
    492,
    548,
    500,
    447,
    556,
    670,
    573,
    486,
    603,
    374,
    550,
    652,
    546,
    728,
    779,
    222,
    550,
    556,
    550,
    779,
    667,
    667,
    843,
    544,
    708,
    667,
    278,
    278,
    500,
    1066,
    982,
    844,
    589,
    715,
    639,
    724,
    667,
    651,
    667,
    544,
    704,
    667,
    917,
    614,
    715,
    715,
    589,
    686,
    833,
    722,
    778,
    725,
    667,
    722,
    611,
    639,
    795,
    667,
    727,
    673,
    920,
    923,
    805,
    886,
    651,
    694,
    1022,
    682,
    556,
    562,
    522,
    493,
    553,
    556,
    688,
    465,
    556,
    556,
    472,
    564,
    686,
    550,
    556,
    556,
    556,
    500,
    833,
    500,
    835,
    500,
    572,
    518,
    830,
    851,
    621,
    736,
    526,
    492,
    752,
    534,
    556,
    556,
    556,
    378,
    496,
    500,
    222,
    222,
    222,
    910,
    828,
    556,
    472,
    565,
    500,
    556,
    778,
    556,
    492,
    339,
    944,
    722,
    944,
    722,
    944,
    722,
    667,
    500,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    222,
    222,
    222,
    222,
    333,
    333,
    333,
    556,
    556,
    350,
    1e3,
    1e3,
    188,
    354,
    333,
    333,
    500,
    333,
    167,
    365,
    556,
    556,
    1094,
    556,
    885,
    323,
    1083,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    998,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    719,
    274,
    549,
    549,
    584,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    500,
    500,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    294,
    294,
    324,
    324,
    316,
    328,
    398,
    285
], Ja = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Ya = [
    365,
    0,
    333,
    278,
    278,
    355,
    556,
    556,
    889,
    667,
    191,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    584,
    584,
    584,
    556,
    1015,
    667,
    667,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    500,
    667,
    556,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    278,
    278,
    278,
    469,
    556,
    333,
    556,
    556,
    500,
    556,
    556,
    278,
    556,
    556,
    222,
    222,
    500,
    222,
    833,
    556,
    556,
    556,
    556,
    333,
    500,
    278,
    556,
    500,
    722,
    500,
    500,
    500,
    334,
    260,
    334,
    584,
    333,
    556,
    556,
    556,
    556,
    260,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    537,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    667,
    667,
    667,
    667,
    667,
    667,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    500,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    549,
    611,
    556,
    556,
    556,
    556,
    500,
    556,
    500,
    667,
    556,
    667,
    556,
    667,
    556,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    615,
    722,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    722,
    556,
    722,
    556,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    222,
    278,
    278,
    735,
    444,
    500,
    222,
    667,
    500,
    500,
    556,
    222,
    556,
    222,
    556,
    292,
    556,
    334,
    556,
    222,
    722,
    556,
    722,
    556,
    722,
    556,
    604,
    723,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    1e3,
    944,
    722,
    333,
    722,
    333,
    722,
    333,
    667,
    500,
    667,
    500,
    667,
    500,
    667,
    500,
    611,
    278,
    611,
    375,
    611,
    278,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    944,
    722,
    667,
    500,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    222,
    556,
    667,
    556,
    1e3,
    889,
    778,
    611,
    667,
    500,
    611,
    278,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    667,
    278,
    784,
    838,
    384,
    774,
    855,
    752,
    222,
    667,
    667,
    551,
    668,
    667,
    611,
    722,
    778,
    278,
    667,
    668,
    833,
    722,
    650,
    778,
    722,
    667,
    618,
    611,
    667,
    798,
    667,
    835,
    748,
    278,
    667,
    578,
    446,
    556,
    222,
    547,
    578,
    575,
    500,
    557,
    446,
    441,
    556,
    556,
    222,
    500,
    500,
    576,
    500,
    448,
    556,
    690,
    569,
    482,
    617,
    395,
    547,
    648,
    525,
    713,
    781,
    222,
    547,
    556,
    547,
    781,
    667,
    667,
    865,
    542,
    719,
    667,
    278,
    278,
    500,
    1057,
    1010,
    854,
    583,
    722,
    635,
    719,
    667,
    656,
    667,
    542,
    677,
    667,
    923,
    604,
    719,
    719,
    583,
    656,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    635,
    760,
    667,
    740,
    667,
    917,
    938,
    792,
    885,
    656,
    719,
    1010,
    722,
    556,
    573,
    531,
    365,
    583,
    556,
    669,
    458,
    559,
    559,
    438,
    583,
    688,
    552,
    556,
    542,
    556,
    500,
    458,
    500,
    823,
    500,
    573,
    521,
    802,
    823,
    625,
    719,
    521,
    510,
    750,
    542,
    556,
    556,
    556,
    365,
    510,
    500,
    222,
    278,
    222,
    906,
    812,
    556,
    438,
    559,
    500,
    552,
    778,
    556,
    489,
    411,
    944,
    722,
    944,
    722,
    944,
    722,
    667,
    500,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    222,
    222,
    222,
    222,
    333,
    333,
    333,
    556,
    556,
    350,
    1e3,
    1e3,
    188,
    354,
    333,
    333,
    500,
    333,
    167,
    365,
    556,
    556,
    1094,
    556,
    885,
    323,
    1073,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    719,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    500,
    500,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    294,
    294,
    324,
    324,
    316,
    328,
    398,
    285
], va = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Ka = [
    1.36898,
    1,
    1,
    .72706,
    .80479,
    .83734,
    .98894,
    .99793,
    .9897,
    .93884,
    .86209,
    .94292,
    .94292,
    1.16661,
    1.02058,
    .93582,
    .96694,
    .93582,
    1.19137,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .78076,
    .78076,
    1.02058,
    1.02058,
    1.02058,
    .72851,
    .78966,
    .90838,
    .83637,
    .82391,
    .96376,
    .80061,
    .86275,
    .8768,
    .95407,
    1.0258,
    .73901,
    .85022,
    .83655,
    1.0156,
    .95546,
    .92179,
    .87107,
    .92179,
    .82114,
    .8096,
    .89713,
    .94438,
    .95353,
    .94083,
    .91905,
    .90406,
    .9446,
    .94292,
    1.18777,
    .94292,
    1.02058,
    .89903,
    .90088,
    .94938,
    .97898,
    .81093,
    .97571,
    .94938,
    1.024,
    .9577,
    .95933,
    .98621,
    1.0474,
    .97455,
    .98981,
    .9672,
    .95933,
    .9446,
    .97898,
    .97407,
    .97646,
    .78036,
    1.10208,
    .95442,
    .95298,
    .97579,
    .9332,
    .94039,
    .938,
    .80687,
    1.01149,
    .80687,
    1.02058,
    .80479,
    .99793,
    .99793,
    .99793,
    .99793,
    1.01149,
    1.00872,
    .90088,
    .91882,
    1.0213,
    .8361,
    1.02058,
    .62295,
    .54324,
    .89022,
    1.08595,
    1,
    1,
    .90088,
    1,
    .97455,
    .93582,
    .90088,
    1,
    1.05686,
    .8361,
    .99642,
    .99642,
    .99642,
    .72851,
    .90838,
    .90838,
    .90838,
    .90838,
    .90838,
    .90838,
    .868,
    .82391,
    .80061,
    .80061,
    .80061,
    .80061,
    1.0258,
    1.0258,
    1.0258,
    1.0258,
    .97484,
    .95546,
    .92179,
    .92179,
    .92179,
    .92179,
    .92179,
    1.02058,
    .92179,
    .94438,
    .94438,
    .94438,
    .94438,
    .90406,
    .86958,
    .98225,
    .94938,
    .94938,
    .94938,
    .94938,
    .94938,
    .94938,
    .9031,
    .81093,
    .94938,
    .94938,
    .94938,
    .94938,
    .98621,
    .98621,
    .98621,
    .98621,
    .93969,
    .95933,
    .9446,
    .9446,
    .9446,
    .9446,
    .9446,
    1.08595,
    .9446,
    .95442,
    .95442,
    .95442,
    .95442,
    .94039,
    .97898,
    .94039,
    .90838,
    .94938,
    .90838,
    .94938,
    .90838,
    .94938,
    .82391,
    .81093,
    .82391,
    .81093,
    .82391,
    .81093,
    .82391,
    .81093,
    .96376,
    .84313,
    .97484,
    .97571,
    .80061,
    .94938,
    .80061,
    .94938,
    .80061,
    .94938,
    .80061,
    .94938,
    .80061,
    .94938,
    .8768,
    .9577,
    .8768,
    .9577,
    .8768,
    .9577,
    1,
    1,
    .95407,
    .95933,
    .97069,
    .95933,
    1.0258,
    .98621,
    1.0258,
    .98621,
    1.0258,
    .98621,
    1.0258,
    .98621,
    1.0258,
    .98621,
    .887,
    1.01591,
    .73901,
    1.0474,
    1,
    1,
    .97455,
    .83655,
    .98981,
    1,
    1,
    .83655,
    .73977,
    .83655,
    .73903,
    .84638,
    1.033,
    .95546,
    .95933,
    1,
    1,
    .95546,
    .95933,
    .8271,
    .95417,
    .95933,
    .92179,
    .9446,
    .92179,
    .9446,
    .92179,
    .9446,
    .936,
    .91964,
    .82114,
    .97646,
    1,
    1,
    .82114,
    .97646,
    .8096,
    .78036,
    .8096,
    .78036,
    1,
    1,
    .8096,
    .78036,
    1,
    1,
    .89713,
    .77452,
    .89713,
    1.10208,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94083,
    .97579,
    .90406,
    .94039,
    .90406,
    .9446,
    .938,
    .9446,
    .938,
    .9446,
    .938,
    1,
    .99793,
    .90838,
    .94938,
    .868,
    .9031,
    .92179,
    .9446,
    1,
    1,
    .89713,
    1.10208,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90989,
    .9358,
    .91945,
    .83181,
    .75261,
    .87992,
    .82976,
    .96034,
    .83689,
    .97268,
    1.0078,
    .90838,
    .83637,
    .8019,
    .90157,
    .80061,
    .9446,
    .95407,
    .92436,
    1.0258,
    .85022,
    .97153,
    1.0156,
    .95546,
    .89192,
    .92179,
    .92361,
    .87107,
    .96318,
    .89713,
    .93704,
    .95638,
    .91905,
    .91709,
    .92796,
    1.0258,
    .93704,
    .94836,
    1.0373,
    .95933,
    1.0078,
    .95871,
    .94836,
    .96174,
    .92601,
    .9498,
    .98607,
    .95776,
    .95933,
    1.05453,
    1.0078,
    .98275,
    .9314,
    .95617,
    .91701,
    1.05993,
    .9446,
    .78367,
    .9553,
    1,
    .86832,
    1.0128,
    .95871,
    .99394,
    .87548,
    .96361,
    .86774,
    1.0078,
    .95871,
    .9446,
    .95871,
    .86774,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .94083,
    .97579,
    .94083,
    .97579,
    .94083,
    .97579,
    .90406,
    .94039,
    .96694,
    1,
    .89903,
    1,
    1,
    1,
    .93582,
    .93582,
    .93582,
    1,
    .908,
    .908,
    .918,
    .94219,
    .94219,
    .96544,
    1,
    1.285,
    1,
    1,
    .81079,
    .81079,
    1,
    1,
    .74854,
    1,
    1,
    1,
    1,
    .99793,
    1,
    1,
    1,
    .65,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.17173,
    1,
    .80535,
    .76169,
    1.02058,
    1.0732,
    1.05486,
    1,
    1,
    1.30692,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.16161,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ta = {
    lineHeight: 1.2,
    lineGap: .2
}, qa = [
    1.36898,
    1,
    1,
    .66227,
    .80779,
    .81625,
    .97276,
    .97276,
    .97733,
    .92222,
    .83266,
    .94292,
    .94292,
    1.16148,
    1.02058,
    .93582,
    .96694,
    .93582,
    1.17337,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .78076,
    .78076,
    1.02058,
    1.02058,
    1.02058,
    .71541,
    .76813,
    .85576,
    .80591,
    .80729,
    .94299,
    .77512,
    .83655,
    .86523,
    .92222,
    .98621,
    .71743,
    .81698,
    .79726,
    .98558,
    .92222,
    .90637,
    .83809,
    .90637,
    .80729,
    .76463,
    .86275,
    .90699,
    .91605,
    .9154,
    .85308,
    .85458,
    .90531,
    .94292,
    1.21296,
    .94292,
    1.02058,
    .89903,
    1.18616,
    .99613,
    .91677,
    .78216,
    .91677,
    .90083,
    .98796,
    .9135,
    .92168,
    .95381,
    .98981,
    .95298,
    .95381,
    .93459,
    .92168,
    .91513,
    .92004,
    .91677,
    .95077,
    .748,
    1.04502,
    .91677,
    .92061,
    .94236,
    .89544,
    .89364,
    .9,
    .80687,
    .8578,
    .80687,
    1.02058,
    .80779,
    .97276,
    .97276,
    .97276,
    .97276,
    .8578,
    .99973,
    1.18616,
    .91339,
    1.08074,
    .82891,
    1.02058,
    .55509,
    .71526,
    .89022,
    1.08595,
    1,
    1,
    1.18616,
    1,
    .96736,
    .93582,
    1.18616,
    1,
    1.04864,
    .82711,
    .99043,
    .99043,
    .99043,
    .71541,
    .85576,
    .85576,
    .85576,
    .85576,
    .85576,
    .85576,
    .845,
    .80729,
    .77512,
    .77512,
    .77512,
    .77512,
    .98621,
    .98621,
    .98621,
    .98621,
    .95961,
    .92222,
    .90637,
    .90637,
    .90637,
    .90637,
    .90637,
    1.02058,
    .90251,
    .90699,
    .90699,
    .90699,
    .90699,
    .85458,
    .83659,
    .94951,
    .99613,
    .99613,
    .99613,
    .99613,
    .99613,
    .99613,
    .85811,
    .78216,
    .90083,
    .90083,
    .90083,
    .90083,
    .95381,
    .95381,
    .95381,
    .95381,
    .9135,
    .92168,
    .91513,
    .91513,
    .91513,
    .91513,
    .91513,
    1.08595,
    .91677,
    .91677,
    .91677,
    .91677,
    .91677,
    .89364,
    .92332,
    .89364,
    .85576,
    .99613,
    .85576,
    .99613,
    .85576,
    .99613,
    .80729,
    .78216,
    .80729,
    .78216,
    .80729,
    .78216,
    .80729,
    .78216,
    .94299,
    .76783,
    .95961,
    .91677,
    .77512,
    .90083,
    .77512,
    .90083,
    .77512,
    .90083,
    .77512,
    .90083,
    .77512,
    .90083,
    .86523,
    .9135,
    .86523,
    .9135,
    .86523,
    .9135,
    1,
    1,
    .92222,
    .92168,
    .92222,
    .92168,
    .98621,
    .95381,
    .98621,
    .95381,
    .98621,
    .95381,
    .98621,
    .95381,
    .98621,
    .95381,
    .86036,
    .97096,
    .71743,
    .98981,
    1,
    1,
    .95298,
    .79726,
    .95381,
    1,
    1,
    .79726,
    .6894,
    .79726,
    .74321,
    .81691,
    1.0006,
    .92222,
    .92168,
    1,
    1,
    .92222,
    .92168,
    .79464,
    .92098,
    .92168,
    .90637,
    .91513,
    .90637,
    .91513,
    .90637,
    .91513,
    .909,
    .87514,
    .80729,
    .95077,
    1,
    1,
    .80729,
    .95077,
    .76463,
    .748,
    .76463,
    .748,
    1,
    1,
    .76463,
    .748,
    1,
    1,
    .86275,
    .72651,
    .86275,
    1.04502,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .9154,
    .94236,
    .85458,
    .89364,
    .85458,
    .90531,
    .9,
    .90531,
    .9,
    .90531,
    .9,
    1,
    .97276,
    .85576,
    .99613,
    .845,
    .85811,
    .90251,
    .91677,
    1,
    1,
    .86275,
    1.04502,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.00899,
    1.30628,
    .85576,
    .80178,
    .66862,
    .7927,
    .69323,
    .88127,
    .72459,
    .89711,
    .95381,
    .85576,
    .80591,
    .7805,
    .94729,
    .77512,
    .90531,
    .92222,
    .90637,
    .98621,
    .81698,
    .92655,
    .98558,
    .92222,
    .85359,
    .90637,
    .90976,
    .83809,
    .94523,
    .86275,
    .83509,
    .93157,
    .85308,
    .83392,
    .92346,
    .98621,
    .83509,
    .92886,
    .91324,
    .92168,
    .95381,
    .90646,
    .92886,
    .90557,
    .86847,
    .90276,
    .91324,
    .86842,
    .92168,
    .99531,
    .95381,
    .9224,
    .85408,
    .92699,
    .86847,
    1.0051,
    .91513,
    .80487,
    .93481,
    1,
    .88159,
    1.05214,
    .90646,
    .97355,
    .81539,
    .89398,
    .85923,
    .95381,
    .90646,
    .91513,
    .90646,
    .85923,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .9154,
    .94236,
    .9154,
    .94236,
    .9154,
    .94236,
    .85458,
    .89364,
    .96694,
    1,
    .89903,
    1,
    1,
    1,
    .91782,
    .91782,
    .91782,
    1,
    .896,
    .896,
    .896,
    .9332,
    .9332,
    .95973,
    1,
    1.26,
    1,
    1,
    .80479,
    .80178,
    1,
    1,
    .85633,
    1,
    1,
    1,
    1,
    .97276,
    1,
    1,
    1,
    .698,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.14542,
    1,
    .79199,
    .78694,
    1.02058,
    1.03493,
    1.05486,
    1,
    1,
    1.23026,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.20006,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Oa = {
    lineHeight: 1.2,
    lineGap: .2
}, Pa = [
    1.36898,
    1,
    1,
    .65507,
    .84943,
    .85639,
    .88465,
    .88465,
    .86936,
    .88307,
    .86948,
    .85283,
    .85283,
    1.06383,
    1.02058,
    .75945,
    .9219,
    .75945,
    1.17337,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .75945,
    .75945,
    1.02058,
    1.02058,
    1.02058,
    .69046,
    .70926,
    .85158,
    .77812,
    .76852,
    .89591,
    .70466,
    .76125,
    .80094,
    .86822,
    .83864,
    .728,
    .77212,
    .79475,
    .93637,
    .87514,
    .8588,
    .76013,
    .8588,
    .72421,
    .69866,
    .77598,
    .85991,
    .80811,
    .87832,
    .78112,
    .77512,
    .8562,
    1.0222,
    1.18417,
    1.0222,
    1.27014,
    .89903,
    1.15012,
    .93859,
    .94399,
    .846,
    .94399,
    .81453,
    1.0186,
    .94219,
    .96017,
    1.03075,
    1.02175,
    .912,
    1.03075,
    .96998,
    .96017,
    .93859,
    .94399,
    .94399,
    .95493,
    .746,
    1.12658,
    .94578,
    .91,
    .979,
    .882,
    .882,
    .83,
    .85034,
    .83537,
    .85034,
    1.02058,
    .70869,
    .88465,
    .88465,
    .88465,
    .88465,
    .83537,
    .90083,
    1.15012,
    .9161,
    .94565,
    .73541,
    1.02058,
    .53609,
    .69353,
    .79519,
    1.08595,
    1,
    1,
    1.15012,
    1,
    .91974,
    .75945,
    1.15012,
    1,
    .9446,
    .73361,
    .9005,
    .9005,
    .9005,
    .62864,
    .85158,
    .85158,
    .85158,
    .85158,
    .85158,
    .85158,
    .773,
    .76852,
    .70466,
    .70466,
    .70466,
    .70466,
    .83864,
    .83864,
    .83864,
    .83864,
    .90561,
    .87514,
    .8588,
    .8588,
    .8588,
    .8588,
    .8588,
    1.02058,
    .85751,
    .85991,
    .85991,
    .85991,
    .85991,
    .77512,
    .76013,
    .88075,
    .93859,
    .93859,
    .93859,
    .93859,
    .93859,
    .93859,
    .8075,
    .846,
    .81453,
    .81453,
    .81453,
    .81453,
    .82424,
    .82424,
    .82424,
    .82424,
    .9278,
    .96017,
    .93859,
    .93859,
    .93859,
    .93859,
    .93859,
    1.08595,
    .8562,
    .94578,
    .94578,
    .94578,
    .94578,
    .882,
    .94578,
    .882,
    .85158,
    .93859,
    .85158,
    .93859,
    .85158,
    .93859,
    .76852,
    .846,
    .76852,
    .846,
    .76852,
    .846,
    .76852,
    .846,
    .89591,
    .8544,
    .90561,
    .94399,
    .70466,
    .81453,
    .70466,
    .81453,
    .70466,
    .81453,
    .70466,
    .81453,
    .70466,
    .81453,
    .80094,
    .94219,
    .80094,
    .94219,
    .80094,
    .94219,
    1,
    1,
    .86822,
    .96017,
    .86822,
    .96017,
    .83864,
    .82424,
    .83864,
    .82424,
    .83864,
    .82424,
    .83864,
    1.03075,
    .83864,
    .82424,
    .81402,
    1.02738,
    .728,
    1.02175,
    1,
    1,
    .912,
    .79475,
    1.03075,
    1,
    1,
    .79475,
    .83911,
    .79475,
    .66266,
    .80553,
    1.06676,
    .87514,
    .96017,
    1,
    1,
    .87514,
    .96017,
    .86865,
    .87396,
    .96017,
    .8588,
    .93859,
    .8588,
    .93859,
    .8588,
    .93859,
    .867,
    .84759,
    .72421,
    .95493,
    1,
    1,
    .72421,
    .95493,
    .69866,
    .746,
    .69866,
    .746,
    1,
    1,
    .69866,
    .746,
    1,
    1,
    .77598,
    .88417,
    .77598,
    1.12658,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .87832,
    .979,
    .77512,
    .882,
    .77512,
    .8562,
    .83,
    .8562,
    .83,
    .8562,
    .83,
    1,
    .88465,
    .85158,
    .93859,
    .773,
    .8075,
    .85751,
    .8562,
    1,
    1,
    .77598,
    1.12658,
    1.15012,
    1.15012,
    1.15012,
    1.15012,
    1.15012,
    1.15313,
    1.15012,
    1.15012,
    1.15012,
    1.08106,
    1.03901,
    .85158,
    .77025,
    .62264,
    .7646,
    .65351,
    .86026,
    .69461,
    .89947,
    1.03075,
    .85158,
    .77812,
    .76449,
    .88836,
    .70466,
    .8562,
    .86822,
    .8588,
    .83864,
    .77212,
    .85308,
    .93637,
    .87514,
    .82352,
    .8588,
    .85701,
    .76013,
    .89058,
    .77598,
    .8156,
    .82565,
    .78112,
    .77899,
    .89386,
    .83864,
    .8156,
    .9486,
    .92388,
    .96186,
    1.03075,
    .91123,
    .9486,
    .93298,
    .878,
    .93942,
    .92388,
    .84596,
    .96186,
    .95119,
    1.03075,
    .922,
    .88787,
    .95829,
    .88,
    .93559,
    .93859,
    .78815,
    .93758,
    1,
    .89217,
    1.03737,
    .91123,
    .93969,
    .77487,
    .85769,
    .86799,
    1.03075,
    .91123,
    .93859,
    .91123,
    .86799,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .87832,
    .979,
    .87832,
    .979,
    .87832,
    .979,
    .77512,
    .882,
    .9219,
    1,
    .89903,
    1,
    1,
    1,
    .87321,
    .87321,
    .87321,
    1,
    1.027,
    1.027,
    1.027,
    .86847,
    .86847,
    .79121,
    1,
    1.124,
    1,
    1,
    .73572,
    .73572,
    1,
    1,
    .85034,
    1,
    1,
    1,
    1,
    .88465,
    1,
    1,
    1,
    .669,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.04828,
    1,
    .74948,
    .75187,
    1.02058,
    .98391,
    1.02119,
    1,
    1,
    1.06233,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05233,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Wa = {
    lineHeight: 1.2,
    lineGap: .2
}, ja = [
    1.36898,
    1,
    1,
    .76305,
    .82784,
    .94935,
    .89364,
    .92241,
    .89073,
    .90706,
    .98472,
    .85283,
    .85283,
    1.0664,
    1.02058,
    .74505,
    .9219,
    .74505,
    1.23456,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .74505,
    .74505,
    1.02058,
    1.02058,
    1.02058,
    .73002,
    .72601,
    .91755,
    .8126,
    .80314,
    .92222,
    .73764,
    .79726,
    .83051,
    .90284,
    .86023,
    .74,
    .8126,
    .84869,
    .96518,
    .91115,
    .8858,
    .79761,
    .8858,
    .74498,
    .73914,
    .81363,
    .89591,
    .83659,
    .89633,
    .85608,
    .8111,
    .90531,
    1.0222,
    1.22736,
    1.0222,
    1.27014,
    .89903,
    .90088,
    .86667,
    1.0231,
    .896,
    1.01411,
    .90083,
    1.05099,
    1.00512,
    .99793,
    1.05326,
    1.09377,
    .938,
    1.06226,
    1.00119,
    .99793,
    .98714,
    1.0231,
    1.01231,
    .98196,
    .792,
    1.19137,
    .99074,
    .962,
    1.01915,
    .926,
    .942,
    .856,
    .85034,
    .92006,
    .85034,
    1.02058,
    .69067,
    .92241,
    .92241,
    .92241,
    .92241,
    .92006,
    .9332,
    .90088,
    .91882,
    .93484,
    .75339,
    1.02058,
    .56866,
    .54324,
    .79519,
    1.08595,
    1,
    1,
    .90088,
    1,
    .95325,
    .74505,
    .90088,
    1,
    .97198,
    .75339,
    .91009,
    .91009,
    .91009,
    .66466,
    .91755,
    .91755,
    .91755,
    .91755,
    .91755,
    .91755,
    .788,
    .80314,
    .73764,
    .73764,
    .73764,
    .73764,
    .86023,
    .86023,
    .86023,
    .86023,
    .92915,
    .91115,
    .8858,
    .8858,
    .8858,
    .8858,
    .8858,
    1.02058,
    .8858,
    .89591,
    .89591,
    .89591,
    .89591,
    .8111,
    .79611,
    .89713,
    .86667,
    .86667,
    .86667,
    .86667,
    .86667,
    .86667,
    .86936,
    .896,
    .90083,
    .90083,
    .90083,
    .90083,
    .84224,
    .84224,
    .84224,
    .84224,
    .97276,
    .99793,
    .98714,
    .98714,
    .98714,
    .98714,
    .98714,
    1.08595,
    .89876,
    .99074,
    .99074,
    .99074,
    .99074,
    .942,
    1.0231,
    .942,
    .91755,
    .86667,
    .91755,
    .86667,
    .91755,
    .86667,
    .80314,
    .896,
    .80314,
    .896,
    .80314,
    .896,
    .80314,
    .896,
    .92222,
    .93372,
    .92915,
    1.01411,
    .73764,
    .90083,
    .73764,
    .90083,
    .73764,
    .90083,
    .73764,
    .90083,
    .73764,
    .90083,
    .83051,
    1.00512,
    .83051,
    1.00512,
    .83051,
    1.00512,
    1,
    1,
    .90284,
    .99793,
    .90976,
    .99793,
    .86023,
    .84224,
    .86023,
    .84224,
    .86023,
    .84224,
    .86023,
    1.05326,
    .86023,
    .84224,
    .82873,
    1.07469,
    .74,
    1.09377,
    1,
    1,
    .938,
    .84869,
    1.06226,
    1,
    1,
    .84869,
    .83704,
    .84869,
    .81441,
    .85588,
    1.08927,
    .91115,
    .99793,
    1,
    1,
    .91115,
    .99793,
    .91887,
    .90991,
    .99793,
    .8858,
    .98714,
    .8858,
    .98714,
    .8858,
    .98714,
    .894,
    .91434,
    .74498,
    .98196,
    1,
    1,
    .74498,
    .98196,
    .73914,
    .792,
    .73914,
    .792,
    1,
    1,
    .73914,
    .792,
    1,
    1,
    .81363,
    .904,
    .81363,
    1.19137,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89633,
    1.01915,
    .8111,
    .942,
    .8111,
    .90531,
    .856,
    .90531,
    .856,
    .90531,
    .856,
    1,
    .92241,
    .91755,
    .86667,
    .788,
    .86936,
    .8858,
    .89876,
    1,
    1,
    .81363,
    1.19137,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90388,
    1.03901,
    .92138,
    .78105,
    .7154,
    .86169,
    .80513,
    .94007,
    .82528,
    .98612,
    1.06226,
    .91755,
    .8126,
    .81884,
    .92819,
    .73764,
    .90531,
    .90284,
    .8858,
    .86023,
    .8126,
    .91172,
    .96518,
    .91115,
    .83089,
    .8858,
    .87791,
    .79761,
    .89297,
    .81363,
    .88157,
    .89992,
    .85608,
    .81992,
    .94307,
    .86023,
    .88157,
    .95308,
    .98699,
    .99793,
    1.06226,
    .95817,
    .95308,
    .97358,
    .928,
    .98088,
    .98699,
    .92761,
    .99793,
    .96017,
    1.06226,
    .986,
    .944,
    .95978,
    .938,
    .96705,
    .98714,
    .80442,
    .98972,
    1,
    .89762,
    1.04552,
    .95817,
    .99007,
    .87064,
    .91879,
    .88888,
    1.06226,
    .95817,
    .98714,
    .95817,
    .88888,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .89633,
    1.01915,
    .89633,
    1.01915,
    .89633,
    1.01915,
    .8111,
    .942,
    .9219,
    1,
    .89903,
    1,
    1,
    1,
    .93173,
    .93173,
    .93173,
    1,
    1.06304,
    1.06304,
    1.06904,
    .89903,
    .89903,
    .80549,
    1,
    1.156,
    1,
    1,
    .76575,
    .76575,
    1,
    1,
    .72458,
    1,
    1,
    1,
    1,
    .92241,
    1,
    1,
    1,
    .619,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.07257,
    1,
    .74705,
    .71119,
    1.02058,
    1.024,
    1.02119,
    1,
    1,
    1.1536,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05638,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Xa = {
    lineHeight: 1.2,
    lineGap: .2
}, Za = [
    1.76738,
    1,
    1,
    .99297,
    .9824,
    1.04016,
    1.06497,
    1.03424,
    .97529,
    1.17647,
    1.23203,
    1.1085,
    1.1085,
    1.16939,
    1.2107,
    .9754,
    1.21408,
    .9754,
    1.59578,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    .81378,
    .81378,
    1.2107,
    1.2107,
    1.2107,
    .71703,
    .97847,
    .97363,
    .88776,
    .8641,
    1.02096,
    .79795,
    .85132,
    .914,
    1.06085,
    1.1406,
    .8007,
    .89858,
    .83693,
    1.14889,
    1.09398,
    .97489,
    .92094,
    .97489,
    .90399,
    .84041,
    .95923,
    1.00135,
    1,
    1.06467,
    .98243,
    .90996,
    .99361,
    1.1085,
    1.56942,
    1.1085,
    1.2107,
    .74627,
    .94282,
    .96752,
    1.01519,
    .86304,
    1.01359,
    .97278,
    1.15103,
    1.01359,
    .98561,
    1.02285,
    1.02285,
    1.00527,
    1.02285,
    1.0302,
    .99041,
    1.0008,
    1.01519,
    1.01359,
    1.02258,
    .79104,
    1.16862,
    .99041,
    .97454,
    1.02511,
    .99298,
    .96752,
    .95801,
    .94856,
    1.16579,
    .94856,
    1.2107,
    .9824,
    1.03424,
    1.03424,
    1,
    1.03424,
    1.16579,
    .8727,
    1.3871,
    1.18622,
    1.10818,
    1.04478,
    1.2107,
    1.18622,
    .75155,
    .94994,
    1.28826,
    1.21408,
    1.21408,
    .91056,
    1,
    .91572,
    .9754,
    .64663,
    1.18328,
    1.24866,
    1.04478,
    1.14169,
    1.15749,
    1.17389,
    .71703,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .93506,
    .8641,
    .79795,
    .79795,
    .79795,
    .79795,
    1.1406,
    1.1406,
    1.1406,
    1.1406,
    1.02096,
    1.09398,
    .97426,
    .97426,
    .97426,
    .97426,
    .97426,
    1.2107,
    .97489,
    1.00135,
    1.00135,
    1.00135,
    1.00135,
    .90996,
    .92094,
    1.02798,
    .96752,
    .96752,
    .96752,
    .96752,
    .96752,
    .96752,
    .93136,
    .86304,
    .97278,
    .97278,
    .97278,
    .97278,
    1.02285,
    1.02285,
    1.02285,
    1.02285,
    .97122,
    .99041,
    1,
    1,
    1,
    1,
    1,
    1.28826,
    1.0008,
    .99041,
    .99041,
    .99041,
    .99041,
    .96752,
    1.01519,
    .96752,
    .97363,
    .96752,
    .97363,
    .96752,
    .97363,
    .96752,
    .8641,
    .86304,
    .8641,
    .86304,
    .8641,
    .86304,
    .8641,
    .86304,
    1.02096,
    1.03057,
    1.02096,
    1.03517,
    .79795,
    .97278,
    .79795,
    .97278,
    .79795,
    .97278,
    .79795,
    .97278,
    .79795,
    .97278,
    .914,
    1.01359,
    .914,
    1.01359,
    .914,
    1.01359,
    1,
    1,
    1.06085,
    .98561,
    1.06085,
    1.00879,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    .97138,
    1.08692,
    .8007,
    1.02285,
    1,
    1,
    1.00527,
    .83693,
    1.02285,
    1,
    1,
    .83693,
    .9455,
    .83693,
    .90418,
    .83693,
    1.13005,
    1.09398,
    .99041,
    1,
    1,
    1.09398,
    .99041,
    .96692,
    1.09251,
    .99041,
    .97489,
    1.0008,
    .97489,
    1.0008,
    .97489,
    1.0008,
    .93994,
    .97931,
    .90399,
    1.02258,
    1,
    1,
    .90399,
    1.02258,
    .84041,
    .79104,
    .84041,
    .79104,
    .84041,
    .79104,
    .84041,
    .79104,
    1,
    1,
    .95923,
    1.07034,
    .95923,
    1.16862,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.06467,
    1.02511,
    .90996,
    .96752,
    .90996,
    .99361,
    .95801,
    .99361,
    .95801,
    .99361,
    .95801,
    1.07733,
    1.03424,
    .97363,
    .96752,
    .93506,
    .93136,
    .97489,
    1.0008,
    1,
    1,
    .95923,
    1.16862,
    1.15103,
    1.15103,
    1.01173,
    1.03959,
    .75953,
    .81378,
    .79912,
    1.15103,
    1.21994,
    .95161,
    .87815,
    1.01149,
    .81525,
    .7676,
    .98167,
    1.01134,
    1.02546,
    .84097,
    1.03089,
    1.18102,
    .97363,
    .88776,
    .85134,
    .97826,
    .79795,
    .99361,
    1.06085,
    .97489,
    1.1406,
    .89858,
    1.0388,
    1.14889,
    1.09398,
    .86039,
    .97489,
    1.0595,
    .92094,
    .94793,
    .95923,
    .90996,
    .99346,
    .98243,
    1.02112,
    .95493,
    1.1406,
    .90996,
    1.03574,
    1.02597,
    1.0008,
    1.18102,
    1.06628,
    1.03574,
    1.0192,
    1.01932,
    1.00886,
    .97531,
    1.0106,
    1.0008,
    1.13189,
    1.18102,
    1.02277,
    .98683,
    1.0016,
    .99561,
    1.07237,
    1.0008,
    .90434,
    .99921,
    .93803,
    .8965,
    1.23085,
    1.06628,
    1.04983,
    .96268,
    1.0499,
    .98439,
    1.18102,
    1.06628,
    1.0008,
    1.06628,
    .98439,
    .79795,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.09466,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .97278,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.02065,
    1,
    1,
    1,
    1,
    1,
    1,
    1.06467,
    1.02511,
    1.06467,
    1.02511,
    1.06467,
    1.02511,
    .90996,
    .96752,
    1,
    1.21408,
    .89903,
    1,
    1,
    .75155,
    1.04394,
    1.04394,
    1.04394,
    1.04394,
    .98633,
    .98633,
    .98633,
    .73047,
    .73047,
    1.20642,
    .91211,
    1.25635,
    1.222,
    1.02956,
    1.03372,
    1.03372,
    .96039,
    1.24633,
    1,
    1.12454,
    .93503,
    1.03424,
    1.19687,
    1.03424,
    1,
    1,
    1,
    .771,
    1,
    1,
    1.15749,
    1.15749,
    1.15749,
    1.10948,
    .86279,
    .94434,
    .86279,
    .94434,
    .86182,
    1,
    1,
    1.16897,
    1,
    .96085,
    .90137,
    1.2107,
    1.18416,
    1.13973,
    .69825,
    .9716,
    2.10339,
    1.29004,
    1.29004,
    1.21172,
    1.29004,
    1.29004,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.18874,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.09193,
    1.09193,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Va = {
    lineHeight: 1.33008,
    lineGap: 0
}, za = [
    1.76738,
    1,
    1,
    .98946,
    1.03959,
    1.04016,
    1.02809,
    1.036,
    .97639,
    1.10953,
    1.23203,
    1.11144,
    1.11144,
    1.16939,
    1.21237,
    .9754,
    1.21261,
    .9754,
    1.59754,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    .81378,
    .81378,
    1.21237,
    1.21237,
    1.21237,
    .73541,
    .97847,
    .97363,
    .89723,
    .87897,
    1.0426,
    .79429,
    .85292,
    .91149,
    1.05815,
    1.1406,
    .79631,
    .90128,
    .83853,
    1.04396,
    1.10615,
    .97552,
    .94436,
    .97552,
    .88641,
    .80527,
    .96083,
    1.00135,
    1,
    1.06777,
    .9817,
    .91142,
    .99361,
    1.11144,
    1.57293,
    1.11144,
    1.21237,
    .74627,
    1.31818,
    1.06585,
    .97042,
    .83055,
    .97042,
    .93503,
    1.1261,
    .97042,
    .97922,
    1.14236,
    .94552,
    1.01054,
    1.14236,
    1.02471,
    .97922,
    .94165,
    .97042,
    .97042,
    1.0276,
    .78929,
    1.1261,
    .97922,
    .95874,
    1.02197,
    .98507,
    .96752,
    .97168,
    .95107,
    1.16579,
    .95107,
    1.21237,
    1.03959,
    1.036,
    1.036,
    1,
    1.036,
    1.16579,
    .87357,
    1.31818,
    1.18754,
    1.26781,
    1.05356,
    1.21237,
    1.18622,
    .79487,
    .94994,
    1.29004,
    1.24047,
    1.24047,
    1.31818,
    1,
    .91484,
    .9754,
    1.31818,
    1.1349,
    1.24866,
    1.05356,
    1.13934,
    1.15574,
    1.17389,
    .73541,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .94385,
    .87897,
    .79429,
    .79429,
    .79429,
    .79429,
    1.1406,
    1.1406,
    1.1406,
    1.1406,
    1.0426,
    1.10615,
    .97552,
    .97552,
    .97552,
    .97552,
    .97552,
    1.21237,
    .97552,
    1.00135,
    1.00135,
    1.00135,
    1.00135,
    .91142,
    .94436,
    .98721,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    .96705,
    .83055,
    .93503,
    .93503,
    .93503,
    .93503,
    1.14236,
    1.14236,
    1.14236,
    1.14236,
    .93125,
    .97922,
    .94165,
    .94165,
    .94165,
    .94165,
    .94165,
    1.29004,
    .94165,
    .97922,
    .97922,
    .97922,
    .97922,
    .96752,
    .97042,
    .96752,
    .97363,
    1.06585,
    .97363,
    1.06585,
    .97363,
    1.06585,
    .87897,
    .83055,
    .87897,
    .83055,
    .87897,
    .83055,
    .87897,
    .83055,
    1.0426,
    1.0033,
    1.0426,
    .97042,
    .79429,
    .93503,
    .79429,
    .93503,
    .79429,
    .93503,
    .79429,
    .93503,
    .79429,
    .93503,
    .91149,
    .97042,
    .91149,
    .97042,
    .91149,
    .97042,
    1,
    1,
    1.05815,
    .97922,
    1.05815,
    .97922,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    .97441,
    1.04302,
    .79631,
    1.01582,
    1,
    1,
    1.01054,
    .83853,
    1.14236,
    1,
    1,
    .83853,
    1.09125,
    .83853,
    .90418,
    .83853,
    1.19508,
    1.10615,
    .97922,
    1,
    1,
    1.10615,
    .97922,
    1.01034,
    1.10466,
    .97922,
    .97552,
    .94165,
    .97552,
    .94165,
    .97552,
    .94165,
    .91602,
    .91981,
    .88641,
    1.0276,
    1,
    1,
    .88641,
    1.0276,
    .80527,
    .78929,
    .80527,
    .78929,
    .80527,
    .78929,
    .80527,
    .78929,
    1,
    1,
    .96083,
    1.05403,
    .95923,
    1.16862,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.06777,
    1.02197,
    .91142,
    .96752,
    .91142,
    .99361,
    .97168,
    .99361,
    .97168,
    .99361,
    .97168,
    1.23199,
    1.036,
    .97363,
    1.06585,
    .94385,
    .96705,
    .97552,
    .94165,
    1,
    1,
    .96083,
    1.1261,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    .95161,
    1.27126,
    1.00811,
    .83284,
    .77702,
    .99137,
    .95253,
    1.0347,
    .86142,
    1.07205,
    1.14236,
    .97363,
    .89723,
    .86869,
    1.09818,
    .79429,
    .99361,
    1.05815,
    .97552,
    1.1406,
    .90128,
    1.06662,
    1.04396,
    1.10615,
    .84918,
    .97552,
    1.04694,
    .94436,
    .98015,
    .96083,
    .91142,
    1.00356,
    .9817,
    1.01945,
    .98999,
    1.1406,
    .91142,
    1.04961,
    .9898,
    1.00639,
    1.14236,
    1.07514,
    1.04961,
    .99607,
    1.02897,
    1.008,
    .9898,
    .95134,
    1.00639,
    1.11121,
    1.14236,
    1.00518,
    .97981,
    1.02186,
    1,
    1.08578,
    .94165,
    .99314,
    .98387,
    .93028,
    .93377,
    1.35125,
    1.07514,
    1.10687,
    .93491,
    1.04232,
    1.00351,
    1.14236,
    1.07514,
    .94165,
    1.07514,
    1.00351,
    .79429,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.09097,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .93503,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .96609,
    1,
    1,
    1,
    1,
    1,
    1,
    1.06777,
    1.02197,
    1.06777,
    1.02197,
    1.06777,
    1.02197,
    .91142,
    .96752,
    1,
    1.21261,
    .89903,
    1,
    1,
    .75155,
    1.04745,
    1.04745,
    1.04745,
    1.04394,
    .98633,
    .98633,
    .98633,
    .72959,
    .72959,
    1.20502,
    .91406,
    1.26514,
    1.222,
    1.02956,
    1.03372,
    1.03372,
    .96039,
    1.24633,
    1,
    1.09125,
    .93327,
    1.03336,
    1.16541,
    1.036,
    1,
    1,
    1,
    .771,
    1,
    1,
    1.15574,
    1.15574,
    1.15574,
    1.15574,
    .86364,
    .94434,
    .86279,
    .94434,
    .86224,
    1,
    1,
    1.16798,
    1,
    .96085,
    .90068,
    1.21237,
    1.18416,
    1.13904,
    .69825,
    .9716,
    2.10339,
    1.29004,
    1.29004,
    1.21339,
    1.29004,
    1.29004,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.18775,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.13269,
    1.13269,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], _a = {
    lineHeight: 1.33008,
    lineGap: 0
}, $a = [
    1.76738,
    1,
    1,
    .98946,
    1.14763,
    1.05365,
    1.06234,
    .96927,
    .92586,
    1.15373,
    1.18414,
    .91349,
    .91349,
    1.07403,
    1.17308,
    .78383,
    1.20088,
    .78383,
    1.42531,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .78383,
    .78383,
    1.17308,
    1.17308,
    1.17308,
    .77349,
    .94565,
    .94729,
    .85944,
    .88506,
    .9858,
    .74817,
    .80016,
    .88449,
    .98039,
    .95782,
    .69238,
    .89898,
    .83231,
    .98183,
    1.03989,
    .96924,
    .86237,
    .96924,
    .80595,
    .74524,
    .86091,
    .95402,
    .94143,
    .98448,
    .8858,
    .83089,
    .93285,
    1.0949,
    1.39016,
    1.0949,
    1.45994,
    .74627,
    1.04839,
    .97454,
    .97454,
    .87207,
    .97454,
    .87533,
    1.06151,
    .97454,
    1.00176,
    1.16484,
    1.08132,
    .98047,
    1.16484,
    1.02989,
    1.01054,
    .96225,
    .97454,
    .97454,
    1.06598,
    .79004,
    1.16344,
    1.00351,
    .94629,
    .9973,
    .91016,
    .96777,
    .9043,
    .91082,
    .92481,
    .91082,
    1.17308,
    .95748,
    .96927,
    .96927,
    1,
    .96927,
    .92481,
    .80597,
    1.04839,
    1.23393,
    1.1781,
    .9245,
    1.17308,
    1.20808,
    .63218,
    .94261,
    1.24822,
    1.09971,
    1.09971,
    1.04839,
    1,
    .85273,
    .78032,
    1.04839,
    1.09971,
    1.22326,
    .9245,
    1.09836,
    1.13525,
    1.15222,
    .70424,
    .94729,
    .94729,
    .94729,
    .94729,
    .94729,
    .94729,
    .85498,
    .88506,
    .74817,
    .74817,
    .74817,
    .74817,
    .95782,
    .95782,
    .95782,
    .95782,
    .9858,
    1.03989,
    .96924,
    .96924,
    .96924,
    .96924,
    .96924,
    1.17308,
    .96924,
    .95402,
    .95402,
    .95402,
    .95402,
    .83089,
    .86237,
    .88409,
    .97454,
    .97454,
    .97454,
    .97454,
    .97454,
    .97454,
    .92916,
    .87207,
    .87533,
    .87533,
    .87533,
    .87533,
    .93146,
    .93146,
    .93146,
    .93146,
    .93854,
    1.01054,
    .96225,
    .96225,
    .96225,
    .96225,
    .96225,
    1.24822,
    .8761,
    1.00351,
    1.00351,
    1.00351,
    1.00351,
    .96777,
    .97454,
    .96777,
    .94729,
    .97454,
    .94729,
    .97454,
    .94729,
    .97454,
    .88506,
    .87207,
    .88506,
    .87207,
    .88506,
    .87207,
    .88506,
    .87207,
    .9858,
    .95391,
    .9858,
    .97454,
    .74817,
    .87533,
    .74817,
    .87533,
    .74817,
    .87533,
    .74817,
    .87533,
    .74817,
    .87533,
    .88449,
    .97454,
    .88449,
    .97454,
    .88449,
    .97454,
    1,
    1,
    .98039,
    1.00176,
    .98039,
    1.00176,
    .95782,
    .93146,
    .95782,
    .93146,
    .95782,
    .93146,
    .95782,
    1.16484,
    .95782,
    .93146,
    .84421,
    1.12761,
    .69238,
    1.08132,
    1,
    1,
    .98047,
    .83231,
    1.16484,
    1,
    1,
    .84723,
    1.04861,
    .84723,
    .78755,
    .83231,
    1.23736,
    1.03989,
    1.01054,
    1,
    1,
    1.03989,
    1.01054,
    .9857,
    1.03849,
    1.01054,
    .96924,
    .96225,
    .96924,
    .96225,
    .96924,
    .96225,
    .92383,
    .90171,
    .80595,
    1.06598,
    1,
    1,
    .80595,
    1.06598,
    .74524,
    .79004,
    .74524,
    .79004,
    .74524,
    .79004,
    .74524,
    .79004,
    1,
    1,
    .86091,
    1.02759,
    .85771,
    1.16344,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .98448,
    .9973,
    .83089,
    .96777,
    .83089,
    .93285,
    .9043,
    .93285,
    .9043,
    .93285,
    .9043,
    1.31868,
    .96927,
    .94729,
    .97454,
    .85498,
    .92916,
    .96924,
    .8761,
    1,
    1,
    .86091,
    1.16344,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    .81965,
    .81965,
    .94729,
    .78032,
    .71022,
    .90883,
    .84171,
    .99877,
    .77596,
    1.05734,
    1.2,
    .94729,
    .85944,
    .82791,
    .9607,
    .74817,
    .93285,
    .98039,
    .96924,
    .95782,
    .89898,
    .98316,
    .98183,
    1.03989,
    .78614,
    .96924,
    .97642,
    .86237,
    .86075,
    .86091,
    .83089,
    .90082,
    .8858,
    .97296,
    1.01284,
    .95782,
    .83089,
    1.0976,
    1.04,
    1.03342,
    1.2,
    1.0675,
    1.0976,
    .98205,
    1.03809,
    1.05097,
    1.04,
    .95364,
    1.03342,
    1.05401,
    1.2,
    1.02148,
    1.0119,
    1.04724,
    1.0127,
    1.02732,
    .96225,
    .8965,
    .97783,
    .93574,
    .94818,
    1.30679,
    1.0675,
    1.11826,
    .99821,
    1.0557,
    1.0326,
    1.2,
    1.0675,
    .96225,
    1.0675,
    1.0326,
    .74817,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.03754,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .87533,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .98705,
    1,
    1,
    1,
    1,
    1,
    1,
    .98448,
    .9973,
    .98448,
    .9973,
    .98448,
    .9973,
    .83089,
    .96777,
    1,
    1.20088,
    .89903,
    1,
    1,
    .75155,
    .94945,
    .94945,
    .94945,
    .94945,
    1.12317,
    1.12317,
    1.12317,
    .67603,
    .67603,
    1.15621,
    .73584,
    1.21191,
    1.22135,
    1.06483,
    .94868,
    .94868,
    .95996,
    1.24633,
    1,
    1.07497,
    .87709,
    .96927,
    1.01473,
    .96927,
    1,
    1,
    1,
    .77295,
    1,
    1,
    1.09836,
    1.09836,
    1.09836,
    1.01522,
    .86321,
    .94434,
    .8649,
    .94434,
    .86182,
    1,
    1,
    1.083,
    1,
    .91578,
    .86438,
    1.17308,
    1.18416,
    1.14589,
    .69825,
    .97622,
    1.96791,
    1.24822,
    1.24822,
    1.17308,
    1.24822,
    1.24822,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.17984,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.10742,
    1.10742,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], As = {
    lineHeight: 1.33008,
    lineGap: 0
}, es = [
    1.76738,
    1,
    1,
    .98594,
    1.02285,
    1.10454,
    1.06234,
    .96927,
    .92037,
    1.19985,
    1.2046,
    .90616,
    .90616,
    1.07152,
    1.1714,
    .78032,
    1.20088,
    .78032,
    1.40246,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .78032,
    .78032,
    1.1714,
    1.1714,
    1.1714,
    .80597,
    .94084,
    .96706,
    .85944,
    .85734,
    .97093,
    .75842,
    .79936,
    .88198,
    .9831,
    .95782,
    .71387,
    .86969,
    .84636,
    1.07796,
    1.03584,
    .96924,
    .83968,
    .96924,
    .82826,
    .79649,
    .85771,
    .95132,
    .93119,
    .98965,
    .88433,
    .8287,
    .93365,
    1.08612,
    1.3638,
    1.08612,
    1.45786,
    .74627,
    .80499,
    .91484,
    1.05707,
    .92383,
    1.05882,
    .9403,
    1.12654,
    1.05882,
    1.01756,
    1.09011,
    1.09011,
    .99414,
    1.09011,
    1.034,
    1.01756,
    1.05356,
    1.05707,
    1.05882,
    1.04399,
    .84863,
    1.21968,
    1.01756,
    .95801,
    1.00068,
    .91797,
    .96777,
    .9043,
    .90351,
    .92105,
    .90351,
    1.1714,
    .85337,
    .96927,
    .96927,
    .99912,
    .96927,
    .92105,
    .80597,
    1.2434,
    1.20808,
    1.05937,
    .90957,
    1.1714,
    1.20808,
    .75155,
    .94261,
    1.24644,
    1.09971,
    1.09971,
    .84751,
    1,
    .85273,
    .78032,
    .61584,
    1.05425,
    1.17914,
    .90957,
    1.08665,
    1.11593,
    1.14169,
    .73381,
    .96706,
    .96706,
    .96706,
    .96706,
    .96706,
    .96706,
    .86035,
    .85734,
    .75842,
    .75842,
    .75842,
    .75842,
    .95782,
    .95782,
    .95782,
    .95782,
    .97093,
    1.03584,
    .96924,
    .96924,
    .96924,
    .96924,
    .96924,
    1.1714,
    .96924,
    .95132,
    .95132,
    .95132,
    .95132,
    .8287,
    .83968,
    .89049,
    .91484,
    .91484,
    .91484,
    .91484,
    .91484,
    .91484,
    .93575,
    .92383,
    .9403,
    .9403,
    .9403,
    .9403,
    .8717,
    .8717,
    .8717,
    .8717,
    1.00527,
    1.01756,
    1.05356,
    1.05356,
    1.05356,
    1.05356,
    1.05356,
    1.24644,
    .95923,
    1.01756,
    1.01756,
    1.01756,
    1.01756,
    .96777,
    1.05707,
    .96777,
    .96706,
    .91484,
    .96706,
    .91484,
    .96706,
    .91484,
    .85734,
    .92383,
    .85734,
    .92383,
    .85734,
    .92383,
    .85734,
    .92383,
    .97093,
    1.0969,
    .97093,
    1.05882,
    .75842,
    .9403,
    .75842,
    .9403,
    .75842,
    .9403,
    .75842,
    .9403,
    .75842,
    .9403,
    .88198,
    1.05882,
    .88198,
    1.05882,
    .88198,
    1.05882,
    1,
    1,
    .9831,
    1.01756,
    .9831,
    1.01756,
    .95782,
    .8717,
    .95782,
    .8717,
    .95782,
    .8717,
    .95782,
    1.09011,
    .95782,
    .8717,
    .84784,
    1.11551,
    .71387,
    1.09011,
    1,
    1,
    .99414,
    .84636,
    1.09011,
    1,
    1,
    .84636,
    1.0536,
    .84636,
    .94298,
    .84636,
    1.23297,
    1.03584,
    1.01756,
    1,
    1,
    1.03584,
    1.01756,
    1.00323,
    1.03444,
    1.01756,
    .96924,
    1.05356,
    .96924,
    1.05356,
    .96924,
    1.05356,
    .93066,
    .98293,
    .82826,
    1.04399,
    1,
    1,
    .82826,
    1.04399,
    .79649,
    .84863,
    .79649,
    .84863,
    .79649,
    .84863,
    .79649,
    .84863,
    1,
    1,
    .85771,
    1.17318,
    .85771,
    1.21968,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .98965,
    1.00068,
    .8287,
    .96777,
    .8287,
    .93365,
    .9043,
    .93365,
    .9043,
    .93365,
    .9043,
    1.08571,
    .96927,
    .96706,
    .91484,
    .86035,
    .93575,
    .96924,
    .95923,
    1,
    1,
    .85771,
    1.21968,
    1.11437,
    1.11437,
    .93109,
    .91202,
    .60411,
    .84164,
    .55572,
    1.01173,
    .97361,
    .81818,
    .81818,
    .96635,
    .78032,
    .72727,
    .92366,
    .98601,
    1.03405,
    .77968,
    1.09799,
    1.2,
    .96706,
    .85944,
    .85638,
    .96491,
    .75842,
    .93365,
    .9831,
    .96924,
    .95782,
    .86969,
    .94152,
    1.07796,
    1.03584,
    .78437,
    .96924,
    .98715,
    .83968,
    .83491,
    .85771,
    .8287,
    .94492,
    .88433,
    .9287,
    1.0098,
    .95782,
    .8287,
    1.0625,
    .98248,
    1.03424,
    1.2,
    1.01071,
    1.0625,
    .95246,
    1.03809,
    1.04912,
    .98248,
    1.00221,
    1.03424,
    1.05443,
    1.2,
    1.04785,
    .99609,
    1.00169,
    1.05176,
    .99346,
    1.05356,
    .9087,
    1.03004,
    .95542,
    .93117,
    1.23362,
    1.01071,
    1.07831,
    1.02512,
    1.05205,
    1.03502,
    1.2,
    1.01071,
    1.05356,
    1.01071,
    1.03502,
    .75842,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.03719,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .9403,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.04021,
    1,
    1,
    1,
    1,
    1,
    1,
    .98965,
    1.00068,
    .98965,
    1.00068,
    .98965,
    1.00068,
    .8287,
    .96777,
    1,
    1.20088,
    .89903,
    1,
    1,
    .75155,
    1.03077,
    1.03077,
    1.03077,
    1.03077,
    1.13196,
    1.13196,
    1.13196,
    .67428,
    .67428,
    1.16039,
    .73291,
    1.20996,
    1.22135,
    1.06483,
    .94868,
    .94868,
    .95996,
    1.24633,
    1,
    1.07497,
    .87796,
    .96927,
    1.01518,
    .96927,
    1,
    1,
    1,
    .77295,
    1,
    1,
    1.10539,
    1.10539,
    1.11358,
    1.06967,
    .86279,
    .94434,
    .86279,
    .94434,
    .86182,
    1,
    1,
    1.083,
    1,
    .91578,
    .86507,
    1.1714,
    1.18416,
    1.14589,
    .69825,
    .97622,
    1.9697,
    1.24822,
    1.24822,
    1.17238,
    1.24822,
    1.24822,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.18083,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.10938,
    1.10938,
    1,
    1,
    1,
    1.05425,
    1.09971,
    1.09971,
    1.09971,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], ts = {
    lineHeight: 1.33008,
    lineGap: 0
}, is = getLookupTableFactory(function(e1) {
    e1["MyriadPro-Regular"] = e1["PdfJS-Fallback-Regular"] = {
        name: "LiberationSans-Regular",
        factors: ja,
        baseWidths: Ya,
        baseMapping: va,
        metrics: Xa
    };
    e1["MyriadPro-Bold"] = e1["PdfJS-Fallback-Bold"] = {
        name: "LiberationSans-Bold",
        factors: Ka,
        baseWidths: Ma,
        baseMapping: Ua,
        metrics: Ta
    };
    e1["MyriadPro-It"] = e1["MyriadPro-Italic"] = e1["PdfJS-Fallback-Italic"] = {
        name: "LiberationSans-Italic",
        factors: Pa,
        baseWidths: Ha,
        baseMapping: Ja,
        metrics: Wa
    };
    e1["MyriadPro-BoldIt"] = e1["MyriadPro-BoldItalic"] = e1["PdfJS-Fallback-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: qa,
        baseWidths: xa,
        baseMapping: La,
        metrics: Oa
    };
    e1.ArialMT = e1.Arial = e1["Arial-Regular"] = {
        name: "LiberationSans-Regular",
        baseWidths: Ya,
        baseMapping: va
    };
    e1["Arial-BoldMT"] = e1["Arial-Bold"] = {
        name: "LiberationSans-Bold",
        baseWidths: Ma,
        baseMapping: Ua
    };
    e1["Arial-ItalicMT"] = e1["Arial-Italic"] = {
        name: "LiberationSans-Italic",
        baseWidths: Ha,
        baseMapping: Ja
    };
    e1["Arial-BoldItalicMT"] = e1["Arial-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        baseWidths: xa,
        baseMapping: La
    };
    e1["Calibri-Regular"] = {
        name: "LiberationSans-Regular",
        factors: ya,
        baseWidths: Ya,
        baseMapping: va,
        metrics: wa
    };
    e1["Calibri-Bold"] = {
        name: "LiberationSans-Bold",
        factors: Ea,
        baseWidths: Ma,
        baseMapping: Ua,
        metrics: ua
    };
    e1["Calibri-Italic"] = {
        name: "LiberationSans-Italic",
        factors: pa,
        baseWidths: Ha,
        baseMapping: Ja,
        metrics: ma
    };
    e1["Calibri-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: da,
        baseWidths: xa,
        baseMapping: La,
        metrics: fa
    };
    e1["Segoeui-Regular"] = {
        name: "LiberationSans-Regular",
        factors: es,
        baseWidths: Ya,
        baseMapping: va,
        metrics: ts
    };
    e1["Segoeui-Bold"] = {
        name: "LiberationSans-Bold",
        factors: Za,
        baseWidths: Ma,
        baseMapping: Ua,
        metrics: Va
    };
    e1["Segoeui-Italic"] = {
        name: "LiberationSans-Italic",
        factors: $a,
        baseWidths: Ha,
        baseMapping: Ja,
        metrics: As
    };
    e1["Segoeui-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: za,
        baseWidths: xa,
        baseMapping: La,
        metrics: _a
    };
    e1["Helvetica-Regular"] = e1.Helvetica = {
        name: "LiberationSans-Regular",
        factors: Na,
        baseWidths: Ya,
        baseMapping: va,
        metrics: Ga
    };
    e1["Helvetica-Bold"] = {
        name: "LiberationSans-Bold",
        factors: Da,
        baseWidths: Ma,
        baseMapping: Ua,
        metrics: ba
    };
    e1["Helvetica-Italic"] = {
        name: "LiberationSans-Italic",
        factors: ka,
        baseWidths: Ha,
        baseMapping: Ja,
        metrics: Ra
    };
    e1["Helvetica-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: Fa,
        baseWidths: xa,
        baseMapping: La,
        metrics: Sa
    };
});
function getXfaFontName(e1) {
    const t = normalizeFontName(e1);
    return is()[t];
}
function getXfaFontDict(e1) {
    const t = function getXfaFontWidths(e1) {
        const t = getXfaFontName(e1);
        if (!t) return null;
        const { baseWidths: i, baseMapping: a, factors: s } = t, r = s ? i.map((e1, t)=>e1 * s[t]) : i;
        let n, g = -2;
        const o = [];
        for (const [e1, t] of a.map((e1, t)=>[
                e1,
                t
            ]).sort(([e1], [t])=>e1 - t))if (-1 !== e1) if (e1 === g + 1) {
            n.push(r[t]);
            g += 1;
        } else {
            g = e1;
            n = [
                r[t]
            ];
            o.push(e1, n);
        }
        return o;
    }(e1), i = new Dict(null);
    i.set("BaseFont", Name.get(e1));
    i.set("Type", Name.get("Font"));
    i.set("Subtype", Name.get("CIDFontType2"));
    i.set("Encoding", Name.get("Identity-H"));
    i.set("CIDToGIDMap", Name.get("Identity"));
    i.set("W", t);
    i.set("FirstChar", t[0]);
    i.set("LastChar", t.at(-2) + t.at(-1).length - 1);
    const a = new Dict(null);
    i.set("FontDescriptor", a);
    const s = new Dict(null);
    s.set("Ordering", "Identity");
    s.set("Registry", "Adobe");
    s.set("Supplement", 0);
    i.set("CIDSystemInfo", s);
    return i;
}
class PostScriptParser {
    constructor(e1){
        this.lexer = e1;
        this.operators = [];
        this.token = null;
        this.prev = null;
    }
    nextToken() {
        this.prev = this.token;
        this.token = this.lexer.getToken();
    }
    accept(e1) {
        if (this.token.type === e1) {
            this.nextToken();
            return !0;
        }
        return !1;
    }
    expect(e1) {
        if (this.accept(e1)) return !0;
        throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${e1}.`);
    }
    parse() {
        this.nextToken();
        this.expect(as.LBRACE);
        this.parseBlock();
        this.expect(as.RBRACE);
        return this.operators;
    }
    parseBlock() {
        for(;;)if (this.accept(as.NUMBER)) this.operators.push(this.prev.value);
        else if (this.accept(as.OPERATOR)) this.operators.push(this.prev.value);
        else {
            if (!this.accept(as.LBRACE)) return;
            this.parseCondition();
        }
    }
    parseCondition() {
        const e1 = this.operators.length;
        this.operators.push(null, null);
        this.parseBlock();
        this.expect(as.RBRACE);
        if (this.accept(as.IF)) {
            this.operators[e1] = this.operators.length;
            this.operators[e1 + 1] = "jz";
        } else {
            if (!this.accept(as.LBRACE)) throw new FormatError("PS Function: error parsing conditional.");
            {
                const t = this.operators.length;
                this.operators.push(null, null);
                const i = this.operators.length;
                this.parseBlock();
                this.expect(as.RBRACE);
                this.expect(as.IFELSE);
                this.operators[t] = this.operators.length;
                this.operators[t + 1] = "j";
                this.operators[e1] = i;
                this.operators[e1 + 1] = "jz";
            }
        }
    }
}
const as = {
    LBRACE: 0,
    RBRACE: 1,
    NUMBER: 2,
    OPERATOR: 3,
    IF: 4,
    IFELSE: 5
};
class PostScriptToken {
    static get opCache() {
        return shadow(this, "opCache", Object.create(null));
    }
    constructor(e1, t){
        this.type = e1;
        this.value = t;
    }
    static getOperator(e1) {
        return PostScriptToken.opCache[e1] ||= new PostScriptToken(as.OPERATOR, e1);
    }
    static get LBRACE() {
        return shadow(this, "LBRACE", new PostScriptToken(as.LBRACE, "{"));
    }
    static get RBRACE() {
        return shadow(this, "RBRACE", new PostScriptToken(as.RBRACE, "}"));
    }
    static get IF() {
        return shadow(this, "IF", new PostScriptToken(as.IF, "IF"));
    }
    static get IFELSE() {
        return shadow(this, "IFELSE", new PostScriptToken(as.IFELSE, "IFELSE"));
    }
}
class PostScriptLexer {
    constructor(e1){
        this.stream = e1;
        this.nextChar();
        this.strBuf = [];
    }
    nextChar() {
        return this.currentChar = this.stream.getByte();
    }
    getToken() {
        let e1 = !1, t = this.currentChar;
        for(;;){
            if (t < 0) return Bt;
            if (e1) 10 !== t && 13 !== t || (e1 = !1);
            else if (37 === t) e1 = !0;
            else if (!isWhiteSpace(t)) break;
            t = this.nextChar();
        }
        switch(0 | t){
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 43:
            case 45:
            case 46:
                return new PostScriptToken(as.NUMBER, this.getNumber());
            case 123:
                this.nextChar();
                return PostScriptToken.LBRACE;
            case 125:
                this.nextChar();
                return PostScriptToken.RBRACE;
        }
        const i = this.strBuf;
        i.length = 0;
        i[0] = String.fromCharCode(t);
        for(; (t = this.nextChar()) >= 0 && (t >= 65 && t <= 90 || t >= 97 && t <= 122);)i.push(String.fromCharCode(t));
        const a = i.join("");
        switch(a.toLowerCase()){
            case "if":
                return PostScriptToken.IF;
            case "ifelse":
                return PostScriptToken.IFELSE;
            default:
                return PostScriptToken.getOperator(a);
        }
    }
    getNumber() {
        let e1 = this.currentChar;
        const t = this.strBuf;
        t.length = 0;
        t[0] = String.fromCharCode(e1);
        for(; (e1 = this.nextChar()) >= 0 && (e1 >= 48 && e1 <= 57 || 45 === e1 || 46 === e1);)t.push(String.fromCharCode(e1));
        const i = parseFloat(t.join(""));
        if (isNaN(i)) throw new FormatError(`Invalid floating point number: ${i}`);
        return i;
    }
}
class BaseLocalCache {
    constructor(e1){
        this._onlyRefs = !0 === e1?.onlyRefs;
        if (!this._onlyRefs) {
            this._nameRefMap = new Map;
            this._imageMap = new Map;
        }
        this._imageCache = new RefSetCache;
    }
    getByName(e1) {
        this._onlyRefs && unreachable("Should not call `getByName` method.");
        const t = this._nameRefMap.get(e1);
        return t ? this.getByRef(t) : this._imageMap.get(e1) || null;
    }
    getByRef(e1) {
        return this._imageCache.get(e1) || null;
    }
    set(e1, t, i) {
        unreachable("Abstract method `set` called.");
    }
}
class LocalImageCache extends BaseLocalCache {
    set(e1, t = null, i) {
        if ("string" != typeof e1) throw new Error('LocalImageCache.set - expected "name" argument.');
        if (t) {
            if (this._imageCache.has(t)) return;
            this._nameRefMap.set(e1, t);
            this._imageCache.put(t, i);
        } else this._imageMap.has(e1) || this._imageMap.set(e1, i);
    }
}
class LocalColorSpaceCache extends BaseLocalCache {
    set(e1 = null, t = null, i) {
        if ("string" != typeof e1 && !t) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
        if (t) {
            if (this._imageCache.has(t)) return;
            null !== e1 && this._nameRefMap.set(e1, t);
            this._imageCache.put(t, i);
        } else this._imageMap.has(e1) || this._imageMap.set(e1, i);
    }
}
class LocalFunctionCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, i) {
        if (!t) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, i);
    }
}
class LocalGStateCache extends BaseLocalCache {
    set(e1, t = null, i) {
        if ("string" != typeof e1) throw new Error('LocalGStateCache.set - expected "name" argument.');
        if (t) {
            if (this._imageCache.has(t)) return;
            this._nameRefMap.set(e1, t);
            this._imageCache.put(t, i);
        } else this._imageMap.has(e1) || this._imageMap.set(e1, i);
    }
}
class LocalTilingPatternCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, i) {
        if (!t) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, i);
    }
}
class RegionalImageCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, i) {
        if (!t) throw new Error('RegionalImageCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, i);
    }
}
class GlobalImageCache {
    static NUM_PAGES_THRESHOLD = 2;
    static MIN_IMAGES_TO_CACHE = 10;
    static MAX_BYTE_SIZE = 5e7;
    #F = new RefSet;
    constructor(){
        this._refCache = new RefSetCache;
        this._imageCache = new RefSetCache;
    }
    get #S() {
        let e1 = 0;
        for (const t of this._imageCache)e1 += t.byteSize;
        return e1;
    }
    get #k() {
        return !(this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(this.#S < GlobalImageCache.MAX_BYTE_SIZE);
    }
    shouldCache(e1, t) {
        let i = this._refCache.get(e1);
        if (!i) {
            i = new Set;
            this._refCache.put(e1, i);
        }
        i.add(t);
        return !(i.size < GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e1) && this.#k);
    }
    addDecodeFailed(e1) {
        this.#F.put(e1);
    }
    hasDecodeFailed(e1) {
        return this.#F.has(e1);
    }
    addByteSize(e1, t) {
        const i = this._imageCache.get(e1);
        i && (i.byteSize || (i.byteSize = t));
    }
    getData(e1, t) {
        const i = this._refCache.get(e1);
        if (!i) return null;
        if (i.size < GlobalImageCache.NUM_PAGES_THRESHOLD) return null;
        const a = this._imageCache.get(e1);
        if (!a) return null;
        i.add(t);
        return a;
    }
    setData(e1, t) {
        if (!this._refCache.has(e1)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
        this._imageCache.has(e1) || (this.#k ? warn("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e1, t));
    }
    clear(e1 = !1) {
        if (!e1) {
            this.#F.clear();
            this._refCache.clear();
        }
        this._imageCache.clear();
    }
}
class PDFFunctionFactory {
    constructor({ xref: e1, isEvalSupported: t = !0 }){
        this.xref = e1;
        this.isEvalSupported = !1 !== t;
    }
    create(e1) {
        const t = this.getCached(e1);
        if (t) return t;
        const i = PDFFunction.parse({
            xref: this.xref,
            isEvalSupported: this.isEvalSupported,
            fn: e1 instanceof Ref ? this.xref.fetch(e1) : e1
        });
        this._cache(e1, i);
        return i;
    }
    createFromArray(e1) {
        const t = this.getCached(e1);
        if (t) return t;
        const i = PDFFunction.parseArray({
            xref: this.xref,
            isEvalSupported: this.isEvalSupported,
            fnObj: e1 instanceof Ref ? this.xref.fetch(e1) : e1
        });
        this._cache(e1, i);
        return i;
    }
    getCached(e1) {
        let t;
        e1 instanceof Ref ? t = e1 : e1 instanceof Dict ? t = e1.objId : e1 instanceof BaseStream && (t = e1.dict?.objId);
        if (t) {
            const e1 = this._localFunctionCache.getByRef(t);
            if (e1) return e1;
        }
        return null;
    }
    _cache(e1, t) {
        if (!t) throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
        let i;
        e1 instanceof Ref ? i = e1 : e1 instanceof Dict ? i = e1.objId : e1 instanceof BaseStream && (i = e1.dict?.objId);
        i && this._localFunctionCache.set(null, i, t);
    }
    get _localFunctionCache() {
        return shadow(this, "_localFunctionCache", new LocalFunctionCache);
    }
}
function toNumberArray(e1) {
    return Array.isArray(e1) ? isNumberArray(e1, null) ? e1 : e1.map((e1)=>+e1) : null;
}
class PDFFunction {
    static getSampleArray(e1, t, i, a) {
        let s, r, n = 1;
        for(s = 0, r = e1.length; s < r; s++)n *= e1[s];
        n *= t;
        const g = new Array(n);
        let o = 0, c = 0;
        const C = 1 / (2 ** i - 1), h = a.getBytes((n * i + 7) / 8);
        let l = 0;
        for(s = 0; s < n; s++){
            for(; o < i;){
                c <<= 8;
                c |= h[l++];
                o += 8;
            }
            o -= i;
            g[s] = (c >> o) * C;
            c &= (1 << o) - 1;
        }
        return g;
    }
    static parse({ xref: e1, isEvalSupported: t, fn: i }) {
        const a = i.dict || i;
        switch(a.get("FunctionType")){
            case 0:
                return this.constructSampled({
                    xref: e1,
                    isEvalSupported: t,
                    fn: i,
                    dict: a
                });
            case 1:
                break;
            case 2:
                return this.constructInterpolated({
                    xref: e1,
                    isEvalSupported: t,
                    dict: a
                });
            case 3:
                return this.constructStiched({
                    xref: e1,
                    isEvalSupported: t,
                    dict: a
                });
            case 4:
                return this.constructPostScript({
                    xref: e1,
                    isEvalSupported: t,
                    fn: i,
                    dict: a
                });
        }
        throw new FormatError("Unknown type of function");
    }
    static parseArray({ xref: e1, isEvalSupported: t, fnObj: i }) {
        if (!Array.isArray(i)) return this.parse({
            xref: e1,
            isEvalSupported: t,
            fn: i
        });
        const a = [];
        for (const s of i)a.push(this.parse({
            xref: e1,
            isEvalSupported: t,
            fn: e1.fetchIfRef(s)
        }));
        return function(e1, t, i, s) {
            for(let r = 0, n = a.length; r < n; r++)a[r](e1, t, i, s + r);
        };
    }
    static constructSampled({ xref: e1, isEvalSupported: t, fn: i, dict: a }) {
        function toMultiArray(e1) {
            const t = e1.length, i = [];
            let a = 0;
            for(let s = 0; s < t; s += 2)i[a++] = [
                e1[s],
                e1[s + 1]
            ];
            return i;
        }
        function interpolate(e1, t, i, a, s) {
            return a + (s - a) / (i - t) * (e1 - t);
        }
        let s = toNumberArray(a.getArray("Domain")), r = toNumberArray(a.getArray("Range"));
        if (!s || !r) throw new FormatError("No domain or range");
        const n = s.length / 2, g = r.length / 2;
        s = toMultiArray(s);
        r = toMultiArray(r);
        const o = toNumberArray(a.getArray("Size")), c = a.get("BitsPerSample"), C = a.get("Order") || 1;
        1 !== C && info("No support for cubic spline interpolation: " + C);
        let h = toNumberArray(a.getArray("Encode"));
        if (h) h = toMultiArray(h);
        else {
            h = [];
            for(let e1 = 0; e1 < n; ++e1)h.push([
                0,
                o[e1] - 1
            ]);
        }
        let l = toNumberArray(a.getArray("Decode"));
        l = l ? toMultiArray(l) : r;
        const Q = this.getSampleArray(o, g, c, i);
        return function constructSampledFn(e1, t, i, a) {
            const c = 1 << n, C = new Float64Array(c), E = new Uint32Array(c);
            let u, d;
            for(d = 0; d < c; d++)C[d] = 1;
            let f = g, p = 1;
            for(u = 0; u < n; ++u){
                const i = s[u][0], a = s[u][1];
                let r = interpolate(Math.min(Math.max(e1[t + u], i), a), i, a, h[u][0], h[u][1]);
                const n = o[u];
                r = Math.min(Math.max(r, 0), n - 1);
                const g = r < n - 1 ? Math.floor(r) : r - 1, l = g + 1 - r, Q = r - g, m = g * f, y = m + f;
                for(d = 0; d < c; d++)if (d & p) {
                    C[d] *= Q;
                    E[d] += y;
                } else {
                    C[d] *= l;
                    E[d] += m;
                }
                f *= n;
                p <<= 1;
            }
            for(d = 0; d < g; ++d){
                let e1 = 0;
                for(u = 0; u < c; u++)e1 += Q[E[u] + d] * C[u];
                e1 = interpolate(e1, 0, 1, l[d][0], l[d][1]);
                i[a + d] = Math.min(Math.max(e1, r[d][0]), r[d][1]);
            }
        };
    }
    static constructInterpolated({ xref: e1, isEvalSupported: t, dict: i }) {
        const a = toNumberArray(i.getArray("C0")) || [
            0
        ], s = toNumberArray(i.getArray("C1")) || [
            1
        ], r = i.get("N"), n = [];
        for(let e1 = 0, t = a.length; e1 < t; ++e1)n.push(s[e1] - a[e1]);
        const g = n.length;
        return function constructInterpolatedFn(e1, t, i, s) {
            const o = 1 === r ? e1[t] : e1[t] ** r;
            for(let e1 = 0; e1 < g; ++e1)i[s + e1] = a[e1] + o * n[e1];
        };
    }
    static constructStiched({ xref: e1, isEvalSupported: t, dict: i }) {
        const a = toNumberArray(i.getArray("Domain"));
        if (!a) throw new FormatError("No domain");
        if (1 !== a.length / 2) throw new FormatError("Bad domain for stiched function");
        const s = [];
        for (const a of i.get("Functions"))s.push(this.parse({
            xref: e1,
            isEvalSupported: t,
            fn: e1.fetchIfRef(a)
        }));
        const r = toNumberArray(i.getArray("Bounds")), n = toNumberArray(i.getArray("Encode")), g = new Float32Array(1);
        return function constructStichedFn(e1, t, i, o) {
            const c = function constructStichedFromIRClip(e1, t, i) {
                e1 > i ? e1 = i : e1 < t && (e1 = t);
                return e1;
            }(e1[t], a[0], a[1]), C = r.length;
            let h;
            for(h = 0; h < C && !(c < r[h]); ++h);
            let l = a[0];
            h > 0 && (l = r[h - 1]);
            let Q = a[1];
            h < r.length && (Q = r[h]);
            const E = n[2 * h], u = n[2 * h + 1];
            g[0] = l === Q ? E : E + (c - l) * (u - E) / (Q - l);
            s[h](g, 0, i, o);
        };
    }
    static constructPostScript({ xref: e1, isEvalSupported: t, fn: i, dict: a }) {
        const s = toNumberArray(a.getArray("Domain")), r = toNumberArray(a.getArray("Range"));
        if (!s) throw new FormatError("No domain.");
        if (!r) throw new FormatError("No range.");
        const n = new PostScriptLexer(i), g = new PostScriptParser(n).parse();
        if (t && FeatureTest.isEvalSupported) {
            const e1 = (new PostScriptCompiler).compile(g, s, r);
            if (e1) return new Function("src", "srcOffset", "dest", "destOffset", e1);
        }
        info("Unable to compile PS function");
        const o = r.length >> 1, c = s.length >> 1, C = new PostScriptEvaluator(g), h = Object.create(null);
        let l = 8192;
        const Q = new Float32Array(c);
        return function constructPostScriptFn(e1, t, i, a) {
            let s, n, g = "";
            const E = Q;
            for(s = 0; s < c; s++){
                n = e1[t + s];
                E[s] = n;
                g += n + "_";
            }
            const u = h[g];
            if (void 0 !== u) {
                i.set(u, a);
                return;
            }
            const d = new Float32Array(o), f = C.execute(E), p = f.length - o;
            for(s = 0; s < o; s++){
                n = f[p + s];
                let e1 = r[2 * s];
                if (n < e1) n = e1;
                else {
                    e1 = r[2 * s + 1];
                    n > e1 && (n = e1);
                }
                d[s] = n;
            }
            if (l > 0) {
                l--;
                h[g] = d;
            }
            i.set(d, a);
        };
    }
}
function isPDFFunction(e1) {
    let t;
    if (e1 instanceof Dict) t = e1;
    else {
        if (!(e1 instanceof BaseStream)) return !1;
        t = e1.dict;
    }
    return t.has("FunctionType");
}
class PostScriptStack {
    static MAX_STACK_SIZE = 100;
    constructor(e1){
        this.stack = e1 ? Array.from(e1) : [];
    }
    push(e1) {
        if (this.stack.length >= PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
        this.stack.push(e1);
    }
    pop() {
        if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
        return this.stack.pop();
    }
    copy(e1) {
        if (this.stack.length + e1 >= PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
        const t = this.stack;
        for(let i = t.length - e1, a = e1 - 1; a >= 0; a--, i++)t.push(t[i]);
    }
    index(e1) {
        this.push(this.stack[this.stack.length - e1 - 1]);
    }
    roll(e1, t) {
        const i = this.stack, a = i.length - e1, s = i.length - 1, r = a + (t - Math.floor(t / e1) * e1);
        for(let e1 = a, t = s; e1 < t; e1++, t--){
            const a = i[e1];
            i[e1] = i[t];
            i[t] = a;
        }
        for(let e1 = a, t = r - 1; e1 < t; e1++, t--){
            const a = i[e1];
            i[e1] = i[t];
            i[t] = a;
        }
        for(let e1 = r, t = s; e1 < t; e1++, t--){
            const a = i[e1];
            i[e1] = i[t];
            i[t] = a;
        }
    }
}
class PostScriptEvaluator {
    constructor(e1){
        this.operators = e1;
    }
    execute(e1) {
        const t = new PostScriptStack(e1);
        let i = 0;
        const a = this.operators, s = a.length;
        let r, n, g;
        for(; i < s;){
            r = a[i++];
            if ("number" != typeof r) switch(r){
                case "jz":
                    g = t.pop();
                    n = t.pop();
                    n || (i = g);
                    break;
                case "j":
                    n = t.pop();
                    i = n;
                    break;
                case "abs":
                    n = t.pop();
                    t.push(Math.abs(n));
                    break;
                case "add":
                    g = t.pop();
                    n = t.pop();
                    t.push(n + g);
                    break;
                case "and":
                    g = t.pop();
                    n = t.pop();
                    "boolean" == typeof n && "boolean" == typeof g ? t.push(n && g) : t.push(n & g);
                    break;
                case "atan":
                    g = t.pop();
                    n = t.pop();
                    n = Math.atan2(n, g) / Math.PI * 180;
                    n < 0 && (n += 360);
                    t.push(n);
                    break;
                case "bitshift":
                    g = t.pop();
                    n = t.pop();
                    n > 0 ? t.push(n << g) : t.push(n >> g);
                    break;
                case "ceiling":
                    n = t.pop();
                    t.push(Math.ceil(n));
                    break;
                case "copy":
                    n = t.pop();
                    t.copy(n);
                    break;
                case "cos":
                    n = t.pop();
                    t.push(Math.cos(n % 360 / 180 * Math.PI));
                    break;
                case "cvi":
                    n = 0 | t.pop();
                    t.push(n);
                    break;
                case "cvr":
                    break;
                case "div":
                    g = t.pop();
                    n = t.pop();
                    t.push(n / g);
                    break;
                case "dup":
                    t.copy(1);
                    break;
                case "eq":
                    g = t.pop();
                    n = t.pop();
                    t.push(n === g);
                    break;
                case "exch":
                    t.roll(2, 1);
                    break;
                case "exp":
                    g = t.pop();
                    n = t.pop();
                    t.push(n ** g);
                    break;
                case "false":
                    t.push(!1);
                    break;
                case "floor":
                    n = t.pop();
                    t.push(Math.floor(n));
                    break;
                case "ge":
                    g = t.pop();
                    n = t.pop();
                    t.push(n >= g);
                    break;
                case "gt":
                    g = t.pop();
                    n = t.pop();
                    t.push(n > g);
                    break;
                case "idiv":
                    g = t.pop();
                    n = t.pop();
                    t.push(n / g | 0);
                    break;
                case "index":
                    n = t.pop();
                    t.index(n);
                    break;
                case "le":
                    g = t.pop();
                    n = t.pop();
                    t.push(n <= g);
                    break;
                case "ln":
                    n = t.pop();
                    t.push(Math.log(n));
                    break;
                case "log":
                    n = t.pop();
                    t.push(Math.log10(n));
                    break;
                case "lt":
                    g = t.pop();
                    n = t.pop();
                    t.push(n < g);
                    break;
                case "mod":
                    g = t.pop();
                    n = t.pop();
                    t.push(n % g);
                    break;
                case "mul":
                    g = t.pop();
                    n = t.pop();
                    t.push(n * g);
                    break;
                case "ne":
                    g = t.pop();
                    n = t.pop();
                    t.push(n !== g);
                    break;
                case "neg":
                    n = t.pop();
                    t.push(-n);
                    break;
                case "not":
                    n = t.pop();
                    "boolean" == typeof n ? t.push(!n) : t.push(~n);
                    break;
                case "or":
                    g = t.pop();
                    n = t.pop();
                    "boolean" == typeof n && "boolean" == typeof g ? t.push(n || g) : t.push(n | g);
                    break;
                case "pop":
                    t.pop();
                    break;
                case "roll":
                    g = t.pop();
                    n = t.pop();
                    t.roll(n, g);
                    break;
                case "round":
                    n = t.pop();
                    t.push(Math.round(n));
                    break;
                case "sin":
                    n = t.pop();
                    t.push(Math.sin(n % 360 / 180 * Math.PI));
                    break;
                case "sqrt":
                    n = t.pop();
                    t.push(Math.sqrt(n));
                    break;
                case "sub":
                    g = t.pop();
                    n = t.pop();
                    t.push(n - g);
                    break;
                case "true":
                    t.push(!0);
                    break;
                case "truncate":
                    n = t.pop();
                    n = n < 0 ? Math.ceil(n) : Math.floor(n);
                    t.push(n);
                    break;
                case "xor":
                    g = t.pop();
                    n = t.pop();
                    "boolean" == typeof n && "boolean" == typeof g ? t.push(n !== g) : t.push(n ^ g);
                    break;
                default:
                    throw new FormatError(`Unknown operator ${r}`);
            }
            else t.push(r);
        }
        return t.stack;
    }
}
class AstNode {
    constructor(e1){
        this.type = e1;
    }
    visit(e1) {
        unreachable("abstract method");
    }
}
class AstArgument extends AstNode {
    constructor(e1, t, i){
        super("args");
        this.index = e1;
        this.min = t;
        this.max = i;
    }
    visit(e1) {
        e1.visitArgument(this);
    }
}
class AstLiteral extends AstNode {
    constructor(e1){
        super("literal");
        this.number = e1;
        this.min = e1;
        this.max = e1;
    }
    visit(e1) {
        e1.visitLiteral(this);
    }
}
class AstBinaryOperation extends AstNode {
    constructor(e1, t, i, a, s){
        super("binary");
        this.op = e1;
        this.arg1 = t;
        this.arg2 = i;
        this.min = a;
        this.max = s;
    }
    visit(e1) {
        e1.visitBinaryOperation(this);
    }
}
class AstMin extends AstNode {
    constructor(e1, t){
        super("max");
        this.arg = e1;
        this.min = e1.min;
        this.max = t;
    }
    visit(e1) {
        e1.visitMin(this);
    }
}
class AstVariable extends AstNode {
    constructor(e1, t, i){
        super("var");
        this.index = e1;
        this.min = t;
        this.max = i;
    }
    visit(e1) {
        e1.visitVariable(this);
    }
}
class AstVariableDefinition extends AstNode {
    constructor(e1, t){
        super("definition");
        this.variable = e1;
        this.arg = t;
    }
    visit(e1) {
        e1.visitVariableDefinition(this);
    }
}
class ExpressionBuilderVisitor {
    constructor(){
        this.parts = [];
    }
    visitArgument(e1) {
        this.parts.push("Math.max(", e1.min, ", Math.min(", e1.max, ", src[srcOffset + ", e1.index, "]))");
    }
    visitVariable(e1) {
        this.parts.push("v", e1.index);
    }
    visitLiteral(e1) {
        this.parts.push(e1.number);
    }
    visitBinaryOperation(e1) {
        this.parts.push("(");
        e1.arg1.visit(this);
        this.parts.push(" ", e1.op, " ");
        e1.arg2.visit(this);
        this.parts.push(")");
    }
    visitVariableDefinition(e1) {
        this.parts.push("var ");
        e1.variable.visit(this);
        this.parts.push(" = ");
        e1.arg.visit(this);
        this.parts.push(";");
    }
    visitMin(e1) {
        this.parts.push("Math.min(");
        e1.arg.visit(this);
        this.parts.push(", ", e1.max, ")");
    }
    toString() {
        return this.parts.join("");
    }
}
function buildAddOperation(e1, t) {
    return "literal" === t.type && 0 === t.number ? e1 : "literal" === e1.type && 0 === e1.number ? t : "literal" === t.type && "literal" === e1.type ? new AstLiteral(e1.number + t.number) : new AstBinaryOperation("+", e1, t, e1.min + t.min, e1.max + t.max);
}
function buildMulOperation(e1, t) {
    if ("literal" === t.type) {
        if (0 === t.number) return new AstLiteral(0);
        if (1 === t.number) return e1;
        if ("literal" === e1.type) return new AstLiteral(e1.number * t.number);
    }
    if ("literal" === e1.type) {
        if (0 === e1.number) return new AstLiteral(0);
        if (1 === e1.number) return t;
    }
    const i = Math.min(e1.min * t.min, e1.min * t.max, e1.max * t.min, e1.max * t.max), a = Math.max(e1.min * t.min, e1.min * t.max, e1.max * t.min, e1.max * t.max);
    return new AstBinaryOperation("*", e1, t, i, a);
}
function buildSubOperation(e1, t) {
    if ("literal" === t.type) {
        if (0 === t.number) return e1;
        if ("literal" === e1.type) return new AstLiteral(e1.number - t.number);
    }
    return "binary" === t.type && "-" === t.op && "literal" === e1.type && 1 === e1.number && "literal" === t.arg1.type && 1 === t.arg1.number ? t.arg2 : new AstBinaryOperation("-", e1, t, e1.min - t.max, e1.max - t.min);
}
function buildMinOperation(e1, t) {
    return e1.min >= t ? new AstLiteral(t) : e1.max <= t ? e1 : new AstMin(e1, t);
}
class PostScriptCompiler {
    compile(e1, t, i) {
        const a = [], s = [], r = t.length >> 1, n = i.length >> 1;
        let g, o, c, C, h, l, Q, E, u = 0;
        for(let e1 = 0; e1 < r; e1++)a.push(new AstArgument(e1, t[2 * e1], t[2 * e1 + 1]));
        for(let t = 0, i = e1.length; t < i; t++){
            E = e1[t];
            if ("number" != typeof E) switch(E){
                case "add":
                    if (a.length < 2) return null;
                    C = a.pop();
                    c = a.pop();
                    a.push(buildAddOperation(c, C));
                    break;
                case "cvr":
                    if (a.length < 1) return null;
                    break;
                case "mul":
                    if (a.length < 2) return null;
                    C = a.pop();
                    c = a.pop();
                    a.push(buildMulOperation(c, C));
                    break;
                case "sub":
                    if (a.length < 2) return null;
                    C = a.pop();
                    c = a.pop();
                    a.push(buildSubOperation(c, C));
                    break;
                case "exch":
                    if (a.length < 2) return null;
                    h = a.pop();
                    l = a.pop();
                    a.push(h, l);
                    break;
                case "pop":
                    if (a.length < 1) return null;
                    a.pop();
                    break;
                case "index":
                    if (a.length < 1) return null;
                    c = a.pop();
                    if ("literal" !== c.type) return null;
                    g = c.number;
                    if (g < 0 || !Number.isInteger(g) || a.length < g) return null;
                    h = a[a.length - g - 1];
                    if ("literal" === h.type || "var" === h.type) {
                        a.push(h);
                        break;
                    }
                    Q = new AstVariable(u++, h.min, h.max);
                    a[a.length - g - 1] = Q;
                    a.push(Q);
                    s.push(new AstVariableDefinition(Q, h));
                    break;
                case "dup":
                    if (a.length < 1) return null;
                    if ("number" == typeof e1[t + 1] && "gt" === e1[t + 2] && e1[t + 3] === t + 7 && "jz" === e1[t + 4] && "pop" === e1[t + 5] && e1[t + 6] === e1[t + 1]) {
                        c = a.pop();
                        a.push(buildMinOperation(c, e1[t + 1]));
                        t += 6;
                        break;
                    }
                    h = a.at(-1);
                    if ("literal" === h.type || "var" === h.type) {
                        a.push(h);
                        break;
                    }
                    Q = new AstVariable(u++, h.min, h.max);
                    a[a.length - 1] = Q;
                    a.push(Q);
                    s.push(new AstVariableDefinition(Q, h));
                    break;
                case "roll":
                    if (a.length < 2) return null;
                    C = a.pop();
                    c = a.pop();
                    if ("literal" !== C.type || "literal" !== c.type) return null;
                    o = C.number;
                    g = c.number;
                    if (g <= 0 || !Number.isInteger(g) || !Number.isInteger(o) || a.length < g) return null;
                    o = (o % g + g) % g;
                    if (0 === o) break;
                    a.push(...a.splice(a.length - g, g - o));
                    break;
                default:
                    return null;
            }
            else a.push(new AstLiteral(E));
        }
        if (a.length !== n) return null;
        const d = [];
        for (const e1 of s){
            const t = new ExpressionBuilderVisitor;
            e1.visit(t);
            d.push(t.toString());
        }
        for(let e1 = 0, t = a.length; e1 < t; e1++){
            const t = a[e1], s = new ExpressionBuilderVisitor;
            t.visit(s);
            const r = i[2 * e1], n = i[2 * e1 + 1], g = [
                s.toString()
            ];
            if (r > t.min) {
                g.unshift("Math.max(", r, ", ");
                g.push(")");
            }
            if (n < t.max) {
                g.unshift("Math.min(", n, ", ");
                g.push(")");
            }
            g.unshift("dest[destOffset + ", e1, "] = ");
            g.push(";");
            d.push(g.join(""));
        }
        return d.join("\n");
    }
}
const ss = [
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "S",
    "B",
    "S",
    "WS",
    "B",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "B",
    "B",
    "B",
    "S",
    "WS",
    "ON",
    "ON",
    "ET",
    "ET",
    "ET",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ES",
    "CS",
    "ES",
    "CS",
    "CS",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "CS",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "B",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "CS",
    "ON",
    "ET",
    "ET",
    "ET",
    "ET",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "ON",
    "ON",
    "BN",
    "ON",
    "ON",
    "ET",
    "ET",
    "EN",
    "EN",
    "ON",
    "L",
    "ON",
    "ON",
    "ON",
    "EN",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L"
], rs = [
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "ON",
    "ON",
    "AL",
    "ET",
    "ET",
    "AL",
    "CS",
    "AL",
    "ON",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "ET",
    "AN",
    "AN",
    "AL",
    "AL",
    "AL",
    "NSM",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AN",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL"
];
function isOdd(e1) {
    return !!(1 & e1);
}
function isEven(e1) {
    return !(1 & e1);
}
function findUnequal(e1, t, i) {
    let a, s;
    for(a = t, s = e1.length; a < s; ++a)if (e1[a] !== i) return a;
    return a;
}
function setValues(e1, t, i, a) {
    for(let s = t; s < i; ++s)e1[s] = a;
}
function reverseValues(e1, t, i) {
    for(let a = t, s = i - 1; a < s; ++a, --s){
        const t = e1[a];
        e1[a] = e1[s];
        e1[s] = t;
    }
}
function createBidiText(e1, t, i = !1) {
    let a = "ltr";
    i ? a = "ttb" : t || (a = "rtl");
    return {
        str: e1,
        dir: a
    };
}
const ns = [], gs = [];
function bidi(e1, t = -1, i = !1) {
    let a = !0;
    const s = e1.length;
    if (0 === s || i) return createBidiText(e1, a, i);
    ns.length = s;
    gs.length = s;
    let r, n, g = 0;
    for(r = 0; r < s; ++r){
        ns[r] = e1.charAt(r);
        const t = e1.charCodeAt(r);
        let i = "L";
        if (t <= 255) i = ss[t];
        else if (1424 <= t && t <= 1524) i = "R";
        else if (1536 <= t && t <= 1791) {
            i = rs[255 & t];
            i || warn("Bidi: invalid Unicode character " + t.toString(16));
        } else (1792 <= t && t <= 2220 || 64336 <= t && t <= 65023 || 65136 <= t && t <= 65279) && (i = "AL");
        "R" !== i && "AL" !== i && "AN" !== i || g++;
        gs[r] = i;
    }
    if (0 === g) {
        a = !0;
        return createBidiText(e1, a);
    }
    if (-1 === t) if (g / s < .3 && s > 4) {
        a = !0;
        t = 0;
    } else {
        a = !1;
        t = 1;
    }
    const o = [];
    for(r = 0; r < s; ++r)o[r] = t;
    const c = isOdd(t) ? "R" : "L", C = c, h = C;
    let l, Q = C;
    for(r = 0; r < s; ++r)"NSM" === gs[r] ? gs[r] = Q : Q = gs[r];
    Q = C;
    for(r = 0; r < s; ++r){
        l = gs[r];
        "EN" === l ? gs[r] = "AL" === Q ? "AN" : "EN" : "R" !== l && "L" !== l && "AL" !== l || (Q = l);
    }
    for(r = 0; r < s; ++r){
        l = gs[r];
        "AL" === l && (gs[r] = "R");
    }
    for(r = 1; r < s - 1; ++r){
        "ES" === gs[r] && "EN" === gs[r - 1] && "EN" === gs[r + 1] && (gs[r] = "EN");
        "CS" !== gs[r] || "EN" !== gs[r - 1] && "AN" !== gs[r - 1] || gs[r + 1] !== gs[r - 1] || (gs[r] = gs[r - 1]);
    }
    for(r = 0; r < s; ++r)if ("EN" === gs[r]) {
        for(let e1 = r - 1; e1 >= 0 && "ET" === gs[e1]; --e1)gs[e1] = "EN";
        for(let e1 = r + 1; e1 < s && "ET" === gs[e1]; ++e1)gs[e1] = "EN";
    }
    for(r = 0; r < s; ++r){
        l = gs[r];
        "WS" !== l && "ES" !== l && "ET" !== l && "CS" !== l || (gs[r] = "ON");
    }
    Q = C;
    for(r = 0; r < s; ++r){
        l = gs[r];
        "EN" === l ? gs[r] = "L" === Q ? "L" : "EN" : "R" !== l && "L" !== l || (Q = l);
    }
    for(r = 0; r < s; ++r)if ("ON" === gs[r]) {
        const e1 = findUnequal(gs, r + 1, "ON");
        let t = C;
        r > 0 && (t = gs[r - 1]);
        let i = h;
        e1 + 1 < s && (i = gs[e1 + 1]);
        "L" !== t && (t = "R");
        "L" !== i && (i = "R");
        t === i && setValues(gs, r, e1, t);
        r = e1 - 1;
    }
    for(r = 0; r < s; ++r)"ON" === gs[r] && (gs[r] = c);
    for(r = 0; r < s; ++r){
        l = gs[r];
        isEven(o[r]) ? "R" === l ? o[r] += 1 : "AN" !== l && "EN" !== l || (o[r] += 2) : "L" !== l && "AN" !== l && "EN" !== l || (o[r] += 1);
    }
    let E, u = -1, d = 99;
    for(r = 0, n = o.length; r < n; ++r){
        E = o[r];
        u < E && (u = E);
        d > E && isOdd(E) && (d = E);
    }
    for(E = u; E >= d; --E){
        let e1 = -1;
        for(r = 0, n = o.length; r < n; ++r)if (o[r] < E) {
            if (e1 >= 0) {
                reverseValues(ns, e1, r);
                e1 = -1;
            }
        } else e1 < 0 && (e1 = r);
        e1 >= 0 && reverseValues(ns, e1, o.length);
    }
    for(r = 0, n = ns.length; r < n; ++r){
        const e1 = ns[r];
        "<" !== e1 && ">" !== e1 || (ns[r] = "");
    }
    return createBidiText(ns.join(""), a);
}
const os = {
    style: "normal",
    weight: "normal"
}, Is = {
    style: "normal",
    weight: "bold"
}, cs = {
    style: "italic",
    weight: "normal"
}, Cs = {
    style: "italic",
    weight: "bold"
}, hs = new Map([
    [
        "Times-Roman",
        {
            local: [
                "Times New Roman",
                "Times-Roman",
                "Times",
                "Liberation Serif",
                "Nimbus Roman",
                "Nimbus Roman L",
                "Tinos",
                "Thorndale",
                "TeX Gyre Termes",
                "FreeSerif",
                "Linux Libertine O",
                "Libertinus Serif",
                "DejaVu Serif",
                "Bitstream Vera Serif",
                "Ubuntu"
            ],
            style: os,
            ultimate: "serif"
        }
    ],
    [
        "Times-Bold",
        {
            alias: "Times-Roman",
            style: Is,
            ultimate: "serif"
        }
    ],
    [
        "Times-Italic",
        {
            alias: "Times-Roman",
            style: cs,
            ultimate: "serif"
        }
    ],
    [
        "Times-BoldItalic",
        {
            alias: "Times-Roman",
            style: Cs,
            ultimate: "serif"
        }
    ],
    [
        "Helvetica",
        {
            local: [
                "Helvetica",
                "Helvetica Neue",
                "Arial",
                "Arial Nova",
                "Liberation Sans",
                "Arimo",
                "Nimbus Sans",
                "Nimbus Sans L",
                "A030",
                "TeX Gyre Heros",
                "FreeSans",
                "DejaVu Sans",
                "Albany",
                "Bitstream Vera Sans",
                "Arial Unicode MS",
                "Microsoft Sans Serif",
                "Apple Symbols",
                "Cantarell"
            ],
            path: "LiberationSans-Regular.ttf",
            style: os,
            ultimate: "sans-serif"
        }
    ],
    [
        "Helvetica-Bold",
        {
            alias: "Helvetica",
            path: "LiberationSans-Bold.ttf",
            style: Is,
            ultimate: "sans-serif"
        }
    ],
    [
        "Helvetica-Oblique",
        {
            alias: "Helvetica",
            path: "LiberationSans-Italic.ttf",
            style: cs,
            ultimate: "sans-serif"
        }
    ],
    [
        "Helvetica-BoldOblique",
        {
            alias: "Helvetica",
            path: "LiberationSans-BoldItalic.ttf",
            style: Cs,
            ultimate: "sans-serif"
        }
    ],
    [
        "Courier",
        {
            local: [
                "Courier",
                "Courier New",
                "Liberation Mono",
                "Nimbus Mono",
                "Nimbus Mono L",
                "Cousine",
                "Cumberland",
                "TeX Gyre Cursor",
                "FreeMono",
                "Linux Libertine Mono O",
                "Libertinus Mono"
            ],
            style: os,
            ultimate: "monospace"
        }
    ],
    [
        "Courier-Bold",
        {
            alias: "Courier",
            style: Is,
            ultimate: "monospace"
        }
    ],
    [
        "Courier-Oblique",
        {
            alias: "Courier",
            style: cs,
            ultimate: "monospace"
        }
    ],
    [
        "Courier-BoldOblique",
        {
            alias: "Courier",
            style: Cs,
            ultimate: "monospace"
        }
    ],
    [
        "ArialBlack",
        {
            local: [
                "Arial Black"
            ],
            style: {
                style: "normal",
                weight: "900"
            },
            fallback: "Helvetica-Bold"
        }
    ],
    [
        "ArialBlack-Bold",
        {
            alias: "ArialBlack"
        }
    ],
    [
        "ArialBlack-Italic",
        {
            alias: "ArialBlack",
            style: {
                style: "italic",
                weight: "900"
            },
            fallback: "Helvetica-BoldOblique"
        }
    ],
    [
        "ArialBlack-BoldItalic",
        {
            alias: "ArialBlack-Italic"
        }
    ],
    [
        "ArialNarrow",
        {
            local: [
                "Arial Narrow",
                "Liberation Sans Narrow",
                "Helvetica Condensed",
                "Nimbus Sans Narrow",
                "TeX Gyre Heros Cn"
            ],
            style: os,
            fallback: "Helvetica"
        }
    ],
    [
        "ArialNarrow-Bold",
        {
            alias: "ArialNarrow",
            style: Is,
            fallback: "Helvetica-Bold"
        }
    ],
    [
        "ArialNarrow-Italic",
        {
            alias: "ArialNarrow",
            style: cs,
            fallback: "Helvetica-Oblique"
        }
    ],
    [
        "ArialNarrow-BoldItalic",
        {
            alias: "ArialNarrow",
            style: Cs,
            fallback: "Helvetica-BoldOblique"
        }
    ],
    [
        "Calibri",
        {
            local: [
                "Calibri",
                "Carlito"
            ],
            style: os,
            fallback: "Helvetica"
        }
    ],
    [
        "Calibri-Bold",
        {
            alias: "Calibri",
            style: Is,
            fallback: "Helvetica-Bold"
        }
    ],
    [
        "Calibri-Italic",
        {
            alias: "Calibri",
            style: cs,
            fallback: "Helvetica-Oblique"
        }
    ],
    [
        "Calibri-BoldItalic",
        {
            alias: "Calibri",
            style: Cs,
            fallback: "Helvetica-BoldOblique"
        }
    ],
    [
        "Wingdings",
        {
            local: [
                "Wingdings",
                "URW Dingbats"
            ],
            style: os
        }
    ],
    [
        "Wingdings-Regular",
        {
            alias: "Wingdings"
        }
    ],
    [
        "Wingdings-Bold",
        {
            alias: "Wingdings"
        }
    ]
]), ls = new Map([
    [
        "Arial-Black",
        "ArialBlack"
    ]
]);
function getFamilyName(e1) {
    const t = new Set([
        "thin",
        "extralight",
        "ultralight",
        "demilight",
        "semilight",
        "light",
        "book",
        "regular",
        "normal",
        "medium",
        "demibold",
        "semibold",
        "bold",
        "extrabold",
        "ultrabold",
        "black",
        "heavy",
        "extrablack",
        "ultrablack",
        "roman",
        "italic",
        "oblique",
        "ultracondensed",
        "extracondensed",
        "condensed",
        "semicondensed",
        "normal",
        "semiexpanded",
        "expanded",
        "extraexpanded",
        "ultraexpanded",
        "bolditalic"
    ]);
    return e1.split(/[- ,+]+/g).filter((e1)=>!t.has(e1.toLowerCase())).join(" ");
}
function generateFont({ alias: e1, local: t, path: i, fallback: a, style: s, ultimate: r }, n, g, o = !0, c = !0, C = "") {
    const h = {
        style: null,
        ultimate: null
    };
    if (t) {
        const e1 = C ? ` ${C}` : "";
        for (const i of t)n.push(`local(${i}${e1})`);
    }
    if (e1) {
        const t = hs.get(e1), r = C || function getStyleToAppend(e1) {
            switch(e1){
                case Is:
                    return "Bold";
                case cs:
                    return "Italic";
                case Cs:
                    return "Bold Italic";
                default:
                    if ("bold" === e1?.weight) return "Bold";
                    if ("italic" === e1?.style) return "Italic";
            }
            return "";
        }(s);
        Object.assign(h, generateFont(t, n, g, o && !a, c && !i, r));
    }
    s && (h.style = s);
    r && (h.ultimate = r);
    if (o && a) {
        const e1 = hs.get(a), { ultimate: t } = generateFont(e1, n, g, o, c && !i, C);
        h.ultimate ||= t;
    }
    c && i && g && n.push(`url(${g}${i})`);
    return h;
}
function getFontSubstitution(e1, t, i, a, s, r) {
    if (a.startsWith("InvalidPDFjsFont_")) return null;
    "TrueType" !== r && "Type1" !== r || !/^[A-Z]{6}\+/.test(a) || (a = a.slice(7));
    const n = a = normalizeFontName(a);
    let g = e1.get(n);
    if (g) return g;
    let o = hs.get(a);
    if (!o) {
        for (const [e1, t] of ls)if (a.startsWith(e1)) {
            a = `${t}${a.substring(e1.length)}`;
            o = hs.get(a);
            break;
        }
    }
    let c = !1;
    if (!o) {
        o = hs.get(s);
        c = !0;
    }
    const C = `${t.getDocId()}_s${t.createFontId()}`;
    if (!o) {
        if (!validateFontName(a)) {
            warn(`Cannot substitute the font because of its name: ${a}`);
            e1.set(n, null);
            return null;
        }
        const t = /bold/gi.test(a), i = /oblique|italic/gi.test(a), s = t && i && Cs || t && Is || i && cs || os;
        g = {
            css: `"${getFamilyName(a)}",${C}`,
            guessFallback: !0,
            loadedName: C,
            baseFontName: a,
            src: `local(${a})`,
            style: s
        };
        e1.set(n, g);
        return g;
    }
    const h = [];
    c && validateFontName(a) && h.push(`local(${a})`);
    const { style: l, ultimate: Q } = generateFont(o, h, i), E = null === Q, u = E ? "" : `,${Q}`;
    g = {
        css: `"${getFamilyName(a)}",${C}${u}`,
        guessFallback: E,
        loadedName: C,
        baseFontName: a,
        src: h.join(","),
        style: l
    };
    e1.set(n, g);
    return g;
}
class ImageResizer {
    static #R = 2048;
    static #y = FeatureTest.isImageDecoderSupported;
    constructor(e1, t){
        this._imgData = e1;
        this._isMask = t;
    }
    static get canUseImageDecoder() {
        return shadow(this, "canUseImageDecoder", this.#y ? ImageDecoder.isTypeSupported("image/bmp") : Promise.resolve(!1));
    }
    static needsToBeResized(e1, t) {
        if (e1 <= this.#R && t <= this.#R) return !1;
        const { MAX_DIM: i } = this;
        if (e1 > i || t > i) return !0;
        const a = e1 * t;
        if (this._hasMaxArea) return a > this.MAX_AREA;
        if (a < this.#R ** 2) return !1;
        if (this._areGoodDims(e1, t)) {
            this.#R = Math.max(this.#R, Math.floor(Math.sqrt(e1 * t)));
            return !1;
        }
        this.#R = this._guessMax(this.#R, i, 128, 0);
        return a > (this.MAX_AREA = this.#R ** 2);
    }
    static get MAX_DIM() {
        return shadow(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
    }
    static get MAX_AREA() {
        this._hasMaxArea = !0;
        return shadow(this, "MAX_AREA", this._guessMax(this.#R, this.MAX_DIM, 128, 0) ** 2);
    }
    static set MAX_AREA(e1) {
        if (e1 >= 0) {
            this._hasMaxArea = !0;
            shadow(this, "MAX_AREA", e1);
        }
    }
    static setOptions({ canvasMaxAreaInBytes: e1 = -1, isImageDecoderSupported: t = !1 }) {
        this._hasMaxArea || (this.MAX_AREA = e1 >> 2);
        this.#y = t;
    }
    static _areGoodDims(e1, t) {
        try {
            const i = new OffscreenCanvas(e1, t), a = i.getContext("2d");
            a.fillRect(0, 0, 1, 1);
            const s = a.getImageData(0, 0, 1, 1).data[3];
            i.width = i.height = 1;
            return 0 !== s;
        } catch  {
            return !1;
        }
    }
    static _guessMax(e1, t, i, a) {
        for(; e1 + i + 1 < t;){
            const i = Math.floor((e1 + t) / 2), s = a || i;
            this._areGoodDims(i, s) ? e1 = i : t = i;
        }
        return e1;
    }
    static async createImage(e1, t = !1) {
        return new ImageResizer(e1, t)._createImage();
    }
    async _createImage() {
        const { _imgData: e1 } = this, { width: t, height: i } = e1;
        if (t * i * 4 > pt) {
            const e1 = this.#N();
            if (e1) return e1;
        }
        const a = this._encodeBMP();
        let s, r;
        if (await ImageResizer.canUseImageDecoder) {
            s = new ImageDecoder({
                data: a,
                type: "image/bmp",
                preferAnimation: !1,
                transfer: [
                    a.buffer
                ]
            });
            r = s.decode().catch((e1)=>{
                warn(`BMP image decoding failed: ${e1}`);
                return createImageBitmap(new Blob([
                    this._encodeBMP().buffer
                ], {
                    type: "image/bmp"
                }));
            }).finally(()=>{
                s.close();
            });
        } else r = createImageBitmap(new Blob([
            a.buffer
        ], {
            type: "image/bmp"
        }));
        const { MAX_AREA: n, MAX_DIM: g } = ImageResizer, o = Math.max(t / g, i / g, Math.sqrt(t * i / n)), c = Math.max(o, 2), C = Math.round(10 * (o + 1.25)) / 10 / c, h = Math.floor(Math.log2(C)), l = new Array(h + 2).fill(2);
        l[0] = c;
        l.splice(-1, 1, C / (1 << h));
        let Q = t, E = i;
        const u = await r;
        let d = u.image || u;
        for (const e1 of l){
            const t = Q, i = E;
            Q = Math.floor(Q / e1) - 1;
            E = Math.floor(E / e1) - 1;
            const a = new OffscreenCanvas(Q, E);
            a.getContext("2d").drawImage(d, 0, 0, t, i, 0, 0, Q, E);
            d.close();
            d = a.transferToImageBitmap();
        }
        e1.data = null;
        e1.bitmap = d;
        e1.width = Q;
        e1.height = E;
        return e1;
    }
    #N() {
        const { _imgData: e1 } = this, { data: t, width: i, height: a, kind: s } = e1, r = i * a * 4, n = Math.ceil(Math.log2(r / pt)), g = i >> n, o = a >> n;
        let c, C = a;
        try {
            c = new Uint8Array(r);
        } catch  {
            let e1 = Math.floor(Math.log2(r + 1));
            for(;;)try {
                c = new Uint8Array(2 ** e1 - 1);
                break;
            } catch  {
                e1 -= 1;
            }
            C = Math.floor((2 ** e1 - 1) / (4 * i));
            const t = i * C * 4;
            t < c.length && (c = new Uint8Array(t));
        }
        const h = new Uint32Array(c.buffer), l = new Uint32Array(g * o);
        let Q = 0, E = 0;
        const u = Math.ceil(a / C), d = a % C == 0 ? a : a % C;
        for(let e1 = 0; e1 < u; e1++){
            const a = e1 < u - 1 ? C : d;
            ({ srcPos: Q } = convertToRGBA({
                kind: s,
                src: t,
                dest: h,
                width: i,
                height: a,
                inverseDecode: this._isMask,
                srcPos: Q
            }));
            for(let e1 = 0, t = a >> n; e1 < t; e1++){
                const t = h.subarray((e1 << n) * i);
                for(let e1 = 0; e1 < g; e1++)l[E++] = t[e1 << n];
            }
        }
        if (ImageResizer.needsToBeResized(g, o)) {
            e1.data = l;
            e1.width = g;
            e1.height = o;
            e1.kind = S;
            return null;
        }
        const f = new OffscreenCanvas(g, o);
        f.getContext("2d", {
            willReadFrequently: !0
        }).putImageData(new ImageData(new Uint8ClampedArray(l.buffer), g, o), 0, 0);
        e1.data = null;
        e1.bitmap = f.transferToImageBitmap();
        e1.width = g;
        e1.height = o;
        return e1;
    }
    _encodeBMP() {
        const { width: e1, height: t, kind: i } = this._imgData;
        let a, s = this._imgData.data, r = new Uint8Array(0), n = r, g = 0;
        switch(i){
            case b:
                {
                    a = 1;
                    r = new Uint8Array(this._isMask ? [
                        255,
                        255,
                        255,
                        255,
                        0,
                        0,
                        0,
                        0
                    ] : [
                        0,
                        0,
                        0,
                        0,
                        255,
                        255,
                        255,
                        255
                    ]);
                    const i = e1 + 7 >> 3, n = i + 3 & -4;
                    if (i !== n) {
                        const e1 = new Uint8Array(n * t);
                        let a = 0;
                        for(let r = 0, g = t * i; r < g; r += i, a += n)e1.set(s.subarray(r, r + i), a);
                        s = e1;
                    }
                    break;
                }
            case F:
                a = 24;
                if (3 & e1) {
                    const i = 3 * e1, a = i + 3 & -4, r = a - i, n = new Uint8Array(a * t);
                    let g = 0;
                    for(let e1 = 0, a = t * i; e1 < a; e1 += i){
                        const t = s.subarray(e1, e1 + i);
                        for(let e1 = 0; e1 < i; e1 += 3){
                            n[g++] = t[e1 + 2];
                            n[g++] = t[e1 + 1];
                            n[g++] = t[e1];
                        }
                        g += r;
                    }
                    s = n;
                } else for(let e1 = 0, t = s.length; e1 < t; e1 += 3){
                    const t = s[e1];
                    s[e1] = s[e1 + 2];
                    s[e1 + 2] = t;
                }
                break;
            case S:
                a = 32;
                g = 3;
                n = new Uint8Array(68);
                const i1 = new DataView(n.buffer);
                if (FeatureTest.isLittleEndian) {
                    i1.setUint32(0, 255, !0);
                    i1.setUint32(4, 65280, !0);
                    i1.setUint32(8, 16711680, !0);
                    i1.setUint32(12, 4278190080, !0);
                } else {
                    i1.setUint32(0, 4278190080, !0);
                    i1.setUint32(4, 16711680, !0);
                    i1.setUint32(8, 65280, !0);
                    i1.setUint32(12, 255, !0);
                }
                break;
            default:
                throw new Error("invalid format");
        }
        let o = 0;
        const c = 40 + n.length, C = 14 + c + r.length + s.length, h = new Uint8Array(C), l = new DataView(h.buffer);
        l.setUint16(o, 19778, !0);
        o += 2;
        l.setUint32(o, C, !0);
        o += 4;
        l.setUint32(o, 0, !0);
        o += 4;
        l.setUint32(o, 14 + c + r.length, !0);
        o += 4;
        l.setUint32(o, c, !0);
        o += 4;
        l.setInt32(o, e1, !0);
        o += 4;
        l.setInt32(o, -t, !0);
        o += 4;
        l.setUint16(o, 1, !0);
        o += 2;
        l.setUint16(o, a, !0);
        o += 2;
        l.setUint32(o, g, !0);
        o += 4;
        l.setUint32(o, 0, !0);
        o += 4;
        l.setInt32(o, 0, !0);
        o += 4;
        l.setInt32(o, 0, !0);
        o += 4;
        l.setUint32(o, r.length / 4, !0);
        o += 4;
        l.setUint32(o, 0, !0);
        o += 4;
        h.set(n, o);
        o += n.length;
        h.set(r, o);
        o += r.length;
        h.set(s, o);
        return h;
    }
}
const Bs = 3285377520, Qs = 4294901760, Es = 65535;
class MurmurHash3_64 {
    constructor(e1){
        this.h1 = e1 ? 4294967295 & e1 : Bs;
        this.h2 = e1 ? 4294967295 & e1 : Bs;
    }
    update(e1) {
        let t, i;
        if ("string" == typeof e1) {
            t = new Uint8Array(2 * e1.length);
            i = 0;
            for(let a = 0, s = e1.length; a < s; a++){
                const s = e1.charCodeAt(a);
                if (s <= 255) t[i++] = s;
                else {
                    t[i++] = s >>> 8;
                    t[i++] = 255 & s;
                }
            }
        } else {
            if (!ArrayBuffer.isView(e1)) throw new Error("Invalid data format, must be a string or TypedArray.");
            t = e1.slice();
            i = t.byteLength;
        }
        const a = i >> 2, s = i - 4 * a, r = new Uint32Array(t.buffer, 0, a);
        let n = 0, g = 0, o = this.h1, c = this.h2;
        const C = 3432918353, h = 461845907, l = 11601, Q = 13715;
        for(let e1 = 0; e1 < a; e1++)if (1 & e1) {
            n = r[e1];
            n = n * C & Qs | n * l & Es;
            n = n << 15 | n >>> 17;
            n = n * h & Qs | n * Q & Es;
            o ^= n;
            o = o << 13 | o >>> 19;
            o = 5 * o + 3864292196;
        } else {
            g = r[e1];
            g = g * C & Qs | g * l & Es;
            g = g << 15 | g >>> 17;
            g = g * h & Qs | g * Q & Es;
            c ^= g;
            c = c << 13 | c >>> 19;
            c = 5 * c + 3864292196;
        }
        n = 0;
        switch(s){
            case 3:
                n ^= t[4 * a + 2] << 16;
            case 2:
                n ^= t[4 * a + 1] << 8;
            case 1:
                n ^= t[4 * a];
                n = n * C & Qs | n * l & Es;
                n = n << 15 | n >>> 17;
                n = n * h & Qs | n * Q & Es;
                1 & a ? o ^= n : c ^= n;
        }
        this.h1 = o;
        this.h2 = c;
    }
    hexdigest() {
        let e1 = this.h1, t = this.h2;
        e1 ^= t >>> 1;
        e1 = 3981806797 * e1 & Qs | 36045 * e1 & Es;
        t = 4283543511 * t & Qs | (2950163797 * (t << 16 | e1 >>> 16) & Qs) >>> 16;
        e1 ^= t >>> 1;
        e1 = 444984403 * e1 & Qs | 60499 * e1 & Es;
        t = 3301882366 * t & Qs | (3120437893 * (t << 16 | e1 >>> 16) & Qs) >>> 16;
        e1 ^= t >>> 1;
        return (e1 >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0");
    }
}
function addState(e1, t, i, a, s) {
    let r = e1;
    for(let e1 = 0, i = t.length - 1; e1 < i; e1++){
        const i = t[e1];
        r = r[i] ||= [];
    }
    r[t.at(-1)] = {
        checkFn: i,
        iterateFn: a,
        processFn: s
    };
}
const us = [];
addState(us, [
    MA,
    xA,
    _e,
    UA
], null, function iterateInlineImageGroup(e1, t) {
    const i = e1.fnArray, a = (t - (e1.iCurr - 3)) % 4;
    switch(a){
        case 0:
            return i[t] === MA;
        case 1:
            return i[t] === xA;
        case 2:
            return i[t] === _e;
        case 3:
            return i[t] === UA;
    }
    throw new Error(`iterateInlineImageGroup - invalid pos: ${a}`);
}, function foundInlineImageGroup(e1, t) {
    const i = e1.fnArray, a = e1.argsArray, s = e1.iCurr, r = s - 3, n = s - 2, g = s - 1, o = Math.min(Math.floor((t - r) / 4), 200);
    if (o < 10) return t - (t - r) % 4;
    let c = 0;
    const C = [];
    let h = 0, l = 1, Q = 1;
    for(let e1 = 0; e1 < o; e1++){
        const t = a[n + (e1 << 2)], i = a[g + (e1 << 2)][0];
        if (l + i.width > 1e3) {
            c = Math.max(c, l);
            Q += h + 2;
            l = 0;
            h = 0;
        }
        C.push({
            transform: t,
            x: l,
            y: Q,
            w: i.width,
            h: i.height
        });
        l += i.width + 2;
        h = Math.max(h, i.height);
    }
    const E = Math.max(c, l) + 1, u = Q + h + 1, d = new Uint8Array(E * u * 4), f = E << 2;
    for(let e1 = 0; e1 < o; e1++){
        const t = a[g + (e1 << 2)][0].data, i = C[e1].w << 2;
        let s = 0, r = C[e1].x + C[e1].y * E << 2;
        d.set(t.subarray(0, i), r - f);
        for(let a = 0, n = C[e1].h; a < n; a++){
            d.set(t.subarray(s, s + i), r);
            s += i;
            r += f;
        }
        d.set(t.subarray(s - i, s), r);
        for(; r >= 0;){
            t[r - 4] = t[r];
            t[r - 3] = t[r + 1];
            t[r - 2] = t[r + 2];
            t[r - 1] = t[r + 3];
            t[r + i] = t[r + i - 4];
            t[r + i + 1] = t[r + i - 3];
            t[r + i + 2] = t[r + i - 2];
            t[r + i + 3] = t[r + i - 1];
            r -= f;
        }
    }
    const p = {
        width: E,
        height: u
    };
    if (e1.isOffscreenCanvasSupported) {
        const e1 = new OffscreenCanvas(E, u);
        e1.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(d.buffer), E, u), 0, 0);
        p.bitmap = e1.transferToImageBitmap();
        p.data = null;
    } else {
        p.kind = S;
        p.data = d;
    }
    i.splice(r, 4 * o, $e);
    a.splice(r, 4 * o, [
        p,
        C
    ]);
    return r + 1;
});
addState(us, [
    MA,
    xA,
    Ze,
    UA
], null, function iterateImageMaskGroup(e1, t) {
    const i = e1.fnArray, a = (t - (e1.iCurr - 3)) % 4;
    switch(a){
        case 0:
            return i[t] === MA;
        case 1:
            return i[t] === xA;
        case 2:
            return i[t] === Ze;
        case 3:
            return i[t] === UA;
    }
    throw new Error(`iterateImageMaskGroup - invalid pos: ${a}`);
}, function foundImageMaskGroup(e1, t) {
    const i = e1.fnArray, a = e1.argsArray, s = e1.iCurr, r = s - 3, n = s - 2, g = s - 1;
    let o = Math.floor((t - r) / 4);
    if (o < 10) return t - (t - r) % 4;
    let c, C, h = !1;
    const l = a[g][0], Q = a[n][0], E = a[n][1], u = a[n][2], d = a[n][3];
    if (E === u) {
        h = !0;
        c = n + 4;
        let e1 = g + 4;
        for(let t = 1; t < o; t++, c += 4, e1 += 4){
            C = a[c];
            if (a[e1][0] !== l || C[0] !== Q || C[1] !== E || C[2] !== u || C[3] !== d) {
                t < 10 ? h = !1 : o = t;
                break;
            }
        }
    }
    if (h) {
        o = Math.min(o, 1e3);
        const e1 = new Float32Array(2 * o);
        c = n;
        for(let t = 0; t < o; t++, c += 4){
            C = a[c];
            e1[t << 1] = C[4];
            e1[1 + (t << 1)] = C[5];
        }
        i.splice(r, 4 * o, et);
        a.splice(r, 4 * o, [
            l,
            Q,
            E,
            u,
            d,
            e1
        ]);
    } else {
        o = Math.min(o, 100);
        const e1 = [];
        for(let t = 0; t < o; t++){
            C = a[n + (t << 2)];
            const i = a[g + (t << 2)][0];
            e1.push({
                data: i.data,
                width: i.width,
                height: i.height,
                interpolate: i.interpolate,
                count: i.count,
                transform: C
            });
        }
        i.splice(r, 4 * o, Ve);
        a.splice(r, 4 * o, [
            e1
        ]);
    }
    return r + 1;
});
addState(us, [
    MA,
    xA,
    ze,
    UA
], function(e1) {
    const t = e1.argsArray, i = e1.iCurr - 2;
    return 0 === t[i][1] && 0 === t[i][2];
}, function iterateImageGroup(e1, t) {
    const i = e1.fnArray, a = e1.argsArray, s = (t - (e1.iCurr - 3)) % 4;
    switch(s){
        case 0:
            return i[t] === MA;
        case 1:
            if (i[t] !== xA) return !1;
            const s1 = e1.iCurr - 2, r = a[s1][0], n = a[s1][3];
            return a[t][0] === r && 0 === a[t][1] && 0 === a[t][2] && a[t][3] === n;
        case 2:
            if (i[t] !== ze) return !1;
            const g = a[e1.iCurr - 1][0];
            return a[t][0] === g;
        case 3:
            return i[t] === UA;
    }
    throw new Error(`iterateImageGroup - invalid pos: ${s}`);
}, function(e1, t) {
    const i = e1.fnArray, a = e1.argsArray, s = e1.iCurr, r = s - 3, n = s - 2, g = a[s - 1][0], o = a[n][0], c = a[n][3], C = Math.min(Math.floor((t - r) / 4), 1e3);
    if (C < 3) return t - (t - r) % 4;
    const h = new Float32Array(2 * C);
    let l = n;
    for(let e1 = 0; e1 < C; e1++, l += 4){
        const t = a[l];
        h[e1 << 1] = t[4];
        h[1 + (e1 << 1)] = t[5];
    }
    const Q = [
        g,
        o,
        c,
        h
    ];
    i.splice(r, 4 * C, At);
    a.splice(r, 4 * C, Q);
    return r + 1;
});
addState(us, [
    Ae,
    re,
    ce,
    he,
    ee
], null, function iterateShowTextGroup(e1, t) {
    const i = e1.fnArray, a = e1.argsArray, s = (t - (e1.iCurr - 4)) % 5;
    switch(s){
        case 0:
            return i[t] === Ae;
        case 1:
            return i[t] === re;
        case 2:
            return i[t] === ce;
        case 3:
            if (i[t] !== he) return !1;
            const s1 = e1.iCurr - 3, r = a[s1][0], n = a[s1][1];
            return a[t][0] === r && a[t][1] === n;
        case 4:
            return i[t] === ee;
    }
    throw new Error(`iterateShowTextGroup - invalid pos: ${s}`);
}, function(e1, t) {
    const i = e1.fnArray, a = e1.argsArray, s = e1.iCurr, r = s - 4, n = s - 3, g = s - 2, o = s - 1, c = s, C = a[n][0], h = a[n][1];
    let l = Math.min(Math.floor((t - r) / 5), 1e3);
    if (l < 3) return t - (t - r) % 5;
    let Q = r;
    if (r >= 4 && i[r - 4] === i[n] && i[r - 3] === i[g] && i[r - 2] === i[o] && i[r - 1] === i[c] && a[r - 4][0] === C && a[r - 4][1] === h) {
        l++;
        Q -= 5;
    }
    let E = Q + 4;
    for(let e1 = 1; e1 < l; e1++){
        i.splice(E, 3);
        a.splice(E, 3);
        E += 2;
    }
    return E + 1;
});
class NullOptimizer {
    constructor(e1){
        this.queue = e1;
    }
    _optimize() {}
    push(e1, t) {
        this.queue.fnArray.push(e1);
        this.queue.argsArray.push(t);
        this._optimize();
    }
    flush() {}
    reset() {}
}
class QueueOptimizer extends NullOptimizer {
    constructor(e1){
        super(e1);
        this.state = null;
        this.context = {
            iCurr: 0,
            fnArray: e1.fnArray,
            argsArray: e1.argsArray,
            isOffscreenCanvasSupported: !1
        };
        this.match = null;
        this.lastProcessed = 0;
    }
    set isOffscreenCanvasSupported(e1) {
        this.context.isOffscreenCanvasSupported = e1;
    }
    _optimize() {
        const e1 = this.queue.fnArray;
        let t = this.lastProcessed, i = e1.length, a = this.state, s = this.match;
        if (!a && !s && t + 1 === i && !us[e1[t]]) {
            this.lastProcessed = i;
            return;
        }
        const r = this.context;
        for(; t < i;){
            if (s) {
                if ((0, s.iterateFn)(r, t)) {
                    t++;
                    continue;
                }
                t = (0, s.processFn)(r, t + 1);
                i = e1.length;
                s = null;
                a = null;
                if (t >= i) break;
            }
            a = (a || us)[e1[t]];
            if (a && !Array.isArray(a)) {
                r.iCurr = t;
                t++;
                if (!a.checkFn || (0, a.checkFn)(r)) {
                    s = a;
                    a = null;
                } else a = null;
            } else t++;
        }
        this.state = a;
        this.match = s;
        this.lastProcessed = t;
    }
    flush() {
        for(; this.match;){
            const e1 = this.queue.fnArray.length;
            this.lastProcessed = (0, this.match.processFn)(this.context, e1);
            this.match = null;
            this.state = null;
            this._optimize();
        }
    }
    reset() {
        this.state = null;
        this.match = null;
        this.lastProcessed = 0;
    }
}
class OperatorList {
    static CHUNK_SIZE = 1e3;
    static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
    constructor(e1 = 0, t){
        this._streamSink = t;
        this.fnArray = [];
        this.argsArray = [];
        this.optimizer = !t || e1 & E ? new NullOptimizer(this) : new QueueOptimizer(this);
        this.dependencies = new Set;
        this._totalLength = 0;
        this.weight = 0;
        this._resolved = t ? null : Promise.resolve();
    }
    set isOffscreenCanvasSupported(e1) {
        this.optimizer.isOffscreenCanvasSupported = e1;
    }
    get length() {
        return this.argsArray.length;
    }
    get ready() {
        return this._resolved || this._streamSink.ready;
    }
    get totalLength() {
        return this._totalLength + this.length;
    }
    addOp(e1, t) {
        this.optimizer.push(e1, t);
        this.weight++;
        this._streamSink && (this.weight >= OperatorList.CHUNK_SIZE || this.weight >= OperatorList.CHUNK_SIZE_ABOUT && (e1 === UA || e1 === ee)) && this.flush();
    }
    addImageOps(e1, t, i, a = !1) {
        if (a) {
            this.addOp(MA);
            this.addOp(GA, [
                [
                    [
                        "SMask",
                        !1
                    ]
                ]
            ]);
        }
        void 0 !== i && this.addOp(Ye, [
            "OC",
            i
        ]);
        this.addOp(e1, t);
        void 0 !== i && this.addOp(ve, []);
        a && this.addOp(UA);
    }
    addDependency(e1) {
        if (!this.dependencies.has(e1)) {
            this.dependencies.add(e1);
            this.addOp(wA, [
                e1
            ]);
        }
    }
    addDependencies(e1) {
        for (const t of e1)this.addDependency(t);
    }
    addOpList(e1) {
        if (e1 instanceof OperatorList) {
            for (const t of e1.dependencies)this.dependencies.add(t);
            for(let t = 0, i = e1.length; t < i; t++)this.addOp(e1.fnArray[t], e1.argsArray[t]);
        } else warn('addOpList - ignoring invalid "opList" parameter.');
    }
    getIR() {
        return {
            fnArray: this.fnArray,
            argsArray: this.argsArray,
            length: this.length
        };
    }
    get _transfers() {
        const e1 = [], { fnArray: t, argsArray: i, length: a } = this;
        for(let s = 0; s < a; s++)switch(t[s]){
            case _e:
            case $e:
            case Ze:
                const t1 = i[s][0];
                !t1.cached && t1.data?.buffer instanceof ArrayBuffer && e1.push(t1.data.buffer);
        }
        return e1;
    }
    flush(e1 = !1, t = null) {
        this.optimizer.flush();
        const i = this.length;
        this._totalLength += i;
        this._streamSink.enqueue({
            fnArray: this.fnArray,
            argsArray: this.argsArray,
            lastChunk: e1,
            separateAnnots: t,
            length: i
        }, 1, this._transfers);
        this.dependencies.clear();
        this.fnArray.length = 0;
        this.argsArray.length = 0;
        this.weight = 0;
        this.optimizer.reset();
    }
}
function decodeAndClamp(e1, t, i, a) {
    (e1 = t + e1 * i) < 0 ? e1 = 0 : e1 > a && (e1 = a);
    return e1;
}
function resizeImageMask(e1, t, i, a, s, r) {
    const n = s * r;
    let g;
    g = t <= 8 ? new Uint8Array(n) : t <= 16 ? new Uint16Array(n) : new Uint32Array(n);
    const o = i / s, c = a / r;
    let C, h, l, Q, E = 0;
    const u = new Uint16Array(s), d = i;
    for(C = 0; C < s; C++)u[C] = Math.floor(C * o);
    for(C = 0; C < r; C++){
        l = Math.floor(C * c) * d;
        for(h = 0; h < s; h++){
            Q = l + u[h];
            g[E++] = e1[Q];
        }
    }
    return g;
}
class PDFImage {
    constructor({ xref: e1, res: t, image: i, isInline: a = !1, smask: s = null, mask: r = null, isMask: n = !1, pdfFunctionFactory: g, localColorSpaceCache: o }){
        this.image = i;
        const c = i.dict, C = c.get("F", "Filter");
        let h;
        if (C instanceof Name) h = C.name;
        else if (Array.isArray(C)) {
            const t = e1.fetchIfRef(C[0]);
            t instanceof Name && (h = t.name);
        }
        switch(h){
            case "JPXDecode":
                ({ width: i.width, height: i.height, componentsCount: i.numComps, bitsPerComponent: i.bitsPerComponent } = JpxImage.parseImageProperties(i.stream));
                i.stream.reset();
                this.jpxDecoderOptions = {
                    numComponents: 0,
                    isIndexedColormap: !1,
                    smaskInData: c.has("SMaskInData")
                };
                break;
            case "JBIG2Decode":
                i.bitsPerComponent = 1;
                i.numComps = 1;
        }
        let l = c.get("W", "Width"), Q = c.get("H", "Height");
        if (Number.isInteger(i.width) && i.width > 0 && Number.isInteger(i.height) && i.height > 0 && (i.width !== l || i.height !== Q)) {
            warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
            l = i.width;
            Q = i.height;
        }
        if (l < 1 || Q < 1) throw new FormatError(`Invalid image width: ${l} or height: ${Q}`);
        this.width = l;
        this.height = Q;
        this.interpolate = c.get("I", "Interpolate");
        this.imageMask = c.get("IM", "ImageMask") || !1;
        this.matte = c.get("Matte") || !1;
        let E = i.bitsPerComponent;
        if (!E) {
            E = c.get("BPC", "BitsPerComponent");
            if (!E) {
                if (!this.imageMask) throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);
                E = 1;
            }
        }
        this.bpc = E;
        if (!this.imageMask) {
            let s = c.getRaw("CS") || c.getRaw("ColorSpace");
            const r = !!s;
            if (r) this.jpxDecoderOptions?.smaskInData && (s = Name.get("DeviceRGBA"));
            else if (this.jpxDecoderOptions) s = Name.get("DeviceRGBA");
            else switch(i.numComps){
                case 1:
                    s = Name.get("DeviceGray");
                    break;
                case 3:
                    s = Name.get("DeviceRGB");
                    break;
                case 4:
                    s = Name.get("DeviceCMYK");
                    break;
                default:
                    throw new Error(`Images with ${i.numComps} color components not supported.`);
            }
            this.colorSpace = ColorSpace.parse({
                cs: s,
                xref: e1,
                resources: a ? t : null,
                pdfFunctionFactory: g,
                localColorSpaceCache: o
            });
            this.numComps = this.colorSpace.numComps;
            if (this.jpxDecoderOptions) {
                this.jpxDecoderOptions.numComponents = r ? this.numComp : 0;
                this.jpxDecoderOptions.isIndexedColormap = "Indexed" === this.colorSpace.name;
            }
        }
        this.decode = c.getArray("D", "Decode");
        this.needsDecode = !1;
        if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, E) || n && !ColorSpace.isDefaultDecode(this.decode, 1))) {
            this.needsDecode = !0;
            const e1 = (1 << E) - 1;
            this.decodeCoefficients = [];
            this.decodeAddends = [];
            const t = "Indexed" === this.colorSpace?.name;
            for(let i = 0, a = 0; i < this.decode.length; i += 2, ++a){
                const s = this.decode[i], r = this.decode[i + 1];
                this.decodeCoefficients[a] = t ? (r - s) / e1 : r - s;
                this.decodeAddends[a] = t ? s : e1 * s;
            }
        }
        if (s) this.smask = new PDFImage({
            xref: e1,
            res: t,
            image: s,
            isInline: a,
            pdfFunctionFactory: g,
            localColorSpaceCache: o
        });
        else if (r) if (r instanceof BaseStream) {
            r.dict.get("IM", "ImageMask") ? this.mask = new PDFImage({
                xref: e1,
                res: t,
                image: r,
                isInline: a,
                isMask: !0,
                pdfFunctionFactory: g,
                localColorSpaceCache: o
            }) : warn("Ignoring /Mask in image without /ImageMask.");
        } else this.mask = r;
    }
    static async buildImage({ xref: e1, res: t, image: i, isInline: a = !1, pdfFunctionFactory: s, localColorSpaceCache: r }) {
        const n = i;
        let g = null, o = null;
        const c = i.dict.get("SMask"), C = i.dict.get("Mask");
        c ? c instanceof BaseStream ? g = c : warn("Unsupported /SMask format.") : C && (C instanceof BaseStream || Array.isArray(C) ? o = C : warn("Unsupported /Mask format."));
        return new PDFImage({
            xref: e1,
            res: t,
            image: n,
            isInline: a,
            smask: g,
            mask: o,
            pdfFunctionFactory: s,
            localColorSpaceCache: r
        });
    }
    static createRawMask({ imgArray: e1, width: t, height: i, imageIsFromDecodeStream: a, inverseDecode: s, interpolate: r }) {
        const n = (t + 7 >> 3) * i, g = e1.byteLength;
        let o, c;
        if (!a || s && !(n === g)) if (s) {
            o = new Uint8Array(n);
            o.set(e1);
            o.fill(255, g);
        } else o = new Uint8Array(e1);
        else o = e1;
        if (s) for(c = 0; c < g; c++)o[c] ^= 255;
        return {
            data: o,
            width: t,
            height: i,
            interpolate: r
        };
    }
    static async createMask({ imgArray: e1, width: t, height: i, imageIsFromDecodeStream: a, inverseDecode: s, interpolate: r, isOffscreenCanvasSupported: n = !1 }) {
        const g = 1 === t && 1 === i && s === (0 === e1.length || !!(128 & e1[0]));
        if (g) return {
            isSingleOpaquePixel: g
        };
        if (n) {
            if (ImageResizer.needsToBeResized(t, i)) {
                const a = new Uint8ClampedArray(t * i * 4);
                convertBlackAndWhiteToRGBA({
                    src: e1,
                    dest: a,
                    width: t,
                    height: i,
                    nonBlackColor: 0,
                    inverseDecode: s
                });
                return ImageResizer.createImage({
                    kind: S,
                    data: a,
                    width: t,
                    height: i,
                    interpolate: r
                });
            }
            const a = new OffscreenCanvas(t, i), n = a.getContext("2d"), g = n.createImageData(t, i);
            convertBlackAndWhiteToRGBA({
                src: e1,
                dest: g.data,
                width: t,
                height: i,
                nonBlackColor: 0,
                inverseDecode: s
            });
            n.putImageData(g, 0, 0);
            return {
                data: null,
                width: t,
                height: i,
                interpolate: r,
                bitmap: a.transferToImageBitmap()
            };
        }
        return this.createRawMask({
            imgArray: e1,
            width: t,
            height: i,
            inverseDecode: s,
            imageIsFromDecodeStream: a,
            interpolate: r
        });
    }
    get drawWidth() {
        return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
    }
    get drawHeight() {
        return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
    }
    decodeBuffer(e1) {
        const t = this.bpc, i = this.numComps, a = this.decodeAddends, s = this.decodeCoefficients, r = (1 << t) - 1;
        let n, g;
        if (1 === t) {
            for(n = 0, g = e1.length; n < g; n++)e1[n] = +!e1[n];
            return;
        }
        let o = 0;
        for(n = 0, g = this.width * this.height; n < g; n++)for(let t = 0; t < i; t++){
            e1[o] = decodeAndClamp(e1[o], a[t], s[t], r);
            o++;
        }
    }
    getComponents(e1) {
        const t = this.bpc;
        if (8 === t) return e1;
        const i = this.width, a = this.height, s = this.numComps, r = i * a * s;
        let n, g = 0;
        n = t <= 8 ? new Uint8Array(r) : t <= 16 ? new Uint16Array(r) : new Uint32Array(r);
        const o = i * s, c = (1 << t) - 1;
        let C, h, l = 0;
        if (1 === t) {
            let t, i, s;
            for(let r = 0; r < a; r++){
                i = l + (-8 & o);
                s = l + o;
                for(; l < i;){
                    h = e1[g++];
                    n[l] = h >> 7 & 1;
                    n[l + 1] = h >> 6 & 1;
                    n[l + 2] = h >> 5 & 1;
                    n[l + 3] = h >> 4 & 1;
                    n[l + 4] = h >> 3 & 1;
                    n[l + 5] = h >> 2 & 1;
                    n[l + 6] = h >> 1 & 1;
                    n[l + 7] = 1 & h;
                    l += 8;
                }
                if (l < s) {
                    h = e1[g++];
                    t = 128;
                    for(; l < s;){
                        n[l++] = +!!(h & t);
                        t >>= 1;
                    }
                }
            }
        } else {
            let i = 0;
            h = 0;
            for(l = 0, C = r; l < C; ++l){
                if (l % o == 0) {
                    h = 0;
                    i = 0;
                }
                for(; i < t;){
                    h = h << 8 | e1[g++];
                    i += 8;
                }
                const a = i - t;
                let s = h >> a;
                s < 0 ? s = 0 : s > c && (s = c);
                n[l] = s;
                h &= (1 << a) - 1;
                i = a;
            }
        }
        return n;
    }
    async fillOpacity(e1, t, i, a, s) {
        const r = this.smask, n = this.mask;
        let g, o, c, C, h, l;
        if (r) {
            o = r.width;
            c = r.height;
            g = new Uint8ClampedArray(o * c);
            await r.fillGrayBuffer(g);
            o === t && c === i || (g = resizeImageMask(g, r.bpc, o, c, t, i));
        } else if (n) if (n instanceof PDFImage) {
            o = n.width;
            c = n.height;
            g = new Uint8ClampedArray(o * c);
            n.numComps = 1;
            await n.fillGrayBuffer(g);
            for(C = 0, h = o * c; C < h; ++C)g[C] = 255 - g[C];
            o === t && c === i || (g = resizeImageMask(g, n.bpc, o, c, t, i));
        } else {
            if (!Array.isArray(n)) throw new FormatError("Unknown mask format.");
            {
                g = new Uint8ClampedArray(t * i);
                const e1 = this.numComps;
                for(C = 0, h = t * i; C < h; ++C){
                    let t = 0;
                    const i = C * e1;
                    for(l = 0; l < e1; ++l){
                        const e1 = s[i + l], a = 2 * l;
                        if (e1 < n[a] || e1 > n[a + 1]) {
                            t = 255;
                            break;
                        }
                    }
                    g[C] = t;
                }
            }
        }
        if (g) for(C = 0, l = 3, h = t * a; C < h; ++C, l += 4)e1[l] = g[C];
        else for(C = 0, l = 3, h = t * a; C < h; ++C, l += 4)e1[l] = 255;
    }
    undoPreblend(e1, t, i) {
        const a = this.smask?.matte;
        if (!a) return;
        const s = this.colorSpace.getRgb(a, 0), r = s[0], n = s[1], g = s[2], o = t * i * 4;
        for(let t = 0; t < o; t += 4){
            const i = e1[t + 3];
            if (0 === i) {
                e1[t] = 255;
                e1[t + 1] = 255;
                e1[t + 2] = 255;
                continue;
            }
            const a = 255 / i;
            e1[t] = (e1[t] - r) * a + r;
            e1[t + 1] = (e1[t + 1] - n) * a + n;
            e1[t + 2] = (e1[t + 2] - g) * a + g;
        }
    }
    async createImageData(e1 = !1, t = !1) {
        const i = this.drawWidth, a = this.drawHeight, s = {
            width: i,
            height: a,
            interpolate: this.interpolate,
            kind: 0,
            data: null
        }, r = this.numComps, n = this.width, g = this.height, o = this.bpc, c = n * r * o + 7 >> 3, C = t && ImageResizer.needsToBeResized(i, a);
        if (!this.smask && !this.mask && "DeviceRGBA" === this.colorSpace.name) {
            s.kind = S;
            const e1 = s.data = await this.getImageBytes(g * n * 4, {});
            return t ? C ? ImageResizer.createImage(s, !1) : this.createBitmap(S, i, a, e1) : s;
        }
        if (!e1) {
            let e1;
            "DeviceGray" === this.colorSpace.name && 1 === o ? e1 = b : "DeviceRGB" !== this.colorSpace.name || 8 !== o || this.needsDecode || (e1 = F);
            if (e1 && !this.smask && !this.mask && i === n && a === g) {
                const r = await this.#G(n, g);
                if (r) return r;
                const o = await this.getImageBytes(g * c, {});
                if (t) return C ? ImageResizer.createImage({
                    data: o,
                    kind: e1,
                    width: i,
                    height: a,
                    interpolate: this.interpolate
                }, this.needsDecode) : this.createBitmap(e1, n, g, o);
                s.kind = e1;
                s.data = o;
                if (this.needsDecode) {
                    assert(e1 === b, "PDFImage.createImageData: The image must be grayscale.");
                    const t = s.data;
                    for(let e1 = 0, i = t.length; e1 < i; e1++)t[e1] ^= 255;
                }
                return s;
            }
            if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
                let e1 = g * c;
                if (t && !C) {
                    let t = !1;
                    switch(this.colorSpace.name){
                        case "DeviceGray":
                            e1 *= 4;
                            t = !0;
                            break;
                        case "DeviceRGB":
                            e1 = e1 / 3 * 4;
                            t = !0;
                            break;
                        case "DeviceCMYK":
                            t = !0;
                    }
                    if (t) {
                        const t = await this.#G(i, a);
                        if (t) return t;
                        const s = await this.getImageBytes(e1, {
                            drawWidth: i,
                            drawHeight: a,
                            forceRGBA: !0
                        });
                        return this.createBitmap(S, i, a, s);
                    }
                } else switch(this.colorSpace.name){
                    case "DeviceGray":
                        e1 *= 3;
                    case "DeviceRGB":
                    case "DeviceCMYK":
                        s.kind = F;
                        s.data = await this.getImageBytes(e1, {
                            drawWidth: i,
                            drawHeight: a,
                            forceRGB: !0
                        });
                        return C ? ImageResizer.createImage(s) : s;
                }
            }
        }
        const h = await this.getImageBytes(g * c, {
            internal: !0
        }), l = 0 | h.length / c * a / g, Q = this.getComponents(h);
        let E, u, d, f, p, m;
        if (t && !C) {
            d = new OffscreenCanvas(i, a);
            f = d.getContext("2d");
            p = f.createImageData(i, a);
            m = p.data;
        }
        s.kind = S;
        if (e1 || this.smask || this.mask) {
            t && !C || (m = new Uint8ClampedArray(i * a * 4));
            E = 1;
            u = !0;
            await this.fillOpacity(m, i, a, l, Q);
        } else {
            if (!t || C) {
                s.kind = F;
                m = new Uint8ClampedArray(i * a * 3);
                E = 0;
            } else {
                new Uint32Array(m.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255);
                E = 1;
            }
            u = !1;
        }
        this.needsDecode && this.decodeBuffer(Q);
        this.colorSpace.fillRgb(m, n, g, i, a, l, o, Q, E);
        u && this.undoPreblend(m, i, l);
        if (t && !C) {
            f.putImageData(p, 0, 0);
            return {
                data: null,
                width: i,
                height: a,
                bitmap: d.transferToImageBitmap(),
                interpolate: this.interpolate
            };
        }
        s.data = m;
        return C ? ImageResizer.createImage(s) : s;
    }
    async fillGrayBuffer(e1) {
        const t = this.numComps;
        if (1 !== t) throw new FormatError(`Reading gray scale from a color image: ${t}`);
        const i = this.width, a = this.height, s = this.bpc, r = i * t * s + 7 >> 3, n = await this.getImageBytes(a * r, {
            internal: !0
        }), g = this.getComponents(n);
        let o, c;
        if (1 === s) {
            c = i * a;
            if (this.needsDecode) for(o = 0; o < c; ++o)e1[o] = g[o] - 1 & 255;
            else for(o = 0; o < c; ++o)e1[o] = 255 & -g[o];
            return;
        }
        this.needsDecode && this.decodeBuffer(g);
        c = i * a;
        const C = 255 / ((1 << s) - 1);
        for(o = 0; o < c; ++o)e1[o] = C * g[o];
    }
    createBitmap(e1, t, i, a) {
        const s = new OffscreenCanvas(t, i), r = s.getContext("2d");
        let n;
        if (e1 === S) n = new ImageData(a, t, i);
        else {
            n = r.createImageData(t, i);
            convertToRGBA({
                kind: e1,
                src: a,
                dest: new Uint32Array(n.data.buffer),
                width: t,
                height: i,
                inverseDecode: this.needsDecode
            });
        }
        r.putImageData(n, 0, 0);
        return {
            data: null,
            width: t,
            height: i,
            bitmap: s.transferToImageBitmap(),
            interpolate: this.interpolate
        };
    }
    async #G(e1, t) {
        const i = await this.image.getTransferableImage();
        return i ? {
            data: null,
            width: e1,
            height: t,
            bitmap: i,
            interpolate: this.interpolate
        } : null;
    }
    async getImageBytes(e1, { drawWidth: t, drawHeight: i, forceRGBA: a = !1, forceRGB: s = !1, internal: r = !1 }) {
        this.image.reset();
        this.image.drawWidth = t || this.width;
        this.image.drawHeight = i || this.height;
        this.image.forceRGBA = !!a;
        this.image.forceRGB = !!s;
        const n = await this.image.getImageData(e1, this.jpxDecoderOptions);
        if (r || this.image instanceof DecodeStream) return n;
        assert(n instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
        return new Uint8Array(n);
    }
}
const ds = Object.freeze({
    maxImageSize: -1,
    disableFontFace: !1,
    ignoreErrors: !1,
    isEvalSupported: !0,
    isOffscreenCanvasSupported: !1,
    isImageDecoderSupported: !1,
    canvasMaxAreaInBytes: -1,
    fontExtraProperties: !1,
    useSystemFonts: !0,
    cMapUrl: null,
    standardFontDataUrl: null
}), fs = 1, ps = 2, ms = Promise.resolve();
function normalizeBlendMode(e1, t = !1) {
    if (Array.isArray(e1)) {
        for (const t of e1){
            const e1 = normalizeBlendMode(t, !0);
            if (e1) return e1;
        }
        warn(`Unsupported blend mode Array: ${e1}`);
        return "source-over";
    }
    if (!(e1 instanceof Name)) return t ? null : "source-over";
    switch(e1.name){
        case "Normal":
        case "Compatible":
            return "source-over";
        case "Multiply":
            return "multiply";
        case "Screen":
            return "screen";
        case "Overlay":
            return "overlay";
        case "Darken":
            return "darken";
        case "Lighten":
            return "lighten";
        case "ColorDodge":
            return "color-dodge";
        case "ColorBurn":
            return "color-burn";
        case "HardLight":
            return "hard-light";
        case "SoftLight":
            return "soft-light";
        case "Difference":
            return "difference";
        case "Exclusion":
            return "exclusion";
        case "Hue":
            return "hue";
        case "Saturation":
            return "saturation";
        case "Color":
            return "color";
        case "Luminosity":
            return "luminosity";
    }
    if (t) return null;
    warn(`Unsupported blend mode: ${e1.name}`);
    return "source-over";
}
function addLocallyCachedImageOps(e1, t) {
    t.objId && e1.addDependency(t.objId);
    e1.addImageOps(t.fn, t.args, t.optionalContent, t.hasMask);
    t.fn === Ze && t.args[0]?.count > 0 && t.args[0].count++;
}
class TimeSlotManager {
    static TIME_SLOT_DURATION_MS = 20;
    static CHECK_TIME_EVERY = 100;
    constructor(){
        this.reset();
    }
    check() {
        if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) return !1;
        this.checked = 0;
        return this.endTime <= Date.now();
    }
    reset() {
        this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
        this.checked = 0;
    }
}
class PartialEvaluator {
    constructor({ xref: e1, handler: t, pageIndex: i, idFactory: a, fontCache: s, builtInCMapCache: r, standardFontDataCache: n, globalImageCache: g, systemFontCache: o, options: c = null }){
        this.xref = e1;
        this.handler = t;
        this.pageIndex = i;
        this.idFactory = a;
        this.fontCache = s;
        this.builtInCMapCache = r;
        this.standardFontDataCache = n;
        this.globalImageCache = g;
        this.systemFontCache = o;
        this.options = c || ds;
        this.type3FontRefs = null;
        this._regionalImageCache = new RegionalImageCache;
        this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
        ImageResizer.setOptions(this.options);
        JpegStream.setOptions(this.options);
    }
    get _pdfFunctionFactory() {
        return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({
            xref: this.xref,
            isEvalSupported: this.options.isEvalSupported
        }));
    }
    get parsingType3Font() {
        return !!this.type3FontRefs;
    }
    clone(e1 = null) {
        const t = Object.create(this);
        t.options = Object.assign(Object.create(null), this.options, e1);
        return t;
    }
    hasBlendModes(e1, t) {
        if (!(e1 instanceof Dict)) return !1;
        if (e1.objId && t.has(e1.objId)) return !1;
        const i = new RefSet(t);
        e1.objId && i.put(e1.objId);
        const a = [
            e1
        ], s = this.xref;
        for(; a.length;){
            const e1 = a.shift(), t = e1.get("ExtGState");
            if (t instanceof Dict) for (let e1 of t.getRawValues()){
                if (e1 instanceof Ref) {
                    if (i.has(e1)) continue;
                    try {
                        e1 = s.fetch(e1);
                    } catch (t) {
                        i.put(e1);
                        info(`hasBlendModes - ignoring ExtGState: "${t}".`);
                        continue;
                    }
                }
                if (!(e1 instanceof Dict)) continue;
                e1.objId && i.put(e1.objId);
                const t = e1.get("BM");
                if (t instanceof Name) {
                    if ("Normal" !== t.name) return !0;
                } else if (void 0 !== t && Array.isArray(t)) {
                    for (const e1 of t)if (e1 instanceof Name && "Normal" !== e1.name) return !0;
                }
            }
            const r = e1.get("XObject");
            if (r instanceof Dict) for (let e1 of r.getRawValues()){
                if (e1 instanceof Ref) {
                    if (i.has(e1)) continue;
                    try {
                        e1 = s.fetch(e1);
                    } catch (t) {
                        i.put(e1);
                        info(`hasBlendModes - ignoring XObject: "${t}".`);
                        continue;
                    }
                }
                if (!(e1 instanceof BaseStream)) continue;
                e1.dict.objId && i.put(e1.dict.objId);
                const t = e1.dict.get("Resources");
                if (t instanceof Dict && (!t.objId || !i.has(t.objId))) {
                    a.push(t);
                    t.objId && i.put(t.objId);
                }
            }
        }
        for (const e1 of i)t.put(e1);
        return !1;
    }
    async #M(e1) {
        const t = await fetch(e1);
        if (!t.ok) throw new Error(`Failed to fetch file "${e1}" with "${t.statusText}".`);
        return new Uint8Array(await t.arrayBuffer());
    }
    async fetchBuiltInCMap(e1) {
        const t = this.builtInCMapCache.get(e1);
        if (t) return t;
        let i;
        if (null !== this.options.cMapUrl) {
            i = {
                cMapData: await this.#M(`${this.options.cMapUrl}${e1}.bcmap`),
                isCompressed: !0
            };
        } else i = await this.handler.sendWithPromise("FetchBuiltInCMap", {
            name: e1
        });
        this.builtInCMapCache.set(e1, i);
        return i;
    }
    async fetchStandardFontData(e1) {
        const t = this.standardFontDataCache.get(e1);
        if (t) return new Stream(t);
        if (this.options.useSystemFonts && "Symbol" !== e1 && "ZapfDingbats" !== e1) return null;
        const i = vi()[e1];
        let a;
        try {
            a = null !== this.options.standardFontDataUrl ? await this.#M(`${this.options.standardFontDataUrl}${i}`) : await this.handler.sendWithPromise("FetchStandardFontData", {
                filename: i
            });
        } catch (e1) {
            warn(e1);
            return null;
        }
        this.standardFontDataCache.set(e1, a);
        return new Stream(a);
    }
    async buildFormXObject(e1, t, i, a, s, r, n) {
        const g = t.dict, o = lookupMatrix(g.getArray("Matrix"), null), c = lookupNormalRect(g.getArray("BBox"), null);
        let C, h;
        g.has("OC") && (C = await this.parseMarkedContentProps(g.get("OC"), e1));
        void 0 !== C && a.addOp(Ye, [
            "OC",
            C
        ]);
        const l = g.get("Group");
        if (l) {
            h = {
                matrix: o,
                bbox: c,
                smask: i,
                isolated: !1,
                knockout: !1
            };
            let t = null;
            if (isName(l.get("S"), "Transparency")) {
                h.isolated = l.get("I") || !1;
                h.knockout = l.get("K") || !1;
                if (l.has("CS")) {
                    const i = l.getRaw("CS"), a = ColorSpace.getCached(i, this.xref, n);
                    t = a || await this.parseColorSpace({
                        cs: i,
                        resources: e1,
                        localColorSpaceCache: n
                    });
                }
            }
            if (i?.backdrop) {
                t ||= ColorSpace.singletons.rgb;
                i.backdrop = t.getRgb(i.backdrop, 0);
            }
            a.addOp(Pe, [
                h
            ]);
        }
        const Q = l ? [
            o,
            null
        ] : [
            o,
            c
        ];
        a.addOp(qe, Q);
        await this.getOperatorList({
            stream: t,
            task: s,
            resources: g.get("Resources") || e1,
            operatorList: a,
            initialState: r
        });
        a.addOp(Oe, []);
        l && a.addOp(We, [
            h
        ]);
        void 0 !== C && a.addOp(ve, []);
    }
    _sendImgData(e1, t, i = !1) {
        const a = t ? [
            t.bitmap || t.data.buffer
        ] : null;
        return this.parsingType3Font || i ? this.handler.send("commonobj", [
            e1,
            "Image",
            t
        ], a) : this.handler.send("obj", [
            e1,
            this.pageIndex,
            "Image",
            t
        ], a);
    }
    async buildPaintImageXObject({ resources: e1, image: t, isInline: i = !1, operatorList: a, cacheKey: s, localImageCache: r, localColorSpaceCache: n }) {
        const g = t.dict, o = g.objId, c = g.get("W", "Width"), C = g.get("H", "Height");
        if (!c || "number" != typeof c || !C || "number" != typeof C) {
            warn("Image dimensions are missing, or not numbers.");
            return;
        }
        const h = this.options.maxImageSize;
        if (-1 !== h && c * C > h) {
            const e1 = "Image exceeded maximum allowed size and was removed.";
            if (this.options.ignoreErrors) {
                warn(e1);
                return;
            }
            throw new Error(e1);
        }
        let l;
        g.has("OC") && (l = await this.parseMarkedContentProps(g.get("OC"), e1));
        let Q, E;
        if (g.get("IM", "ImageMask") || !1) {
            const e1 = g.get("I", "Interpolate"), i = c + 7 >> 3, n = t.getBytes(i * C), h = g.getArray("D", "Decode");
            if (this.parsingType3Font) {
                Q = PDFImage.createRawMask({
                    imgArray: n,
                    width: c,
                    height: C,
                    imageIsFromDecodeStream: t instanceof DecodeStream,
                    inverseDecode: h?.[0] > 0,
                    interpolate: e1
                });
                Q.cached = !!s;
                E = [
                    Q
                ];
                a.addImageOps(Ze, E, l);
                if (s) {
                    const e1 = {
                        fn: Ze,
                        args: E,
                        optionalContent: l
                    };
                    r.set(s, o, e1);
                    o && this._regionalImageCache.set(null, o, e1);
                }
                return;
            }
            Q = await PDFImage.createMask({
                imgArray: n,
                width: c,
                height: C,
                imageIsFromDecodeStream: t instanceof DecodeStream,
                inverseDecode: h?.[0] > 0,
                interpolate: e1,
                isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported
            });
            if (Q.isSingleOpaquePixel) {
                a.addImageOps(tt, [], l);
                if (s) {
                    const e1 = {
                        fn: tt,
                        args: [],
                        optionalContent: l
                    };
                    r.set(s, o, e1);
                    o && this._regionalImageCache.set(null, o, e1);
                }
                return;
            }
            const u = `mask_${this.idFactory.createObjId()}`;
            a.addDependency(u);
            Q.dataLen = Q.bitmap ? Q.width * Q.height * 4 : Q.data.length;
            this._sendImgData(u, Q);
            E = [
                {
                    data: u,
                    width: Q.width,
                    height: Q.height,
                    interpolate: Q.interpolate,
                    count: 1
                }
            ];
            a.addImageOps(Ze, E, l);
            if (s) {
                const e1 = {
                    objId: u,
                    fn: Ze,
                    args: E,
                    optionalContent: l
                };
                r.set(s, o, e1);
                o && this._regionalImageCache.set(null, o, e1);
            }
            return;
        }
        const u = g.has("SMask") || g.has("Mask");
        if (i && c + C < 200 && !u) {
            try {
                const s = new PDFImage({
                    xref: this.xref,
                    res: e1,
                    image: t,
                    isInline: i,
                    pdfFunctionFactory: this._pdfFunctionFactory,
                    localColorSpaceCache: n
                });
                Q = await s.createImageData(!0, !1);
                a.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;
                a.addImageOps(_e, [
                    Q
                ], l);
            } catch (e1) {
                const t = `Unable to decode inline image: "${e1}".`;
                if (!this.options.ignoreErrors) throw new Error(t);
                warn(t);
            }
            return;
        }
        let d = `img_${this.idFactory.createObjId()}`, f = !1;
        if (this.parsingType3Font) d = `${this.idFactory.getDocId()}_type3_${d}`;
        else if (s && o) {
            f = this.globalImageCache.shouldCache(o, this.pageIndex);
            if (f) {
                assert(!i, "Cannot cache an inline image globally.");
                d = `${this.idFactory.getDocId()}_${d}`;
            }
        }
        a.addDependency(d);
        E = [
            d,
            c,
            C
        ];
        a.addImageOps(ze, E, l, u);
        if (f) {
            if (this.globalImageCache.hasDecodeFailed(o)) {
                this.globalImageCache.setData(o, {
                    objId: d,
                    fn: ze,
                    args: E,
                    optionalContent: l,
                    hasMask: u,
                    byteSize: 0
                });
                this._sendImgData(d, null, f);
                return;
            }
            if (c * C > 25e4 || u) {
                const e1 = await this.handler.sendWithPromise("commonobj", [
                    d,
                    "CopyLocalImage",
                    {
                        imageRef: o
                    }
                ]);
                if (e1) {
                    this.globalImageCache.setData(o, {
                        objId: d,
                        fn: ze,
                        args: E,
                        optionalContent: l,
                        hasMask: u,
                        byteSize: 0
                    });
                    this.globalImageCache.addByteSize(o, e1);
                    return;
                }
            }
        }
        PDFImage.buildImage({
            xref: this.xref,
            res: e1,
            image: t,
            isInline: i,
            pdfFunctionFactory: this._pdfFunctionFactory,
            localColorSpaceCache: n
        }).then(async (e1)=>{
            Q = await e1.createImageData(!1, this.options.isOffscreenCanvasSupported);
            Q.dataLen = Q.bitmap ? Q.width * Q.height * 4 : Q.data.length;
            Q.ref = o;
            f && this.globalImageCache.addByteSize(o, Q.dataLen);
            return this._sendImgData(d, Q, f);
        }).catch((e1)=>{
            warn(`Unable to decode image "${d}": "${e1}".`);
            o && this.globalImageCache.addDecodeFailed(o);
            return this._sendImgData(d, null, f);
        });
        if (s) {
            const e1 = {
                objId: d,
                fn: ze,
                args: E,
                optionalContent: l,
                hasMask: u
            };
            r.set(s, o, e1);
            if (o) {
                this._regionalImageCache.set(null, o, e1);
                f && this.globalImageCache.setData(o, {
                    objId: d,
                    fn: ze,
                    args: E,
                    optionalContent: l,
                    hasMask: u,
                    byteSize: 0
                });
            }
        }
    }
    handleSMask(e1, t, i, a, s, r) {
        const n = e1.get("G"), g = {
            subtype: e1.get("S").name,
            backdrop: e1.get("BC")
        }, o = e1.get("TR");
        if (isPDFFunction(o)) {
            const e1 = this._pdfFunctionFactory.create(o), t = new Uint8Array(256), i = new Float32Array(1);
            for(let a = 0; a < 256; a++){
                i[0] = a / 255;
                e1(i, 0, i, 0);
                t[a] = 255 * i[0] | 0;
            }
            g.transferMap = t;
        }
        return this.buildFormXObject(t, n, g, i, a, s.state.clone(), r);
    }
    handleTransferFunction(e1) {
        let t;
        if (Array.isArray(e1)) t = e1;
        else {
            if (!isPDFFunction(e1)) return null;
            t = [
                e1
            ];
        }
        const i = [];
        let a = 0, s = 0;
        for (const e1 of t){
            const t = this.xref.fetchIfRef(e1);
            a++;
            if (isName(t, "Identity")) {
                i.push(null);
                continue;
            }
            if (!isPDFFunction(t)) return null;
            const r = this._pdfFunctionFactory.create(t), n = new Uint8Array(256), g = new Float32Array(1);
            for(let e1 = 0; e1 < 256; e1++){
                g[0] = e1 / 255;
                r(g, 0, g, 0);
                n[e1] = 255 * g[0] | 0;
            }
            i.push(n);
            s++;
        }
        return 1 !== a && 4 !== a || 0 === s ? null : i;
    }
    handleTilingType(e1, t, i, a, s, r, n, g) {
        const o = new OperatorList, c = Dict.merge({
            xref: this.xref,
            dictArray: [
                s.get("Resources"),
                i
            ]
        });
        return this.getOperatorList({
            stream: a,
            task: n,
            resources: c,
            operatorList: o
        }).then(function() {
            const i = o.getIR(), a = getTilingPatternIR(i, s, t);
            r.addDependencies(o.dependencies);
            r.addOp(e1, a);
            s.objId && g.set(null, s.objId, {
                operatorListIR: i,
                dict: s
            });
        }).catch((e1)=>{
            if (!(e1 instanceof AbortException)) {
                if (!this.options.ignoreErrors) throw e1;
                warn(`handleTilingType - ignoring pattern: "${e1}".`);
            }
        });
    }
    async handleSetFont(e1, t, i, a, s, r, n = null, g = null) {
        const o = t?.[0] instanceof Name ? t[0].name : null;
        let c = await this.loadFont(o, i, e1, n, g);
        if (c.font.isType3Font) try {
            await c.loadType3Data(this, e1, s);
            a.addDependencies(c.type3Dependencies);
        } catch (e1) {
            c = new TranslatedFont({
                loadedName: "g_font_error",
                font: new ErrorFont(`Type3 font load error: ${e1}`),
                dict: c.font,
                evaluatorOptions: this.options
            });
        }
        r.font = c.font;
        c.send(this.handler);
        return c.loadedName;
    }
    handleText(e1, t) {
        const i = t.font, a = i.charsToGlyphs(e1);
        if (i.data) {
            (!!(t.textRenderingMode & D) || "Pattern" === t.fillColorSpace.name || i.disableFontFace || this.options.disableFontFace) && PartialEvaluator.buildFontPaths(i, a, this.handler, this.options);
        }
        return a;
    }
    ensureStateFont(e1) {
        if (e1.font) return;
        const t = new FormatError("Missing setFont (Tf) operator before text rendering operator.");
        if (!this.options.ignoreErrors) throw t;
        warn(`ensureStateFont: "${t}".`);
    }
    async setGState({ resources: e1, gState: t, operatorList: i, cacheKey: a, task: s, stateManager: r, localGStateCache: n, localColorSpaceCache: g }) {
        const o = t.objId;
        let c = !0;
        const C = [];
        let h = Promise.resolve();
        for (const a of t.getKeys()){
            const n = t.get(a);
            switch(a){
                case "Type":
                    break;
                case "LW":
                case "LC":
                case "LJ":
                case "ML":
                case "D":
                case "RI":
                case "FL":
                case "CA":
                case "ca":
                    C.push([
                        a,
                        n
                    ]);
                    break;
                case "Font":
                    c = !1;
                    h = h.then(()=>this.handleSetFont(e1, null, n[0], i, s, r.state).then(function(e1) {
                            i.addDependency(e1);
                            C.push([
                                a,
                                [
                                    e1,
                                    n[1]
                                ]
                            ]);
                        }));
                    break;
                case "BM":
                    C.push([
                        a,
                        normalizeBlendMode(n)
                    ]);
                    break;
                case "SMask":
                    if (isName(n, "None")) {
                        C.push([
                            a,
                            !1
                        ]);
                        break;
                    }
                    if (n instanceof Dict) {
                        c = !1;
                        h = h.then(()=>this.handleSMask(n, e1, i, s, r, g));
                        C.push([
                            a,
                            !0
                        ]);
                    } else warn("Unsupported SMask type");
                    break;
                case "TR":
                    const t1 = this.handleTransferFunction(n);
                    C.push([
                        a,
                        t1
                    ]);
                    break;
                case "OP":
                case "op":
                case "OPM":
                case "BG":
                case "BG2":
                case "UCR":
                case "UCR2":
                case "TR2":
                case "HT":
                case "SM":
                case "SA":
                case "AIS":
                case "TK":
                    info("graphic state operator " + a);
                    break;
                default:
                    info("Unknown graphic state operator " + a);
            }
        }
        await h;
        C.length > 0 && i.addOp(GA, [
            C
        ]);
        c && n.set(a, o, C);
    }
    loadFont(e1, t, i, a = null, s = null) {
        const errorFont = async ()=>new TranslatedFont({
                loadedName: "g_font_error",
                font: new ErrorFont(`Font "${e1}" is not available.`),
                dict: t,
                evaluatorOptions: this.options
            });
        let r;
        if (t) t instanceof Ref && (r = t);
        else {
            const t = i.get("Font");
            t && (r = t.getRaw(e1));
        }
        if (r) {
            if (this.type3FontRefs?.has(r)) return errorFont();
            if (this.fontCache.has(r)) return this.fontCache.get(r);
            try {
                t = this.xref.fetchIfRef(r);
            } catch (e1) {
                warn(`loadFont - lookup failed: "${e1}".`);
            }
        }
        if (!(t instanceof Dict)) {
            if (!this.options.ignoreErrors && !this.parsingType3Font) {
                warn(`Font "${e1}" is not available.`);
                return errorFont();
            }
            warn(`Font "${e1}" is not available -- attempting to fallback to a default font.`);
            t = a || PartialEvaluator.fallbackFontDict;
        }
        if (t.cacheKey && this.fontCache.has(t.cacheKey)) return this.fontCache.get(t.cacheKey);
        const { promise: n, resolve: g } = Promise.withResolvers();
        let o;
        try {
            o = this.preEvaluateFont(t);
            o.cssFontInfo = s;
        } catch (e1) {
            warn(`loadFont - preEvaluateFont failed: "${e1}".`);
            return errorFont();
        }
        const { descriptor: c, hash: C } = o, h = r instanceof Ref;
        let l;
        if (C && c instanceof Dict) {
            const e1 = c.fontAliases ||= Object.create(null);
            if (e1[C]) {
                const t = e1[C].aliasRef;
                if (h && t && this.fontCache.has(t)) {
                    this.fontCache.putAlias(r, t);
                    return this.fontCache.get(r);
                }
            } else e1[C] = {
                fontID: this.idFactory.createFontId()
            };
            h && (e1[C].aliasRef = r);
            l = e1[C].fontID;
        } else l = this.idFactory.createFontId();
        assert(l?.startsWith("f"), 'The "fontID" must be (correctly) defined.');
        if (h) this.fontCache.put(r, n);
        else {
            t.cacheKey = `cacheKey_${l}`;
            this.fontCache.put(t.cacheKey, n);
        }
        t.loadedName = `${this.idFactory.getDocId()}_${l}`;
        this.translateFont(o).then((e1)=>{
            g(new TranslatedFont({
                loadedName: t.loadedName,
                font: e1,
                dict: t,
                evaluatorOptions: this.options
            }));
        }).catch((e1)=>{
            warn(`loadFont - translateFont failed: "${e1}".`);
            g(new TranslatedFont({
                loadedName: t.loadedName,
                font: new ErrorFont(e1 instanceof Error ? e1.message : e1),
                dict: t,
                evaluatorOptions: this.options
            }));
        });
        return n;
    }
    buildPath(e1, t, i, a = !1) {
        const s = e1.length - 1;
        i || (i = []);
        if (s < 0 || e1.fnArray[s] !== it) {
            if (a) {
                warn(`Encountered path operator "${t}" inside of a text object.`);
                e1.addOp(MA, null);
            }
            let s;
            switch(t){
                case TA:
                    const e2 = i[0] + i[2], t1 = i[1] + i[3];
                    s = [
                        Math.min(i[0], e2),
                        Math.min(i[1], t1),
                        Math.max(i[0], e2),
                        Math.max(i[1], t1)
                    ];
                    break;
                case LA:
                case HA:
                    s = [
                        i[0],
                        i[1],
                        i[0],
                        i[1]
                    ];
                    break;
                default:
                    s = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ];
            }
            e1.addOp(it, [
                [
                    t
                ],
                i,
                s
            ]);
            a && e1.addOp(UA, null);
        } else {
            const a = e1.argsArray[s];
            a[0].push(t);
            a[1].push(...i);
            const r = a[2];
            switch(t){
                case TA:
                    const e2 = i[0] + i[2], t1 = i[1] + i[3];
                    r[0] = Math.min(r[0], i[0], e2);
                    r[1] = Math.min(r[1], i[1], t1);
                    r[2] = Math.max(r[2], i[0], e2);
                    r[3] = Math.max(r[3], i[1], t1);
                    break;
                case LA:
                case HA:
                    r[0] = Math.min(r[0], i[0]);
                    r[1] = Math.min(r[1], i[1]);
                    r[2] = Math.max(r[2], i[0]);
                    r[3] = Math.max(r[3], i[1]);
            }
        }
    }
    parseColorSpace({ cs: e1, resources: t, localColorSpaceCache: i }) {
        return ColorSpace.parseAsync({
            cs: e1,
            xref: this.xref,
            resources: t,
            pdfFunctionFactory: this._pdfFunctionFactory,
            localColorSpaceCache: i
        }).catch((e1)=>{
            if (e1 instanceof AbortException) return null;
            if (this.options.ignoreErrors) {
                warn(`parseColorSpace - ignoring ColorSpace: "${e1}".`);
                return null;
            }
            throw e1;
        });
    }
    parseShading({ shading: e1, resources: t, localColorSpaceCache: i, localShadingPatternCache: a }) {
        let s, r = a.get(e1);
        if (r) return r;
        try {
            s = Pattern.parseShading(e1, this.xref, t, this._pdfFunctionFactory, i).getIR();
        } catch (t) {
            if (t instanceof AbortException) return null;
            if (this.options.ignoreErrors) {
                warn(`parseShading - ignoring shading: "${t}".`);
                a.set(e1, null);
                return null;
            }
            throw t;
        }
        r = `pattern_${this.idFactory.createObjId()}`;
        this.parsingType3Font && (r = `${this.idFactory.getDocId()}_type3_${r}`);
        a.set(e1, r);
        this.parsingType3Font ? this.handler.send("commonobj", [
            r,
            "Pattern",
            s
        ]) : this.handler.send("obj", [
            r,
            this.pageIndex,
            "Pattern",
            s
        ]);
        return r;
    }
    handleColorN(e1, t, i, a, s, r, n, g, o, c) {
        const C = i.pop();
        if (C instanceof Name) {
            const h = s.getRaw(C.name), l = h instanceof Ref && o.getByRef(h);
            if (l) try {
                const s = a.base ? a.base.getRgb(i, 0) : null, r = getTilingPatternIR(l.operatorListIR, l.dict, s);
                e1.addOp(t, r);
                return;
            } catch  {}
            const Q = this.xref.fetchIfRef(h);
            if (Q) {
                const s = Q instanceof BaseStream ? Q.dict : Q, C = s.get("PatternType");
                if (C === fs) {
                    const g = a.base ? a.base.getRgb(i, 0) : null;
                    return this.handleTilingType(t, g, r, Q, s, e1, n, o);
                }
                if (C === ps) {
                    const i = s.get("Shading"), a = this.parseShading({
                        shading: i,
                        resources: r,
                        localColorSpaceCache: g,
                        localShadingPatternCache: c
                    });
                    if (a) {
                        const i = lookupMatrix(s.getArray("Matrix"), null);
                        e1.addOp(t, [
                            "Shading",
                            a,
                            i
                        ]);
                    }
                    return;
                }
                throw new FormatError(`Unknown PatternType: ${C}`);
            }
        }
        throw new FormatError(`Unknown PatternName: ${C}`);
    }
    _parseVisibilityExpression(e1, t, i) {
        if (++t > 10) {
            warn("Visibility expression is too deeply nested");
            return;
        }
        const a = e1.length, s = this.xref.fetchIfRef(e1[0]);
        if (!(a < 2) && s instanceof Name) {
            switch(s.name){
                case "And":
                case "Or":
                case "Not":
                    i.push(s.name);
                    break;
                default:
                    warn(`Invalid operator ${s.name} in visibility expression`);
                    return;
            }
            for(let s = 1; s < a; s++){
                const a = e1[s], r = this.xref.fetchIfRef(a);
                if (Array.isArray(r)) {
                    const e1 = [];
                    i.push(e1);
                    this._parseVisibilityExpression(r, t, e1);
                } else a instanceof Ref && i.push(a.toString());
            }
        } else warn("Invalid visibility expression");
    }
    async parseMarkedContentProps(e1, t) {
        let i;
        if (e1 instanceof Name) {
            i = t.get("Properties").get(e1.name);
        } else {
            if (!(e1 instanceof Dict)) throw new FormatError("Optional content properties malformed.");
            i = e1;
        }
        const a = i.get("Type")?.name;
        if ("OCG" === a) return {
            type: a,
            id: i.objId
        };
        if ("OCMD" === a) {
            const e1 = i.get("VE");
            if (Array.isArray(e1)) {
                const t = [];
                this._parseVisibilityExpression(e1, 0, t);
                if (t.length > 0) return {
                    type: "OCMD",
                    expression: t
                };
            }
            const t = i.get("OCGs");
            if (Array.isArray(t) || t instanceof Dict) {
                const e1 = [];
                if (Array.isArray(t)) for (const i of t)e1.push(i.toString());
                else e1.push(t.objId);
                return {
                    type: a,
                    ids: e1,
                    policy: i.get("P") instanceof Name ? i.get("P").name : null,
                    expression: null
                };
            }
            if (t instanceof Ref) return {
                type: a,
                id: t.toString()
            };
        }
        return null;
    }
    getOperatorList({ stream: e1, task: t, resources: i, operatorList: a, initialState: s = null, fallbackFontDict: r = null }) {
        i ||= Dict.empty;
        s ||= new EvalState;
        if (!a) throw new Error('getOperatorList: missing "operatorList" parameter');
        const n = this, g = this.xref;
        let o = !1;
        const c = new LocalImageCache, C = new LocalColorSpaceCache, h = new LocalGStateCache, l = new LocalTilingPatternCache, Q = new Map, E = i.get("XObject") || Dict.empty, u = i.get("Pattern") || Dict.empty, d = new StateManager(s), f = new EvaluatorPreprocessor(e1, g, d), p = new TimeSlotManager;
        function closePendingRestoreOPS(e1) {
            for(let e1 = 0, t = f.savedStatesDepth; e1 < t; e1++)a.addOp(UA, []);
        }
        return new Promise(function promiseBody(e1, s) {
            const next = function(t) {
                Promise.all([
                    t,
                    a.ready
                ]).then(function() {
                    try {
                        promiseBody(e1, s);
                    } catch (e1) {
                        s(e1);
                    }
                }, s);
            };
            t.ensureNotTerminated();
            p.reset();
            const m = {};
            let y, w, D, b, F, S;
            for(; !(y = p.check());){
                m.args = null;
                if (!f.read(m)) break;
                let e1 = m.args, s = m.fn;
                switch(0 | s){
                    case xe:
                        S = e1[0] instanceof Name;
                        F = e1[0].name;
                        if (S) {
                            const t = c.getByName(F);
                            if (t) {
                                addLocallyCachedImageOps(a, t);
                                e1 = null;
                                continue;
                            }
                        }
                        next(new Promise(function(e1, s) {
                            if (!S) throw new FormatError("XObject must be referred to by name.");
                            let r = E.getRaw(F);
                            if (r instanceof Ref) {
                                const t = c.getByRef(r) || n._regionalImageCache.getByRef(r);
                                if (t) {
                                    addLocallyCachedImageOps(a, t);
                                    e1();
                                    return;
                                }
                                const i = n.globalImageCache.getData(r, n.pageIndex);
                                if (i) {
                                    a.addDependency(i.objId);
                                    a.addImageOps(i.fn, i.args, i.optionalContent, i.hasMask);
                                    e1();
                                    return;
                                }
                                r = g.fetch(r);
                            }
                            if (!(r instanceof BaseStream)) throw new FormatError("XObject should be a stream");
                            const o = r.dict.get("Subtype");
                            if (!(o instanceof Name)) throw new FormatError("XObject should have a Name subtype");
                            if ("Form" !== o.name) if ("Image" !== o.name) {
                                if ("PS" !== o.name) throw new FormatError(`Unhandled XObject subtype ${o.name}`);
                                info("Ignored XObject subtype PS");
                                e1();
                            } else n.buildPaintImageXObject({
                                resources: i,
                                image: r,
                                operatorList: a,
                                cacheKey: F,
                                localImageCache: c,
                                localColorSpaceCache: C
                            }).then(e1, s);
                            else {
                                d.save();
                                n.buildFormXObject(i, r, null, a, t, d.state.clone(), C).then(function() {
                                    d.restore();
                                    e1();
                                }, s);
                            }
                        }).catch(function(e1) {
                            if (!(e1 instanceof AbortException)) {
                                if (!n.options.ignoreErrors) throw e1;
                                warn(`getOperatorList - ignoring XObject: "${e1}".`);
                            }
                        }));
                        return;
                    case re:
                        const f1 = e1[1];
                        next(n.handleSetFont(i, e1, null, a, t, d.state, r).then(function(e1) {
                            a.addDependency(e1);
                            a.addOp(re, [
                                e1,
                                f1
                            ]);
                        }));
                        return;
                    case Ae:
                        o = !0;
                        break;
                    case ee:
                        o = !1;
                        break;
                    case Ue:
                        const p = e1[0].cacheKey;
                        if (p) {
                            const t = c.getByName(p);
                            if (t) {
                                addLocallyCachedImageOps(a, t);
                                e1 = null;
                                continue;
                            }
                        }
                        next(n.buildPaintImageXObject({
                            resources: i,
                            image: e1[0],
                            isInline: !0,
                            operatorList: a,
                            cacheKey: p,
                            localImageCache: c,
                            localColorSpaceCache: C
                        }));
                        return;
                    case he:
                        if (!d.state.font) {
                            n.ensureStateFont(d.state);
                            continue;
                        }
                        e1[0] = n.handleText(e1[0], d.state);
                        break;
                    case le:
                        if (!d.state.font) {
                            n.ensureStateFont(d.state);
                            continue;
                        }
                        const m1 = [], y = d.state;
                        for (const t of e1[0])"string" == typeof t ? m1.push(...n.handleText(t, y)) : "number" == typeof t && m1.push(t);
                        e1[0] = m1;
                        s = he;
                        break;
                    case Be:
                        if (!d.state.font) {
                            n.ensureStateFont(d.state);
                            continue;
                        }
                        a.addOp(Ce);
                        e1[0] = n.handleText(e1[0], d.state);
                        s = he;
                        break;
                    case Qe:
                        if (!d.state.font) {
                            n.ensureStateFont(d.state);
                            continue;
                        }
                        a.addOp(Ce);
                        a.addOp(ie, [
                            e1.shift()
                        ]);
                        a.addOp(te, [
                            e1.shift()
                        ]);
                        e1[0] = n.handleText(e1[0], d.state);
                        s = he;
                        break;
                    case ne:
                        d.state.textRenderingMode = e1[0];
                        break;
                    case fe:
                        {
                            const t = ColorSpace.getCached(e1[0], g, C);
                            if (t) {
                                d.state.fillColorSpace = t;
                                continue;
                            }
                            next(n.parseColorSpace({
                                cs: e1[0],
                                resources: i,
                                localColorSpaceCache: C
                            }).then(function(e1) {
                                d.state.fillColorSpace = e1 || ColorSpace.singletons.gray;
                            }));
                            return;
                        }
                    case de:
                        {
                            const t = ColorSpace.getCached(e1[0], g, C);
                            if (t) {
                                d.state.strokeColorSpace = t;
                                continue;
                            }
                            next(n.parseColorSpace({
                                cs: e1[0],
                                resources: i,
                                localColorSpaceCache: C
                            }).then(function(e1) {
                                d.state.strokeColorSpace = e1 || ColorSpace.singletons.gray;
                            }));
                            return;
                        }
                    case ye:
                        b = d.state.fillColorSpace;
                        e1 = b.getRgb(e1, 0);
                        s = Se;
                        break;
                    case pe:
                        b = d.state.strokeColorSpace;
                        e1 = b.getRgb(e1, 0);
                        s = Fe;
                        break;
                    case be:
                        d.state.fillColorSpace = ColorSpace.singletons.gray;
                        e1 = ColorSpace.singletons.gray.getRgb(e1, 0);
                        s = Se;
                        break;
                    case De:
                        d.state.strokeColorSpace = ColorSpace.singletons.gray;
                        e1 = ColorSpace.singletons.gray.getRgb(e1, 0);
                        s = Fe;
                        break;
                    case Re:
                        d.state.fillColorSpace = ColorSpace.singletons.cmyk;
                        e1 = ColorSpace.singletons.cmyk.getRgb(e1, 0);
                        s = Se;
                        break;
                    case ke:
                        d.state.strokeColorSpace = ColorSpace.singletons.cmyk;
                        e1 = ColorSpace.singletons.cmyk.getRgb(e1, 0);
                        s = Fe;
                        break;
                    case Se:
                        d.state.fillColorSpace = ColorSpace.singletons.rgb;
                        e1 = ColorSpace.singletons.rgb.getRgb(e1, 0);
                        break;
                    case Fe:
                        d.state.strokeColorSpace = ColorSpace.singletons.rgb;
                        e1 = ColorSpace.singletons.rgb.getRgb(e1, 0);
                        break;
                    case we:
                        b = d.state.patternFillColorSpace;
                        if (!b) {
                            if (isNumberArray(e1, null)) {
                                e1 = ColorSpace.singletons.gray.getRgb(e1, 0);
                                s = Se;
                                break;
                            }
                            e1 = [];
                            s = st;
                            break;
                        }
                        if ("Pattern" === b.name) {
                            next(n.handleColorN(a, we, e1, b, u, i, t, C, l, Q));
                            return;
                        }
                        e1 = b.getRgb(e1, 0);
                        s = Se;
                        break;
                    case me:
                        b = d.state.patternStrokeColorSpace;
                        if (!b) {
                            if (isNumberArray(e1, null)) {
                                e1 = ColorSpace.singletons.gray.getRgb(e1, 0);
                                s = Fe;
                                break;
                            }
                            e1 = [];
                            s = at;
                            break;
                        }
                        if ("Pattern" === b.name) {
                            next(n.handleColorN(a, me, e1, b, u, i, t, C, l, Q));
                            return;
                        }
                        e1 = b.getRgb(e1, 0);
                        s = Fe;
                        break;
                    case Ne:
                        let k;
                        try {
                            const t = i.get("Shading");
                            if (!t) throw new FormatError("No shading resource found");
                            k = t.get(e1[0].name);
                            if (!k) throw new FormatError("No shading object found");
                        } catch (e1) {
                            if (e1 instanceof AbortException) continue;
                            if (n.options.ignoreErrors) {
                                warn(`getOperatorList - ignoring Shading: "${e1}".`);
                                continue;
                            }
                            throw e1;
                        }
                        const R = n.parseShading({
                            shading: k,
                            resources: i,
                            localColorSpaceCache: C,
                            localShadingPatternCache: Q
                        });
                        if (!R) continue;
                        e1 = [
                            R
                        ];
                        s = Ne;
                        break;
                    case GA:
                        S = e1[0] instanceof Name;
                        F = e1[0].name;
                        if (S) {
                            const t = h.getByName(F);
                            if (t) {
                                t.length > 0 && a.addOp(GA, [
                                    t
                                ]);
                                e1 = null;
                                continue;
                            }
                        }
                        next(new Promise(function(e1, s) {
                            if (!S) throw new FormatError("GState must be referred to by name.");
                            const r = i.get("ExtGState");
                            if (!(r instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
                            const g = r.get(F);
                            if (!(g instanceof Dict)) throw new FormatError("GState should be a dictionary.");
                            n.setGState({
                                resources: i,
                                gState: g,
                                operatorList: a,
                                cacheKey: F,
                                task: t,
                                stateManager: d,
                                localGStateCache: h,
                                localColorSpaceCache: C
                            }).then(e1, s);
                        }).catch(function(e1) {
                            if (!(e1 instanceof AbortException)) {
                                if (!n.options.ignoreErrors) throw e1;
                                warn(`getOperatorList - ignoring ExtGState: "${e1}".`);
                            }
                        }));
                        return;
                    case LA:
                    case HA:
                    case JA:
                    case YA:
                    case vA:
                    case KA:
                    case TA:
                        n.buildPath(a, s, e1, o);
                        continue;
                    case Le:
                    case He:
                    case Ke:
                    case Te:
                        continue;
                    case Ye:
                        if (!(e1[0] instanceof Name)) {
                            warn(`Expected name for beginMarkedContentProps arg0=${e1[0]}`);
                            a.addOp(Ye, [
                                "OC",
                                null
                            ]);
                            continue;
                        }
                        if ("OC" === e1[0].name) {
                            next(n.parseMarkedContentProps(e1[1], i).then((e1)=>{
                                a.addOp(Ye, [
                                    "OC",
                                    e1
                                ]);
                            }).catch((e1)=>{
                                if (!(e1 instanceof AbortException)) {
                                    if (!n.options.ignoreErrors) throw e1;
                                    warn(`getOperatorList - ignoring beginMarkedContentProps: "${e1}".`);
                                    a.addOp(Ye, [
                                        "OC",
                                        null
                                    ]);
                                }
                            }));
                            return;
                        }
                        e1 = [
                            e1[0].name,
                            e1[1] instanceof Dict ? e1[1].get("MCID") : null
                        ];
                        break;
                    default:
                        if (null !== e1) {
                            for(w = 0, D = e1.length; w < D && !(e1[w] instanceof Dict); w++);
                            if (w < D) {
                                warn("getOperatorList - ignoring operator: " + s);
                                continue;
                            }
                        }
                }
                a.addOp(s, e1);
            }
            if (y) next(ms);
            else {
                closePendingRestoreOPS();
                e1();
            }
        }).catch((e1)=>{
            if (!(e1 instanceof AbortException)) {
                if (!this.options.ignoreErrors) throw e1;
                warn(`getOperatorList - ignoring errors during "${t.name}" task: "${e1}".`);
                closePendingRestoreOPS();
            }
        });
    }
    getTextContent({ stream: e1, task: t, resources: s, stateManager: r = null, includeMarkedContent: n = !1, sink: g, seenStyles: o = new Set, viewBox: c, lang: C = null, markedContentData: h = null, disableNormalization: l = !1, keepWhiteSpace: Q = !1 }) {
        s ||= Dict.empty;
        r ||= new StateManager(new TextState);
        n && (h ||= {
            level: 0
        });
        const E = {
            items: [],
            styles: Object.create(null),
            lang: C
        }, u = {
            initialized: !1,
            str: [],
            totalWidth: 0,
            totalHeight: 0,
            width: 0,
            height: 0,
            vertical: !1,
            prevTransform: null,
            textAdvanceScale: 0,
            spaceInFlowMin: 0,
            spaceInFlowMax: 0,
            trackingSpaceMin: 1 / 0,
            negativeSpaceMax: -1 / 0,
            notASpace: -1 / 0,
            transform: null,
            fontName: null,
            hasEOL: !1
        }, d = [
            " ",
            " "
        ];
        let f = 0;
        function saveLastChar(e1) {
            const t = (f + 1) % 2, i = " " !== d[f] && " " === d[t];
            d[f] = e1;
            f = t;
            return !Q && i;
        }
        function shouldAddWhitepsace() {
            return !Q && " " !== d[f] && " " === d[(f + 1) % 2];
        }
        function resetLastChars() {
            d[0] = d[1] = " ";
            f = 0;
        }
        const p = this, m = this.xref, y = [];
        let w = null;
        const D = new LocalImageCache, b = new LocalGStateCache, F = new EvaluatorPreprocessor(e1, m, r);
        let S;
        function pushWhitespace({ width: e1 = 0, height: t = 0, transform: i = u.prevTransform, fontName: a = u.fontName }) {
            E.items.push({
                str: " ",
                dir: "ltr",
                width: e1,
                height: t,
                transform: i,
                fontName: a,
                hasEOL: !1
            });
        }
        function getCurrentTextTransform() {
            const e1 = S.font, t = [
                S.fontSize * S.textHScale,
                0,
                0,
                S.fontSize,
                0,
                S.textRise
            ];
            if (e1.isType3Font && (S.fontSize <= 1 || e1.isCharBBox) && !isArrayEqual(S.fontMatrix, a)) {
                const i = e1.bbox[3] - e1.bbox[1];
                i > 0 && (t[3] *= i * S.fontMatrix[3]);
            }
            return Util.transform(S.ctm, Util.transform(S.textMatrix, t));
        }
        function ensureTextContentItem() {
            if (u.initialized) return u;
            const { font: e1, loadedName: t } = S;
            if (!o.has(t)) {
                o.add(t);
                E.styles[t] = {
                    fontFamily: e1.fallbackName,
                    ascent: e1.ascent,
                    descent: e1.descent,
                    vertical: e1.vertical
                };
                if (p.options.fontExtraProperties && e1.systemFontInfo) {
                    const i = E.styles[t];
                    i.fontSubstitution = e1.systemFontInfo.css;
                    i.fontSubstitutionLoadedName = e1.systemFontInfo.loadedName;
                }
            }
            u.fontName = t;
            const i = u.transform = getCurrentTextTransform();
            if (e1.vertical) {
                u.width = u.totalWidth = Math.hypot(i[0], i[1]);
                u.height = u.totalHeight = 0;
                u.vertical = !0;
            } else {
                u.width = u.totalWidth = 0;
                u.height = u.totalHeight = Math.hypot(i[2], i[3]);
                u.vertical = !1;
            }
            const a = Math.hypot(S.textLineMatrix[0], S.textLineMatrix[1]), s = Math.hypot(S.ctm[0], S.ctm[1]);
            u.textAdvanceScale = s * a;
            const { fontSize: r } = S;
            u.trackingSpaceMin = .102 * r;
            u.notASpace = .03 * r;
            u.negativeSpaceMax = -.2 * r;
            u.spaceInFlowMin = .102 * r;
            u.spaceInFlowMax = .6 * r;
            u.hasEOL = !1;
            u.initialized = !0;
            return u;
        }
        function updateAdvanceScale() {
            if (!u.initialized) return;
            const e1 = Math.hypot(S.textLineMatrix[0], S.textLineMatrix[1]), t = Math.hypot(S.ctm[0], S.ctm[1]) * e1;
            if (t !== u.textAdvanceScale) {
                if (u.vertical) {
                    u.totalHeight += u.height * u.textAdvanceScale;
                    u.height = 0;
                } else {
                    u.totalWidth += u.width * u.textAdvanceScale;
                    u.width = 0;
                }
                u.textAdvanceScale = t;
            }
        }
        function runBidiTransform(e1) {
            let t = e1.str.join("");
            l || (t = function normalizeUnicode(e1) {
                if (!Ct) {
                    Ct = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
                    ht = new Map([
                        [
                            "ï¬",
                            "Å¿t"
                        ]
                    ]);
                }
                return e1.replaceAll(Ct, (e1, t, i)=>t ? t.normalize("NFKC") : ht.get(i));
            }(t));
            const i = bidi(t, -1, e1.vertical);
            return {
                str: i.str,
                dir: i.dir,
                width: Math.abs(e1.totalWidth),
                height: Math.abs(e1.totalHeight),
                transform: e1.transform,
                fontName: e1.fontName,
                hasEOL: e1.hasEOL
            };
        }
        async function handleSetFont(e1, i) {
            const r = await p.loadFont(e1, i, s);
            if (r.font.isType3Font) try {
                await r.loadType3Data(p, s, t);
            } catch  {}
            S.loadedName = r.loadedName;
            S.font = r.font;
            S.fontMatrix = r.font.fontMatrix || a;
        }
        function applyInverseRotation(e1, t, i) {
            const a = Math.hypot(i[0], i[1]);
            return [
                (i[0] * e1 + i[1] * t) / a,
                (i[2] * e1 + i[3] * t) / a
            ];
        }
        function compareWithLastPosition(e1) {
            const t = getCurrentTextTransform();
            let i = t[4], a = t[5];
            if (S.font?.vertical) {
                if (i < c[0] || i > c[2] || a + e1 < c[1] || a > c[3]) return !1;
            } else if (i + e1 < c[0] || i > c[2] || a < c[1] || a > c[3]) return !1;
            if (!S.font || !u.prevTransform) return !0;
            let s = u.prevTransform[4], r = u.prevTransform[5];
            if (s === i && r === a) return !0;
            let n = -1;
            t[0] && 0 === t[1] && 0 === t[2] ? n = t[0] > 0 ? 0 : 180 : t[1] && 0 === t[0] && 0 === t[3] && (n = t[1] > 0 ? 90 : 270);
            switch(n){
                case 0:
                    break;
                case 90:
                    [i, a] = [
                        a,
                        i
                    ];
                    [s, r] = [
                        r,
                        s
                    ];
                    break;
                case 180:
                    [i, a, s, r] = [
                        -i,
                        -a,
                        -s,
                        -r
                    ];
                    break;
                case 270:
                    [i, a] = [
                        -a,
                        -i
                    ];
                    [s, r] = [
                        -r,
                        -s
                    ];
                    break;
                default:
                    [i, a] = applyInverseRotation(i, a, t);
                    [s, r] = applyInverseRotation(s, r, u.prevTransform);
            }
            if (S.font.vertical) {
                const e1 = (r - a) / u.textAdvanceScale, t = i - s, n = Math.sign(u.height);
                if (e1 < n * u.negativeSpaceMax) {
                    if (Math.abs(t) > .5 * u.width) {
                        appendEOL();
                        return !0;
                    }
                    resetLastChars();
                    flushTextContentItem();
                    return !0;
                }
                if (Math.abs(t) > u.width) {
                    appendEOL();
                    return !0;
                }
                e1 <= n * u.notASpace && resetLastChars();
                if (e1 <= n * u.trackingSpaceMin) if (shouldAddWhitepsace()) {
                    resetLastChars();
                    flushTextContentItem();
                    pushWhitespace({
                        height: Math.abs(e1)
                    });
                } else u.height += e1;
                else if (!addFakeSpaces(e1, u.prevTransform, n)) if (0 === u.str.length) {
                    resetLastChars();
                    pushWhitespace({
                        height: Math.abs(e1)
                    });
                } else u.height += e1;
                Math.abs(t) > .25 * u.width && flushTextContentItem();
                return !0;
            }
            const g = (i - s) / u.textAdvanceScale, o = a - r, C = Math.sign(u.width);
            if (g < C * u.negativeSpaceMax) {
                if (Math.abs(o) > .5 * u.height) {
                    appendEOL();
                    return !0;
                }
                resetLastChars();
                flushTextContentItem();
                return !0;
            }
            if (Math.abs(o) > u.height) {
                appendEOL();
                return !0;
            }
            g <= C * u.notASpace && resetLastChars();
            if (g <= C * u.trackingSpaceMin) if (shouldAddWhitepsace()) {
                resetLastChars();
                flushTextContentItem();
                pushWhitespace({
                    width: Math.abs(g)
                });
            } else u.width += g;
            else if (!addFakeSpaces(g, u.prevTransform, C)) if (0 === u.str.length) {
                resetLastChars();
                pushWhitespace({
                    width: Math.abs(g)
                });
            } else u.width += g;
            Math.abs(o) > .25 * u.height && flushTextContentItem();
            return !0;
        }
        function buildTextContentItem({ chars: e1, extraSpacing: t }) {
            const i = S.font;
            if (!e1) {
                const e1 = S.charSpacing + t;
                e1 && (i.vertical ? S.translateTextMatrix(0, -e1) : S.translateTextMatrix(e1 * S.textHScale, 0));
                Q && compareWithLastPosition(0);
                return;
            }
            const a = i.charsToGlyphs(e1), s = S.fontMatrix[0] * S.fontSize;
            for(let e1 = 0, r = a.length; e1 < r; e1++){
                const n = a[e1], { category: g } = n;
                if (g.isInvisibleFormatMark) continue;
                let o = S.charSpacing + (e1 + 1 === r ? t : 0), c = n.width;
                i.vertical && (c = n.vmetric ? n.vmetric[0] : -c);
                let C = c * s;
                if (!Q && g.isWhitespace) {
                    if (i.vertical) {
                        o += -C + S.wordSpacing;
                        S.translateTextMatrix(0, -o);
                    } else {
                        o += C + S.wordSpacing;
                        S.translateTextMatrix(o * S.textHScale, 0);
                    }
                    saveLastChar(" ");
                    continue;
                }
                if (!g.isZeroWidthDiacritic && !compareWithLastPosition(C)) {
                    i.vertical ? S.translateTextMatrix(0, C) : S.translateTextMatrix(C * S.textHScale, 0);
                    continue;
                }
                const h = ensureTextContentItem();
                g.isZeroWidthDiacritic && (C = 0);
                if (i.vertical) {
                    S.translateTextMatrix(0, C);
                    C = Math.abs(C);
                    h.height += C;
                } else {
                    C *= S.textHScale;
                    S.translateTextMatrix(C, 0);
                    h.width += C;
                }
                C && (h.prevTransform = getCurrentTextTransform());
                const l = n.unicode;
                saveLastChar(l) && h.str.push(" ");
                h.str.push(l);
                o && (i.vertical ? S.translateTextMatrix(0, -o) : S.translateTextMatrix(o * S.textHScale, 0));
            }
        }
        function appendEOL() {
            resetLastChars();
            if (u.initialized) {
                u.hasEOL = !0;
                flushTextContentItem();
            } else E.items.push({
                str: "",
                dir: "ltr",
                width: 0,
                height: 0,
                transform: getCurrentTextTransform(),
                fontName: S.loadedName,
                hasEOL: !0
            });
        }
        function addFakeSpaces(e1, t, i) {
            if (i * u.spaceInFlowMin <= e1 && e1 <= i * u.spaceInFlowMax) {
                if (u.initialized) {
                    resetLastChars();
                    u.str.push(" ");
                }
                return !1;
            }
            const a = u.fontName;
            let s = 0;
            if (u.vertical) {
                s = e1;
                e1 = 0;
            }
            flushTextContentItem();
            resetLastChars();
            pushWhitespace({
                width: Math.abs(e1),
                height: Math.abs(s),
                transform: t || getCurrentTextTransform(),
                fontName: a
            });
            return !0;
        }
        function flushTextContentItem() {
            if (u.initialized && u.str) {
                u.vertical ? u.totalHeight += u.height * u.textAdvanceScale : u.totalWidth += u.width * u.textAdvanceScale;
                E.items.push(runBidiTransform(u));
                u.initialized = !1;
                u.str.length = 0;
            }
        }
        function enqueueChunk(e1 = !1) {
            const t = E.items.length;
            if (0 !== t && !(e1 && t < 10)) {
                g.enqueue(E, t);
                E.items = [];
                E.styles = Object.create(null);
            }
        }
        const k = new TimeSlotManager;
        return new Promise(function promiseBody(e1, a) {
            const next = function(t) {
                enqueueChunk(!0);
                Promise.all([
                    t,
                    g.ready
                ]).then(function() {
                    try {
                        promiseBody(e1, a);
                    } catch (e1) {
                        a(e1);
                    }
                }, a);
            };
            t.ensureNotTerminated();
            k.reset();
            const u = {};
            let d, f, R, N = [];
            for(; !(d = k.check());){
                N.length = 0;
                u.args = N;
                if (!F.read(u)) break;
                const e1 = S;
                S = r.state;
                const a = u.fn;
                N = u.args;
                switch(0 | a){
                    case re:
                        const a1 = N[0].name, u1 = N[1];
                        if (S.font && a1 === S.fontName && u1 === S.fontSize) break;
                        flushTextContentItem();
                        S.fontName = a1;
                        S.fontSize = u1;
                        next(handleSetFont(a1, null));
                        return;
                    case ge:
                        S.textRise = N[0];
                        break;
                    case ae:
                        S.textHScale = N[0] / 100;
                        break;
                    case se:
                        S.leading = N[0];
                        break;
                    case oe:
                        S.translateTextLineMatrix(N[0], N[1]);
                        S.textMatrix = S.textLineMatrix.slice();
                        break;
                    case Ie:
                        S.leading = -N[1];
                        S.translateTextLineMatrix(N[0], N[1]);
                        S.textMatrix = S.textLineMatrix.slice();
                        break;
                    case Ce:
                        S.carriageReturn();
                        break;
                    case ce:
                        S.setTextMatrix(N[0], N[1], N[2], N[3], N[4], N[5]);
                        S.setTextLineMatrix(N[0], N[1], N[2], N[3], N[4], N[5]);
                        updateAdvanceScale();
                        break;
                    case te:
                        S.charSpacing = N[0];
                        break;
                    case ie:
                        S.wordSpacing = N[0];
                        break;
                    case Ae:
                        S.textMatrix = i.slice();
                        S.textLineMatrix = i.slice();
                        break;
                    case le:
                        if (!r.state.font) {
                            p.ensureStateFont(r.state);
                            continue;
                        }
                        const d1 = (S.font.vertical ? 1 : -1) * S.fontSize / 1e3, F1 = N[0];
                        for(let e1 = 0, t = F1.length; e1 < t; e1++){
                            const t = F1[e1];
                            if ("string" == typeof t) y.push(t);
                            else if ("number" == typeof t && 0 !== t) {
                                const e1 = y.join("");
                                y.length = 0;
                                buildTextContentItem({
                                    chars: e1,
                                    extraSpacing: t * d1
                                });
                            }
                        }
                        if (y.length > 0) {
                            const e1 = y.join("");
                            y.length = 0;
                            buildTextContentItem({
                                chars: e1,
                                extraSpacing: 0
                            });
                        }
                        break;
                    case he:
                        if (!r.state.font) {
                            p.ensureStateFont(r.state);
                            continue;
                        }
                        buildTextContentItem({
                            chars: N[0],
                            extraSpacing: 0
                        });
                        break;
                    case Be:
                        if (!r.state.font) {
                            p.ensureStateFont(r.state);
                            continue;
                        }
                        S.carriageReturn();
                        buildTextContentItem({
                            chars: N[0],
                            extraSpacing: 0
                        });
                        break;
                    case Qe:
                        if (!r.state.font) {
                            p.ensureStateFont(r.state);
                            continue;
                        }
                        S.wordSpacing = N[0];
                        S.charSpacing = N[1];
                        S.carriageReturn();
                        buildTextContentItem({
                            chars: N[2],
                            extraSpacing: 0
                        });
                        break;
                    case xe:
                        flushTextContentItem();
                        w ??= s.get("XObject") || Dict.empty;
                        R = N[0] instanceof Name;
                        f = N[0].name;
                        if (R && D.getByName(f)) break;
                        next(new Promise(function(e1, i) {
                            if (!R) throw new FormatError("XObject must be referred to by name.");
                            let a = w.getRaw(f);
                            if (a instanceof Ref) {
                                if (D.getByRef(a)) {
                                    e1();
                                    return;
                                }
                                if (p.globalImageCache.getData(a, p.pageIndex)) {
                                    e1();
                                    return;
                                }
                                a = m.fetch(a);
                            }
                            if (!(a instanceof BaseStream)) throw new FormatError("XObject should be a stream");
                            const E = a.dict.get("Subtype");
                            if (!(E instanceof Name)) throw new FormatError("XObject should have a Name subtype");
                            if ("Form" !== E.name) {
                                D.set(f, a.dict.objId, !0);
                                e1();
                                return;
                            }
                            const u = r.state.clone(), d = new StateManager(u), y = lookupMatrix(a.dict.getArray("Matrix"), null);
                            y && d.transform(y);
                            enqueueChunk();
                            const b = {
                                enqueueInvoked: !1,
                                enqueue (e1, t) {
                                    this.enqueueInvoked = !0;
                                    g.enqueue(e1, t);
                                },
                                get desiredSize () {
                                    return g.desiredSize;
                                },
                                get ready () {
                                    return g.ready;
                                }
                            };
                            p.getTextContent({
                                stream: a,
                                task: t,
                                resources: a.dict.get("Resources") || s,
                                stateManager: d,
                                includeMarkedContent: n,
                                sink: b,
                                seenStyles: o,
                                viewBox: c,
                                lang: C,
                                markedContentData: h,
                                disableNormalization: l,
                                keepWhiteSpace: Q
                            }).then(function() {
                                b.enqueueInvoked || D.set(f, a.dict.objId, !0);
                                e1();
                            }, i);
                        }).catch(function(e1) {
                            if (!(e1 instanceof AbortException)) {
                                if (!p.options.ignoreErrors) throw e1;
                                warn(`getTextContent - ignoring XObject: "${e1}".`);
                            }
                        }));
                        return;
                    case GA:
                        R = N[0] instanceof Name;
                        f = N[0].name;
                        if (R && b.getByName(f)) break;
                        next(new Promise(function(e1, t) {
                            if (!R) throw new FormatError("GState must be referred to by name.");
                            const i = s.get("ExtGState");
                            if (!(i instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
                            const a = i.get(f);
                            if (!(a instanceof Dict)) throw new FormatError("GState should be a dictionary.");
                            const r = a.get("Font");
                            if (r) {
                                flushTextContentItem();
                                S.fontName = null;
                                S.fontSize = r[1];
                                handleSetFont(null, r[0]).then(e1, t);
                            } else {
                                b.set(f, a.objId, !0);
                                e1();
                            }
                        }).catch(function(e1) {
                            if (!(e1 instanceof AbortException)) {
                                if (!p.options.ignoreErrors) throw e1;
                                warn(`getTextContent - ignoring ExtGState: "${e1}".`);
                            }
                        }));
                        return;
                    case Je:
                        flushTextContentItem();
                        if (n) {
                            h.level++;
                            E.items.push({
                                type: "beginMarkedContent",
                                tag: N[0] instanceof Name ? N[0].name : null
                            });
                        }
                        break;
                    case Ye:
                        flushTextContentItem();
                        if (n) {
                            h.level++;
                            let e1 = null;
                            N[1] instanceof Dict && (e1 = N[1].get("MCID"));
                            E.items.push({
                                type: "beginMarkedContentProps",
                                id: Number.isInteger(e1) ? `${p.idFactory.getPageObjId()}_mc${e1}` : null,
                                tag: N[0] instanceof Name ? N[0].name : null
                            });
                        }
                        break;
                    case ve:
                        flushTextContentItem();
                        if (n) {
                            if (0 === h.level) break;
                            h.level--;
                            E.items.push({
                                type: "endMarkedContent"
                            });
                        }
                        break;
                    case UA:
                        !e1 || e1.font === S.font && e1.fontSize === S.fontSize && e1.fontName === S.fontName || flushTextContentItem();
                }
                if (E.items.length >= g.desiredSize) {
                    d = !0;
                    break;
                }
            }
            if (d) next(ms);
            else {
                flushTextContentItem();
                enqueueChunk();
                e1();
            }
        }).catch((e1)=>{
            if (!(e1 instanceof AbortException)) {
                if (!this.options.ignoreErrors) throw e1;
                warn(`getTextContent - ignoring errors during "${t.name}" task: "${e1}".`);
                flushTextContentItem();
                enqueueChunk();
            }
        });
    }
    async extractDataStructures(e1, t) {
        const i = this.xref;
        let a;
        const s = this.readToUnicode(t.toUnicode);
        if (t.composite) {
            const i = e1.get("CIDSystemInfo");
            i instanceof Dict && (t.cidSystemInfo = {
                registry: stringToPDFString(i.get("Registry")),
                ordering: stringToPDFString(i.get("Ordering")),
                supplement: i.get("Supplement")
            });
            try {
                const t = e1.get("CIDToGIDMap");
                t instanceof BaseStream && (a = t.getBytes());
            } catch (e1) {
                if (!this.options.ignoreErrors) throw e1;
                warn(`extractDataStructures - ignoring CIDToGIDMap data: "${e1}".`);
            }
        }
        const r = [];
        let n, g = null;
        if (e1.has("Encoding")) {
            n = e1.get("Encoding");
            if (n instanceof Dict) {
                g = n.get("BaseEncoding");
                g = g instanceof Name ? g.name : null;
                if (n.has("Differences")) {
                    const e1 = n.get("Differences");
                    let t = 0;
                    for (const a of e1){
                        const e1 = i.fetchIfRef(a);
                        if ("number" == typeof e1) t = e1;
                        else {
                            if (!(e1 instanceof Name)) throw new FormatError(`Invalid entry in 'Differences' array: ${e1}`);
                            r[t++] = e1.name;
                        }
                    }
                }
            } else if (n instanceof Name) g = n.name;
            else {
                const e1 = "Encoding is not a Name nor a Dict";
                if (!this.options.ignoreErrors) throw new FormatError(e1);
                warn(e1);
            }
            "MacRomanEncoding" !== g && "MacExpertEncoding" !== g && "WinAnsiEncoding" !== g && (g = null);
        }
        const o = !t.file || t.isInternalFont, c = qi()[t.name];
        g && o && c && (g = null);
        if (g) t.defaultEncoding = getEncoding(g);
        else {
            const e1 = !!(t.flags & Mi), i = !!(t.flags & xi);
            n = hi;
            "TrueType" !== t.type || i || (n = li);
            if (e1 || c) {
                n = Ci;
                o && (/Symbol/i.test(t.name) ? n = Bi : /Dingbats/i.test(t.name) ? n = Qi : /Wingdings/i.test(t.name) && (n = li));
            }
            t.defaultEncoding = n;
        }
        t.differences = r;
        t.baseEncodingName = g;
        t.hasEncoding = !!g || r.length > 0;
        t.dict = e1;
        t.toUnicode = await s;
        const C = await this.buildToUnicode(t);
        t.toUnicode = C;
        a && (t.cidToGidMap = this.readCidToGidMap(a, C));
        return t;
    }
    _simpleFontToUnicode(e1, t = !1) {
        assert(!e1.composite, "Must be a simple font.");
        const i = [], a = e1.defaultEncoding.slice(), s = e1.baseEncodingName, r = e1.differences;
        for(const e1 in r){
            const t = r[e1];
            ".notdef" !== t && (a[e1] = t);
        }
        const n = wi();
        for(const r in a){
            let g = a[r];
            if ("" === g) continue;
            let o = n[g];
            if (void 0 !== o) {
                i[r] = String.fromCharCode(o);
                continue;
            }
            let c = 0;
            switch(g[0]){
                case "G":
                    3 === g.length && (c = parseInt(g.substring(1), 16));
                    break;
                case "g":
                    5 === g.length && (c = parseInt(g.substring(1), 16));
                    break;
                case "C":
                case "c":
                    if (g.length >= 3 && g.length <= 4) {
                        const i = g.substring(1);
                        if (t) {
                            c = parseInt(i, 16);
                            break;
                        }
                        c = +i;
                        if (Number.isNaN(c) && Number.isInteger(parseInt(i, 16))) return this._simpleFontToUnicode(e1, !0);
                    }
                    break;
                case "u":
                    o = getUnicodeForGlyph(g, n);
                    -1 !== o && (c = o);
                    break;
                default:
                    switch(g){
                        case "f_h":
                        case "f_t":
                        case "T_h":
                            i[r] = g.replaceAll("_", "");
                            continue;
                    }
            }
            if (c > 0 && c <= 1114111 && Number.isInteger(c)) {
                if (s && c === +r) {
                    const e1 = getEncoding(s);
                    if (e1 && (g = e1[r])) {
                        i[r] = String.fromCharCode(n[g]);
                        continue;
                    }
                }
                i[r] = String.fromCodePoint(c);
            }
        }
        return i;
    }
    async buildToUnicode(e1) {
        e1.hasIncludedToUnicodeMap = e1.toUnicode?.length > 0;
        if (e1.hasIncludedToUnicodeMap) {
            !e1.composite && e1.hasEncoding && (e1.fallbackToUnicode = this._simpleFontToUnicode(e1));
            return e1.toUnicode;
        }
        if (!e1.composite) return new ToUnicodeMap(this._simpleFontToUnicode(e1));
        if (e1.composite && (e1.cMap.builtInCMap && !(e1.cMap instanceof IdentityCMap) || "Adobe" === e1.cidSystemInfo?.registry && ("GB1" === e1.cidSystemInfo.ordering || "CNS1" === e1.cidSystemInfo.ordering || "Japan1" === e1.cidSystemInfo.ordering || "Korea1" === e1.cidSystemInfo.ordering))) {
            const { registry: t, ordering: i } = e1.cidSystemInfo, a = Name.get(`${t}-${i}-UCS2`), s = await CMapFactory.create({
                encoding: a,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            }), r = [], n = [];
            e1.cMap.forEach(function(e1, t) {
                if (t > 65535) throw new FormatError("Max size of CID is 65,535");
                const i = s.lookup(t);
                if (i) {
                    n.length = 0;
                    for(let e1 = 0, t = i.length; e1 < t; e1 += 2)n.push((i.charCodeAt(e1) << 8) + i.charCodeAt(e1 + 1));
                    r[e1] = String.fromCharCode(...n);
                }
            });
            return new ToUnicodeMap(r);
        }
        return new IdentityToUnicodeMap(e1.firstChar, e1.lastChar);
    }
    async readToUnicode(e1) {
        if (!e1) return null;
        if (e1 instanceof Name) {
            const t = await CMapFactory.create({
                encoding: e1,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            });
            return t instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t.getMap());
        }
        if (e1 instanceof BaseStream) try {
            const t = await CMapFactory.create({
                encoding: e1,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            });
            if (t instanceof IdentityCMap) return new IdentityToUnicodeMap(0, 65535);
            const i = new Array(t.length);
            t.forEach(function(e1, t) {
                if ("number" == typeof t) {
                    i[e1] = String.fromCodePoint(t);
                    return;
                }
                t.length % 2 != 0 && (t = "\0" + t);
                const a = [];
                for(let e1 = 0; e1 < t.length; e1 += 2){
                    const i = t.charCodeAt(e1) << 8 | t.charCodeAt(e1 + 1);
                    if (55296 != (63488 & i)) {
                        a.push(i);
                        continue;
                    }
                    e1 += 2;
                    const s = t.charCodeAt(e1) << 8 | t.charCodeAt(e1 + 1);
                    a.push(((1023 & i) << 10) + (1023 & s) + 65536);
                }
                i[e1] = String.fromCodePoint(...a);
            });
            return new ToUnicodeMap(i);
        } catch (e1) {
            if (e1 instanceof AbortException) return null;
            if (this.options.ignoreErrors) {
                warn(`readToUnicode - ignoring ToUnicode data: "${e1}".`);
                return null;
            }
            throw e1;
        }
        return null;
    }
    readCidToGidMap(e1, t) {
        const i = [];
        for(let a = 0, s = e1.length; a < s; a++){
            const s = e1[a++] << 8 | e1[a], r = a >> 1;
            (0 !== s || t.has(r)) && (i[r] = s);
        }
        return i;
    }
    extractWidths(e1, t, i) {
        const a = this.xref;
        let s = [], r = 0;
        const n = [];
        let g;
        if (i.composite) {
            const t = e1.get("DW");
            r = "number" == typeof t ? Math.ceil(t) : 1e3;
            const o = e1.get("W");
            if (Array.isArray(o)) for(let e1 = 0, t = o.length; e1 < t; e1++){
                let t = a.fetchIfRef(o[e1++]);
                if (!Number.isInteger(t)) break;
                const i = a.fetchIfRef(o[e1]);
                if (Array.isArray(i)) for (const e1 of i){
                    const i = a.fetchIfRef(e1);
                    "number" == typeof i && (s[t] = i);
                    t++;
                }
                else {
                    if (!Number.isInteger(i)) break;
                    {
                        const r = a.fetchIfRef(o[++e1]);
                        if ("number" != typeof r) continue;
                        for(let e1 = t; e1 <= i; e1++)s[e1] = r;
                    }
                }
            }
            if (i.vertical) {
                const t = e1.getArray("DW2");
                let i = isNumberArray(t, 2) ? t : [
                    880,
                    -1e3
                ];
                g = [
                    i[1],
                    .5 * r,
                    i[0]
                ];
                i = e1.get("W2");
                if (Array.isArray(i)) for(let e1 = 0, t = i.length; e1 < t; e1++){
                    let t = a.fetchIfRef(i[e1++]);
                    if (!Number.isInteger(t)) break;
                    const s = a.fetchIfRef(i[e1]);
                    if (Array.isArray(s)) for(let e1 = 0, i = s.length; e1 < i; e1++){
                        const i = [
                            a.fetchIfRef(s[e1++]),
                            a.fetchIfRef(s[e1++]),
                            a.fetchIfRef(s[e1])
                        ];
                        isNumberArray(i, null) && (n[t] = i);
                        t++;
                    }
                    else {
                        if (!Number.isInteger(s)) break;
                        {
                            const r = [
                                a.fetchIfRef(i[++e1]),
                                a.fetchIfRef(i[++e1]),
                                a.fetchIfRef(i[++e1])
                            ];
                            if (!isNumberArray(r, null)) continue;
                            for(let e1 = t; e1 <= s; e1++)n[e1] = r;
                        }
                    }
                }
            }
        } else {
            const n = e1.get("Widths");
            if (Array.isArray(n)) {
                let e1 = i.firstChar;
                for (const t of n){
                    const i = a.fetchIfRef(t);
                    "number" == typeof i && (s[e1] = i);
                    e1++;
                }
                const g = t.get("MissingWidth");
                r = "number" == typeof g ? g : 0;
            } else {
                const t = e1.get("BaseFont");
                if (t instanceof Name) {
                    const e1 = this.getBaseFontMetrics(t.name);
                    s = this.buildCharCodeToWidth(e1.widths, i);
                    r = e1.defaultWidth;
                }
            }
        }
        let o = !0, c = r;
        for(const e1 in s){
            const t = s[e1];
            if (t) if (c) {
                if (c !== t) {
                    o = !1;
                    break;
                }
            } else c = t;
        }
        o ? i.flags |= Ni : i.flags &= ~Ni;
        i.defaultWidth = r;
        i.widths = s;
        i.defaultVMetrics = g;
        i.vmetrics = n;
    }
    isSerifFont(e1) {
        const t = e1.split("-", 1)[0];
        return t in Ti() || /serif/gi.test(t);
    }
    getBaseFontMetrics(e1) {
        let t = 0, i = Object.create(null), a = !1;
        let s = Yi()[e1] || e1;
        const r = ji();
        s in r || (s = this.isSerifFont(e1) ? "Times-Roman" : "Helvetica");
        const n = r[s];
        if ("number" == typeof n) {
            t = n;
            a = !0;
        } else i = n();
        return {
            defaultWidth: t,
            monospace: a,
            widths: i
        };
    }
    buildCharCodeToWidth(e1, t) {
        const i = Object.create(null), a = t.differences, s = t.defaultEncoding;
        for(let t = 0; t < 256; t++)t in a && e1[a[t]] ? i[t] = e1[a[t]] : t in s && e1[s[t]] && (i[t] = e1[s[t]]);
        return i;
    }
    preEvaluateFont(e1) {
        const t = e1;
        let i = e1.get("Subtype");
        if (!(i instanceof Name)) throw new FormatError("invalid font Subtype");
        let a, s = !1;
        if ("Type0" === i.name) {
            const t = e1.get("DescendantFonts");
            if (!t) throw new FormatError("Descendant fonts are not specified");
            if (!((e1 = Array.isArray(t) ? this.xref.fetchIfRef(t[0]) : t) instanceof Dict)) throw new FormatError("Descendant font is not a dictionary.");
            i = e1.get("Subtype");
            if (!(i instanceof Name)) throw new FormatError("invalid font Subtype");
            s = !0;
        }
        let r = e1.get("FirstChar");
        Number.isInteger(r) || (r = 0);
        let n = e1.get("LastChar");
        Number.isInteger(n) || (n = s ? 65535 : 255);
        const g = e1.get("FontDescriptor"), o = e1.get("ToUnicode") || t.get("ToUnicode");
        if (g) {
            a = new MurmurHash3_64;
            const i = t.getRaw("Encoding");
            if (i instanceof Name) a.update(i.name);
            else if (i instanceof Ref) a.update(i.toString());
            else if (i instanceof Dict) {
                for (const e1 of i.getRawValues())if (e1 instanceof Name) a.update(e1.name);
                else if (e1 instanceof Ref) a.update(e1.toString());
                else if (Array.isArray(e1)) {
                    const t = e1.length, i = new Array(t);
                    for(let a = 0; a < t; a++){
                        const t = e1[a];
                        t instanceof Name ? i[a] = t.name : ("number" == typeof t || t instanceof Ref) && (i[a] = t.toString());
                    }
                    a.update(i.join());
                }
            }
            a.update(`${r}-${n}`);
            if (o instanceof BaseStream) {
                const e1 = o.str || o, t = e1.buffer ? new Uint8Array(e1.buffer.buffer, 0, e1.bufferLength) : new Uint8Array(e1.bytes.buffer, e1.start, e1.end - e1.start);
                a.update(t);
            } else o instanceof Name && a.update(o.name);
            const g = e1.get("Widths") || t.get("Widths");
            if (Array.isArray(g)) {
                const e1 = [];
                for (const t of g)("number" == typeof t || t instanceof Ref) && e1.push(t.toString());
                a.update(e1.join());
            }
            if (s) {
                a.update("compositeFont");
                const i = e1.get("W") || t.get("W");
                if (Array.isArray(i)) {
                    const e1 = [];
                    for (const t of i)if ("number" == typeof t || t instanceof Ref) e1.push(t.toString());
                    else if (Array.isArray(t)) {
                        const i = [];
                        for (const e1 of t)("number" == typeof e1 || e1 instanceof Ref) && i.push(e1.toString());
                        e1.push(`[${i.join()}]`);
                    }
                    a.update(e1.join());
                }
                const s = e1.getRaw("CIDToGIDMap") || t.getRaw("CIDToGIDMap");
                s instanceof Name ? a.update(s.name) : s instanceof Ref ? a.update(s.toString()) : s instanceof BaseStream && a.update(s.peekBytes());
            }
        }
        return {
            descriptor: g,
            dict: e1,
            baseDict: t,
            composite: s,
            type: i.name,
            firstChar: r,
            lastChar: n,
            toUnicode: o,
            hash: a ? a.hexdigest() : ""
        };
    }
    async translateFont({ descriptor: e1, dict: t, baseDict: i, composite: s, type: r, firstChar: n, lastChar: g, toUnicode: o, cssFontInfo: c }) {
        const C = "Type3" === r;
        if (!e1) {
            if (!C) {
                let e1 = t.get("BaseFont");
                if (!(e1 instanceof Name)) throw new FormatError("Base font is not specified");
                e1 = e1.name.replaceAll(/[,_]/g, "-");
                const a = this.getBaseFontMetrics(e1), s = e1.split("-", 1)[0], c = (this.isSerifFont(s) ? Gi : 0) | (a.monospace ? Ni : 0) | (qi()[s] ? Mi : xi), h = {
                    type: r,
                    name: e1,
                    loadedName: i.loadedName,
                    systemFontInfo: null,
                    widths: a.widths,
                    defaultWidth: a.defaultWidth,
                    isSimulatedFlags: !0,
                    flags: c,
                    firstChar: n,
                    lastChar: g,
                    toUnicode: o,
                    xHeight: 0,
                    capHeight: 0,
                    italicAngle: 0,
                    isType3Font: C
                }, l = t.get("Widths"), Q = getStandardFontName(e1);
                let E = null;
                if (Q) {
                    E = await this.fetchStandardFontData(Q);
                    h.isInternalFont = !!E;
                }
                !h.isInternalFont && this.options.useSystemFonts && (h.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e1, Q, r));
                const u = await this.extractDataStructures(t, h);
                if (Array.isArray(l)) {
                    const e1 = [];
                    let t = n;
                    for (const i of l){
                        const a = this.xref.fetchIfRef(i);
                        "number" == typeof a && (e1[t] = a);
                        t++;
                    }
                    u.widths = e1;
                } else u.widths = this.buildCharCodeToWidth(a.widths, u);
                return new Font(e1, E, u);
            }
            {
                const i = lookupNormalRect(t.getArray("FontBBox"), [
                    0,
                    0,
                    0,
                    0
                ]);
                (e1 = new Dict(null)).set("FontName", Name.get(r));
                e1.set("FontBBox", i);
            }
        }
        let h = e1.get("FontName"), l = t.get("BaseFont");
        "string" == typeof h && (h = Name.get(h));
        "string" == typeof l && (l = Name.get(l));
        const Q = h?.name, E = l?.name;
        if (!C && Q !== E) {
            info(`The FontDescriptor's FontName is "${Q}" but should be the same as the Font's BaseFont "${E}".`);
            Q && E && (E.startsWith(Q) || !isKnownFontName(Q) && isKnownFontName(E)) && (h = null);
        }
        h ||= l;
        if (!(h instanceof Name)) throw new FormatError("invalid font name");
        let u, d, f, p, m;
        try {
            u = e1.get("FontFile", "FontFile2", "FontFile3");
            if (u) {
                if (!(u instanceof BaseStream)) throw new FormatError("FontFile should be a stream");
                if (u.isEmpty) throw new FormatError("FontFile is empty");
            }
        } catch (e1) {
            if (!this.options.ignoreErrors) throw e1;
            warn(`translateFont - fetching "${h.name}" font file: "${e1}".`);
            u = null;
        }
        let y = !1, w = null, D = null;
        if (u) {
            if (u.dict) {
                const e1 = u.dict.get("Subtype");
                e1 instanceof Name && (d = e1.name);
                f = u.dict.get("Length1");
                p = u.dict.get("Length2");
                m = u.dict.get("Length3");
            }
        } else if (c) {
            const e1 = getXfaFontName(h.name);
            if (e1) {
                c.fontFamily = `${c.fontFamily}-PdfJS-XFA`;
                c.metrics = e1.metrics || null;
                w = e1.factors || null;
                u = await this.fetchStandardFontData(e1.name);
                y = !!u;
                i = t = getXfaFontDict(h.name);
                s = !0;
            }
        } else if (!C) {
            const e1 = getStandardFontName(h.name);
            if (e1) {
                u = await this.fetchStandardFontData(e1);
                y = !!u;
            }
            !y && this.options.useSystemFonts && (D = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, h.name, e1, r));
        }
        const b = lookupMatrix(t.getArray("FontMatrix"), a), F = lookupNormalRect(e1.getArray("FontBBox") || t.getArray("FontBBox"), void 0);
        let S = e1.get("Ascent");
        "number" != typeof S && (S = void 0);
        let k = e1.get("Descent");
        "number" != typeof k && (k = void 0);
        let R = e1.get("XHeight");
        "number" != typeof R && (R = 0);
        let N = e1.get("CapHeight");
        "number" != typeof N && (N = 0);
        let G = e1.get("Flags");
        Number.isInteger(G) || (G = 0);
        let M = e1.get("ItalicAngle");
        "number" != typeof M && (M = 0);
        const U = {
            type: r,
            name: h.name,
            subtype: d,
            file: u,
            length1: f,
            length2: p,
            length3: m,
            isInternalFont: y,
            loadedName: i.loadedName,
            composite: s,
            fixedPitch: !1,
            fontMatrix: b,
            firstChar: n,
            lastChar: g,
            toUnicode: o,
            bbox: F,
            ascent: S,
            descent: k,
            xHeight: R,
            capHeight: N,
            flags: G,
            italicAngle: M,
            isType3Font: C,
            cssFontInfo: c,
            scaleFactors: w,
            systemFontInfo: D
        };
        if (s) {
            const e1 = i.get("Encoding");
            e1 instanceof Name && (U.cidEncoding = e1.name);
            const t = await CMapFactory.create({
                encoding: e1,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            });
            U.cMap = t;
            U.vertical = U.cMap.vertical;
        }
        const x = await this.extractDataStructures(t, U);
        this.extractWidths(t, e1, x);
        return new Font(h.name, u, x);
    }
    static buildFontPaths(e1, t, i, a) {
        function buildPath(t) {
            const s = `${e1.loadedName}_path_${t}`;
            try {
                if (e1.renderer.hasBuiltPath(t)) return;
                i.send("commonobj", [
                    s,
                    "FontPath",
                    e1.renderer.getPathJs(t)
                ]);
            } catch (e1) {
                if (a.ignoreErrors) {
                    warn(`buildFontPaths - ignoring ${s} glyph: "${e1}".`);
                    return;
                }
                throw e1;
            }
        }
        for (const e1 of t){
            buildPath(e1.fontChar);
            const t = e1.accent;
            t?.fontChar && buildPath(t.fontChar);
        }
    }
    static get fallbackFontDict() {
        const e1 = new Dict;
        e1.set("BaseFont", Name.get("Helvetica"));
        e1.set("Type", Name.get("FallbackType"));
        e1.set("Subtype", Name.get("FallbackType"));
        e1.set("Encoding", Name.get("WinAnsiEncoding"));
        return shadow(this, "fallbackFontDict", e1);
    }
}
class TranslatedFont {
    constructor({ loadedName: e1, font: t, dict: i, evaluatorOptions: a }){
        this.loadedName = e1;
        this.font = t;
        this.dict = i;
        this._evaluatorOptions = a || ds;
        this.type3Loaded = null;
        this.type3Dependencies = t.isType3Font ? new Set : null;
        this.sent = !1;
    }
    send(e1) {
        if (!this.sent) {
            this.sent = !0;
            e1.send("commonobj", [
                this.loadedName,
                "Font",
                this.font.exportData(this._evaluatorOptions.fontExtraProperties)
            ]);
        }
    }
    fallback(e1) {
        if (this.font.data) {
            this.font.disableFontFace = !0;
            PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e1, this._evaluatorOptions);
        }
    }
    loadType3Data(e1, t, i) {
        if (this.type3Loaded) return this.type3Loaded;
        if (!this.font.isType3Font) throw new Error("Must be a Type3 font.");
        const a = e1.clone({
            ignoreErrors: !1
        }), s = new RefSet(e1.type3FontRefs);
        this.dict.objId && !s.has(this.dict.objId) && s.put(this.dict.objId);
        a.type3FontRefs = s;
        const r = this.font, n = this.type3Dependencies;
        let g = Promise.resolve();
        const o = this.dict.get("CharProcs"), c = this.dict.get("Resources") || t, C = Object.create(null), h = Util.normalizeRect(r.bbox || [
            0,
            0,
            0,
            0
        ]), l = h[2] - h[0], Q = h[3] - h[1], E = Math.hypot(l, Q);
        for (const e1 of o.getKeys())g = g.then(()=>{
            const t = o.get(e1), s = new OperatorList;
            return a.getOperatorList({
                stream: t,
                task: i,
                resources: c,
                operatorList: s
            }).then(()=>{
                s.fnArray[0] === ue && this._removeType3ColorOperators(s, E);
                C[e1] = s.getIR();
                for (const e1 of s.dependencies)n.add(e1);
            }).catch(function(t) {
                warn(`Type3 font resource "${e1}" is not available.`);
                const i = new OperatorList;
                C[e1] = i.getIR();
            });
        });
        this.type3Loaded = g.then(()=>{
            r.charProcOperatorList = C;
            if (this._bbox) {
                r.isCharBBox = !0;
                r.bbox = this._bbox;
            }
        });
        return this.type3Loaded;
    }
    _removeType3ColorOperators(e1, t = NaN) {
        const i = Util.normalizeRect(e1.argsArray[0].slice(2)), a = i[2] - i[0], s = i[3] - i[1], r = Math.hypot(a, s);
        if (0 === a || 0 === s) {
            e1.fnArray.splice(0, 1);
            e1.argsArray.splice(0, 1);
        } else if (0 === t || Math.round(r / t) >= 10) {
            this._bbox || (this._bbox = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ]);
            this._bbox[0] = Math.min(this._bbox[0], i[0]);
            this._bbox[1] = Math.min(this._bbox[1], i[1]);
            this._bbox[2] = Math.max(this._bbox[2], i[2]);
            this._bbox[3] = Math.max(this._bbox[3], i[3]);
        }
        let n = 0, g = e1.length;
        for(; n < g;){
            switch(e1.fnArray[n]){
                case ue:
                    break;
                case de:
                case fe:
                case pe:
                case me:
                case ye:
                case we:
                case De:
                case be:
                case Fe:
                case Se:
                case ke:
                case Re:
                case Ne:
                case RA:
                    e1.fnArray.splice(n, 1);
                    e1.argsArray.splice(n, 1);
                    g--;
                    continue;
                case GA:
                    const [t] = e1.argsArray[n];
                    let i = 0, a = t.length;
                    for(; i < a;){
                        const [e1] = t[i];
                        switch(e1){
                            case "TR":
                            case "TR2":
                            case "HT":
                            case "BG":
                            case "BG2":
                            case "UCR":
                            case "UCR2":
                                t.splice(i, 1);
                                a--;
                                continue;
                        }
                        i++;
                    }
            }
            n++;
        }
    }
}
class StateManager {
    constructor(e1 = new EvalState){
        this.state = e1;
        this.stateStack = [];
    }
    save() {
        const e1 = this.state;
        this.stateStack.push(this.state);
        this.state = e1.clone();
    }
    restore() {
        const e1 = this.stateStack.pop();
        e1 && (this.state = e1);
    }
    transform(e1) {
        this.state.ctm = Util.transform(this.state.ctm, e1);
    }
}
class TextState {
    constructor(){
        this.ctm = new Float32Array(i);
        this.fontName = null;
        this.fontSize = 0;
        this.loadedName = null;
        this.font = null;
        this.fontMatrix = a;
        this.textMatrix = i.slice();
        this.textLineMatrix = i.slice();
        this.charSpacing = 0;
        this.wordSpacing = 0;
        this.leading = 0;
        this.textHScale = 1;
        this.textRise = 0;
    }
    setTextMatrix(e1, t, i, a, s, r) {
        const n = this.textMatrix;
        n[0] = e1;
        n[1] = t;
        n[2] = i;
        n[3] = a;
        n[4] = s;
        n[5] = r;
    }
    setTextLineMatrix(e1, t, i, a, s, r) {
        const n = this.textLineMatrix;
        n[0] = e1;
        n[1] = t;
        n[2] = i;
        n[3] = a;
        n[4] = s;
        n[5] = r;
    }
    translateTextMatrix(e1, t) {
        const i = this.textMatrix;
        i[4] = i[0] * e1 + i[2] * t + i[4];
        i[5] = i[1] * e1 + i[3] * t + i[5];
    }
    translateTextLineMatrix(e1, t) {
        const i = this.textLineMatrix;
        i[4] = i[0] * e1 + i[2] * t + i[4];
        i[5] = i[1] * e1 + i[3] * t + i[5];
    }
    carriageReturn() {
        this.translateTextLineMatrix(0, -this.leading);
        this.textMatrix = this.textLineMatrix.slice();
    }
    clone() {
        const e1 = Object.create(this);
        e1.textMatrix = this.textMatrix.slice();
        e1.textLineMatrix = this.textLineMatrix.slice();
        e1.fontMatrix = this.fontMatrix.slice();
        return e1;
    }
}
class EvalState {
    constructor(){
        this.ctm = new Float32Array(i);
        this.font = null;
        this.textRenderingMode = w;
        this._fillColorSpace = ColorSpace.singletons.gray;
        this._strokeColorSpace = ColorSpace.singletons.gray;
        this.patternFillColorSpace = null;
        this.patternStrokeColorSpace = null;
    }
    get fillColorSpace() {
        return this._fillColorSpace;
    }
    set fillColorSpace(e1) {
        this._fillColorSpace = this.patternFillColorSpace = e1;
    }
    get strokeColorSpace() {
        return this._strokeColorSpace;
    }
    set strokeColorSpace(e1) {
        this._strokeColorSpace = this.patternStrokeColorSpace = e1;
    }
    clone() {
        return Object.create(this);
    }
}
class EvaluatorPreprocessor {
    static get opMap() {
        return shadow(this, "opMap", Object.assign(Object.create(null), {
            w: {
                id: DA,
                numArgs: 1,
                variableArgs: !1
            },
            J: {
                id: bA,
                numArgs: 1,
                variableArgs: !1
            },
            j: {
                id: FA,
                numArgs: 1,
                variableArgs: !1
            },
            M: {
                id: SA,
                numArgs: 1,
                variableArgs: !1
            },
            d: {
                id: kA,
                numArgs: 2,
                variableArgs: !1
            },
            ri: {
                id: RA,
                numArgs: 1,
                variableArgs: !1
            },
            i: {
                id: NA,
                numArgs: 1,
                variableArgs: !1
            },
            gs: {
                id: GA,
                numArgs: 1,
                variableArgs: !1
            },
            q: {
                id: MA,
                numArgs: 0,
                variableArgs: !1
            },
            Q: {
                id: UA,
                numArgs: 0,
                variableArgs: !1
            },
            cm: {
                id: xA,
                numArgs: 6,
                variableArgs: !1
            },
            m: {
                id: LA,
                numArgs: 2,
                variableArgs: !1
            },
            l: {
                id: HA,
                numArgs: 2,
                variableArgs: !1
            },
            c: {
                id: JA,
                numArgs: 6,
                variableArgs: !1
            },
            v: {
                id: YA,
                numArgs: 4,
                variableArgs: !1
            },
            y: {
                id: vA,
                numArgs: 4,
                variableArgs: !1
            },
            h: {
                id: KA,
                numArgs: 0,
                variableArgs: !1
            },
            re: {
                id: TA,
                numArgs: 4,
                variableArgs: !1
            },
            S: {
                id: qA,
                numArgs: 0,
                variableArgs: !1
            },
            s: {
                id: OA,
                numArgs: 0,
                variableArgs: !1
            },
            f: {
                id: PA,
                numArgs: 0,
                variableArgs: !1
            },
            F: {
                id: PA,
                numArgs: 0,
                variableArgs: !1
            },
            "f*": {
                id: WA,
                numArgs: 0,
                variableArgs: !1
            },
            B: {
                id: jA,
                numArgs: 0,
                variableArgs: !1
            },
            "B*": {
                id: XA,
                numArgs: 0,
                variableArgs: !1
            },
            b: {
                id: ZA,
                numArgs: 0,
                variableArgs: !1
            },
            "b*": {
                id: VA,
                numArgs: 0,
                variableArgs: !1
            },
            n: {
                id: zA,
                numArgs: 0,
                variableArgs: !1
            },
            W: {
                id: _A,
                numArgs: 0,
                variableArgs: !1
            },
            "W*": {
                id: $A,
                numArgs: 0,
                variableArgs: !1
            },
            BT: {
                id: Ae,
                numArgs: 0,
                variableArgs: !1
            },
            ET: {
                id: ee,
                numArgs: 0,
                variableArgs: !1
            },
            Tc: {
                id: te,
                numArgs: 1,
                variableArgs: !1
            },
            Tw: {
                id: ie,
                numArgs: 1,
                variableArgs: !1
            },
            Tz: {
                id: ae,
                numArgs: 1,
                variableArgs: !1
            },
            TL: {
                id: se,
                numArgs: 1,
                variableArgs: !1
            },
            Tf: {
                id: re,
                numArgs: 2,
                variableArgs: !1
            },
            Tr: {
                id: ne,
                numArgs: 1,
                variableArgs: !1
            },
            Ts: {
                id: ge,
                numArgs: 1,
                variableArgs: !1
            },
            Td: {
                id: oe,
                numArgs: 2,
                variableArgs: !1
            },
            TD: {
                id: Ie,
                numArgs: 2,
                variableArgs: !1
            },
            Tm: {
                id: ce,
                numArgs: 6,
                variableArgs: !1
            },
            "T*": {
                id: Ce,
                numArgs: 0,
                variableArgs: !1
            },
            Tj: {
                id: he,
                numArgs: 1,
                variableArgs: !1
            },
            TJ: {
                id: le,
                numArgs: 1,
                variableArgs: !1
            },
            "'": {
                id: Be,
                numArgs: 1,
                variableArgs: !1
            },
            '"': {
                id: Qe,
                numArgs: 3,
                variableArgs: !1
            },
            d0: {
                id: Ee,
                numArgs: 2,
                variableArgs: !1
            },
            d1: {
                id: ue,
                numArgs: 6,
                variableArgs: !1
            },
            CS: {
                id: de,
                numArgs: 1,
                variableArgs: !1
            },
            cs: {
                id: fe,
                numArgs: 1,
                variableArgs: !1
            },
            SC: {
                id: pe,
                numArgs: 4,
                variableArgs: !0
            },
            SCN: {
                id: me,
                numArgs: 33,
                variableArgs: !0
            },
            sc: {
                id: ye,
                numArgs: 4,
                variableArgs: !0
            },
            scn: {
                id: we,
                numArgs: 33,
                variableArgs: !0
            },
            G: {
                id: De,
                numArgs: 1,
                variableArgs: !1
            },
            g: {
                id: be,
                numArgs: 1,
                variableArgs: !1
            },
            RG: {
                id: Fe,
                numArgs: 3,
                variableArgs: !1
            },
            rg: {
                id: Se,
                numArgs: 3,
                variableArgs: !1
            },
            K: {
                id: ke,
                numArgs: 4,
                variableArgs: !1
            },
            k: {
                id: Re,
                numArgs: 4,
                variableArgs: !1
            },
            sh: {
                id: Ne,
                numArgs: 1,
                variableArgs: !1
            },
            BI: {
                id: Ge,
                numArgs: 0,
                variableArgs: !1
            },
            ID: {
                id: Me,
                numArgs: 0,
                variableArgs: !1
            },
            EI: {
                id: Ue,
                numArgs: 1,
                variableArgs: !1
            },
            Do: {
                id: xe,
                numArgs: 1,
                variableArgs: !1
            },
            MP: {
                id: Le,
                numArgs: 1,
                variableArgs: !1
            },
            DP: {
                id: He,
                numArgs: 2,
                variableArgs: !1
            },
            BMC: {
                id: Je,
                numArgs: 1,
                variableArgs: !1
            },
            BDC: {
                id: Ye,
                numArgs: 2,
                variableArgs: !1
            },
            EMC: {
                id: ve,
                numArgs: 0,
                variableArgs: !1
            },
            BX: {
                id: Ke,
                numArgs: 0,
                variableArgs: !1
            },
            EX: {
                id: Te,
                numArgs: 0,
                variableArgs: !1
            },
            BM: null,
            BD: null,
            true: null,
            fa: null,
            fal: null,
            fals: null,
            false: null,
            nu: null,
            nul: null,
            null: null
        }));
    }
    static MAX_INVALID_PATH_OPS = 10;
    constructor(e1, t, i = new StateManager){
        this.parser = new Parser({
            lexer: new Lexer(e1, EvaluatorPreprocessor.opMap),
            xref: t
        });
        this.stateManager = i;
        this.nonProcessedArgs = [];
        this._isPathOp = !1;
        this._numInvalidPathOPS = 0;
    }
    get savedStatesDepth() {
        return this.stateManager.stateStack.length;
    }
    read(e1) {
        let t = e1.args;
        for(;;){
            const i = this.parser.getObj();
            if (i instanceof Cmd) {
                const a = i.cmd, s = EvaluatorPreprocessor.opMap[a];
                if (!s) {
                    warn(`Unknown command "${a}".`);
                    continue;
                }
                const r = s.id, n = s.numArgs;
                let g = null !== t ? t.length : 0;
                this._isPathOp || (this._numInvalidPathOPS = 0);
                this._isPathOp = r >= LA && r <= zA;
                if (s.variableArgs) g > n && info(`Command ${a}: expected [0, ${n}] args, but received ${g} args.`);
                else {
                    if (g !== n) {
                        const e1 = this.nonProcessedArgs;
                        for(; g > n;){
                            e1.push(t.shift());
                            g--;
                        }
                        for(; g < n && 0 !== e1.length;){
                            null === t && (t = []);
                            t.unshift(e1.pop());
                            g++;
                        }
                    }
                    if (g < n) {
                        const e1 = `command ${a}: expected ${n} args, but received ${g} args.`;
                        if (this._isPathOp && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) throw new FormatError(`Invalid ${e1}`);
                        warn(`Skipping ${e1}`);
                        null !== t && (t.length = 0);
                        continue;
                    }
                }
                this.preprocessCommand(r, t);
                e1.fn = r;
                e1.args = t;
                return !0;
            }
            if (i === Bt) return !1;
            if (null !== i) {
                null === t && (t = []);
                t.push(i);
                if (t.length > 33) throw new FormatError("Too many arguments");
            }
        }
    }
    preprocessCommand(e1, t) {
        switch(0 | e1){
            case MA:
                this.stateManager.save();
                break;
            case UA:
                this.stateManager.restore();
                break;
            case xA:
                this.stateManager.transform(t);
        }
    }
}
class DefaultAppearanceEvaluator extends EvaluatorPreprocessor {
    constructor(e1){
        super(new StringStream(e1));
    }
    parse() {
        const e1 = {
            fn: 0,
            args: []
        }, t = {
            fontSize: 0,
            fontName: "",
            fontColor: new Uint8ClampedArray(3)
        };
        try {
            for(;;){
                e1.args.length = 0;
                if (!this.read(e1)) break;
                if (0 !== this.savedStatesDepth) continue;
                const { fn: i, args: a } = e1;
                switch(0 | i){
                    case re:
                        const [e2, i1] = a;
                        e2 instanceof Name && (t.fontName = e2.name);
                        "number" == typeof i1 && i1 > 0 && (t.fontSize = i1);
                        break;
                    case Se:
                        ColorSpace.singletons.rgb.getRgbItem(a, 0, t.fontColor, 0);
                        break;
                    case be:
                        ColorSpace.singletons.gray.getRgbItem(a, 0, t.fontColor, 0);
                        break;
                    case Re:
                        ColorSpace.singletons.cmyk.getRgbItem(a, 0, t.fontColor, 0);
                }
            }
        } catch (e1) {
            warn(`parseDefaultAppearance - ignoring errors: "${e1}".`);
        }
        return t;
    }
}
function parseDefaultAppearance(e1) {
    return new DefaultAppearanceEvaluator(e1).parse();
}
class AppearanceStreamEvaluator extends EvaluatorPreprocessor {
    constructor(e1, t, i){
        super(e1);
        this.stream = e1;
        this.evaluatorOptions = t;
        this.xref = i;
        this.resources = e1.dict?.get("Resources");
    }
    parse() {
        const e1 = {
            fn: 0,
            args: []
        };
        let t = {
            scaleFactor: 1,
            fontSize: 0,
            fontName: "",
            fontColor: new Uint8ClampedArray(3),
            fillColorSpace: ColorSpace.singletons.gray
        }, i = !1;
        const a = [];
        try {
            for(;;){
                e1.args.length = 0;
                if (i || !this.read(e1)) break;
                const { fn: s, args: r } = e1;
                switch(0 | s){
                    case MA:
                        a.push({
                            scaleFactor: t.scaleFactor,
                            fontSize: t.fontSize,
                            fontName: t.fontName,
                            fontColor: t.fontColor.slice(),
                            fillColorSpace: t.fillColorSpace
                        });
                        break;
                    case UA:
                        t = a.pop() || t;
                        break;
                    case ce:
                        t.scaleFactor *= Math.hypot(r[0], r[1]);
                        break;
                    case re:
                        const [e2, s1] = r;
                        e2 instanceof Name && (t.fontName = e2.name);
                        "number" == typeof s1 && s1 > 0 && (t.fontSize = s1 * t.scaleFactor);
                        break;
                    case fe:
                        t.fillColorSpace = ColorSpace.parse({
                            cs: r[0],
                            xref: this.xref,
                            resources: this.resources,
                            pdfFunctionFactory: this._pdfFunctionFactory,
                            localColorSpaceCache: this._localColorSpaceCache
                        });
                        break;
                    case ye:
                        t.fillColorSpace.getRgbItem(r, 0, t.fontColor, 0);
                        break;
                    case Se:
                        ColorSpace.singletons.rgb.getRgbItem(r, 0, t.fontColor, 0);
                        break;
                    case be:
                        ColorSpace.singletons.gray.getRgbItem(r, 0, t.fontColor, 0);
                        break;
                    case Re:
                        ColorSpace.singletons.cmyk.getRgbItem(r, 0, t.fontColor, 0);
                        break;
                    case he:
                    case le:
                    case Be:
                    case Qe:
                        i = !0;
                }
            }
        } catch (e1) {
            warn(`parseAppearanceStream - ignoring errors: "${e1}".`);
        }
        this.stream.reset();
        delete t.scaleFactor;
        delete t.fillColorSpace;
        return t;
    }
    get _localColorSpaceCache() {
        return shadow(this, "_localColorSpaceCache", new LocalColorSpaceCache);
    }
    get _pdfFunctionFactory() {
        return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({
            xref: this.xref,
            isEvalSupported: this.evaluatorOptions.isEvalSupported
        }));
    }
}
function getPdfColor(e1, t) {
    if (e1[0] === e1[1] && e1[1] === e1[2]) {
        return `${numberToString(e1[0] / 255)} ${t ? "g" : "G"}`;
    }
    return Array.from(e1, (e1)=>numberToString(e1 / 255)).join(" ") + " " + (t ? "rg" : "RG");
}
class FakeUnicodeFont {
    constructor(e1, t){
        this.xref = e1;
        this.widths = null;
        this.firstChar = 1 / 0;
        this.lastChar = -1 / 0;
        this.fontFamily = t;
        const i = new OffscreenCanvas(1, 1);
        this.ctxMeasure = i.getContext("2d", {
            willReadFrequently: !0
        });
        FakeUnicodeFont._fontNameId || (FakeUnicodeFont._fontNameId = 1);
        this.fontName = Name.get(`InvalidPDFjsFont_${t}_${FakeUnicodeFont._fontNameId++}`);
    }
    get fontDescriptorRef() {
        if (!FakeUnicodeFont._fontDescriptorRef) {
            const e1 = new Dict(this.xref);
            e1.set("Type", Name.get("FontDescriptor"));
            e1.set("FontName", this.fontName);
            e1.set("FontFamily", "MyriadPro Regular");
            e1.set("FontBBox", [
                0,
                0,
                0,
                0
            ]);
            e1.set("FontStretch", Name.get("Normal"));
            e1.set("FontWeight", 400);
            e1.set("ItalicAngle", 0);
            FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e1);
        }
        return FakeUnicodeFont._fontDescriptorRef;
    }
    get descendantFontRef() {
        const e1 = new Dict(this.xref);
        e1.set("BaseFont", this.fontName);
        e1.set("Type", Name.get("Font"));
        e1.set("Subtype", Name.get("CIDFontType0"));
        e1.set("CIDToGIDMap", Name.get("Identity"));
        e1.set("FirstChar", this.firstChar);
        e1.set("LastChar", this.lastChar);
        e1.set("FontDescriptor", this.fontDescriptorRef);
        e1.set("DW", 1e3);
        const t = [], i = [
            ...this.widths.entries()
        ].sort();
        let a = null, s = null;
        for (const [e1, r] of i)if (a) if (e1 === a + s.length) s.push(r);
        else {
            t.push(a, s);
            a = e1;
            s = [
                r
            ];
        }
        else {
            a = e1;
            s = [
                r
            ];
        }
        a && t.push(a, s);
        e1.set("W", t);
        const r = new Dict(this.xref);
        r.set("Ordering", "Identity");
        r.set("Registry", "Adobe");
        r.set("Supplement", 0);
        e1.set("CIDSystemInfo", r);
        return this.xref.getNewPersistentRef(e1);
    }
    get baseFontRef() {
        const e1 = new Dict(this.xref);
        e1.set("BaseFont", this.fontName);
        e1.set("Type", Name.get("Font"));
        e1.set("Subtype", Name.get("Type0"));
        e1.set("Encoding", Name.get("Identity-H"));
        e1.set("DescendantFonts", [
            this.descendantFontRef
        ]);
        e1.set("ToUnicode", Name.get("Identity-H"));
        return this.xref.getNewPersistentRef(e1);
    }
    get resources() {
        const e1 = new Dict(this.xref), t = new Dict(this.xref);
        t.set(this.fontName.name, this.baseFontRef);
        e1.set("Font", t);
        return e1;
    }
    _createContext() {
        this.widths = new Map;
        this.ctxMeasure.font = `1000px ${this.fontFamily}`;
        return this.ctxMeasure;
    }
    createFontResources(e1) {
        const t = this._createContext();
        for (const i of e1.split(/\r\n?|\n/))for (const e1 of i.split("")){
            const i = e1.charCodeAt(0);
            if (this.widths.has(i)) continue;
            const a = t.measureText(e1), s = Math.ceil(a.width);
            this.widths.set(i, s);
            this.firstChar = Math.min(i, this.firstChar);
            this.lastChar = Math.max(i, this.lastChar);
        }
        return this.resources;
    }
    static getFirstPositionInfo(e1, t, i) {
        const [a, n, g, o] = e1;
        let c = g - a, C = o - n;
        t % 180 != 0 && ([c, C] = [
            C,
            c
        ]);
        const h = s * i;
        return {
            coords: [
                0,
                C + r * i - h
            ],
            bbox: [
                0,
                0,
                c,
                C
            ],
            matrix: 0 !== t ? getRotationMatrix(t, C, h) : void 0
        };
    }
    createAppearance(e1, t, i, a, n, g) {
        const o = this._createContext(), c = [];
        let C = -1 / 0;
        for (const t of e1.split(/\r\n?|\n/)){
            c.push(t);
            const e1 = o.measureText(t).width;
            C = Math.max(C, e1);
            for (const e1 of codePointIter(t)){
                const t = String.fromCodePoint(e1);
                let i = this.widths.get(e1);
                if (void 0 === i) {
                    const a = o.measureText(t);
                    i = Math.ceil(a.width);
                    this.widths.set(e1, i);
                    this.firstChar = Math.min(e1, this.firstChar);
                    this.lastChar = Math.max(e1, this.lastChar);
                }
            }
        }
        C *= a / 1e3;
        const [h, l, Q, E] = t;
        let u = Q - h, d = E - l;
        i % 180 != 0 && ([u, d] = [
            d,
            u
        ]);
        let f = 1;
        C > u && (f = u / C);
        let p = 1;
        const m = s * a, y = r * a, w = m * c.length;
        w > d && (p = d / w);
        const D = a * Math.min(f, p), b = [
            "q",
            `0 0 ${numberToString(u)} ${numberToString(d)} re W n`,
            "BT",
            `1 0 0 1 0 ${numberToString(d + y)} Tm 0 Tc ${getPdfColor(n, !0)}`,
            `/${this.fontName.name} ${numberToString(D)} Tf`
        ], { resources: F } = this;
        if (1 !== (g = "number" == typeof g && g >= 0 && g <= 1 ? g : 1)) {
            b.push("/R0 gs");
            const e1 = new Dict(this.xref), t = new Dict(this.xref);
            t.set("ca", g);
            t.set("CA", g);
            t.set("Type", Name.get("ExtGState"));
            e1.set("R0", t);
            F.set("ExtGState", e1);
        }
        const S = numberToString(m);
        for (const e1 of c)b.push(`0 -${S} Td <${stringToUTF16HexString(e1)}> Tj`);
        b.push("ET", "Q");
        const k = b.join("\n"), R = new Dict(this.xref);
        R.set("Subtype", Name.get("Form"));
        R.set("Type", Name.get("XObject"));
        R.set("BBox", [
            0,
            0,
            u,
            d
        ]);
        R.set("Length", k.length);
        R.set("Resources", F);
        if (i) {
            const e1 = getRotationMatrix(i, u, d);
            R.set("Matrix", e1);
        }
        const N = new StringStream(k);
        N.dict = R;
        return N;
    }
}
class NameOrNumberTree {
    constructor(e1, t, i){
        this.root = e1;
        this.xref = t;
        this._type = i;
    }
    getAll() {
        const e1 = new Map;
        if (!this.root) return e1;
        const t = this.xref, i = new RefSet;
        i.put(this.root);
        const a = [
            this.root
        ];
        for(; a.length > 0;){
            const s = t.fetchIfRef(a.shift());
            if (!(s instanceof Dict)) continue;
            if (s.has("Kids")) {
                const e1 = s.get("Kids");
                if (!Array.isArray(e1)) continue;
                for (const t of e1){
                    if (i.has(t)) throw new FormatError(`Duplicate entry in "${this._type}" tree.`);
                    a.push(t);
                    i.put(t);
                }
                continue;
            }
            const r = s.get(this._type);
            if (Array.isArray(r)) for(let i = 0, a = r.length; i < a; i += 2)e1.set(t.fetchIfRef(r[i]), t.fetchIfRef(r[i + 1]));
        }
        return e1;
    }
    getRaw(e1) {
        if (!this.root) return null;
        const t = this.xref;
        let i = t.fetchIfRef(this.root), a = 0;
        for(; i.has("Kids");){
            if (++a > 10) {
                warn(`Search depth limit reached for "${this._type}" tree.`);
                return null;
            }
            const s = i.get("Kids");
            if (!Array.isArray(s)) return null;
            let r = 0, n = s.length - 1;
            for(; r <= n;){
                const a = r + n >> 1, g = t.fetchIfRef(s[a]), o = g.get("Limits");
                if (e1 < t.fetchIfRef(o[0])) n = a - 1;
                else {
                    if (!(e1 > t.fetchIfRef(o[1]))) {
                        i = g;
                        break;
                    }
                    r = a + 1;
                }
            }
            if (r > n) return null;
        }
        const s = i.get(this._type);
        if (Array.isArray(s)) {
            let i = 0, a = s.length - 2;
            for(; i <= a;){
                const r = i + a >> 1, n = r + (1 & r), g = t.fetchIfRef(s[n]);
                if (e1 < g) a = n - 2;
                else {
                    if (!(e1 > g)) return s[n + 1];
                    i = n + 2;
                }
            }
        }
        return null;
    }
    get(e1) {
        return this.xref.fetchIfRef(this.getRaw(e1));
    }
}
class NameTree extends NameOrNumberTree {
    constructor(e1, t){
        super(e1, t, "Names");
    }
}
class NumberTree extends NameOrNumberTree {
    constructor(e1, t){
        super(e1, t, "Nums");
    }
}
function clearGlobalCaches() {
    !function clearPatternCaches() {
        Qa = Object.create(null);
    }();
    !function clearPrimitiveCaches() {
        Qt = Object.create(null);
        Et = Object.create(null);
        ut = Object.create(null);
    }();
    !function clearUnicodeCaches() {
        ki.clear();
    }();
    JpxImage.cleanup();
}
function pickPlatformItem(e1) {
    return e1 instanceof Dict ? e1.has("UF") ? e1.get("UF") : e1.has("F") ? e1.get("F") : e1.has("Unix") ? e1.get("Unix") : e1.has("Mac") ? e1.get("Mac") : e1.has("DOS") ? e1.get("DOS") : null : null;
}
class FileSpec {
    #U = !1;
    constructor(e1, t, i = !1){
        if (e1 instanceof Dict) {
            this.xref = t;
            this.root = e1;
            e1.has("FS") && (this.fs = e1.get("FS"));
            e1.has("RF") && warn("Related file specifications are not supported");
            i || (e1.has("EF") ? this.#U = !0 : warn("Non-embedded file specifications are not supported"));
        }
    }
    get filename() {
        let e1 = "";
        const t = pickPlatformItem(this.root);
        t && "string" == typeof t && (e1 = stringToPDFString(t).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/"));
        return shadow(this, "filename", e1 || "unnamed");
    }
    get content() {
        if (!this.#U) return null;
        this._contentRef ||= pickPlatformItem(this.root?.get("EF"));
        let e1 = null;
        if (this._contentRef) {
            const t = this.xref.fetchIfRef(this._contentRef);
            t instanceof BaseStream ? e1 = t.getBytes() : warn("Embedded file specification points to non-existing/invalid content");
        } else warn("Embedded file specification does not have any content");
        return e1;
    }
    get description() {
        let e1 = "";
        const t = this.root?.get("Desc");
        t && "string" == typeof t && (e1 = stringToPDFString(t));
        return shadow(this, "description", e1);
    }
    get serializable() {
        return {
            rawFilename: this.filename,
            filename: (e1 = this.filename, e1.substring(e1.lastIndexOf("/") + 1)),
            content: this.content,
            description: this.description
        };
        "TURBOPACK unreachable";
        var e1;
    }
}
const ys = 0, ws = -2, Ds = -3, bs = -4, Fs = -5, Ss = -6, ks = -9;
function isWhitespace(e1, t) {
    const i = e1[t];
    return " " === i || "\n" === i || "\r" === i || "\t" === i;
}
class XMLParserBase {
    _resolveEntities(e1) {
        return e1.replaceAll(/&([^;]+);/g, (e1, t)=>{
            if ("#x" === t.substring(0, 2)) return String.fromCodePoint(parseInt(t.substring(2), 16));
            if ("#" === t.substring(0, 1)) return String.fromCodePoint(parseInt(t.substring(1), 10));
            switch(t){
                case "lt":
                    return "<";
                case "gt":
                    return ">";
                case "amp":
                    return "&";
                case "quot":
                    return '"';
                case "apos":
                    return "'";
            }
            return this.onResolveEntity(t);
        });
    }
    _parseContent(e1, t) {
        const i = [];
        let a = t;
        function skipWs() {
            for(; a < e1.length && isWhitespace(e1, a);)++a;
        }
        for(; a < e1.length && !isWhitespace(e1, a) && ">" !== e1[a] && "/" !== e1[a];)++a;
        const s = e1.substring(t, a);
        skipWs();
        for(; a < e1.length && ">" !== e1[a] && "/" !== e1[a] && "?" !== e1[a];){
            skipWs();
            let t = "", s = "";
            for(; a < e1.length && !isWhitespace(e1, a) && "=" !== e1[a];){
                t += e1[a];
                ++a;
            }
            skipWs();
            if ("=" !== e1[a]) return null;
            ++a;
            skipWs();
            const r = e1[a];
            if ('"' !== r && "'" !== r) return null;
            const n = e1.indexOf(r, ++a);
            if (n < 0) return null;
            s = e1.substring(a, n);
            i.push({
                name: t,
                value: this._resolveEntities(s)
            });
            a = n + 1;
            skipWs();
        }
        return {
            name: s,
            attributes: i,
            parsed: a - t
        };
    }
    _parseProcessingInstruction(e1, t) {
        let i = t;
        for(; i < e1.length && !isWhitespace(e1, i) && ">" !== e1[i] && "?" !== e1[i] && "/" !== e1[i];)++i;
        const a = e1.substring(t, i);
        !function skipWs() {
            for(; i < e1.length && isWhitespace(e1, i);)++i;
        }();
        const s = i;
        for(; i < e1.length && ("?" !== e1[i] || ">" !== e1[i + 1]);)++i;
        return {
            name: a,
            value: e1.substring(s, i),
            parsed: i - t
        };
    }
    parseXml(e1) {
        let t = 0;
        for(; t < e1.length;){
            let i = t;
            if ("<" === e1[t]) {
                ++i;
                let t;
                switch(e1[i]){
                    case "/":
                        ++i;
                        t = e1.indexOf(">", i);
                        if (t < 0) {
                            this.onError(ks);
                            return;
                        }
                        this.onEndElement(e1.substring(i, t));
                        i = t + 1;
                        break;
                    case "?":
                        ++i;
                        const a = this._parseProcessingInstruction(e1, i);
                        if ("?>" !== e1.substring(i + a.parsed, i + a.parsed + 2)) {
                            this.onError(Ds);
                            return;
                        }
                        this.onPi(a.name, a.value);
                        i += a.parsed + 2;
                        break;
                    case "!":
                        if ("--" === e1.substring(i + 1, i + 3)) {
                            t = e1.indexOf("--\x3e", i + 3);
                            if (t < 0) {
                                this.onError(Fs);
                                return;
                            }
                            this.onComment(e1.substring(i + 3, t));
                            i = t + 3;
                        } else if ("[CDATA[" === e1.substring(i + 1, i + 8)) {
                            t = e1.indexOf("]]>", i + 8);
                            if (t < 0) {
                                this.onError(ws);
                                return;
                            }
                            this.onCdata(e1.substring(i + 8, t));
                            i = t + 3;
                        } else {
                            if ("DOCTYPE" !== e1.substring(i + 1, i + 8)) {
                                this.onError(Ss);
                                return;
                            }
                            {
                                const a = e1.indexOf("[", i + 8);
                                let s = !1;
                                t = e1.indexOf(">", i + 8);
                                if (t < 0) {
                                    this.onError(bs);
                                    return;
                                }
                                if (a > 0 && t > a) {
                                    t = e1.indexOf("]>", i + 8);
                                    if (t < 0) {
                                        this.onError(bs);
                                        return;
                                    }
                                    s = !0;
                                }
                                const r = e1.substring(i + 8, t + (s ? 1 : 0));
                                this.onDoctype(r);
                                i = t + (s ? 2 : 1);
                            }
                        }
                        break;
                    default:
                        const s = this._parseContent(e1, i);
                        if (null === s) {
                            this.onError(Ss);
                            return;
                        }
                        let r = !1;
                        if ("/>" === e1.substring(i + s.parsed, i + s.parsed + 2)) r = !0;
                        else if (">" !== e1.substring(i + s.parsed, i + s.parsed + 1)) {
                            this.onError(ks);
                            return;
                        }
                        this.onBeginElement(s.name, s.attributes, r);
                        i += s.parsed + (r ? 2 : 1);
                }
            } else {
                for(; i < e1.length && "<" !== e1[i];)i++;
                const a = e1.substring(t, i);
                this.onText(this._resolveEntities(a));
            }
            t = i;
        }
    }
    onResolveEntity(e1) {
        return `&${e1};`;
    }
    onPi(e1, t) {}
    onComment(e1) {}
    onCdata(e1) {}
    onDoctype(e1) {}
    onText(e1) {}
    onBeginElement(e1, t, i) {}
    onEndElement(e1) {}
    onError(e1) {}
}
class SimpleDOMNode {
    constructor(e1, t){
        this.nodeName = e1;
        this.nodeValue = t;
        Object.defineProperty(this, "parentNode", {
            value: null,
            writable: !0
        });
    }
    get firstChild() {
        return this.childNodes?.[0];
    }
    get nextSibling() {
        const e1 = this.parentNode.childNodes;
        if (!e1) return;
        const t = e1.indexOf(this);
        return -1 !== t ? e1[t + 1] : void 0;
    }
    get textContent() {
        return this.childNodes ? this.childNodes.map(function(e1) {
            return e1.textContent;
        }).join("") : this.nodeValue || "";
    }
    get children() {
        return this.childNodes || [];
    }
    hasChildNodes() {
        return this.childNodes?.length > 0;
    }
    searchNode(e1, t) {
        if (t >= e1.length) return this;
        const i = e1[t];
        if (i.name.startsWith("#") && t < e1.length - 1) return this.searchNode(e1, t + 1);
        const a = [];
        let s = this;
        for(;;){
            if (i.name === s.nodeName) {
                if (0 !== i.pos) {
                    if (0 === a.length) return null;
                    {
                        const [r] = a.pop();
                        let n = 0;
                        for (const a of r.childNodes)if (i.name === a.nodeName) {
                            if (n === i.pos) return a.searchNode(e1, t + 1);
                            n++;
                        }
                        return s.searchNode(e1, t + 1);
                    }
                }
                {
                    const i = s.searchNode(e1, t + 1);
                    if (null !== i) return i;
                }
            }
            if (s.childNodes?.length > 0) {
                a.push([
                    s,
                    0
                ]);
                s = s.childNodes[0];
            } else {
                if (0 === a.length) return null;
                for(; 0 !== a.length;){
                    const [e1, t] = a.pop(), i = t + 1;
                    if (i < e1.childNodes.length) {
                        a.push([
                            e1,
                            i
                        ]);
                        s = e1.childNodes[i];
                        break;
                    }
                }
                if (0 === a.length) return null;
            }
        }
    }
    dump(e1) {
        if ("#text" !== this.nodeName) {
            e1.push(`<${this.nodeName}`);
            if (this.attributes) for (const t of this.attributes)e1.push(` ${t.name}="${encodeToXmlString(t.value)}"`);
            if (this.hasChildNodes()) {
                e1.push(">");
                for (const t of this.childNodes)t.dump(e1);
                e1.push(`</${this.nodeName}>`);
            } else this.nodeValue ? e1.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e1.push("/>");
        } else e1.push(encodeToXmlString(this.nodeValue));
    }
}
class SimpleXMLParser extends XMLParserBase {
    constructor({ hasAttributes: e1 = !1, lowerCaseName: t = !1 }){
        super();
        this._currentFragment = null;
        this._stack = null;
        this._errorCode = ys;
        this._hasAttributes = e1;
        this._lowerCaseName = t;
    }
    parseFromString(e1) {
        this._currentFragment = [];
        this._stack = [];
        this._errorCode = ys;
        this.parseXml(e1);
        if (this._errorCode !== ys) return;
        const [t] = this._currentFragment;
        return t ? {
            documentElement: t
        } : void 0;
    }
    onText(e1) {
        if (function isWhitespaceString(e1) {
            for(let t = 0, i = e1.length; t < i; t++)if (!isWhitespace(e1, t)) return !1;
            return !0;
        }(e1)) return;
        const t = new SimpleDOMNode("#text", e1);
        this._currentFragment.push(t);
    }
    onCdata(e1) {
        const t = new SimpleDOMNode("#text", e1);
        this._currentFragment.push(t);
    }
    onBeginElement(e1, t, i) {
        this._lowerCaseName && (e1 = e1.toLowerCase());
        const a = new SimpleDOMNode(e1);
        a.childNodes = [];
        this._hasAttributes && (a.attributes = t);
        this._currentFragment.push(a);
        if (!i) {
            this._stack.push(this._currentFragment);
            this._currentFragment = a.childNodes;
        }
    }
    onEndElement(e1) {
        this._currentFragment = this._stack.pop() || [];
        const t = this._currentFragment.at(-1);
        if (!t) return null;
        for (const e1 of t.childNodes)e1.parentNode = t;
        return t;
    }
    onError(e1) {
        this._errorCode = e1;
    }
}
class MetadataParser {
    constructor(e1){
        e1 = this._repair(e1);
        const t = new SimpleXMLParser({
            lowerCaseName: !0
        }).parseFromString(e1);
        this._metadataMap = new Map;
        this._data = e1;
        t && this._parse(t);
    }
    _repair(e1) {
        return e1.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e1, t) {
            const i = t.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e1, t, i, a) {
                return String.fromCharCode(64 * t + 8 * i + 1 * a);
            }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e1, t) {
                switch(t){
                    case "amp":
                        return "&";
                    case "apos":
                        return "'";
                    case "gt":
                        return ">";
                    case "lt":
                        return "<";
                    case "quot":
                        return '"';
                }
                throw new Error(`_repair: ${t} isn't defined.`);
            }), a = [
                ">"
            ];
            for(let e1 = 0, t = i.length; e1 < t; e1 += 2){
                const t = 256 * i.charCodeAt(e1) + i.charCodeAt(e1 + 1);
                t >= 32 && t < 127 && 60 !== t && 62 !== t && 38 !== t ? a.push(String.fromCharCode(t)) : a.push("&#x" + (65536 + t).toString(16).substring(1) + ";");
            }
            return a.join("");
        });
    }
    _getSequence(e1) {
        const t = e1.nodeName;
        return "rdf:bag" !== t && "rdf:seq" !== t && "rdf:alt" !== t ? null : e1.childNodes.filter((e1)=>"rdf:li" === e1.nodeName);
    }
    _parseArray(e1) {
        if (!e1.hasChildNodes()) return;
        const [t] = e1.childNodes, i = this._getSequence(t) || [];
        this._metadataMap.set(e1.nodeName, i.map((e1)=>e1.textContent.trim()));
    }
    _parse(e1) {
        let t = e1.documentElement;
        if ("rdf:rdf" !== t.nodeName) {
            t = t.firstChild;
            for(; t && "rdf:rdf" !== t.nodeName;)t = t.nextSibling;
        }
        if (t && "rdf:rdf" === t.nodeName && t.hasChildNodes()) {
            for (const e1 of t.childNodes)if ("rdf:description" === e1.nodeName) for (const t of e1.childNodes){
                const e1 = t.nodeName;
                switch(e1){
                    case "#text":
                        continue;
                    case "dc:creator":
                    case "dc:subject":
                        this._parseArray(t);
                        continue;
                }
                this._metadataMap.set(e1, t.textContent.trim());
            }
        }
    }
    get serializable() {
        return {
            parsedData: this._metadataMap,
            rawData: this._data
        };
    }
}
const Rs = 1, Ns = 2, Gs = 3, Ms = 4, Us = 5;
class StructTreeRoot {
    constructor(e1, t){
        this.dict = e1;
        this.ref = t instanceof Ref ? t : null;
        this.roleMap = new Map;
        this.structParentIds = null;
    }
    init() {
        this.readRoleMap();
    }
    #x(e1, t, i) {
        if (!(e1 instanceof Ref) || t < 0) return;
        this.structParentIds ||= new RefSetCache;
        let a = this.structParentIds.get(e1);
        if (!a) {
            a = [];
            this.structParentIds.put(e1, a);
        }
        a.push([
            t,
            i
        ]);
    }
    addAnnotationIdToPage(e1, t) {
        this.#x(e1, t, Ms);
    }
    readRoleMap() {
        const e1 = this.dict.get("RoleMap");
        if (e1 instanceof Dict) for (const [t, i] of e1)i instanceof Name && this.roleMap.set(t, i.name);
    }
    static async canCreateStructureTree({ catalogRef: e1, pdfManager: t, newAnnotationsByPage: i }) {
        if (!(e1 instanceof Ref)) {
            warn("Cannot save the struct tree: no catalog reference.");
            return !1;
        }
        let a = 0, s = !0;
        for (const [e1, r] of i){
            const { ref: i } = await t.getPage(e1);
            if (!(i instanceof Ref)) {
                warn(`Cannot save the struct tree: page ${e1} has no ref.`);
                s = !0;
                break;
            }
            for (const e1 of r)if (e1.accessibilityData?.type) {
                e1.parentTreeId = a++;
                s = !1;
            }
        }
        if (s) {
            for (const e1 of i.values())for (const t of e1)delete t.parentTreeId;
            return !1;
        }
        return !0;
    }
    static async createStructureTree({ newAnnotationsByPage: e1, xref: t, catalogRef: i, pdfManager: a, changes: s }) {
        const r = a.catalog.cloneDict(), n = new RefSetCache;
        n.put(i, r);
        const g = t.getNewTemporaryRef();
        r.set("StructTreeRoot", g);
        const o = new Dict(t);
        o.set("Type", Name.get("StructTreeRoot"));
        const c = t.getNewTemporaryRef();
        o.set("ParentTree", c);
        const C = [];
        o.set("K", C);
        n.put(g, o);
        const h = new Dict(t), l = [];
        h.set("Nums", l);
        const Q = await this.#L({
            newAnnotationsByPage: e1,
            structTreeRootRef: g,
            structTreeRoot: null,
            kids: C,
            nums: l,
            xref: t,
            pdfManager: a,
            changes: s,
            cache: n
        });
        o.set("ParentTreeNextKey", Q);
        n.put(c, h);
        for (const [e1, t] of n.items())s.put(e1, {
            data: t
        });
    }
    async canUpdateStructTree({ pdfManager: e1, xref: t, newAnnotationsByPage: i }) {
        if (!this.ref) {
            warn("Cannot update the struct tree: no root reference.");
            return !1;
        }
        let a = this.dict.get("ParentTreeNextKey");
        if (!Number.isInteger(a) || a < 0) {
            warn("Cannot update the struct tree: invalid next key.");
            return !1;
        }
        const s = this.dict.get("ParentTree");
        if (!(s instanceof Dict)) {
            warn("Cannot update the struct tree: ParentTree isn't a dict.");
            return !1;
        }
        const r = s.get("Nums");
        if (!Array.isArray(r)) {
            warn("Cannot update the struct tree: nums isn't an array.");
            return !1;
        }
        const n = new NumberTree(s, t);
        for (const t of i.keys()){
            const { pageDict: i } = await e1.getPage(t);
            if (!i.has("StructParents")) continue;
            const a = i.get("StructParents");
            if (!Number.isInteger(a) || !Array.isArray(n.get(a))) {
                warn(`Cannot save the struct tree: page ${t} has a wrong id.`);
                return !1;
            }
        }
        let g = !0;
        for (const [t, s] of i){
            const { pageDict: i } = await e1.getPage(t);
            StructTreeRoot.#H({
                elements: s,
                xref: this.dict.xref,
                pageDict: i,
                numberTree: n
            });
            for (const e1 of s)if (e1.accessibilityData?.type) {
                e1.accessibilityData.structParent >= 0 || (e1.parentTreeId = a++);
                g = !1;
            }
        }
        if (g) {
            for (const e1 of i.values())for (const t of e1){
                delete t.parentTreeId;
                delete t.structTreeParent;
            }
            return !1;
        }
        return !0;
    }
    async updateStructureTree({ newAnnotationsByPage: e1, pdfManager: t, changes: i }) {
        const a = this.dict.xref, s = this.dict.clone(), r = this.ref, n = new RefSetCache;
        n.put(r, s);
        let g, o = s.getRaw("ParentTree");
        if (o instanceof Ref) g = a.fetch(o);
        else {
            g = o;
            o = a.getNewTemporaryRef();
            s.set("ParentTree", o);
        }
        g = g.clone();
        n.put(o, g);
        let c = g.getRaw("Nums"), C = null;
        if (c instanceof Ref) {
            C = c;
            c = a.fetch(C);
        }
        c = c.slice();
        C || g.set("Nums", c);
        const h = await StructTreeRoot.#L({
            newAnnotationsByPage: e1,
            structTreeRootRef: r,
            structTreeRoot: this,
            kids: null,
            nums: c,
            xref: a,
            pdfManager: t,
            changes: i,
            cache: n
        });
        if (-1 !== h) {
            s.set("ParentTreeNextKey", h);
            C && n.put(C, c);
            for (const [e1, t] of n.items())i.put(e1, {
                data: t
            });
        }
    }
    static async #L({ newAnnotationsByPage: e1, structTreeRootRef: t, structTreeRoot: i, kids: a, nums: s, xref: r, pdfManager: n, changes: g, cache: o }) {
        const c = Name.get("OBJR");
        let C, h = -1;
        for (const [l, Q] of e1){
            const e1 = await n.getPage(l), { ref: E } = e1, u = E instanceof Ref;
            for (const { accessibilityData: n, ref: d, parentTreeId: f, structTreeParent: p } of Q){
                if (!n?.type) continue;
                const { structParent: Q } = n;
                if (i && Number.isInteger(Q) && Q >= 0) {
                    let t = (C ||= new Map).get(l);
                    if (void 0 === t) {
                        t = new StructTreePage(i, e1.pageDict).collectObjects(E);
                        C.set(l, t);
                    }
                    const a = t?.get(Q);
                    if (a) {
                        const e1 = r.fetch(a).clone();
                        StructTreeRoot.#J(e1, n);
                        g.put(a, {
                            data: e1
                        });
                        continue;
                    }
                }
                h = Math.max(h, f);
                const m = r.getNewTemporaryRef(), y = new Dict(r);
                StructTreeRoot.#J(y, n);
                await this.#Y({
                    structTreeParent: p,
                    tagDict: y,
                    newTagRef: m,
                    structTreeRootRef: t,
                    fallbackKids: a,
                    xref: r,
                    cache: o
                });
                const w = new Dict(r);
                y.set("K", w);
                w.set("Type", c);
                u && w.set("Pg", E);
                w.set("Obj", d);
                o.put(m, y);
                s.push(f, m);
            }
        }
        return h + 1;
    }
    static #J(e1, { type: t, title: i, lang: a, alt: s, expanded: r, actualText: n }) {
        e1.set("S", Name.get(t));
        i && e1.set("T", stringToAsciiOrUTF16BE(i));
        a && e1.set("Lang", stringToAsciiOrUTF16BE(a));
        s && e1.set("Alt", stringToAsciiOrUTF16BE(s));
        r && e1.set("E", stringToAsciiOrUTF16BE(r));
        n && e1.set("ActualText", stringToAsciiOrUTF16BE(n));
    }
    static #H({ elements: e1, xref: t, pageDict: i, numberTree: a }) {
        const s = new Map;
        for (const t of e1)if (t.structTreeParentId) {
            const e1 = parseInt(t.structTreeParentId.split("_mc")[1], 10);
            let i = s.get(e1);
            if (!i) {
                i = [];
                s.set(e1, i);
            }
            i.push(t);
        }
        const r = i.get("StructParents");
        if (!Number.isInteger(r)) return;
        const n = a.get(r), updateElement = (e1, i, a)=>{
            const r = s.get(e1);
            if (r) {
                const e1 = i.getRaw("P"), s = t.fetchIfRef(e1);
                if (e1 instanceof Ref && s instanceof Dict) {
                    const e1 = {
                        ref: a,
                        dict: i
                    };
                    for (const t of r)t.structTreeParent = e1;
                }
                return !0;
            }
            return !1;
        };
        for (const e1 of n){
            if (!(e1 instanceof Ref)) continue;
            const i = t.fetch(e1), a = i.get("K");
            if (Number.isInteger(a)) updateElement(a, i, e1);
            else if (Array.isArray(a)) for (let s of a){
                s = t.fetchIfRef(s);
                if (Number.isInteger(s) && updateElement(s, i, e1)) break;
                if (!(s instanceof Dict)) continue;
                if (!isName(s.get("Type"), "MCR")) break;
                const a = s.get("MCID");
                if (Number.isInteger(a) && updateElement(a, i, e1)) break;
            }
        }
    }
    static async #Y({ structTreeParent: e1, tagDict: t, newTagRef: i, structTreeRootRef: a, fallbackKids: s, xref: r, cache: n }) {
        let g, o = null;
        if (e1) {
            ({ ref: o } = e1);
            g = e1.dict.getRaw("P") || a;
        } else g = a;
        t.set("P", g);
        const c = r.fetchIfRef(g);
        if (!c) {
            s.push(i);
            return;
        }
        let C = n.get(g);
        if (!C) {
            C = c.clone();
            n.put(g, C);
        }
        const h = C.getRaw("K");
        let l = h instanceof Ref ? n.get(h) : null;
        if (!l) {
            l = r.fetchIfRef(h);
            l = Array.isArray(l) ? l.slice() : [
                h
            ];
            const e1 = r.getNewTemporaryRef();
            C.set("K", e1);
            n.put(e1, l);
        }
        const Q = l.indexOf(o);
        l.splice(Q >= 0 ? Q + 1 : l.length, 0, i);
    }
}
class StructElementNode {
    constructor(e1, t){
        this.tree = e1;
        this.dict = t;
        this.kids = [];
        this.parseKids();
    }
    get role() {
        const e1 = this.dict.get("S"), t = e1 instanceof Name ? e1.name : "", { root: i } = this.tree;
        return i.roleMap.has(t) ? i.roleMap.get(t) : t;
    }
    parseKids() {
        let e1 = null;
        const t = this.dict.getRaw("Pg");
        t instanceof Ref && (e1 = t.toString());
        const i = this.dict.get("K");
        if (Array.isArray(i)) for (const t of i){
            const i = this.parseKid(e1, t);
            i && this.kids.push(i);
        }
        else {
            const t = this.parseKid(e1, i);
            t && this.kids.push(t);
        }
    }
    parseKid(e1, t) {
        if (Number.isInteger(t)) return this.tree.pageDict.objId !== e1 ? null : new StructElement({
            type: Rs,
            mcid: t,
            pageObjId: e1
        });
        let i = null;
        t instanceof Ref ? i = this.dict.xref.fetch(t) : t instanceof Dict && (i = t);
        if (!i) return null;
        const a = i.getRaw("Pg");
        a instanceof Ref && (e1 = a.toString());
        const s = i.get("Type") instanceof Name ? i.get("Type").name : null;
        if ("MCR" === s) {
            if (this.tree.pageDict.objId !== e1) return null;
            const t = i.getRaw("Stm");
            return new StructElement({
                type: Ns,
                refObjId: t instanceof Ref ? t.toString() : null,
                pageObjId: e1,
                mcid: i.get("MCID")
            });
        }
        if ("OBJR" === s) {
            if (this.tree.pageDict.objId !== e1) return null;
            const t = i.getRaw("Obj");
            return new StructElement({
                type: Gs,
                refObjId: t instanceof Ref ? t.toString() : null,
                pageObjId: e1
            });
        }
        return new StructElement({
            type: Us,
            dict: i
        });
    }
}
class StructElement {
    constructor({ type: e1, dict: t = null, mcid: i = null, pageObjId: a = null, refObjId: s = null }){
        this.type = e1;
        this.dict = t;
        this.mcid = i;
        this.pageObjId = a;
        this.refObjId = s;
        this.parentNode = null;
    }
}
class StructTreePage {
    constructor(e1, t){
        this.root = e1;
        this.rootDict = e1 ? e1.dict : null;
        this.pageDict = t;
        this.nodes = [];
    }
    collectObjects(e1) {
        if (!(this.root && this.rootDict && e1 instanceof Ref)) return null;
        const t = this.rootDict.get("ParentTree");
        if (!t) return null;
        const i = this.root.structParentIds?.get(e1);
        if (!i) return null;
        const a = new Map, s = new NumberTree(t, this.rootDict.xref);
        for (const [e1] of i){
            const t = s.getRaw(e1);
            t instanceof Ref && a.set(e1, t);
        }
        return a;
    }
    parse(e1) {
        if (!(this.root && this.rootDict && e1 instanceof Ref)) return;
        const t = this.rootDict.get("ParentTree");
        if (!t) return;
        const i = this.pageDict.get("StructParents"), a = this.root.structParentIds?.get(e1);
        if (!Number.isInteger(i) && !a) return;
        const s = new Map, r = new NumberTree(t, this.rootDict.xref);
        if (Number.isInteger(i)) {
            const e1 = r.get(i);
            if (Array.isArray(e1)) for (const t of e1)t instanceof Ref && this.addNode(this.rootDict.xref.fetch(t), s);
        }
        if (a) for (const [e1, t] of a){
            const i = r.get(e1);
            if (i) {
                const e1 = this.addNode(this.rootDict.xref.fetchIfRef(i), s);
                1 === e1?.kids?.length && e1.kids[0].type === Gs && (e1.kids[0].type = t);
            }
        }
    }
    addNode(e1, t, i = 0) {
        if (i > 40) {
            warn("StructTree MAX_DEPTH reached.");
            return null;
        }
        if (!(e1 instanceof Dict)) return null;
        if (t.has(e1)) return t.get(e1);
        const a = new StructElementNode(this, e1);
        t.set(e1, a);
        const s = e1.get("P");
        if (!s || isName(s.get("Type"), "StructTreeRoot")) {
            this.addTopLevelNode(e1, a) || t.delete(e1);
            return a;
        }
        const r = this.addNode(s, t, i + 1);
        if (!r) return a;
        let n = !1;
        for (const t of r.kids)if (t.type === Us && t.dict === e1) {
            t.parentNode = a;
            n = !0;
        }
        n || t.delete(e1);
        return a;
    }
    addTopLevelNode(e1, t) {
        const i = this.rootDict.get("K");
        if (!i) return !1;
        if (i instanceof Dict) {
            if (i.objId !== e1.objId) return !1;
            this.nodes[0] = t;
            return !0;
        }
        if (!Array.isArray(i)) return !0;
        let a = !1;
        for(let s = 0; s < i.length; s++){
            const r = i[s];
            if (r?.toString() === e1.objId) {
                this.nodes[s] = t;
                a = !0;
            }
        }
        return a;
    }
    get serializable() {
        function nodeToSerializable(e1, t, i = 0) {
            if (i > 40) {
                warn("StructTree too deep to be fully serialized.");
                return;
            }
            const a = Object.create(null);
            a.role = e1.role;
            a.children = [];
            t.children.push(a);
            let s = e1.dict.get("Alt");
            "string" != typeof s && (s = e1.dict.get("ActualText"));
            "string" == typeof s && (a.alt = stringToPDFString(s));
            const r = e1.dict.get("A");
            if (r instanceof Dict) {
                const e1 = lookupNormalRect(r.getArray("BBox"), null);
                if (e1) a.bbox = e1;
                else {
                    const e1 = r.get("Width"), t = r.get("Height");
                    "number" == typeof e1 && e1 > 0 && "number" == typeof t && t > 0 && (a.bbox = [
                        0,
                        0,
                        e1,
                        t
                    ]);
                }
            }
            const n = e1.dict.get("Lang");
            "string" == typeof n && (a.lang = stringToPDFString(n));
            for (const t of e1.kids){
                const e1 = t.type === Us ? t.parentNode : null;
                e1 ? nodeToSerializable(e1, a, i + 1) : t.type === Rs || t.type === Ns ? a.children.push({
                    type: "content",
                    id: `p${t.pageObjId}_mc${t.mcid}`
                }) : t.type === Gs ? a.children.push({
                    type: "object",
                    id: t.refObjId
                }) : t.type === Ms && a.children.push({
                    type: "annotation",
                    id: `pdfjs_internal_id_${t.refObjId}`
                });
            }
        }
        const e1 = Object.create(null);
        e1.children = [];
        e1.role = "Root";
        for (const t of this.nodes)t && nodeToSerializable(t, e1);
        return e1;
    }
}
function isValidExplicitDest(e1) {
    if (!Array.isArray(e1) || e1.length < 2) return !1;
    const [t, i, ...a] = e1;
    if (!(t instanceof Ref || Number.isInteger(t))) return !1;
    if (!(i instanceof Name)) return !1;
    const s = a.length;
    let r = !0;
    switch(i.name){
        case "XYZ":
            if (s < 2 || s > 3) return !1;
            break;
        case "Fit":
        case "FitB":
            return 0 === s;
        case "FitH":
        case "FitBH":
        case "FitV":
        case "FitBV":
            if (s > 1) return !1;
            break;
        case "FitR":
            if (4 !== s) return !1;
            r = !1;
            break;
        default:
            return !1;
    }
    for (const e1 of a)if (!("number" == typeof e1 || r && null === e1)) return !1;
    return !0;
}
function fetchDest(e1) {
    e1 instanceof Dict && (e1 = e1.get("D"));
    return isValidExplicitDest(e1) ? e1 : null;
}
function fetchRemoteDest(e1) {
    let t = e1.get("D");
    if (t) {
        t instanceof Name && (t = t.name);
        if ("string" == typeof t) return stringToPDFString(t);
        if (isValidExplicitDest(t)) return JSON.stringify(t);
    }
    return null;
}
class Catalog {
    constructor(e1, t){
        this.pdfManager = e1;
        this.xref = t;
        this._catDict = t.getCatalogObj();
        if (!(this._catDict instanceof Dict)) throw new FormatError("Catalog object is not a dictionary.");
        this.toplevelPagesDict;
        this._actualNumPages = null;
        this.fontCache = new RefSetCache;
        this.builtInCMapCache = new Map;
        this.standardFontDataCache = new Map;
        this.globalImageCache = new GlobalImageCache;
        this.pageKidsCountCache = new RefSetCache;
        this.pageIndexCache = new RefSetCache;
        this.pageDictCache = new RefSetCache;
        this.nonBlendModesSet = new RefSet;
        this.systemFontCache = new Map;
    }
    cloneDict() {
        return this._catDict.clone();
    }
    get version() {
        const e1 = this._catDict.get("Version");
        if (e1 instanceof Name) {
            if (ft.test(e1.name)) return shadow(this, "version", e1.name);
            warn(`Invalid PDF catalog version: ${e1.name}`);
        }
        return shadow(this, "version", null);
    }
    get lang() {
        const e1 = this._catDict.get("Lang");
        return shadow(this, "lang", e1 && "string" == typeof e1 ? stringToPDFString(e1) : null);
    }
    get needsRendering() {
        const e1 = this._catDict.get("NeedsRendering");
        return shadow(this, "needsRendering", "boolean" == typeof e1 && e1);
    }
    get collection() {
        let e1 = null;
        try {
            const t = this._catDict.get("Collection");
            t instanceof Dict && t.size > 0 && (e1 = t);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info("Cannot fetch Collection entry; assuming no collection is present.");
        }
        return shadow(this, "collection", e1);
    }
    get acroForm() {
        let e1 = null;
        try {
            const t = this._catDict.get("AcroForm");
            t instanceof Dict && t.size > 0 && (e1 = t);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info("Cannot fetch AcroForm entry; assuming no forms are present.");
        }
        return shadow(this, "acroForm", e1);
    }
    get acroFormRef() {
        const e1 = this._catDict.getRaw("AcroForm");
        return shadow(this, "acroFormRef", e1 instanceof Ref ? e1 : null);
    }
    get metadata() {
        const e1 = this._catDict.getRaw("Metadata");
        if (!(e1 instanceof Ref)) return shadow(this, "metadata", null);
        let t = null;
        try {
            const i = this.xref.fetch(e1, !this.xref.encrypt?.encryptMetadata);
            if (i instanceof BaseStream && i.dict instanceof Dict) {
                const e1 = i.dict.get("Type"), a = i.dict.get("Subtype");
                if (isName(e1, "Metadata") && isName(a, "XML")) {
                    const e1 = stringToUTF8String(i.getString());
                    e1 && (t = new MetadataParser(e1).serializable);
                }
            }
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info(`Skipping invalid Metadata: "${e1}".`);
        }
        return shadow(this, "metadata", t);
    }
    get markInfo() {
        let e1 = null;
        try {
            e1 = this._readMarkInfo();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable to read mark info.");
        }
        return shadow(this, "markInfo", e1);
    }
    _readMarkInfo() {
        const e1 = this._catDict.get("MarkInfo");
        if (!(e1 instanceof Dict)) return null;
        const t = {
            Marked: !1,
            UserProperties: !1,
            Suspects: !1
        };
        for(const i in t){
            const a = e1.get(i);
            "boolean" == typeof a && (t[i] = a);
        }
        return t;
    }
    get structTreeRoot() {
        let e1 = null;
        try {
            e1 = this._readStructTreeRoot();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable read to structTreeRoot info.");
        }
        return shadow(this, "structTreeRoot", e1);
    }
    _readStructTreeRoot() {
        const e1 = this._catDict.getRaw("StructTreeRoot"), t = this.xref.fetchIfRef(e1);
        if (!(t instanceof Dict)) return null;
        const i = new StructTreeRoot(t, e1);
        i.init();
        return i;
    }
    get toplevelPagesDict() {
        const e1 = this._catDict.get("Pages");
        if (!(e1 instanceof Dict)) throw new FormatError("Invalid top-level pages dictionary.");
        return shadow(this, "toplevelPagesDict", e1);
    }
    get documentOutline() {
        let e1 = null;
        try {
            e1 = this._readDocumentOutline();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable to read document outline.");
        }
        return shadow(this, "documentOutline", e1);
    }
    _readDocumentOutline() {
        let e1 = this._catDict.get("Outlines");
        if (!(e1 instanceof Dict)) return null;
        e1 = e1.getRaw("First");
        if (!(e1 instanceof Ref)) return null;
        const t = {
            items: []
        }, i = [
            {
                obj: e1,
                parent: t
            }
        ], a = new RefSet;
        a.put(e1);
        const s = this.xref, r = new Uint8ClampedArray(3);
        for(; i.length > 0;){
            const t = i.shift(), n = s.fetchIfRef(t.obj);
            if (null === n) continue;
            n.has("Title") || warn("Invalid outline item encountered.");
            const g = {
                url: null,
                dest: null,
                action: null
            };
            Catalog.parseDestDictionary({
                destDict: n,
                resultObj: g,
                docBaseUrl: this.baseUrl,
                docAttachments: this.attachments
            });
            const o = n.get("Title"), c = n.get("F") || 0, C = n.getArray("C"), h = n.get("Count");
            let l = r;
            !isNumberArray(C, 3) || 0 === C[0] && 0 === C[1] && 0 === C[2] || (l = ColorSpace.singletons.rgb.getRgb(C, 0));
            const Q = {
                action: g.action,
                attachment: g.attachment,
                dest: g.dest,
                url: g.url,
                unsafeUrl: g.unsafeUrl,
                newWindow: g.newWindow,
                setOCGState: g.setOCGState,
                title: "string" == typeof o ? stringToPDFString(o) : "",
                color: l,
                count: Number.isInteger(h) ? h : void 0,
                bold: !!(2 & c),
                italic: !!(1 & c),
                items: []
            };
            t.parent.items.push(Q);
            e1 = n.getRaw("First");
            if (e1 instanceof Ref && !a.has(e1)) {
                i.push({
                    obj: e1,
                    parent: Q
                });
                a.put(e1);
            }
            e1 = n.getRaw("Next");
            if (e1 instanceof Ref && !a.has(e1)) {
                i.push({
                    obj: e1,
                    parent: t.parent
                });
                a.put(e1);
            }
        }
        return t.items.length > 0 ? t.items : null;
    }
    get permissions() {
        let e1 = null;
        try {
            e1 = this._readPermissions();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable to read permissions.");
        }
        return shadow(this, "permissions", e1);
    }
    _readPermissions() {
        const e1 = this.xref.trailer.get("Encrypt");
        if (!(e1 instanceof Dict)) return null;
        let t = e1.get("P");
        if ("number" != typeof t) return null;
        t += 2 ** 32;
        const i = [];
        for(const e1 in y){
            const a = y[e1];
            t & a && i.push(a);
        }
        return i;
    }
    get optionalContentConfig() {
        let e1 = null;
        try {
            const t = this._catDict.get("OCProperties");
            if (!t) return shadow(this, "optionalContentConfig", null);
            const i = t.get("D");
            if (!i) return shadow(this, "optionalContentConfig", null);
            const a = t.get("OCGs");
            if (!Array.isArray(a)) return shadow(this, "optionalContentConfig", null);
            const s = new RefSetCache;
            for (const e1 of a)e1 instanceof Ref && !s.has(e1) && s.put(e1, this.#v(e1));
            e1 = this.#K(i, s);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`Unable to read optional content config: ${e1}`);
        }
        return shadow(this, "optionalContentConfig", e1);
    }
    #v(e1) {
        const t = this.xref.fetch(e1), i = {
            id: e1.toString(),
            name: null,
            intent: null,
            usage: {
                print: null,
                view: null
            },
            rbGroups: []
        }, a = t.get("Name");
        "string" == typeof a && (i.name = stringToPDFString(a));
        let s = t.getArray("Intent");
        Array.isArray(s) || (s = [
            s
        ]);
        s.every((e1)=>e1 instanceof Name) && (i.intent = s.map((e1)=>e1.name));
        const r = t.get("Usage");
        if (!(r instanceof Dict)) return i;
        const n = i.usage, g = r.get("Print");
        if (g instanceof Dict) {
            const e1 = g.get("PrintState");
            if (e1 instanceof Name) switch(e1.name){
                case "ON":
                case "OFF":
                    n.print = {
                        printState: e1.name
                    };
            }
        }
        const o = r.get("View");
        if (o instanceof Dict) {
            const e1 = o.get("ViewState");
            if (e1 instanceof Name) switch(e1.name){
                case "ON":
                case "OFF":
                    n.view = {
                        viewState: e1.name
                    };
            }
        }
        return i;
    }
    #K(e1, t) {
        function parseOnOff(e1) {
            const i = [];
            if (Array.isArray(e1)) for (const a of e1)a instanceof Ref && t.has(a) && i.push(a.toString());
            return i;
        }
        function parseOrder(e1, i = 0) {
            if (!Array.isArray(e1)) return null;
            const s = [];
            for (const r of e1){
                if (r instanceof Ref && t.has(r)) {
                    a.put(r);
                    s.push(r.toString());
                    continue;
                }
                const e1 = parseNestedOrder(r, i);
                e1 && s.push(e1);
            }
            if (i > 0) return s;
            const r = [];
            for (const [e1] of t.items())a.has(e1) || r.push(e1.toString());
            r.length && s.push({
                name: null,
                order: r
            });
            return s;
        }
        function parseNestedOrder(e1, t) {
            if (++t > s) {
                warn("parseNestedOrder - reached MAX_NESTED_LEVELS.");
                return null;
            }
            const a = i.fetchIfRef(e1);
            if (!Array.isArray(a)) return null;
            const r = i.fetchIfRef(a[0]);
            if ("string" != typeof r) return null;
            const n = parseOrder(a.slice(1), t);
            return n?.length ? {
                name: stringToPDFString(r),
                order: n
            } : null;
        }
        const i = this.xref, a = new RefSet, s = 10;
        !function parseRBGroups(e1) {
            if (Array.isArray(e1)) for (const a of e1){
                const e1 = i.fetchIfRef(a);
                if (!Array.isArray(e1) || !e1.length) continue;
                const s = new Set;
                for (const i of e1)if (i instanceof Ref && t.has(i) && !s.has(i.toString())) {
                    s.add(i.toString());
                    t.get(i).rbGroups.push(s);
                }
            }
        }(e1.get("RBGroups"));
        return {
            name: "string" == typeof e1.get("Name") ? stringToPDFString(e1.get("Name")) : null,
            creator: "string" == typeof e1.get("Creator") ? stringToPDFString(e1.get("Creator")) : null,
            baseState: e1.get("BaseState") instanceof Name ? e1.get("BaseState").name : null,
            on: parseOnOff(e1.get("ON")),
            off: parseOnOff(e1.get("OFF")),
            order: parseOrder(e1.get("Order")),
            groups: [
                ...t
            ]
        };
    }
    setActualNumPages(e1 = null) {
        this._actualNumPages = e1;
    }
    get hasActualNumPages() {
        return null !== this._actualNumPages;
    }
    get _pagesCount() {
        const e1 = this.toplevelPagesDict.get("Count");
        if (!Number.isInteger(e1)) throw new FormatError("Page count in top-level pages dictionary is not an integer.");
        return shadow(this, "_pagesCount", e1);
    }
    get numPages() {
        return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
    }
    get destinations() {
        const e1 = this._readDests(), t = Object.create(null);
        if (e1 instanceof NameTree) for (const [i, a] of e1.getAll()){
            const e1 = fetchDest(a);
            e1 && (t[stringToPDFString(i)] = e1);
        }
        else if (e1 instanceof Dict) for (const [i, a] of e1){
            const e1 = fetchDest(a);
            e1 && (t[i] = e1);
        }
        return shadow(this, "destinations", t);
    }
    getDestination(e1) {
        const t = this._readDests();
        if (t instanceof NameTree) {
            const i = fetchDest(t.get(e1));
            if (i) return i;
            const a = this.destinations[e1];
            if (a) {
                warn(`Found "${e1}" at an incorrect position in the NameTree.`);
                return a;
            }
        } else if (t instanceof Dict) {
            const i = fetchDest(t.get(e1));
            if (i) return i;
        }
        return null;
    }
    _readDests() {
        const e1 = this._catDict.get("Names");
        return e1?.has("Dests") ? new NameTree(e1.getRaw("Dests"), this.xref) : this._catDict.has("Dests") ? this._catDict.get("Dests") : void 0;
    }
    get pageLabels() {
        let e1 = null;
        try {
            e1 = this._readPageLabels();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable to read page labels.");
        }
        return shadow(this, "pageLabels", e1);
    }
    _readPageLabels() {
        const e1 = this._catDict.getRaw("PageLabels");
        if (!e1) return null;
        const t = new Array(this.numPages);
        let i = null, a = "";
        const s = new NumberTree(e1, this.xref).getAll();
        let r = "", n = 1;
        for(let e1 = 0, g = this.numPages; e1 < g; e1++){
            const g = s.get(e1);
            if (void 0 !== g) {
                if (!(g instanceof Dict)) throw new FormatError("PageLabel is not a dictionary.");
                if (g.has("Type") && !isName(g.get("Type"), "PageLabel")) throw new FormatError("Invalid type in PageLabel dictionary.");
                if (g.has("S")) {
                    const e1 = g.get("S");
                    if (!(e1 instanceof Name)) throw new FormatError("Invalid style in PageLabel dictionary.");
                    i = e1.name;
                } else i = null;
                if (g.has("P")) {
                    const e1 = g.get("P");
                    if ("string" != typeof e1) throw new FormatError("Invalid prefix in PageLabel dictionary.");
                    a = stringToPDFString(e1);
                } else a = "";
                if (g.has("St")) {
                    const e1 = g.get("St");
                    if (!(Number.isInteger(e1) && e1 >= 1)) throw new FormatError("Invalid start in PageLabel dictionary.");
                    n = e1;
                } else n = 1;
            }
            switch(i){
                case "D":
                    r = n;
                    break;
                case "R":
                case "r":
                    r = toRomanNumerals(n, "r" === i);
                    break;
                case "A":
                case "a":
                    const e2 = 26, t1 = "a" === i ? 97 : 65, a1 = n - 1;
                    r = String.fromCharCode(t1 + a1 % e2).repeat(Math.floor(a1 / e2) + 1);
                    break;
                default:
                    if (i) throw new FormatError(`Invalid style "${i}" in PageLabel dictionary.`);
                    r = "";
            }
            t[e1] = a + r;
            n++;
        }
        return t;
    }
    get pageLayout() {
        const e1 = this._catDict.get("PageLayout");
        let t = "";
        if (e1 instanceof Name) switch(e1.name){
            case "SinglePage":
            case "OneColumn":
            case "TwoColumnLeft":
            case "TwoColumnRight":
            case "TwoPageLeft":
            case "TwoPageRight":
                t = e1.name;
        }
        return shadow(this, "pageLayout", t);
    }
    get pageMode() {
        const e1 = this._catDict.get("PageMode");
        let t = "UseNone";
        if (e1 instanceof Name) switch(e1.name){
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "FullScreen":
            case "UseOC":
            case "UseAttachments":
                t = e1.name;
        }
        return shadow(this, "pageMode", t);
    }
    get viewerPreferences() {
        const e1 = this._catDict.get("ViewerPreferences");
        if (!(e1 instanceof Dict)) return shadow(this, "viewerPreferences", null);
        let t = null;
        for (const i of e1.getKeys()){
            const a = e1.get(i);
            let s;
            switch(i){
                case "HideToolbar":
                case "HideMenubar":
                case "HideWindowUI":
                case "FitWindow":
                case "CenterWindow":
                case "DisplayDocTitle":
                case "PickTrayByPDFSize":
                    "boolean" == typeof a && (s = a);
                    break;
                case "NonFullScreenPageMode":
                    if (a instanceof Name) switch(a.name){
                        case "UseNone":
                        case "UseOutlines":
                        case "UseThumbs":
                        case "UseOC":
                            s = a.name;
                            break;
                        default:
                            s = "UseNone";
                    }
                    break;
                case "Direction":
                    if (a instanceof Name) switch(a.name){
                        case "L2R":
                        case "R2L":
                            s = a.name;
                            break;
                        default:
                            s = "L2R";
                    }
                    break;
                case "ViewArea":
                case "ViewClip":
                case "PrintArea":
                case "PrintClip":
                    if (a instanceof Name) switch(a.name){
                        case "MediaBox":
                        case "CropBox":
                        case "BleedBox":
                        case "TrimBox":
                        case "ArtBox":
                            s = a.name;
                            break;
                        default:
                            s = "CropBox";
                    }
                    break;
                case "PrintScaling":
                    if (a instanceof Name) switch(a.name){
                        case "None":
                        case "AppDefault":
                            s = a.name;
                            break;
                        default:
                            s = "AppDefault";
                    }
                    break;
                case "Duplex":
                    if (a instanceof Name) switch(a.name){
                        case "Simplex":
                        case "DuplexFlipShortEdge":
                        case "DuplexFlipLongEdge":
                            s = a.name;
                            break;
                        default:
                            s = "None";
                    }
                    break;
                case "PrintPageRange":
                    if (Array.isArray(a) && a.length % 2 == 0) {
                        a.every((e1, t, i)=>Number.isInteger(e1) && e1 > 0 && (0 === t || e1 >= i[t - 1]) && e1 <= this.numPages) && (s = a);
                    }
                    break;
                case "NumCopies":
                    Number.isInteger(a) && a > 0 && (s = a);
                    break;
                default:
                    warn(`Ignoring non-standard key in ViewerPreferences: ${i}.`);
                    continue;
            }
            if (void 0 !== s) {
                t || (t = Object.create(null));
                t[i] = s;
            } else warn(`Bad value, for key "${i}", in ViewerPreferences: ${a}.`);
        }
        return shadow(this, "viewerPreferences", t);
    }
    get openAction() {
        const e1 = this._catDict.get("OpenAction"), t = Object.create(null);
        if (e1 instanceof Dict) {
            const i = new Dict(this.xref);
            i.set("A", e1);
            const a = {
                url: null,
                dest: null,
                action: null
            };
            Catalog.parseDestDictionary({
                destDict: i,
                resultObj: a
            });
            Array.isArray(a.dest) ? t.dest = a.dest : a.action && (t.action = a.action);
        } else Array.isArray(e1) && (t.dest = e1);
        return shadow(this, "openAction", objectSize(t) > 0 ? t : null);
    }
    get attachments() {
        const e1 = this._catDict.get("Names");
        let t = null;
        if (e1 instanceof Dict && e1.has("EmbeddedFiles")) {
            const i = new NameTree(e1.getRaw("EmbeddedFiles"), this.xref);
            for (const [e1, a] of i.getAll()){
                const i = new FileSpec(a, this.xref);
                t || (t = Object.create(null));
                t[stringToPDFString(e1)] = i.serializable;
            }
        }
        return shadow(this, "attachments", t);
    }
    get xfaImages() {
        const e1 = this._catDict.get("Names");
        let t = null;
        if (e1 instanceof Dict && e1.has("XFAImages")) {
            const i = new NameTree(e1.getRaw("XFAImages"), this.xref);
            for (const [e1, a] of i.getAll()){
                t || (t = new Dict(this.xref));
                t.set(stringToPDFString(e1), a);
            }
        }
        return shadow(this, "xfaImages", t);
    }
    _collectJavaScript() {
        const e1 = this._catDict.get("Names");
        let t = null;
        function appendIfJavaScriptDict(e1, i) {
            if (!(i instanceof Dict)) return;
            if (!isName(i.get("S"), "JavaScript")) return;
            let a = i.get("JS");
            if (a instanceof BaseStream) a = a.getString();
            else if ("string" != typeof a) return;
            a = stringToPDFString(a).replaceAll("\0", "");
            a && (t ||= new Map).set(e1, a);
        }
        if (e1 instanceof Dict && e1.has("JavaScript")) {
            const t = new NameTree(e1.getRaw("JavaScript"), this.xref);
            for (const [e1, i] of t.getAll())appendIfJavaScriptDict(stringToPDFString(e1), i);
        }
        const i = this._catDict.get("OpenAction");
        i && appendIfJavaScriptDict("OpenAction", i);
        return t;
    }
    get jsActions() {
        const e1 = this._collectJavaScript();
        let t = collectActions(this.xref, this._catDict, fA);
        if (e1) {
            t ||= Object.create(null);
            for (const [i, a] of e1)i in t ? t[i].push(a) : t[i] = [
                a
            ];
        }
        return shadow(this, "jsActions", t);
    }
    async fontFallback(e1, t) {
        const i = await Promise.all(this.fontCache);
        for (const a of i)if (a.loadedName === e1) {
            a.fallback(t);
            return;
        }
    }
    async cleanup(e1 = !1) {
        clearGlobalCaches();
        this.globalImageCache.clear(e1);
        this.pageKidsCountCache.clear();
        this.pageIndexCache.clear();
        this.pageDictCache.clear();
        this.nonBlendModesSet.clear();
        const t = await Promise.all(this.fontCache);
        for (const { dict: e1 } of t)delete e1.cacheKey;
        this.fontCache.clear();
        this.builtInCMapCache.clear();
        this.standardFontDataCache.clear();
        this.systemFontCache.clear();
    }
    async getPageDict(e1) {
        const t = [
            this.toplevelPagesDict
        ], i = new RefSet, a = this._catDict.getRaw("Pages");
        a instanceof Ref && i.put(a);
        const s = this.xref, r = this.pageKidsCountCache, n = this.pageIndexCache, g = this.pageDictCache;
        let o = 0;
        for(; t.length;){
            const a = t.pop();
            if (a instanceof Ref) {
                const c = r.get(a);
                if (c >= 0 && o + c <= e1) {
                    o += c;
                    continue;
                }
                if (i.has(a)) throw new FormatError("Pages tree contains circular reference.");
                i.put(a);
                const C = await (g.get(a) || s.fetchAsync(a));
                if (C instanceof Dict) {
                    let t = C.getRaw("Type");
                    t instanceof Ref && (t = await s.fetchAsync(t));
                    if (isName(t, "Page") || !C.has("Kids")) {
                        r.has(a) || r.put(a, 1);
                        n.has(a) || n.put(a, o);
                        if (o === e1) return [
                            C,
                            a
                        ];
                        o++;
                        continue;
                    }
                }
                t.push(C);
                continue;
            }
            if (!(a instanceof Dict)) throw new FormatError("Page dictionary kid reference points to wrong type of object.");
            const { objId: c } = a;
            let C = a.getRaw("Count");
            C instanceof Ref && (C = await s.fetchAsync(C));
            if (Number.isInteger(C) && C >= 0) {
                c && !r.has(c) && r.put(c, C);
                if (o + C <= e1) {
                    o += C;
                    continue;
                }
            }
            let h = a.getRaw("Kids");
            h instanceof Ref && (h = await s.fetchAsync(h));
            if (!Array.isArray(h)) {
                let t = a.getRaw("Type");
                t instanceof Ref && (t = await s.fetchAsync(t));
                if (isName(t, "Page") || !a.has("Kids")) {
                    if (o === e1) return [
                        a,
                        null
                    ];
                    o++;
                    continue;
                }
                throw new FormatError("Page dictionary kids object is not an array.");
            }
            for(let e1 = h.length - 1; e1 >= 0; e1--){
                const i = h[e1];
                t.push(i);
                a === this.toplevelPagesDict && i instanceof Ref && !g.has(i) && g.put(i, s.fetchAsync(i));
            }
        }
        throw new Error(`Page index ${e1} not found.`);
    }
    async getAllPageDicts(e1 = !1) {
        const { ignoreErrors: t } = this.pdfManager.evaluatorOptions, i = [
            {
                currentNode: this.toplevelPagesDict,
                posInKids: 0
            }
        ], a = new RefSet, s = this._catDict.getRaw("Pages");
        s instanceof Ref && a.put(s);
        const r = new Map, n = this.xref, g = this.pageIndexCache;
        let o = 0;
        function addPageDict(e1, t) {
            t && !g.has(t) && g.put(t, o);
            r.set(o++, [
                e1,
                t
            ]);
        }
        function addPageError(i) {
            if (i instanceof XRefEntryException && !e1) throw i;
            if (e1 && t && 0 === o) {
                warn(`getAllPageDicts - Skipping invalid first page: "${i}".`);
                i = Dict.empty;
            }
            r.set(o++, [
                i,
                null
            ]);
        }
        for(; i.length > 0;){
            const e1 = i.at(-1), { currentNode: t, posInKids: s } = e1;
            let r = t.getRaw("Kids");
            if (r instanceof Ref) try {
                r = await n.fetchAsync(r);
            } catch (e1) {
                addPageError(e1);
                break;
            }
            if (!Array.isArray(r)) {
                addPageError(new FormatError("Page dictionary kids object is not an array."));
                break;
            }
            if (s >= r.length) {
                i.pop();
                continue;
            }
            const g = r[s];
            let o;
            if (g instanceof Ref) {
                if (a.has(g)) {
                    addPageError(new FormatError("Pages tree contains circular reference."));
                    break;
                }
                a.put(g);
                try {
                    o = await n.fetchAsync(g);
                } catch (e1) {
                    addPageError(e1);
                    break;
                }
            } else o = g;
            if (!(o instanceof Dict)) {
                addPageError(new FormatError("Page dictionary kid reference points to wrong type of object."));
                break;
            }
            let c = o.getRaw("Type");
            if (c instanceof Ref) try {
                c = await n.fetchAsync(c);
            } catch (e1) {
                addPageError(e1);
                break;
            }
            isName(c, "Page") || !o.has("Kids") ? addPageDict(o, g instanceof Ref ? g : null) : i.push({
                currentNode: o,
                posInKids: 0
            });
            e1.posInKids++;
        }
        return r;
    }
    getPageIndex(e1) {
        const t = this.pageIndexCache.get(e1);
        if (void 0 !== t) return Promise.resolve(t);
        const i = this.xref;
        let a = 0;
        const next = (t)=>(function pagesBeforeRef(t) {
                let a, s = 0;
                return i.fetchAsync(t).then(function(i) {
                    if (isRefsEqual(t, e1) && !isDict(i, "Page") && !(i instanceof Dict && !i.has("Type") && i.has("Contents"))) throw new FormatError("The reference does not point to a /Page dictionary.");
                    if (!i) return null;
                    if (!(i instanceof Dict)) throw new FormatError("Node must be a dictionary.");
                    a = i.getRaw("Parent");
                    return i.getAsync("Parent");
                }).then(function(e1) {
                    if (!e1) return null;
                    if (!(e1 instanceof Dict)) throw new FormatError("Parent must be a dictionary.");
                    return e1.getAsync("Kids");
                }).then(function(e1) {
                    if (!e1) return null;
                    const r = [];
                    let n = !1;
                    for (const a of e1){
                        if (!(a instanceof Ref)) throw new FormatError("Kid must be a reference.");
                        if (isRefsEqual(a, t)) {
                            n = !0;
                            break;
                        }
                        r.push(i.fetchAsync(a).then(function(e1) {
                            if (!(e1 instanceof Dict)) throw new FormatError("Kid node must be a dictionary.");
                            e1.has("Count") ? s += e1.get("Count") : s++;
                        }));
                    }
                    if (!n) throw new FormatError("Kid reference not found in parent's kids.");
                    return Promise.all(r).then(function() {
                        return [
                            s,
                            a
                        ];
                    });
                });
            })(t).then((t)=>{
                if (!t) {
                    this.pageIndexCache.put(e1, a);
                    return a;
                }
                const [i, s] = t;
                a += i;
                return next(s);
            });
        return next(e1);
    }
    get baseUrl() {
        const e1 = this._catDict.get("URI");
        if (e1 instanceof Dict) {
            const t = e1.get("Base");
            if ("string" == typeof t) {
                const e1 = createValidAbsoluteUrl(t, null, {
                    tryConvertEncoding: !0
                });
                if (e1) return shadow(this, "baseUrl", e1.href);
            }
        }
        return shadow(this, "baseUrl", this.pdfManager.docBaseUrl);
    }
    static parseDestDictionary({ destDict: e1, resultObj: t, docBaseUrl: i = null, docAttachments: a = null }) {
        if (!(e1 instanceof Dict)) {
            warn("parseDestDictionary: `destDict` must be a dictionary.");
            return;
        }
        let s, r, n = e1.get("A");
        if (!(n instanceof Dict)) if (e1.has("Dest")) n = e1.get("Dest");
        else {
            n = e1.get("AA");
            n instanceof Dict && (n.has("D") ? n = n.get("D") : n.has("U") && (n = n.get("U")));
        }
        if (n instanceof Dict) {
            const e1 = n.get("S");
            if (!(e1 instanceof Name)) {
                warn("parseDestDictionary: Invalid type in Action dictionary.");
                return;
            }
            const i = e1.name;
            switch(i){
                case "ResetForm":
                    const e2 = n.get("Flags"), g = !(1 & ("number" == typeof e2 ? e2 : 0)), o = [], c = [];
                    for (const e1 of n.get("Fields") || [])e1 instanceof Ref ? c.push(e1.toString()) : "string" == typeof e1 && o.push(stringToPDFString(e1));
                    t.resetForm = {
                        fields: o,
                        refs: c,
                        include: g
                    };
                    break;
                case "URI":
                    s = n.get("URI");
                    s instanceof Name && (s = "/" + s.name);
                    break;
                case "GoTo":
                    r = n.get("D");
                    break;
                case "Launch":
                case "GoToR":
                    const C = n.get("F");
                    if (C instanceof Dict) {
                        const e1 = new FileSpec(C, null, !0), { rawFilename: t } = e1.serializable;
                        s = t;
                    } else "string" == typeof C && (s = C);
                    const h = fetchRemoteDest(n);
                    h && "string" == typeof s && (s = s.split("#", 1)[0] + "#" + h);
                    const l = n.get("NewWindow");
                    "boolean" == typeof l && (t.newWindow = l);
                    break;
                case "GoToE":
                    const Q = n.get("T");
                    let E;
                    if (a && Q instanceof Dict) {
                        const e1 = Q.get("R"), t = Q.get("N");
                        isName(e1, "C") && "string" == typeof t && (E = a[stringToPDFString(t)]);
                    }
                    if (E) {
                        t.attachment = E;
                        const e1 = fetchRemoteDest(n);
                        e1 && (t.attachmentDest = e1);
                    } else warn('parseDestDictionary - unimplemented "GoToE" action.');
                    break;
                case "Named":
                    const u = n.get("N");
                    u instanceof Name && (t.action = u.name);
                    break;
                case "SetOCGState":
                    const d = n.get("State"), f = n.get("PreserveRB");
                    if (!Array.isArray(d) || 0 === d.length) break;
                    const p = [];
                    for (const e1 of d)if (e1 instanceof Name) switch(e1.name){
                        case "ON":
                        case "OFF":
                        case "Toggle":
                            p.push(e1.name);
                    }
                    else e1 instanceof Ref && p.push(e1.toString());
                    if (p.length !== d.length) break;
                    t.setOCGState = {
                        state: p,
                        preserveRB: "boolean" != typeof f || f
                    };
                    break;
                case "JavaScript":
                    const m = n.get("JS");
                    let y;
                    m instanceof BaseStream ? y = m.getString() : "string" == typeof m && (y = m);
                    const w = y && recoverJsURL(stringToPDFString(y));
                    if (w) {
                        s = w.url;
                        t.newWindow = w.newWindow;
                        break;
                    }
                default:
                    if ("JavaScript" === i || "SubmitForm" === i) break;
                    warn(`parseDestDictionary - unsupported action: "${i}".`);
            }
        } else e1.has("Dest") && (r = e1.get("Dest"));
        if ("string" == typeof s) {
            const e1 = createValidAbsoluteUrl(s, i, {
                addDefaultProtocol: !0,
                tryConvertEncoding: !0
            });
            e1 && (t.url = e1.href);
            t.unsafeUrl = s;
        }
        if (r) {
            r instanceof Name && (r = r.name);
            "string" == typeof r ? t.dest = stringToPDFString(r) : isValidExplicitDest(r) && (t.dest = r);
        }
    }
}
function addChildren(e1, t) {
    if (e1 instanceof Dict) e1 = e1.getRawValues();
    else if (e1 instanceof BaseStream) e1 = e1.dict.getRawValues();
    else if (!Array.isArray(e1)) return;
    for (const a of e1)((i = a) instanceof Ref || i instanceof Dict || i instanceof BaseStream || Array.isArray(i)) && t.push(a);
    var i;
}
class ObjectLoader {
    constructor(e1, t, i){
        this.dict = e1;
        this.keys = t;
        this.xref = i;
        this.refSet = null;
    }
    async load() {
        if (this.xref.stream.isDataLoaded) return;
        const { keys: e1, dict: t } = this;
        this.refSet = new RefSet;
        const i = [];
        for (const a of e1){
            const e1 = t.getRaw(a);
            void 0 !== e1 && i.push(e1);
        }
        return this._walk(i);
    }
    async _walk(e1) {
        const t = [], i = [];
        for(; e1.length;){
            let a = e1.pop();
            if (a instanceof Ref) {
                if (this.refSet.has(a)) continue;
                try {
                    this.refSet.put(a);
                    a = this.xref.fetch(a);
                } catch (e1) {
                    if (!(e1 instanceof MissingDataException)) {
                        warn(`ObjectLoader._walk - requesting all data: "${e1}".`);
                        this.refSet = null;
                        const { manager: t } = this.xref.stream;
                        return t.requestAllChunks();
                    }
                    t.push(a);
                    i.push({
                        begin: e1.begin,
                        end: e1.end
                    });
                }
            }
            if (a instanceof BaseStream) {
                const e1 = a.getBaseStreams();
                if (e1) {
                    let s = !1;
                    for (const t of e1)if (!t.isDataLoaded) {
                        s = !0;
                        i.push({
                            begin: t.start,
                            end: t.end
                        });
                    }
                    s && t.push(a);
                }
            }
            addChildren(a, e1);
        }
        if (i.length) {
            await this.xref.stream.manager.requestRanges(i);
            for (const e1 of t)e1 instanceof Ref && this.refSet.remove(e1);
            return this._walk(t);
        }
        this.refSet = null;
    }
}
const xs = Symbol(), Ls = Symbol(), Hs = Symbol(), Js = Symbol(), Ys = Symbol(), vs = Symbol(), Ks = Symbol(), Ts = Symbol(), qs = Symbol(), Os = Symbol("content"), Ws = Symbol("data"), js = Symbol(), Xs = Symbol("extra"), Zs = Symbol(), Vs = Symbol(), zs = Symbol(), _s = Symbol(), $s = Symbol(), Ar = Symbol(), er = Symbol(), tr = Symbol(), ir = Symbol(), ar = Symbol(), sr = Symbol(), rr = Symbol(), nr = Symbol(), gr = Symbol(), or = Symbol(), Ir = Symbol(), cr = Symbol(), Cr = Symbol(), hr = Symbol(), lr = Symbol(), Qr = Symbol(), Er = Symbol(), ur = Symbol(), dr = Symbol(), fr = Symbol(), pr = Symbol(), mr = Symbol(), yr = Symbol(), wr = Symbol(), Dr = Symbol(), br = Symbol(), Fr = Symbol(), Sr = Symbol("namespaceId"), kr = Symbol("nodeName"), Rr = Symbol(), Nr = Symbol(), Gr = Symbol(), Mr = Symbol(), Ur = Symbol(), xr = Symbol(), Lr = Symbol(), Hr = Symbol(), Jr = Symbol("root"), Yr = Symbol(), vr = Symbol(), Kr = Symbol(), Tr = Symbol(), qr = Symbol(), Or = Symbol(), Pr = Symbol(), Wr = Symbol(), jr = Symbol(), Xr = Symbol(), Zr = Symbol(), Vr = Symbol("uid"), zr = Symbol(), _r = {
    config: {
        id: 0,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xci/")
    },
    connectionSet: {
        id: 1,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
    },
    datasets: {
        id: 2,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-data/")
    },
    form: {
        id: 3,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-form/")
    },
    localeSet: {
        id: 4,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
    },
    pdf: {
        id: 5,
        check: (e1)=>"http://ns.adobe.com/xdp/pdf/" === e1
    },
    signature: {
        id: 6,
        check: (e1)=>"http://www.w3.org/2000/09/xmldsig#" === e1
    },
    sourceSet: {
        id: 7,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-source-set/")
    },
    stylesheet: {
        id: 8,
        check: (e1)=>"http://www.w3.org/1999/XSL/Transform" === e1
    },
    template: {
        id: 9,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-template/")
    },
    xdc: {
        id: 10,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xdc/")
    },
    xdp: {
        id: 11,
        check: (e1)=>"http://ns.adobe.com/xdp/" === e1
    },
    xfdf: {
        id: 12,
        check: (e1)=>"http://ns.adobe.com/xfdf/" === e1
    },
    xhtml: {
        id: 13,
        check: (e1)=>"http://www.w3.org/1999/xhtml" === e1
    },
    xmpmeta: {
        id: 14,
        check: (e1)=>"http://ns.adobe.com/xmpmeta/" === e1
    }
}, $r = {
    pt: (e1)=>e1,
    cm: (e1)=>e1 / 2.54 * 72,
    mm: (e1)=>e1 / 25.4 * 72,
    in: (e1)=>72 * e1,
    px: (e1)=>e1
}, An = /([+-]?\d+\.?\d*)(.*)/;
function stripQuotes(e1) {
    return e1.startsWith("'") || e1.startsWith('"') ? e1.slice(1, -1) : e1;
}
function getInteger({ data: e1, defaultValue: t, validate: i }) {
    if (!e1) return t;
    e1 = e1.trim();
    const a = parseInt(e1, 10);
    return !isNaN(a) && i(a) ? a : t;
}
function getFloat({ data: e1, defaultValue: t, validate: i }) {
    if (!e1) return t;
    e1 = e1.trim();
    const a = parseFloat(e1);
    return !isNaN(a) && i(a) ? a : t;
}
function getKeyword({ data: e1, defaultValue: t, validate: i }) {
    return e1 && i(e1 = e1.trim()) ? e1 : t;
}
function getStringOption(e1, t) {
    return getKeyword({
        data: e1,
        defaultValue: t[0],
        validate: (e1)=>t.includes(e1)
    });
}
function getMeasurement(e1, t = "0") {
    t ||= "0";
    if (!e1) return getMeasurement(t);
    const i = e1.trim().match(An);
    if (!i) return getMeasurement(t);
    const [, a, s] = i, r = parseFloat(a);
    if (isNaN(r)) return getMeasurement(t);
    if (0 === r) return 0;
    const n = $r[s];
    return n ? n(r) : r;
}
function getRatio(e1) {
    if (!e1) return {
        num: 1,
        den: 1
    };
    const t = e1.trim().split(/\s*:\s*/).map((e1)=>parseFloat(e1)).filter((e1)=>!isNaN(e1));
    1 === t.length && t.push(1);
    if (0 === t.length) return {
        num: 1,
        den: 1
    };
    const [i, a] = t;
    return {
        num: i,
        den: a
    };
}
function getRelevant(e1) {
    return e1 ? e1.trim().split(/\s+/).map((e1)=>({
            excluded: "-" === e1[0],
            viewname: e1.substring(1)
        })) : [];
}
class HTMLResult {
    static get FAILURE() {
        return shadow(this, "FAILURE", new HTMLResult(!1, null, null, null));
    }
    static get EMPTY() {
        return shadow(this, "EMPTY", new HTMLResult(!0, null, null, null));
    }
    constructor(e1, t, i, a){
        this.success = e1;
        this.html = t;
        this.bbox = i;
        this.breakNode = a;
    }
    isBreak() {
        return !!this.breakNode;
    }
    static breakNode(e1) {
        return new HTMLResult(!1, null, null, e1);
    }
    static success(e1, t = null) {
        return new HTMLResult(!0, e1, t, null);
    }
}
class FontFinder {
    constructor(e1){
        this.fonts = new Map;
        this.cache = new Map;
        this.warned = new Set;
        this.defaultFont = null;
        this.add(e1);
    }
    add(e1, t = null) {
        for (const t of e1)this.addPdfFont(t);
        for (const e1 of this.fonts.values())e1.regular || (e1.regular = e1.italic || e1.bold || e1.bolditalic);
        if (!t || 0 === t.size) return;
        const i = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
        for (const e1 of t)this.fonts.set(e1, i);
    }
    addPdfFont(e1) {
        const t = e1.cssFontInfo, i = t.fontFamily;
        let a = this.fonts.get(i);
        if (!a) {
            a = Object.create(null);
            this.fonts.set(i, a);
            this.defaultFont || (this.defaultFont = a);
        }
        let s = "";
        const r = parseFloat(t.fontWeight);
        0 !== parseFloat(t.italicAngle) ? s = r >= 700 ? "bolditalic" : "italic" : r >= 700 && (s = "bold");
        if (!s) {
            (e1.name.includes("Bold") || e1.psName?.includes("Bold")) && (s = "bold");
            (e1.name.includes("Italic") || e1.name.endsWith("It") || e1.psName?.includes("Italic") || e1.psName?.endsWith("It")) && (s += "italic");
        }
        s || (s = "regular");
        a[s] = e1;
    }
    getDefault() {
        return this.defaultFont;
    }
    find(e1, t = !0) {
        let i = this.fonts.get(e1) || this.cache.get(e1);
        if (i) return i;
        const a = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
        let s = e1.replaceAll(a, "");
        i = this.fonts.get(s);
        if (i) {
            this.cache.set(e1, i);
            return i;
        }
        s = s.toLowerCase();
        const r = [];
        for (const [e1, t] of this.fonts.entries())e1.replaceAll(a, "").toLowerCase().startsWith(s) && r.push(t);
        if (0 === r.length) for (const [, e1] of this.fonts.entries())e1.regular.name?.replaceAll(a, "").toLowerCase().startsWith(s) && r.push(e1);
        if (0 === r.length) {
            s = s.replaceAll(/psmt|mt/gi, "");
            for (const [e1, t] of this.fonts.entries())e1.replaceAll(a, "").toLowerCase().startsWith(s) && r.push(t);
        }
        if (0 === r.length) for (const e1 of this.fonts.values())e1.regular.name?.replaceAll(a, "").toLowerCase().startsWith(s) && r.push(e1);
        if (r.length >= 1) {
            1 !== r.length && t && warn(`XFA - Too many choices to guess the correct font: ${e1}`);
            this.cache.set(e1, r[0]);
            return r[0];
        }
        if (t && !this.warned.has(e1)) {
            this.warned.add(e1);
            warn(`XFA - Cannot find the font: ${e1}`);
        }
        return null;
    }
}
function selectFont(e1, t) {
    return "italic" === e1.posture ? "bold" === e1.weight ? t.bolditalic : t.italic : "bold" === e1.weight ? t.bold : t.regular;
}
class FontInfo {
    constructor(e1, t, i, a){
        this.lineHeight = i;
        this.paraMargin = t || {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };
        if (!e1) {
            [this.pdfFont, this.xfaFont] = this.defaultFont(a);
            return;
        }
        this.xfaFont = {
            typeface: e1.typeface,
            posture: e1.posture,
            weight: e1.weight,
            size: e1.size,
            letterSpacing: e1.letterSpacing
        };
        const s = a.find(e1.typeface);
        if (s) {
            this.pdfFont = selectFont(e1, s);
            this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(a));
        } else [this.pdfFont, this.xfaFont] = this.defaultFont(a);
    }
    defaultFont(e1) {
        const t = e1.find("Helvetica", !1) || e1.find("Myriad Pro", !1) || e1.find("Arial", !1) || e1.getDefault();
        if (t?.regular) {
            const e1 = t.regular;
            return [
                e1,
                {
                    typeface: e1.cssFontInfo.fontFamily,
                    posture: "normal",
                    weight: "normal",
                    size: 10,
                    letterSpacing: 0
                }
            ];
        }
        return [
            null,
            {
                typeface: "Courier",
                posture: "normal",
                weight: "normal",
                size: 10,
                letterSpacing: 0
            }
        ];
    }
}
class FontSelector {
    constructor(e1, t, i, a){
        this.fontFinder = a;
        this.stack = [
            new FontInfo(e1, t, i, a)
        ];
    }
    pushData(e1, t, i) {
        const a = this.stack.at(-1);
        for (const t of [
            "typeface",
            "posture",
            "weight",
            "size",
            "letterSpacing"
        ])e1[t] || (e1[t] = a.xfaFont[t]);
        for (const e1 of [
            "top",
            "bottom",
            "left",
            "right"
        ])isNaN(t[e1]) && (t[e1] = a.paraMargin[e1]);
        const s = new FontInfo(e1, t, i || a.lineHeight, this.fontFinder);
        s.pdfFont || (s.pdfFont = a.pdfFont);
        this.stack.push(s);
    }
    popFont() {
        this.stack.pop();
    }
    topFont() {
        return this.stack.at(-1);
    }
}
class TextMeasure {
    constructor(e1, t, i, a){
        this.glyphs = [];
        this.fontSelector = new FontSelector(e1, t, i, a);
        this.extraHeight = 0;
    }
    pushData(e1, t, i) {
        this.fontSelector.pushData(e1, t, i);
    }
    popFont(e1) {
        return this.fontSelector.popFont();
    }
    addPara() {
        const e1 = this.fontSelector.topFont();
        this.extraHeight += e1.paraMargin.top + e1.paraMargin.bottom;
    }
    addString(e1) {
        if (!e1) return;
        const t = this.fontSelector.topFont(), i = t.xfaFont.size;
        if (t.pdfFont) {
            const a = t.xfaFont.letterSpacing, s = t.pdfFont, r = s.lineHeight || 1.2, n = t.lineHeight || Math.max(1.2, r) * i, g = r - (void 0 === s.lineGap ? .2 : s.lineGap), o = Math.max(1, g) * i, c = i / 1e3, C = s.defaultWidth || s.charsToGlyphs(" ")[0].width;
            for (const t of e1.split(/[\u2029\n]/)){
                const e1 = s.encodeString(t).join(""), i = s.charsToGlyphs(e1);
                for (const e1 of i){
                    const t = e1.width || C;
                    this.glyphs.push([
                        t * c + a,
                        n,
                        o,
                        e1.unicode,
                        !1
                    ]);
                }
                this.glyphs.push([
                    0,
                    0,
                    0,
                    "\n",
                    !0
                ]);
            }
            this.glyphs.pop();
        } else {
            for (const t of e1.split(/[\u2029\n]/)){
                for (const e1 of t.split(""))this.glyphs.push([
                    i,
                    1.2 * i,
                    i,
                    e1,
                    !1
                ]);
                this.glyphs.push([
                    0,
                    0,
                    0,
                    "\n",
                    !0
                ]);
            }
            this.glyphs.pop();
        }
    }
    compute(e1) {
        let t = -1, i = 0, a = 0, s = 0, r = 0, n = 0, g = !1, o = !0;
        for(let c = 0, C = this.glyphs.length; c < C; c++){
            const [C, h, l, Q, E] = this.glyphs[c], u = " " === Q, d = o ? l : h;
            if (E) {
                a = Math.max(a, r);
                r = 0;
                s += n;
                n = d;
                t = -1;
                i = 0;
                o = !1;
            } else if (u) if (r + C > e1) {
                a = Math.max(a, r);
                r = 0;
                s += n;
                n = d;
                t = -1;
                i = 0;
                g = !0;
                o = !1;
            } else {
                n = Math.max(d, n);
                i = r;
                r += C;
                t = c;
            }
            else if (r + C > e1) {
                s += n;
                n = d;
                if (-1 !== t) {
                    c = t;
                    a = Math.max(a, i);
                    r = 0;
                    t = -1;
                    i = 0;
                } else {
                    a = Math.max(a, r);
                    r = C;
                }
                g = !0;
                o = !1;
            } else {
                r += C;
                n = Math.max(d, n);
            }
        }
        a = Math.max(a, r);
        s += n + this.extraHeight;
        return {
            width: 1.02 * a,
            height: s,
            isBroken: g
        };
    }
}
const en = /^[^.[]+/, tn = /^[^\]]+/, an = 0, sn = 1, rn = 2, nn = 3, gn = 4, on = new Map([
    [
        "$data",
        (e1, t)=>e1.datasets ? e1.datasets.data : e1
    ],
    [
        "$record",
        (e1, t)=>(e1.datasets ? e1.datasets.data : e1)[rr]()[0]
    ],
    [
        "$template",
        (e1, t)=>e1.template
    ],
    [
        "$connectionSet",
        (e1, t)=>e1.connectionSet
    ],
    [
        "$form",
        (e1, t)=>e1.form
    ],
    [
        "$layout",
        (e1, t)=>e1.layout
    ],
    [
        "$host",
        (e1, t)=>e1.host
    ],
    [
        "$dataWindow",
        (e1, t)=>e1.dataWindow
    ],
    [
        "$event",
        (e1, t)=>e1.event
    ],
    [
        "!",
        (e1, t)=>e1.datasets
    ],
    [
        "$xfa",
        (e1, t)=>e1
    ],
    [
        "xfa",
        (e1, t)=>e1
    ],
    [
        "$",
        (e1, t)=>t
    ]
]), In = new WeakMap;
function parseExpression(e1, t, i = !0) {
    let a = e1.match(en);
    if (!a) return null;
    let [s] = a;
    const r = [
        {
            name: s,
            cacheName: "." + s,
            index: 0,
            js: null,
            formCalc: null,
            operator: an
        }
    ];
    let n = s.length;
    for(; n < e1.length;){
        const o = n;
        if ("[" === e1.charAt(n++)) {
            a = e1.slice(n).match(tn);
            if (!a) {
                warn("XFA - Invalid index in SOM expression");
                return null;
            }
            r.at(-1).index = "*" === (g = (g = a[0]).trim()) ? 1 / 0 : parseInt(g, 10) || 0;
            n += a[0].length + 1;
            continue;
        }
        let c;
        switch(e1.charAt(n)){
            case ".":
                if (!t) return null;
                n++;
                c = sn;
                break;
            case "#":
                n++;
                c = rn;
                break;
            case "[":
                if (i) {
                    warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
                    return null;
                }
                c = nn;
                break;
            case "(":
                if (i) {
                    warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
                    return null;
                }
                c = gn;
                break;
            default:
                c = an;
        }
        a = e1.slice(n).match(en);
        if (!a) break;
        [s] = a;
        n += s.length;
        r.push({
            name: s,
            cacheName: e1.slice(o, n),
            operator: c,
            index: 0,
            js: null,
            formCalc: null
        });
    }
    var g;
    return r;
}
function searchNode(e1, t, i, a = !0, s = !0) {
    const r = parseExpression(i, a);
    if (!r) return null;
    const n = on.get(r[0].name);
    let g, o = 0;
    if (n) {
        g = !0;
        e1 = [
            n(e1, t)
        ];
        o = 1;
    } else {
        g = null === t;
        e1 = [
            t || e1
        ];
    }
    for(let i = r.length; o < i; o++){
        const { name: i, cacheName: a, operator: n, index: c } = r[o], C = [];
        for (const t of e1){
            if (!t.isXFAObject) continue;
            let e1, r;
            if (s) {
                r = In.get(t);
                if (!r) {
                    r = new Map;
                    In.set(t, r);
                }
                e1 = r.get(a);
            }
            if (!e1) {
                switch(n){
                    case an:
                        e1 = t[er](i, !1);
                        break;
                    case sn:
                        e1 = t[er](i, !0);
                        break;
                    case rn:
                        e1 = t[Ar](i);
                        e1 = e1.isXFAObjectArray ? e1.children : [
                            e1
                        ];
                }
                s && r.set(a, e1);
            }
            e1.length > 0 && C.push(e1);
        }
        if (0 !== C.length || g || 0 !== o) e1 = isFinite(c) ? C.filter((e1)=>c < e1.length).map((e1)=>e1[c]) : C.flat();
        else {
            const i = t[Ir]();
            if (!(t = i)) return null;
            o = -1;
            e1 = [
                t
            ];
        }
    }
    return 0 === e1.length ? null : e1;
}
function createDataNode(e1, t, i) {
    const a = parseExpression(i);
    if (!a) return null;
    if (a.some((e1)=>e1.operator === sn)) return null;
    const s = on.get(a[0].name);
    let r = 0;
    if (s) {
        e1 = s(e1, t);
        r = 1;
    } else e1 = t || e1;
    for(let t = a.length; r < t; r++){
        const { name: t, operator: i, index: s } = a[r];
        if (!isFinite(s)) {
            a[r].index = 0;
            return e1.createNodes(a.slice(r));
        }
        let n;
        switch(i){
            case an:
                n = e1[er](t, !1);
                break;
            case sn:
                n = e1[er](t, !0);
                break;
            case rn:
                n = e1[Ar](t);
                n = n.isXFAObjectArray ? n.children : [
                    n
                ];
        }
        if (0 === n.length) return e1.createNodes(a.slice(r));
        if (!(s < n.length)) {
            a[r].index = s - n.length;
            return e1.createNodes(a.slice(r));
        }
        {
            const t = n[s];
            if (!t.isXFAObject) {
                warn("XFA - Cannot create a node.");
                return null;
            }
            e1 = t;
        }
    }
    return null;
}
const cn = Symbol(), Cn = Symbol(), hn = Symbol(), ln = Symbol("_children"), Bn = Symbol(), Qn = Symbol(), En = Symbol(), un = Symbol(), dn = Symbol(), fn = Symbol(), pn = Symbol(), mn = Symbol(), yn = Symbol(), wn = Symbol("parent"), Dn = Symbol(), bn = Symbol(), Fn = Symbol();
let Sn = 0;
const kn = _r.datasets.id;
class XFAObject {
    constructor(e1, t, i = !1){
        this[Sr] = e1;
        this[kr] = t;
        this[pn] = i;
        this[wn] = null;
        this[ln] = [];
        this[Vr] = `${t}${Sn++}`;
        this[Cr] = null;
    }
    get isXFAObject() {
        return !0;
    }
    get isXFAObjectArray() {
        return !1;
    }
    createNodes(e1) {
        let t = this, i = null;
        for (const { name: a, index: s } of e1){
            for(let e1 = 0, r = isFinite(s) ? s : 0; e1 <= r; e1++){
                const e1 = t[Sr] === kn ? -1 : t[Sr];
                i = new XmlObject(e1, a);
                t[Hs](i);
            }
            t = i;
        }
        return i;
    }
    [Nr](e1) {
        if (!this[pn] || !this[Gr](e1)) return !1;
        const t = e1[kr], i = this[t];
        if (!(i instanceof XFAObjectArray)) {
            null !== i && this[Hr](i);
            this[t] = e1;
            this[Hs](e1);
            return !0;
        }
        if (i.push(e1)) {
            this[Hs](e1);
            return !0;
        }
        let a = "";
        this.id ? a = ` (id: ${this.id})` : this.name && (a = ` (name: ${this.name} ${this.h.value})`);
        warn(`XFA - node "${this[kr]}"${a} has already enough "${t}"!`);
        return !1;
    }
    [Gr](e1) {
        return this.hasOwnProperty(e1[kr]) && e1[Sr] === this[Sr];
    }
    [mr]() {
        return !1;
    }
    [xs]() {
        return !1;
    }
    [ur]() {
        return !1;
    }
    [dr]() {
        return !1;
    }
    [xr]() {
        this.para && this[cr]()[Xs].paraStack.pop();
    }
    [Lr]() {
        this[cr]()[Xs].paraStack.push(this.para);
    }
    [Kr](e1) {
        this.id && this[Sr] === _r.template.id && e1.set(this.id, this);
    }
    [cr]() {
        return this[Cr].template;
    }
    [yr]() {
        return !1;
    }
    [wr]() {
        return !1;
    }
    [Hs](e1) {
        e1[wn] = this;
        this[ln].push(e1);
        !e1[Cr] && this[Cr] && (e1[Cr] = this[Cr]);
    }
    [Hr](e1) {
        const t = this[ln].indexOf(e1);
        this[ln].splice(t, 1);
    }
    [hr]() {
        return this.hasOwnProperty("value");
    }
    [qr](e1) {}
    [Mr](e1) {}
    [Zs]() {}
    [Ys](e1) {
        delete this[pn];
        if (this[Ks]) {
            e1.clean(this[Ks]);
            delete this[Ks];
        }
    }
    [Qr](e1) {
        return this[ln].indexOf(e1);
    }
    [Er](e1, t) {
        t[wn] = this;
        this[ln].splice(e1, 0, t);
        !t[Cr] && this[Cr] && (t[Cr] = this[Cr]);
    }
    [Dr]() {
        return !this.name;
    }
    [Fr]() {
        return "";
    }
    [Pr]() {
        return 0 === this[ln].length ? this[Os] : this[ln].map((e1)=>e1[Pr]()).join("");
    }
    get [hn]() {
        const e1 = Object.getPrototypeOf(this);
        if (!e1._attributes) {
            const t = e1._attributes = new Set;
            for (const e1 of Object.getOwnPropertyNames(this)){
                if (null === this[e1] || this[e1] instanceof XFAObject || this[e1] instanceof XFAObjectArray) break;
                t.add(e1);
            }
        }
        return shadow(this, hn, e1._attributes);
    }
    [pr](e1) {
        let t = this;
        for(; t;){
            if (t === e1) return !0;
            t = t[Ir]();
        }
        return !1;
    }
    [Ir]() {
        return this[wn];
    }
    [or]() {
        return this[Ir]();
    }
    [rr](e1 = null) {
        return e1 ? this[e1] : this[ln];
    }
    [js]() {
        const e1 = Object.create(null);
        this[Os] && (e1.$content = this[Os]);
        for (const t of Object.getOwnPropertyNames(this)){
            const i = this[t];
            null !== i && (i instanceof XFAObject ? e1[t] = i[js]() : i instanceof XFAObjectArray ? i.isEmpty() || (e1[t] = i.dump()) : e1[t] = i);
        }
        return e1;
    }
    [Zr]() {
        return null;
    }
    [jr]() {
        return HTMLResult.EMPTY;
    }
    *[nr]() {
        for (const e1 of this[rr]())yield e1;
    }
    *[un](e1, t) {
        for (const i of this[nr]())if (!e1 || t === e1.has(i[kr])) {
            const e1 = this[$s](), t = i[jr](e1);
            t.success || (this[Xs].failingNode = i);
            yield t;
        }
    }
    [Vs]() {
        return null;
    }
    [Ls](e1, t) {
        this[Xs].children.push(e1);
    }
    [$s]() {}
    [Js]({ filter: e1 = null, include: t = !0 }) {
        if (this[Xs].generator) {
            const e1 = this[$s](), t = this[Xs].failingNode[jr](e1);
            if (!t.success) return t;
            t.html && this[Ls](t.html, t.bbox);
            delete this[Xs].failingNode;
        } else this[Xs].generator = this[un](e1, t);
        for(;;){
            const e1 = this[Xs].generator.next();
            if (e1.done) break;
            const t = e1.value;
            if (!t.success) return t;
            t.html && this[Ls](t.html, t.bbox);
        }
        this[Xs].generator = null;
        return HTMLResult.EMPTY;
    }
    [Tr](e1) {
        this[bn] = new Set(Object.keys(e1));
    }
    [fn](e1) {
        const t = this[hn], i = this[bn];
        return [
            ...e1
        ].filter((e1)=>t.has(e1) && !i.has(e1));
    }
    [Yr](e1, t = new Set) {
        for (const i of this[ln])i[Dn](e1, t);
    }
    [Dn](e1, t) {
        const i = this[dn](e1, t);
        i ? this[cn](i, e1, t) : this[Yr](e1, t);
    }
    [dn](e1, t) {
        const { use: i, usehref: a } = this;
        if (!i && !a) return null;
        let s = null, r = null, n = null, g = i;
        if (a) {
            g = a;
            a.startsWith("#som(") && a.endsWith(")") ? r = a.slice(5, -1) : a.startsWith(".#som(") && a.endsWith(")") ? r = a.slice(6, -1) : a.startsWith("#") ? n = a.slice(1) : a.startsWith(".#") && (n = a.slice(2));
        } else i.startsWith("#") ? n = i.slice(1) : r = i;
        this.use = this.usehref = "";
        if (n) s = e1.get(n);
        else {
            s = searchNode(e1.get(Jr), this, r, !0, !1);
            s && (s = s[0]);
        }
        if (!s) {
            warn(`XFA - Invalid prototype reference: ${g}.`);
            return null;
        }
        if (s[kr] !== this[kr]) {
            warn(`XFA - Incompatible prototype: ${s[kr]} !== ${this[kr]}.`);
            return null;
        }
        if (t.has(s)) {
            warn("XFA - Cycle detected in prototypes use.");
            return null;
        }
        t.add(s);
        const o = s[dn](e1, t);
        o && s[cn](o, e1, t);
        s[Yr](e1, t);
        t.delete(s);
        return s;
    }
    [cn](e1, t, i) {
        if (i.has(e1)) {
            warn("XFA - Cycle detected in prototypes use.");
            return;
        }
        !this[Os] && e1[Os] && (this[Os] = e1[Os]);
        new Set(i).add(e1);
        for (const t of this[fn](e1[bn])){
            this[t] = e1[t];
            this[bn] && this[bn].add(t);
        }
        for (const a of Object.getOwnPropertyNames(this)){
            if (this[hn].has(a)) continue;
            const s = this[a], r = e1[a];
            if (s instanceof XFAObjectArray) {
                for (const e1 of s[ln])e1[Dn](t, i);
                for(let a = s[ln].length, n = r[ln].length; a < n; a++){
                    const r = e1[ln][a][Ts]();
                    if (!s.push(r)) break;
                    r[wn] = this;
                    this[ln].push(r);
                    r[Dn](t, i);
                }
            } else if (null === s) {
                if (null !== r) {
                    const e1 = r[Ts]();
                    e1[wn] = this;
                    this[a] = e1;
                    this[ln].push(e1);
                    e1[Dn](t, i);
                }
            } else {
                s[Yr](t, i);
                r && s[cn](r, t, i);
            }
        }
    }
    static [Bn](e1) {
        return Array.isArray(e1) ? e1.map((e1)=>XFAObject[Bn](e1)) : "object" == typeof e1 && null !== e1 ? Object.assign({}, e1) : e1;
    }
    [Ts]() {
        const e1 = Object.create(Object.getPrototypeOf(this));
        for (const t of Object.getOwnPropertySymbols(this))try {
            e1[t] = this[t];
        } catch  {
            shadow(e1, t, this[t]);
        }
        e1[Vr] = `${e1[kr]}${Sn++}`;
        e1[ln] = [];
        for (const t of Object.getOwnPropertyNames(this)){
            if (this[hn].has(t)) {
                e1[t] = XFAObject[Bn](this[t]);
                continue;
            }
            const i = this[t];
            e1[t] = i instanceof XFAObjectArray ? new XFAObjectArray(i[mn]) : null;
        }
        for (const t of this[ln]){
            const i = t[kr], a = t[Ts]();
            e1[ln].push(a);
            a[wn] = e1;
            null === e1[i] ? e1[i] = a : e1[i][ln].push(a);
        }
        return e1;
    }
    [rr](e1 = null) {
        return e1 ? this[ln].filter((t)=>t[kr] === e1) : this[ln];
    }
    [Ar](e1) {
        return this[e1];
    }
    [er](e1, t, i = !0) {
        return Array.from(this[tr](e1, t, i));
    }
    *[tr](e1, t, i = !0) {
        if ("parent" !== e1) {
            for (const i of this[ln]){
                i[kr] === e1 && (yield i);
                i.name === e1 && (yield i);
                (t || i[Dr]()) && (yield* i[tr](e1, t, !1));
            }
            i && this[hn].has(e1) && (yield new XFAAttribute(this, e1, this[e1]));
        } else yield this[wn];
    }
}
class XFAObjectArray {
    constructor(e1 = 1 / 0){
        this[mn] = e1;
        this[ln] = [];
    }
    get isXFAObject() {
        return !1;
    }
    get isXFAObjectArray() {
        return !0;
    }
    push(e1) {
        if (this[ln].length <= this[mn]) {
            this[ln].push(e1);
            return !0;
        }
        warn(`XFA - node "${e1[kr]}" accepts no more than ${this[mn]} children`);
        return !1;
    }
    isEmpty() {
        return 0 === this[ln].length;
    }
    dump() {
        return 1 === this[ln].length ? this[ln][0][js]() : this[ln].map((e1)=>e1[js]());
    }
    [Ts]() {
        const e1 = new XFAObjectArray(this[mn]);
        e1[ln] = this[ln].map((e1)=>e1[Ts]());
        return e1;
    }
    get children() {
        return this[ln];
    }
    clear() {
        this[ln].length = 0;
    }
}
class XFAAttribute {
    constructor(e1, t, i){
        this[wn] = e1;
        this[kr] = t;
        this[Os] = i;
        this[qs] = !1;
        this[Vr] = "attribute" + Sn++;
    }
    [Ir]() {
        return this[wn];
    }
    [fr]() {
        return !0;
    }
    [ir]() {
        return this[Os].trim();
    }
    [qr](e1) {
        e1 = e1.value || "";
        this[Os] = e1.toString();
    }
    [Pr]() {
        return this[Os];
    }
    [pr](e1) {
        return this[wn] === e1 || this[wn][pr](e1);
    }
}
class XmlObject extends XFAObject {
    constructor(e1, t, i = {}){
        super(e1, t);
        this[Os] = "";
        this[Qn] = null;
        if ("#text" !== t) {
            const e1 = new Map;
            this[Cn] = e1;
            for (const [t, a] of Object.entries(i))e1.set(t, new XFAAttribute(this, t, a));
            if (i.hasOwnProperty(Rr)) {
                const e1 = i[Rr].xfa.dataNode;
                void 0 !== e1 && ("dataGroup" === e1 ? this[Qn] = !1 : "dataValue" === e1 && (this[Qn] = !0));
            }
        }
        this[qs] = !1;
    }
    [Xr](e1) {
        const t = this[kr];
        if ("#text" === t) {
            e1.push(encodeToXmlString(this[Os]));
            return;
        }
        const i = utf8StringToString(t), a = this[Sr] === kn ? "xfa:" : "";
        e1.push(`<${a}${i}`);
        for (const [t, i] of this[Cn].entries()){
            const a = utf8StringToString(t);
            e1.push(` ${a}="${encodeToXmlString(i[Os])}"`);
        }
        null !== this[Qn] && (this[Qn] ? e1.push(' xfa:dataNode="dataValue"') : e1.push(' xfa:dataNode="dataGroup"'));
        if (this[Os] || 0 !== this[ln].length) {
            e1.push(">");
            if (this[Os]) "string" == typeof this[Os] ? e1.push(encodeToXmlString(this[Os])) : this[Os][Xr](e1);
            else for (const t of this[ln])t[Xr](e1);
            e1.push(`</${a}${i}>`);
        } else e1.push("/>");
    }
    [Nr](e1) {
        if (this[Os]) {
            const e1 = new XmlObject(this[Sr], "#text");
            this[Hs](e1);
            e1[Os] = this[Os];
            this[Os] = "";
        }
        this[Hs](e1);
        return !0;
    }
    [Mr](e1) {
        this[Os] += e1;
    }
    [Zs]() {
        if (this[Os] && this[ln].length > 0) {
            const e1 = new XmlObject(this[Sr], "#text");
            this[Hs](e1);
            e1[Os] = this[Os];
            delete this[Os];
        }
    }
    [jr]() {
        return "#text" === this[kr] ? HTMLResult.success({
            name: "#text",
            value: this[Os]
        }) : HTMLResult.EMPTY;
    }
    [rr](e1 = null) {
        return e1 ? this[ln].filter((t)=>t[kr] === e1) : this[ln];
    }
    [_s]() {
        return this[Cn];
    }
    [Ar](e1) {
        const t = this[Cn].get(e1);
        return void 0 !== t ? t : this[rr](e1);
    }
    *[tr](e1, t) {
        const i = this[Cn].get(e1);
        i && (yield i);
        for (const i of this[ln]){
            i[kr] === e1 && (yield i);
            t && (yield* i[tr](e1, t));
        }
    }
    *[zs](e1, t) {
        const i = this[Cn].get(e1);
        !i || t && i[qs] || (yield i);
        for (const i of this[ln])yield* i[zs](e1, t);
    }
    *[sr](e1, t, i) {
        for (const a of this[ln]){
            a[kr] !== e1 || i && a[qs] || (yield a);
            t && (yield* a[sr](e1, t, i));
        }
    }
    [fr]() {
        return null === this[Qn] ? 0 === this[ln].length || this[ln][0][Sr] === _r.xhtml.id : this[Qn];
    }
    [ir]() {
        return null === this[Qn] ? 0 === this[ln].length ? this[Os].trim() : this[ln][0][Sr] === _r.xhtml.id ? this[ln][0][Pr]().trim() : null : this[Os].trim();
    }
    [qr](e1) {
        e1 = e1.value || "";
        this[Os] = e1.toString();
    }
    [js](e1 = !1) {
        const t = Object.create(null);
        e1 && (t.$ns = this[Sr]);
        this[Os] && (t.$content = this[Os]);
        t.$name = this[kr];
        t.children = [];
        for (const i of this[ln])t.children.push(i[js](e1));
        t.attributes = Object.create(null);
        for (const [e1, i] of this[Cn])t.attributes[e1] = i[Os];
        return t;
    }
}
class ContentObject extends XFAObject {
    constructor(e1, t){
        super(e1, t);
        this[Os] = "";
    }
    [Mr](e1) {
        this[Os] += e1;
    }
    [Zs]() {}
}
class OptionObject extends ContentObject {
    constructor(e1, t, i){
        super(e1, t);
        this[yn] = i;
    }
    [Zs]() {
        this[Os] = getKeyword({
            data: this[Os],
            defaultValue: this[yn][0],
            validate: (e1)=>this[yn].includes(e1)
        });
    }
    [Ys](e1) {
        super[Ys](e1);
        delete this[yn];
    }
}
class StringObject extends ContentObject {
    [Zs]() {
        this[Os] = this[Os].trim();
    }
}
class IntegerObject extends ContentObject {
    constructor(e1, t, i, a){
        super(e1, t);
        this[En] = i;
        this[Fn] = a;
    }
    [Zs]() {
        this[Os] = getInteger({
            data: this[Os],
            defaultValue: this[En],
            validate: this[Fn]
        });
    }
    [Ys](e1) {
        super[Ys](e1);
        delete this[En];
        delete this[Fn];
    }
}
class Option01 extends IntegerObject {
    constructor(e1, t){
        super(e1, t, 0, (e1)=>1 === e1);
    }
}
class Option10 extends IntegerObject {
    constructor(e1, t){
        super(e1, t, 1, (e1)=>0 === e1);
    }
}
function measureToString(e1) {
    return "string" == typeof e1 ? "0px" : Number.isInteger(e1) ? `${e1}px` : `${e1.toFixed(2)}px`;
}
const Rn = {
    anchorType (e1, t) {
        const i = e1[or]();
        if (i && (!i.layout || "position" === i.layout)) {
            "transform" in t || (t.transform = "");
            switch(e1.anchorType){
                case "bottomCenter":
                    t.transform += "translate(-50%, -100%)";
                    break;
                case "bottomLeft":
                    t.transform += "translate(0,-100%)";
                    break;
                case "bottomRight":
                    t.transform += "translate(-100%,-100%)";
                    break;
                case "middleCenter":
                    t.transform += "translate(-50%,-50%)";
                    break;
                case "middleLeft":
                    t.transform += "translate(0,-50%)";
                    break;
                case "middleRight":
                    t.transform += "translate(-100%,-50%)";
                    break;
                case "topCenter":
                    t.transform += "translate(-50%,0)";
                    break;
                case "topRight":
                    t.transform += "translate(-100%,0)";
            }
        }
    },
    dimensions (e1, t) {
        const i = e1[or]();
        let a = e1.w;
        const s = e1.h;
        if (i.layout?.includes("row")) {
            const t = i[Xs], s = e1.colSpan;
            let r;
            if (-1 === s) {
                r = t.columnWidths.slice(t.currentColumn).reduce((e1, t)=>e1 + t, 0);
                t.currentColumn = 0;
            } else {
                r = t.columnWidths.slice(t.currentColumn, t.currentColumn + s).reduce((e1, t)=>e1 + t, 0);
                t.currentColumn = (t.currentColumn + e1.colSpan) % t.columnWidths.length;
            }
            isNaN(r) || (a = e1.w = r);
        }
        t.width = "" !== a ? measureToString(a) : "auto";
        t.height = "" !== s ? measureToString(s) : "auto";
    },
    position (e1, t) {
        const i = e1[or]();
        if (!i?.layout || "position" === i.layout) {
            t.position = "absolute";
            t.left = measureToString(e1.x);
            t.top = measureToString(e1.y);
        }
    },
    rotate (e1, t) {
        if (e1.rotate) {
            "transform" in t || (t.transform = "");
            t.transform += `rotate(-${e1.rotate}deg)`;
            t.transformOrigin = "top left";
        }
    },
    presence (e1, t) {
        switch(e1.presence){
            case "invisible":
                t.visibility = "hidden";
                break;
            case "hidden":
            case "inactive":
                t.display = "none";
        }
    },
    hAlign (e1, t) {
        if ("para" === e1[kr]) switch(e1.hAlign){
            case "justifyAll":
                t.textAlign = "justify-all";
                break;
            case "radix":
                t.textAlign = "left";
                break;
            default:
                t.textAlign = e1.hAlign;
        }
        else switch(e1.hAlign){
            case "left":
                t.alignSelf = "start";
                break;
            case "center":
                t.alignSelf = "center";
                break;
            case "right":
                t.alignSelf = "end";
        }
    },
    margin (e1, t) {
        e1.margin && (t.margin = e1.margin[Zr]().margin);
    }
};
function setMinMaxDimensions(e1, t) {
    if ("position" === e1[or]().layout) {
        e1.minW > 0 && (t.minWidth = measureToString(e1.minW));
        e1.maxW > 0 && (t.maxWidth = measureToString(e1.maxW));
        e1.minH > 0 && (t.minHeight = measureToString(e1.minH));
        e1.maxH > 0 && (t.maxHeight = measureToString(e1.maxH));
    }
}
function layoutText(e1, t, i, a, s, r) {
    const n = new TextMeasure(t, i, a, s);
    "string" == typeof e1 ? n.addString(e1) : e1[Ur](n);
    return n.compute(r);
}
function layoutNode(e1, t) {
    let i = null, a = null, s = !1;
    if ((!e1.w || !e1.h) && e1.value) {
        let r = 0, n = 0;
        if (e1.margin) {
            r = e1.margin.leftInset + e1.margin.rightInset;
            n = e1.margin.topInset + e1.margin.bottomInset;
        }
        let g = null, o = null;
        if (e1.para) {
            o = Object.create(null);
            g = "" === e1.para.lineHeight ? null : e1.para.lineHeight;
            o.top = "" === e1.para.spaceAbove ? 0 : e1.para.spaceAbove;
            o.bottom = "" === e1.para.spaceBelow ? 0 : e1.para.spaceBelow;
            o.left = "" === e1.para.marginLeft ? 0 : e1.para.marginLeft;
            o.right = "" === e1.para.marginRight ? 0 : e1.para.marginRight;
        }
        let c = e1.font;
        if (!c) {
            const t = e1[cr]();
            let i = e1[Ir]();
            for(; i && i !== t;){
                if (i.font) {
                    c = i.font;
                    break;
                }
                i = i[Ir]();
            }
        }
        const C = (e1.w || t.width) - r, h = e1[Cr].fontFinder;
        if (e1.value.exData && e1.value.exData[Os] && "text/html" === e1.value.exData.contentType) {
            const t = layoutText(e1.value.exData[Os], c, o, g, h, C);
            a = t.width;
            i = t.height;
            s = t.isBroken;
        } else {
            const t = e1.value[Pr]();
            if (t) {
                const e1 = layoutText(t, c, o, g, h, C);
                a = e1.width;
                i = e1.height;
                s = e1.isBroken;
            }
        }
        null === a || e1.w || (a += r);
        null === i || e1.h || (i += n);
    }
    return {
        w: a,
        h: i,
        isBroken: s
    };
}
function computeBbox(e1, t, i) {
    let a;
    if ("" !== e1.w && "" !== e1.h) a = [
        e1.x,
        e1.y,
        e1.w,
        e1.h
    ];
    else {
        if (!i) return null;
        let s = e1.w;
        if ("" === s) {
            if (0 === e1.maxW) {
                const t = e1[or]();
                s = "position" === t.layout && "" !== t.w ? 0 : e1.minW;
            } else s = Math.min(e1.maxW, i.width);
            t.attributes.style.width = measureToString(s);
        }
        let r = e1.h;
        if ("" === r) {
            if (0 === e1.maxH) {
                const t = e1[or]();
                r = "position" === t.layout && "" !== t.h ? 0 : e1.minH;
            } else r = Math.min(e1.maxH, i.height);
            t.attributes.style.height = measureToString(r);
        }
        a = [
            e1.x,
            e1.y,
            s,
            r
        ];
    }
    return a;
}
function fixDimensions(e1) {
    const t = e1[or]();
    if (t.layout?.includes("row")) {
        const i = t[Xs], a = e1.colSpan;
        let s;
        s = -1 === a ? i.columnWidths.slice(i.currentColumn).reduce((e1, t)=>e1 + t, 0) : i.columnWidths.slice(i.currentColumn, i.currentColumn + a).reduce((e1, t)=>e1 + t, 0);
        isNaN(s) || (e1.w = s);
    }
    t.layout && "position" !== t.layout && (e1.x = e1.y = 0);
    "table" === e1.layout && "" === e1.w && Array.isArray(e1.columnWidths) && (e1.w = e1.columnWidths.reduce((e1, t)=>e1 + t, 0));
}
function layoutClass(e1) {
    switch(e1.layout){
        case "position":
        default:
            return "xfaPosition";
        case "lr-tb":
            return "xfaLrTb";
        case "rl-row":
            return "xfaRlRow";
        case "rl-tb":
            return "xfaRlTb";
        case "row":
            return "xfaRow";
        case "table":
            return "xfaTable";
        case "tb":
            return "xfaTb";
    }
}
function toStyle(e1, ...t) {
    const i = Object.create(null);
    for (const a of t){
        const t = e1[a];
        if (null !== t) {
            if (Rn.hasOwnProperty(a)) Rn[a](e1, i);
            else if (t instanceof XFAObject) {
                const e1 = t[Zr]();
                e1 ? Object.assign(i, e1) : warn(`(DEBUG) - XFA - style for ${a} not implemented yet`);
            }
        }
    }
    return i;
}
function createWrapper(e1, t) {
    const { attributes: i } = t, { style: a } = i, s = {
        name: "div",
        attributes: {
            class: [
                "xfaWrapper"
            ],
            style: Object.create(null)
        },
        children: []
    };
    i.class.push("xfaWrapped");
    if (e1.border) {
        const { widths: i, insets: r } = e1.border[Xs];
        let n, g, o = r[0], c = r[3];
        const C = r[0] + r[2], h = r[1] + r[3];
        switch(e1.border.hand){
            case "even":
                o -= i[0] / 2;
                c -= i[3] / 2;
                n = `calc(100% + ${(i[1] + i[3]) / 2 - h}px)`;
                g = `calc(100% + ${(i[0] + i[2]) / 2 - C}px)`;
                break;
            case "left":
                o -= i[0];
                c -= i[3];
                n = `calc(100% + ${i[1] + i[3] - h}px)`;
                g = `calc(100% + ${i[0] + i[2] - C}px)`;
                break;
            case "right":
                n = h ? `calc(100% - ${h}px)` : "100%";
                g = C ? `calc(100% - ${C}px)` : "100%";
        }
        const l = [
            "xfaBorder"
        ];
        isPrintOnly(e1.border) && l.push("xfaPrintOnly");
        const Q = {
            name: "div",
            attributes: {
                class: l,
                style: {
                    top: `${o}px`,
                    left: `${c}px`,
                    width: n,
                    height: g
                }
            },
            children: []
        };
        for (const e1 of [
            "border",
            "borderWidth",
            "borderColor",
            "borderRadius",
            "borderStyle"
        ])if (void 0 !== a[e1]) {
            Q.attributes.style[e1] = a[e1];
            delete a[e1];
        }
        s.children.push(Q, t);
    } else s.children.push(t);
    for (const e1 of [
        "background",
        "backgroundClip",
        "top",
        "left",
        "width",
        "height",
        "minWidth",
        "minHeight",
        "maxWidth",
        "maxHeight",
        "transform",
        "transformOrigin",
        "visibility"
    ])if (void 0 !== a[e1]) {
        s.attributes.style[e1] = a[e1];
        delete a[e1];
    }
    s.attributes.style.position = "absolute" === a.position ? "absolute" : "relative";
    delete a.position;
    if (a.alignSelf) {
        s.attributes.style.alignSelf = a.alignSelf;
        delete a.alignSelf;
    }
    return s;
}
function fixTextIndent(e1) {
    const t = getMeasurement(e1.textIndent, "0px");
    if (t >= 0) return;
    const i = "padding" + ("left" === ("right" === e1.textAlign ? "right" : "left") ? "Left" : "Right"), a = getMeasurement(e1[i], "0px");
    e1[i] = a - t + "px";
}
function setAccess(e1, t) {
    switch(e1.access){
        case "nonInteractive":
            t.push("xfaNonInteractive");
            break;
        case "readOnly":
            t.push("xfaReadOnly");
            break;
        case "protected":
            t.push("xfaDisabled");
    }
}
function isPrintOnly(e1) {
    return e1.relevant.length > 0 && !e1.relevant[0].excluded && "print" === e1.relevant[0].viewname;
}
function getCurrentPara(e1) {
    const t = e1[cr]()[Xs].paraStack;
    return t.length ? t.at(-1) : null;
}
function setPara(e1, t, i) {
    if (i.attributes.class?.includes("xfaRich")) {
        if (t) {
            "" === e1.h && (t.height = "auto");
            "" === e1.w && (t.width = "auto");
        }
        const a = getCurrentPara(e1);
        if (a) {
            const e1 = i.attributes.style;
            e1.display = "flex";
            e1.flexDirection = "column";
            switch(a.vAlign){
                case "top":
                    e1.justifyContent = "start";
                    break;
                case "bottom":
                    e1.justifyContent = "end";
                    break;
                case "middle":
                    e1.justifyContent = "center";
            }
            const t = a[Zr]();
            for (const [i, a] of Object.entries(t))i in e1 || (e1[i] = a);
        }
    }
}
function setFontFamily(e1, t, i, a) {
    if (!i) {
        delete a.fontFamily;
        return;
    }
    const s = stripQuotes(e1.typeface);
    a.fontFamily = `"${s}"`;
    const r = i.find(s);
    if (r) {
        const { fontFamily: i } = r.regular.cssFontInfo;
        i !== s && (a.fontFamily = `"${i}"`);
        const n = getCurrentPara(t);
        if (n && "" !== n.lineHeight) return;
        if (a.lineHeight) return;
        const g = selectFont(e1, r);
        g && (a.lineHeight = Math.max(1.2, g.lineHeight));
    }
}
function fixURL(e1) {
    const t = createValidAbsoluteUrl(e1, null, {
        addDefaultProtocol: !0,
        tryConvertEncoding: !0
    });
    return t ? t.href : null;
}
function createLine(e1, t) {
    return {
        name: "div",
        attributes: {
            class: [
                "lr-tb" === e1.layout ? "xfaLr" : "xfaRl"
            ]
        },
        children: t
    };
}
function flushHTML(e1) {
    if (!e1[Xs]) return null;
    const t = {
        name: "div",
        attributes: e1[Xs].attributes,
        children: e1[Xs].children
    };
    if (e1[Xs].failingNode) {
        const i = e1[Xs].failingNode[Vs]();
        i && (e1.layout.endsWith("-tb") ? t.children.push(createLine(e1, [
            i
        ])) : t.children.push(i));
    }
    return 0 === t.children.length ? null : t;
}
function addHTML(e1, t, i) {
    const a = e1[Xs], s = a.availableSpace, [r, n, g, o] = i;
    switch(e1.layout){
        case "position":
            a.width = Math.max(a.width, r + g);
            a.height = Math.max(a.height, n + o);
            a.children.push(t);
            break;
        case "lr-tb":
        case "rl-tb":
            if (!a.line || 1 === a.attempt) {
                a.line = createLine(e1, []);
                a.children.push(a.line);
                a.numberInLine = 0;
            }
            a.numberInLine += 1;
            a.line.children.push(t);
            if (0 === a.attempt) {
                a.currentWidth += g;
                a.height = Math.max(a.height, a.prevHeight + o);
            } else {
                a.currentWidth = g;
                a.prevHeight = a.height;
                a.height += o;
                a.attempt = 0;
            }
            a.width = Math.max(a.width, a.currentWidth);
            break;
        case "rl-row":
        case "row":
            {
                a.children.push(t);
                a.width += g;
                a.height = Math.max(a.height, o);
                const e1 = measureToString(a.height);
                for (const t of a.children)t.attributes.style.height = e1;
                break;
            }
        case "table":
        case "tb":
            a.width = Math.min(s.width, Math.max(a.width, g));
            a.height += o;
            a.children.push(t);
    }
}
function getAvailableSpace(e1) {
    const t = e1[Xs].availableSpace, i = e1.margin ? e1.margin.topInset + e1.margin.bottomInset : 0, a = e1.margin ? e1.margin.leftInset + e1.margin.rightInset : 0;
    switch(e1.layout){
        case "lr-tb":
        case "rl-tb":
            return 0 === e1[Xs].attempt ? {
                width: t.width - a - e1[Xs].currentWidth,
                height: t.height - i - e1[Xs].prevHeight
            } : {
                width: t.width - a,
                height: t.height - i - e1[Xs].height
            };
        case "rl-row":
        case "row":
            return {
                width: e1[Xs].columnWidths.slice(e1[Xs].currentColumn).reduce((e1, t)=>e1 + t),
                height: t.height - a
            };
        case "table":
        case "tb":
            return {
                width: t.width - a,
                height: t.height - i - e1[Xs].height
            };
        default:
            return t;
    }
}
function checkDimensions(e1, t) {
    if (null === e1[cr]()[Xs].firstUnsplittable) return !0;
    if (0 === e1.w || 0 === e1.h) return !0;
    const i = e1[or](), a = i[Xs]?.attempt || 0, [, s, r, n] = function getTransformedBBox(e1) {
        let t, i, a = "" === e1.w ? NaN : e1.w, s = "" === e1.h ? NaN : e1.h, [r, n] = [
            0,
            0
        ];
        switch(e1.anchorType || ""){
            case "bottomCenter":
                [r, n] = [
                    a / 2,
                    s
                ];
                break;
            case "bottomLeft":
                [r, n] = [
                    0,
                    s
                ];
                break;
            case "bottomRight":
                [r, n] = [
                    a,
                    s
                ];
                break;
            case "middleCenter":
                [r, n] = [
                    a / 2,
                    s / 2
                ];
                break;
            case "middleLeft":
                [r, n] = [
                    0,
                    s / 2
                ];
                break;
            case "middleRight":
                [r, n] = [
                    a,
                    s / 2
                ];
                break;
            case "topCenter":
                [r, n] = [
                    a / 2,
                    0
                ];
                break;
            case "topRight":
                [r, n] = [
                    a,
                    0
                ];
        }
        switch(e1.rotate || 0){
            case 0:
                [t, i] = [
                    -r,
                    -n
                ];
                break;
            case 90:
                [t, i] = [
                    -n,
                    r
                ];
                [a, s] = [
                    s,
                    -a
                ];
                break;
            case 180:
                [t, i] = [
                    r,
                    n
                ];
                [a, s] = [
                    -a,
                    -s
                ];
                break;
            case 270:
                [t, i] = [
                    n,
                    -r
                ];
                [a, s] = [
                    -s,
                    a
                ];
        }
        return [
            e1.x + t + Math.min(0, a),
            e1.y + i + Math.min(0, s),
            Math.abs(a),
            Math.abs(s)
        ];
    }(e1);
    switch(i.layout){
        case "lr-tb":
        case "rl-tb":
            return 0 === a ? e1[cr]()[Xs].noLayoutFailure ? "" !== e1.w ? Math.round(r - t.width) <= 2 : t.width > 2 : !("" !== e1.h && Math.round(n - t.height) > 2) && ("" !== e1.w ? Math.round(r - t.width) <= 2 || 0 === i[Xs].numberInLine && t.height > 2 : t.width > 2) : !!e1[cr]()[Xs].noLayoutFailure || !("" !== e1.h && Math.round(n - t.height) > 2) && ("" === e1.w || Math.round(r - t.width) <= 2 || !i[wr]()) && t.height > 2;
        case "table":
        case "tb":
            return !!e1[cr]()[Xs].noLayoutFailure || ("" === e1.h || e1[yr]() ? ("" === e1.w || Math.round(r - t.width) <= 2 || !i[wr]()) && t.height > 2 : Math.round(n - t.height) <= 2);
        case "position":
            if (e1[cr]()[Xs].noLayoutFailure) return !0;
            if ("" === e1.h || Math.round(n + s - t.height) <= 2) return !0;
            return n + s > e1[cr]()[Xs].currentContentArea.h;
        case "rl-row":
        case "row":
            return !!e1[cr]()[Xs].noLayoutFailure || "" === e1.h || Math.round(n - t.height) <= 2;
        default:
            return !0;
    }
}
const Nn = _r.template.id, Gn = "http://www.w3.org/2000/svg", Mn = /^H(\d+)$/, Un = new Set([
    "image/gif",
    "image/jpeg",
    "image/jpg",
    "image/pjpeg",
    "image/png",
    "image/apng",
    "image/x-png",
    "image/bmp",
    "image/x-ms-bmp",
    "image/tiff",
    "image/tif",
    "application/octet-stream"
]), xn = [
    [
        [
            66,
            77
        ],
        "image/bmp"
    ],
    [
        [
            255,
            216,
            255
        ],
        "image/jpeg"
    ],
    [
        [
            73,
            73,
            42,
            0
        ],
        "image/tiff"
    ],
    [
        [
            77,
            77,
            0,
            42
        ],
        "image/tiff"
    ],
    [
        [
            71,
            73,
            70,
            56,
            57,
            97
        ],
        "image/gif"
    ],
    [
        [
            137,
            80,
            78,
            71,
            13,
            10,
            26,
            10
        ],
        "image/png"
    ]
];
function getBorderDims(e1) {
    if (!e1 || !e1.border) return {
        w: 0,
        h: 0
    };
    const t = e1.border[ar]();
    return t ? {
        w: t.widths[0] + t.widths[2] + t.insets[0] + t.insets[2],
        h: t.widths[1] + t.widths[3] + t.insets[1] + t.insets[3]
    } : {
        w: 0,
        h: 0
    };
}
function hasMargin(e1) {
    return e1.margin && (e1.margin.topInset || e1.margin.rightInset || e1.margin.bottomInset || e1.margin.leftInset);
}
function _setValue(e1, t) {
    if (!e1.value) {
        const t = new Value({});
        e1[Hs](t);
        e1.value = t;
    }
    e1.value[qr](t);
}
function* getContainedChildren(e1) {
    for (const t of e1[rr]())t instanceof SubformSet ? yield* t[nr]() : yield t;
}
function isRequired(e1) {
    return "error" === e1.validate?.nullTest;
}
function setTabIndex(e1) {
    for(; e1;){
        if (!e1.traversal) {
            e1[Or] = e1[Ir]()[Or];
            return;
        }
        if (e1[Or]) return;
        let t = null;
        for (const i of e1.traversal[rr]())if ("next" === i.operation) {
            t = i;
            break;
        }
        if (!t || !t.ref) {
            e1[Or] = e1[Ir]()[Or];
            return;
        }
        const i = e1[cr]();
        e1[Or] = ++i[Or];
        const a = i[vr](t.ref, e1);
        if (!a) return;
        e1 = a[0];
    }
}
function applyAssist(e1, t) {
    const i = e1.assist;
    if (i) {
        const e1 = i[jr]();
        e1 && (t.title = e1);
        const a = i.role.match(Mn);
        if (a) {
            const e1 = "heading", i = a[1];
            t.role = e1;
            t["aria-level"] = i;
        }
    }
    if ("table" === e1.layout) t.role = "table";
    else if ("row" === e1.layout) t.role = "row";
    else {
        const i = e1[Ir]();
        "row" === i.layout && (t.role = "TH" === i.assist?.role ? "columnheader" : "cell");
    }
}
function ariaLabel(e1) {
    if (!e1.assist) return null;
    const t = e1.assist;
    return t.speak && "" !== t.speak[Os] ? t.speak[Os] : t.toolTip ? t.toolTip[Os] : null;
}
function valueToHtml(e1) {
    return HTMLResult.success({
        name: "div",
        attributes: {
            class: [
                "xfaRich"
            ],
            style: Object.create(null)
        },
        children: [
            {
                name: "span",
                attributes: {
                    style: Object.create(null)
                },
                value: e1
            }
        ]
    });
}
function setFirstUnsplittable(e1) {
    const t = e1[cr]();
    if (null === t[Xs].firstUnsplittable) {
        t[Xs].firstUnsplittable = e1;
        t[Xs].noLayoutFailure = !0;
    }
}
function unsetFirstUnsplittable(e1) {
    const t = e1[cr]();
    t[Xs].firstUnsplittable === e1 && (t[Xs].noLayoutFailure = !1);
}
function handleBreak(e1) {
    if (e1[Xs]) return !1;
    e1[Xs] = Object.create(null);
    if ("auto" === e1.targetType) return !1;
    const t = e1[cr]();
    let i = null;
    if (e1.target) {
        i = t[vr](e1.target, e1[Ir]());
        if (!i) return !1;
        i = i[0];
    }
    const { currentPageArea: a, currentContentArea: s } = t[Xs];
    if ("pageArea" === e1.targetType) {
        i instanceof PageArea || (i = null);
        if (e1.startNew) {
            e1[Xs].target = i || a;
            return !0;
        }
        if (i && i !== a) {
            e1[Xs].target = i;
            return !0;
        }
        return !1;
    }
    i instanceof ContentArea || (i = null);
    const r = i && i[Ir]();
    let n, g = r;
    if (e1.startNew) if (i) {
        const e1 = r.contentArea.children, t = e1.indexOf(s), a = e1.indexOf(i);
        -1 !== t && t < a && (g = null);
        n = a - 1;
    } else n = a.contentArea.children.indexOf(s);
    else {
        if (!i || i === s) return !1;
        n = r.contentArea.children.indexOf(i) - 1;
        g = r === a ? null : r;
    }
    e1[Xs].target = g;
    e1[Xs].index = n;
    return !0;
}
function handleOverflow(e1, t, i) {
    const a = e1[cr](), s = a[Xs].noLayoutFailure, r = t[or];
    t[or] = ()=>e1;
    a[Xs].noLayoutFailure = !0;
    const n = t[jr](i);
    e1[Ls](n.html, n.bbox);
    a[Xs].noLayoutFailure = s;
    t[or] = r;
}
class AppearanceFilter extends StringObject {
    constructor(e1){
        super(Nn, "appearanceFilter");
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Arc extends XFAObject {
    constructor(e1){
        super(Nn, "arc", !0);
        this.circular = getInteger({
            data: e1.circular,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]);
        this.id = e1.id || "";
        this.startAngle = getFloat({
            data: e1.startAngle,
            defaultValue: 0,
            validate: (e1)=>!0
        });
        this.sweepAngle = getFloat({
            data: e1.sweepAngle,
            defaultValue: 360,
            validate: (e1)=>!0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.edge = null;
        this.fill = null;
    }
    [jr]() {
        const e1 = this.edge || new Edge({}), t = e1[Zr](), i = Object.create(null);
        "visible" === this.fill?.presence ? Object.assign(i, this.fill[Zr]()) : i.fill = "transparent";
        i.strokeWidth = measureToString("visible" === e1.presence ? e1.thickness : 0);
        i.stroke = t.color;
        let a;
        const s = {
            xmlns: Gn,
            style: {
                width: "100%",
                height: "100%",
                overflow: "visible"
            }
        };
        if (360 === this.sweepAngle) a = {
            name: "ellipse",
            attributes: {
                xmlns: Gn,
                cx: "50%",
                cy: "50%",
                rx: "50%",
                ry: "50%",
                style: i
            }
        };
        else {
            const e1 = this.startAngle * Math.PI / 180, t = this.sweepAngle * Math.PI / 180, r = this.sweepAngle > 180 ? 1 : 0, [n, g, o, c] = [
                50 * (1 + Math.cos(e1)),
                50 * (1 - Math.sin(e1)),
                50 * (1 + Math.cos(e1 + t)),
                50 * (1 - Math.sin(e1 + t))
            ];
            a = {
                name: "path",
                attributes: {
                    xmlns: Gn,
                    d: `M ${n} ${g} A 50 50 0 ${r} 0 ${o} ${c}`,
                    vectorEffect: "non-scaling-stroke",
                    style: i
                }
            };
            Object.assign(s, {
                viewBox: "0 0 100 100",
                preserveAspectRatio: "none"
            });
        }
        const r = {
            name: "svg",
            children: [
                a
            ],
            attributes: s
        };
        if (hasMargin(this[Ir]()[Ir]())) return HTMLResult.success({
            name: "div",
            attributes: {
                style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                }
            },
            children: [
                r
            ]
        });
        r.attributes.style.position = "absolute";
        return HTMLResult.success(r);
    }
}
class Area extends XFAObject {
    constructor(e1){
        super(Nn, "area", !0);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.desc = null;
        this.extras = null;
        this.area = new XFAObjectArray;
        this.draw = new XFAObjectArray;
        this.exObject = new XFAObjectArray;
        this.exclGroup = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.subform = new XFAObjectArray;
        this.subformSet = new XFAObjectArray;
    }
    *[nr]() {
        yield* getContainedChildren(this);
    }
    [Dr]() {
        return !0;
    }
    [dr]() {
        return !0;
    }
    [Ls](e1, t) {
        const [i, a, s, r] = t;
        this[Xs].width = Math.max(this[Xs].width, i + s);
        this[Xs].height = Math.max(this[Xs].height, a + r);
        this[Xs].children.push(e1);
    }
    [$s]() {
        return this[Xs].availableSpace;
    }
    [jr](e1) {
        const t = toStyle(this, "position"), i = {
            style: t,
            id: this[Vr],
            class: [
                "xfaArea"
            ]
        };
        isPrintOnly(this) && i.class.push("xfaPrintOnly");
        this.name && (i.xfaName = this.name);
        const a = [];
        this[Xs] = {
            children: a,
            width: 0,
            height: 0,
            availableSpace: e1
        };
        const s = this[Js]({
            filter: new Set([
                "area",
                "draw",
                "field",
                "exclGroup",
                "subform",
                "subformSet"
            ]),
            include: !0
        });
        if (!s.success) {
            if (s.isBreak()) return s;
            delete this[Xs];
            return HTMLResult.FAILURE;
        }
        t.width = measureToString(this[Xs].width);
        t.height = measureToString(this[Xs].height);
        const r = {
            name: "div",
            attributes: i,
            children: a
        }, n = [
            this.x,
            this.y,
            this[Xs].width,
            this[Xs].height
        ];
        delete this[Xs];
        return HTMLResult.success(r, n);
    }
}
class Assist extends XFAObject {
    constructor(e1){
        super(Nn, "assist", !0);
        this.id = e1.id || "";
        this.role = e1.role || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.speak = null;
        this.toolTip = null;
    }
    [jr]() {
        return this.toolTip?.[Os] || null;
    }
}
class Barcode extends XFAObject {
    constructor(e1){
        super(Nn, "barcode", !0);
        this.charEncoding = getKeyword({
            data: e1.charEncoding ? e1.charEncoding.toLowerCase() : "",
            defaultValue: "",
            validate: (e1)=>[
                    "utf-8",
                    "big-five",
                    "fontspecific",
                    "gbk",
                    "gb-18030",
                    "gb-2312",
                    "ksc-5601",
                    "none",
                    "shift-jis",
                    "ucs-2",
                    "utf-16"
                ].includes(e1) || e1.match(/iso-8859-\d{2}/)
        });
        this.checksum = getStringOption(e1.checksum, [
            "none",
            "1mod10",
            "1mod10_1mod11",
            "2mod10",
            "auto"
        ]);
        this.dataColumnCount = getInteger({
            data: e1.dataColumnCount,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0
        });
        this.dataLength = getInteger({
            data: e1.dataLength,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0
        });
        this.dataPrep = getStringOption(e1.dataPrep, [
            "none",
            "flateCompress"
        ]);
        this.dataRowCount = getInteger({
            data: e1.dataRowCount,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0
        });
        this.endChar = e1.endChar || "";
        this.errorCorrectionLevel = getInteger({
            data: e1.errorCorrectionLevel,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0 && e1 <= 8
        });
        this.id = e1.id || "";
        this.moduleHeight = getMeasurement(e1.moduleHeight, "5mm");
        this.moduleWidth = getMeasurement(e1.moduleWidth, "0.25mm");
        this.printCheckDigit = getInteger({
            data: e1.printCheckDigit,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.rowColumnRatio = getRatio(e1.rowColumnRatio);
        this.startChar = e1.startChar || "";
        this.textLocation = getStringOption(e1.textLocation, [
            "below",
            "above",
            "aboveEmbedded",
            "belowEmbedded",
            "none"
        ]);
        this.truncate = getInteger({
            data: e1.truncate,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.type = getStringOption(e1.type ? e1.type.toLowerCase() : "", [
            "aztec",
            "codabar",
            "code2of5industrial",
            "code2of5interleaved",
            "code2of5matrix",
            "code2of5standard",
            "code3of9",
            "code3of9extended",
            "code11",
            "code49",
            "code93",
            "code128",
            "code128a",
            "code128b",
            "code128c",
            "code128sscc",
            "datamatrix",
            "ean8",
            "ean8add2",
            "ean8add5",
            "ean13",
            "ean13add2",
            "ean13add5",
            "ean13pwcd",
            "fim",
            "logmars",
            "maxicode",
            "msi",
            "pdf417",
            "pdf417macro",
            "plessey",
            "postauscust2",
            "postauscust3",
            "postausreplypaid",
            "postausstandard",
            "postukrm4scc",
            "postusdpbc",
            "postusimb",
            "postusstandard",
            "postus5zip",
            "qrcode",
            "rfid",
            "rss14",
            "rss14expanded",
            "rss14limited",
            "rss14stacked",
            "rss14stackedomni",
            "rss14truncated",
            "telepen",
            "ucc128",
            "ucc128random",
            "ucc128sscc",
            "upca",
            "upcaadd2",
            "upcaadd5",
            "upcapwcd",
            "upce",
            "upceadd2",
            "upceadd5",
            "upcean2",
            "upcean5",
            "upsmaxicode"
        ]);
        this.upsMode = getStringOption(e1.upsMode, [
            "usCarrier",
            "internationalCarrier",
            "secureSymbol",
            "standardSymbol"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.wideNarrowRatio = getRatio(e1.wideNarrowRatio);
        this.encrypt = null;
        this.extras = null;
    }
}
class Bind extends XFAObject {
    constructor(e1){
        super(Nn, "bind", !0);
        this.match = getStringOption(e1.match, [
            "once",
            "dataRef",
            "global",
            "none"
        ]);
        this.ref = e1.ref || "";
        this.picture = null;
    }
}
class BindItems extends XFAObject {
    constructor(e1){
        super(Nn, "bindItems");
        this.connection = e1.connection || "";
        this.labelRef = e1.labelRef || "";
        this.ref = e1.ref || "";
        this.valueRef = e1.valueRef || "";
    }
}
class Bookend extends XFAObject {
    constructor(e1){
        super(Nn, "bookend");
        this.id = e1.id || "";
        this.leader = e1.leader || "";
        this.trailer = e1.trailer || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class BooleanElement extends Option01 {
    constructor(e1){
        super(Nn, "boolean");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [jr](e1) {
        return valueToHtml(1 === this[Os] ? "1" : "0");
    }
}
class Border extends XFAObject {
    constructor(e1){
        super(Nn, "border", !0);
        this.break = getStringOption(e1.break, [
            "close",
            "open"
        ]);
        this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]);
        this.id = e1.id || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.corner = new XFAObjectArray(4);
        this.edge = new XFAObjectArray(4);
        this.extras = null;
        this.fill = null;
        this.margin = null;
    }
    [ar]() {
        if (!this[Xs]) {
            const e1 = this.edge.children.slice();
            if (e1.length < 4) {
                const t = e1.at(-1) || new Edge({});
                for(let i = e1.length; i < 4; i++)e1.push(t);
            }
            const t = e1.map((e1)=>e1.thickness), i = [
                0,
                0,
                0,
                0
            ];
            if (this.margin) {
                i[0] = this.margin.topInset;
                i[1] = this.margin.rightInset;
                i[2] = this.margin.bottomInset;
                i[3] = this.margin.leftInset;
            }
            this[Xs] = {
                widths: t,
                insets: i,
                edges: e1
            };
        }
        return this[Xs];
    }
    [Zr]() {
        const { edges: e1 } = this[ar](), t = e1.map((e1)=>{
            const t = e1[Zr]();
            t.color ||= "#000000";
            return t;
        }), i = Object.create(null);
        this.margin && Object.assign(i, this.margin[Zr]());
        "visible" === this.fill?.presence && Object.assign(i, this.fill[Zr]());
        if (this.corner.children.some((e1)=>0 !== e1.radius)) {
            const e1 = this.corner.children.map((e1)=>e1[Zr]());
            if (2 === e1.length || 3 === e1.length) {
                const t = e1.at(-1);
                for(let i = e1.length; i < 4; i++)e1.push(t);
            }
            i.borderRadius = e1.map((e1)=>e1.radius).join(" ");
        }
        switch(this.presence){
            case "invisible":
            case "hidden":
                i.borderStyle = "";
                break;
            case "inactive":
                i.borderStyle = "none";
                break;
            default:
                i.borderStyle = t.map((e1)=>e1.style).join(" ");
        }
        i.borderWidth = t.map((e1)=>e1.width).join(" ");
        i.borderColor = t.map((e1)=>e1.color).join(" ");
        return i;
    }
}
class Break extends XFAObject {
    constructor(e1){
        super(Nn, "break", !0);
        this.after = getStringOption(e1.after, [
            "auto",
            "contentArea",
            "pageArea",
            "pageEven",
            "pageOdd"
        ]);
        this.afterTarget = e1.afterTarget || "";
        this.before = getStringOption(e1.before, [
            "auto",
            "contentArea",
            "pageArea",
            "pageEven",
            "pageOdd"
        ]);
        this.beforeTarget = e1.beforeTarget || "";
        this.bookendLeader = e1.bookendLeader || "";
        this.bookendTrailer = e1.bookendTrailer || "";
        this.id = e1.id || "";
        this.overflowLeader = e1.overflowLeader || "";
        this.overflowTarget = e1.overflowTarget || "";
        this.overflowTrailer = e1.overflowTrailer || "";
        this.startNew = getInteger({
            data: e1.startNew,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
}
class BreakAfter extends XFAObject {
    constructor(e1){
        super(Nn, "breakAfter", !0);
        this.id = e1.id || "";
        this.leader = e1.leader || "";
        this.startNew = getInteger({
            data: e1.startNew,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.target = e1.target || "";
        this.targetType = getStringOption(e1.targetType, [
            "auto",
            "contentArea",
            "pageArea"
        ]);
        this.trailer = e1.trailer || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.script = null;
    }
}
class BreakBefore extends XFAObject {
    constructor(e1){
        super(Nn, "breakBefore", !0);
        this.id = e1.id || "";
        this.leader = e1.leader || "";
        this.startNew = getInteger({
            data: e1.startNew,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.target = e1.target || "";
        this.targetType = getStringOption(e1.targetType, [
            "auto",
            "contentArea",
            "pageArea"
        ]);
        this.trailer = e1.trailer || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.script = null;
    }
    [jr](e1) {
        this[Xs] = {};
        return HTMLResult.FAILURE;
    }
}
class Button extends XFAObject {
    constructor(e1){
        super(Nn, "button", !0);
        this.highlight = getStringOption(e1.highlight, [
            "inverted",
            "none",
            "outline",
            "push"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
    [jr](e1) {
        const t = this[Ir]()[Ir](), i = {
            name: "button",
            attributes: {
                id: this[Vr],
                class: [
                    "xfaButton"
                ],
                style: {}
            },
            children: []
        };
        for (const e1 of t.event.children){
            if ("click" !== e1.activity || !e1.script) continue;
            const t = recoverJsURL(e1.script[Os]);
            if (!t) continue;
            const a = fixURL(t.url);
            a && i.children.push({
                name: "a",
                attributes: {
                    id: "link" + this[Vr],
                    href: a,
                    newWindow: t.newWindow,
                    class: [
                        "xfaLink"
                    ],
                    style: {}
                },
                children: []
            });
        }
        return HTMLResult.success(i);
    }
}
class Calculate extends XFAObject {
    constructor(e1){
        super(Nn, "calculate", !0);
        this.id = e1.id || "";
        this.override = getStringOption(e1.override, [
            "disabled",
            "error",
            "ignore",
            "warning"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.message = null;
        this.script = null;
    }
}
class Caption extends XFAObject {
    constructor(e1){
        super(Nn, "caption", !0);
        this.id = e1.id || "";
        this.placement = getStringOption(e1.placement, [
            "left",
            "bottom",
            "inline",
            "right",
            "top"
        ]);
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.reserve = Math.ceil(getMeasurement(e1.reserve));
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.font = null;
        this.margin = null;
        this.para = null;
        this.value = null;
    }
    [qr](e1) {
        _setValue(this, e1);
    }
    [ar](e1) {
        if (!this[Xs]) {
            let { width: t, height: i } = e1;
            switch(this.placement){
                case "left":
                case "right":
                case "inline":
                    t = this.reserve <= 0 ? t : this.reserve;
                    break;
                case "top":
                case "bottom":
                    i = this.reserve <= 0 ? i : this.reserve;
            }
            this[Xs] = layoutNode(this, {
                width: t,
                height: i
            });
        }
        return this[Xs];
    }
    [jr](e1) {
        if (!this.value) return HTMLResult.EMPTY;
        this[Lr]();
        const t = this.value[jr](e1).html;
        if (!t) {
            this[xr]();
            return HTMLResult.EMPTY;
        }
        const i = this.reserve;
        if (this.reserve <= 0) {
            const { w: t, h: i } = this[ar](e1);
            switch(this.placement){
                case "left":
                case "right":
                case "inline":
                    this.reserve = t;
                    break;
                case "top":
                case "bottom":
                    this.reserve = i;
            }
        }
        const a = [];
        "string" == typeof t ? a.push({
            name: "#text",
            value: t
        }) : a.push(t);
        const s = toStyle(this, "font", "margin", "visibility");
        switch(this.placement){
            case "left":
            case "right":
                this.reserve > 0 && (s.width = measureToString(this.reserve));
                break;
            case "top":
            case "bottom":
                this.reserve > 0 && (s.height = measureToString(this.reserve));
        }
        setPara(this, null, t);
        this[xr]();
        this.reserve = i;
        return HTMLResult.success({
            name: "div",
            attributes: {
                style: s,
                class: [
                    "xfaCaption"
                ]
            },
            children: a
        });
    }
}
class Certificate extends StringObject {
    constructor(e1){
        super(Nn, "certificate");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Certificates extends XFAObject {
    constructor(e1){
        super(Nn, "certificates", !0);
        this.credentialServerPolicy = getStringOption(e1.credentialServerPolicy, [
            "optional",
            "required"
        ]);
        this.id = e1.id || "";
        this.url = e1.url || "";
        this.urlPolicy = e1.urlPolicy || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.encryption = null;
        this.issuers = null;
        this.keyUsage = null;
        this.oids = null;
        this.signing = null;
        this.subjectDNs = null;
    }
}
class CheckButton extends XFAObject {
    constructor(e1){
        super(Nn, "checkButton", !0);
        this.id = e1.id || "";
        this.mark = getStringOption(e1.mark, [
            "default",
            "check",
            "circle",
            "cross",
            "diamond",
            "square",
            "star"
        ]);
        this.shape = getStringOption(e1.shape, [
            "square",
            "round"
        ]);
        this.size = getMeasurement(e1.size, "10pt");
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
    }
    [jr](e1) {
        const t = toStyle("margin"), i = measureToString(this.size);
        t.width = t.height = i;
        let a, s, r;
        const n = this[Ir]()[Ir](), g = n.items.children.length && n.items.children[0][jr]().html || [], o = {
            on: (void 0 !== g[0] ? g[0] : "on").toString(),
            off: (void 0 !== g[1] ? g[1] : "off").toString()
        }, c = (n.value?.[Pr]() || "off") === o.on || void 0, C = n[or](), h = n[Vr];
        let l;
        if (C instanceof ExclGroup) {
            r = C[Vr];
            a = "radio";
            s = "xfaRadio";
            l = C[Ws]?.[Vr] || C[Vr];
        } else {
            a = "checkbox";
            s = "xfaCheckbox";
            l = n[Ws]?.[Vr] || n[Vr];
        }
        const Q = {
            name: "input",
            attributes: {
                class: [
                    s
                ],
                style: t,
                fieldId: h,
                dataId: l,
                type: a,
                checked: c,
                xfaOn: o.on,
                xfaOff: o.off,
                "aria-label": ariaLabel(n),
                "aria-required": !1
            }
        };
        r && (Q.attributes.name = r);
        if (isRequired(n)) {
            Q.attributes["aria-required"] = !0;
            Q.attributes.required = !0;
        }
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                Q
            ]
        });
    }
}
class ChoiceList extends XFAObject {
    constructor(e1){
        super(Nn, "choiceList", !0);
        this.commitOn = getStringOption(e1.commitOn, [
            "select",
            "exit"
        ]);
        this.id = e1.id || "";
        this.open = getStringOption(e1.open, [
            "userControl",
            "always",
            "multiSelect",
            "onEntry"
        ]);
        this.textEntry = getInteger({
            data: e1.textEntry,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
    }
    [jr](e1) {
        const t = toStyle(this, "border", "margin"), i = this[Ir]()[Ir](), a = {
            fontSize: `calc(${i.font?.size || 10}px * var(--scale-factor))`
        }, s = [];
        if (i.items.children.length > 0) {
            const e1 = i.items;
            let t = 0, r = 0;
            if (2 === e1.children.length) {
                t = e1.children[0].save;
                r = 1 - t;
            }
            const n = e1.children[t][jr]().html, g = e1.children[r][jr]().html;
            let o = !1;
            const c = i.value?.[Pr]() || "";
            for(let e1 = 0, t = n.length; e1 < t; e1++){
                const t = {
                    name: "option",
                    attributes: {
                        value: g[e1] || n[e1],
                        style: a
                    },
                    value: n[e1]
                };
                g[e1] === c && (t.attributes.selected = o = !0);
                s.push(t);
            }
            o || s.splice(0, 0, {
                name: "option",
                attributes: {
                    hidden: !0,
                    selected: !0
                },
                value: " "
            });
        }
        const r = {
            class: [
                "xfaSelect"
            ],
            fieldId: i[Vr],
            dataId: i[Ws]?.[Vr] || i[Vr],
            style: t,
            "aria-label": ariaLabel(i),
            "aria-required": !1
        };
        if (isRequired(i)) {
            r["aria-required"] = !0;
            r.required = !0;
        }
        "multiSelect" === this.open && (r.multiple = !0);
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                {
                    name: "select",
                    children: s,
                    attributes: r
                }
            ]
        });
    }
}
class Color extends XFAObject {
    constructor(e1){
        super(Nn, "color", !0);
        this.cSpace = getStringOption(e1.cSpace, [
            "SRGB"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.value = e1.value ? function getColor(e1, t = [
            0,
            0,
            0
        ]) {
            let [i, a, s] = t;
            if (!e1) return {
                r: i,
                g: a,
                b: s
            };
            const r = e1.trim().split(/\s*,\s*/).map((e1)=>Math.min(Math.max(0, parseInt(e1.trim(), 10)), 255)).map((e1)=>isNaN(e1) ? 0 : e1);
            if (r.length < 3) return {
                r: i,
                g: a,
                b: s
            };
            [i, a, s] = r;
            return {
                r: i,
                g: a,
                b: s
            };
        }(e1.value) : "";
        this.extras = null;
    }
    [hr]() {
        return !1;
    }
    [Zr]() {
        return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
    }
}
class Comb extends XFAObject {
    constructor(e1){
        super(Nn, "comb");
        this.id = e1.id || "";
        this.numberOfCells = getInteger({
            data: e1.numberOfCells,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Connect extends XFAObject {
    constructor(e1){
        super(Nn, "connect", !0);
        this.connection = e1.connection || "";
        this.id = e1.id || "";
        this.ref = e1.ref || "";
        this.usage = getStringOption(e1.usage, [
            "exportAndImport",
            "exportOnly",
            "importOnly"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.picture = null;
    }
}
class ContentArea extends XFAObject {
    constructor(e1){
        super(Nn, "contentArea", !0);
        this.h = getMeasurement(e1.h);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = getMeasurement(e1.w);
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.desc = null;
        this.extras = null;
    }
    [jr](e1) {
        const t = {
            left: measureToString(this.x),
            top: measureToString(this.y),
            width: measureToString(this.w),
            height: measureToString(this.h)
        }, i = [
            "xfaContentarea"
        ];
        isPrintOnly(this) && i.push("xfaPrintOnly");
        return HTMLResult.success({
            name: "div",
            children: [],
            attributes: {
                style: t,
                class: i,
                id: this[Vr]
            }
        });
    }
}
class Corner extends XFAObject {
    constructor(e1){
        super(Nn, "corner", !0);
        this.id = e1.id || "";
        this.inverted = getInteger({
            data: e1.inverted,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.join = getStringOption(e1.join, [
            "square",
            "round"
        ]);
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.radius = getMeasurement(e1.radius);
        this.stroke = getStringOption(e1.stroke, [
            "solid",
            "dashDot",
            "dashDotDot",
            "dashed",
            "dotted",
            "embossed",
            "etched",
            "lowered",
            "raised"
        ]);
        this.thickness = getMeasurement(e1.thickness, "0.5pt");
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Zr]() {
        const e1 = toStyle(this, "visibility");
        e1.radius = measureToString("square" === this.join ? 0 : this.radius);
        return e1;
    }
}
class DateElement extends ContentObject {
    constructor(e1){
        super(Nn, "date");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Zs]() {
        const e1 = this[Os].trim();
        this[Os] = e1 ? new Date(e1) : null;
    }
    [jr](e1) {
        return valueToHtml(this[Os] ? this[Os].toString() : "");
    }
}
class DateTime extends ContentObject {
    constructor(e1){
        super(Nn, "dateTime");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Zs]() {
        const e1 = this[Os].trim();
        this[Os] = e1 ? new Date(e1) : null;
    }
    [jr](e1) {
        return valueToHtml(this[Os] ? this[Os].toString() : "");
    }
}
class DateTimeEdit extends XFAObject {
    constructor(e1){
        super(Nn, "dateTimeEdit", !0);
        this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.id = e1.id || "";
        this.picker = getStringOption(e1.picker, [
            "host",
            "none"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.comb = null;
        this.extras = null;
        this.margin = null;
    }
    [jr](e1) {
        const t = toStyle(this, "border", "font", "margin"), i = this[Ir]()[Ir](), a = {
            name: "input",
            attributes: {
                type: "text",
                fieldId: i[Vr],
                dataId: i[Ws]?.[Vr] || i[Vr],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(i),
                "aria-required": !1
            }
        };
        if (isRequired(i)) {
            a.attributes["aria-required"] = !0;
            a.attributes.required = !0;
        }
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                a
            ]
        });
    }
}
class Decimal extends ContentObject {
    constructor(e1){
        super(Nn, "decimal");
        this.fracDigits = getInteger({
            data: e1.fracDigits,
            defaultValue: 2,
            validate: (e1)=>!0
        });
        this.id = e1.id || "";
        this.leadDigits = getInteger({
            data: e1.leadDigits,
            defaultValue: -1,
            validate: (e1)=>!0
        });
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Zs]() {
        const e1 = parseFloat(this[Os].trim());
        this[Os] = isNaN(e1) ? null : e1;
    }
    [jr](e1) {
        return valueToHtml(null !== this[Os] ? this[Os].toString() : "");
    }
}
class DefaultUi extends XFAObject {
    constructor(e1){
        super(Nn, "defaultUi", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
}
class Desc extends XFAObject {
    constructor(e1){
        super(Nn, "desc", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
}
class DigestMethod extends OptionObject {
    constructor(e1){
        super(Nn, "digestMethod", [
            "",
            "SHA1",
            "SHA256",
            "SHA512",
            "RIPEMD160"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class DigestMethods extends XFAObject {
    constructor(e1){
        super(Nn, "digestMethods", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.digestMethod = new XFAObjectArray;
    }
}
class Draw extends XFAObject {
    constructor(e1){
        super(Nn, "draw", !0);
        this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.h = e1.h ? getMeasurement(e1.h) : "";
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.locale = e1.locale || "";
        this.maxH = getMeasurement(e1.maxH, "0pt");
        this.maxW = getMeasurement(e1.maxW, "0pt");
        this.minH = getMeasurement(e1.minH, "0pt");
        this.minW = getMeasurement(e1.minW, "0pt");
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.rotate = getInteger({
            data: e1.rotate,
            defaultValue: 0,
            validate: (e1)=>e1 % 90 == 0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = e1.w ? getMeasurement(e1.w) : "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.assist = null;
        this.border = null;
        this.caption = null;
        this.desc = null;
        this.extras = null;
        this.font = null;
        this.keep = null;
        this.margin = null;
        this.para = null;
        this.traversal = null;
        this.ui = null;
        this.value = null;
        this.setProperty = new XFAObjectArray;
    }
    [qr](e1) {
        _setValue(this, e1);
    }
    [jr](e1) {
        setTabIndex(this);
        if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
        fixDimensions(this);
        this[Lr]();
        const t = this.w, i = this.h, { w: a, h: s, isBroken: r } = layoutNode(this, e1);
        if (a && "" === this.w) {
            if (r && this[or]()[wr]()) {
                this[xr]();
                return HTMLResult.FAILURE;
            }
            this.w = a;
        }
        s && "" === this.h && (this.h = s);
        setFirstUnsplittable(this);
        if (!checkDimensions(this, e1)) {
            this.w = t;
            this.h = i;
            this[xr]();
            return HTMLResult.FAILURE;
        }
        unsetFirstUnsplittable(this);
        const n = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
        setMinMaxDimensions(this, n);
        if (n.margin) {
            n.padding = n.margin;
            delete n.margin;
        }
        const g = [
            "xfaDraw"
        ];
        this.font && g.push("xfaFont");
        isPrintOnly(this) && g.push("xfaPrintOnly");
        const o = {
            style: n,
            id: this[Vr],
            class: g
        };
        this.name && (o.xfaName = this.name);
        const c = {
            name: "div",
            attributes: o,
            children: []
        };
        applyAssist(this, o);
        const C = computeBbox(this, c, e1), h = this.value ? this.value[jr](e1).html : null;
        if (null === h) {
            this.w = t;
            this.h = i;
            this[xr]();
            return HTMLResult.success(createWrapper(this, c), C);
        }
        c.children.push(h);
        setPara(this, n, h);
        this.w = t;
        this.h = i;
        this[xr]();
        return HTMLResult.success(createWrapper(this, c), C);
    }
}
class Edge extends XFAObject {
    constructor(e1){
        super(Nn, "edge", !0);
        this.cap = getStringOption(e1.cap, [
            "square",
            "butt",
            "round"
        ]);
        this.id = e1.id || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.stroke = getStringOption(e1.stroke, [
            "solid",
            "dashDot",
            "dashDotDot",
            "dashed",
            "dotted",
            "embossed",
            "etched",
            "lowered",
            "raised"
        ]);
        this.thickness = getMeasurement(e1.thickness, "0.5pt");
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Zr]() {
        const e1 = toStyle(this, "visibility");
        Object.assign(e1, {
            linecap: this.cap,
            width: measureToString(this.thickness),
            color: this.color ? this.color[Zr]() : "#000000",
            style: ""
        });
        if ("visible" !== this.presence) e1.style = "none";
        else switch(this.stroke){
            case "solid":
                e1.style = "solid";
                break;
            case "dashDot":
            case "dashDotDot":
            case "dashed":
                e1.style = "dashed";
                break;
            case "dotted":
                e1.style = "dotted";
                break;
            case "embossed":
                e1.style = "ridge";
                break;
            case "etched":
                e1.style = "groove";
                break;
            case "lowered":
                e1.style = "inset";
                break;
            case "raised":
                e1.style = "outset";
        }
        return e1;
    }
}
class Encoding extends OptionObject {
    constructor(e1){
        super(Nn, "encoding", [
            "adbe.x509.rsa_sha1",
            "adbe.pkcs7.detached",
            "adbe.pkcs7.sha1"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Encodings extends XFAObject {
    constructor(e1){
        super(Nn, "encodings", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.encoding = new XFAObjectArray;
    }
}
class Encrypt extends XFAObject {
    constructor(e1){
        super(Nn, "encrypt", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.certificate = null;
    }
}
class EncryptData extends XFAObject {
    constructor(e1){
        super(Nn, "encryptData", !0);
        this.id = e1.id || "";
        this.operation = getStringOption(e1.operation, [
            "encrypt",
            "decrypt"
        ]);
        this.target = e1.target || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.filter = null;
        this.manifest = null;
    }
}
class Encryption extends XFAObject {
    constructor(e1){
        super(Nn, "encryption", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.certificate = new XFAObjectArray;
    }
}
class EncryptionMethod extends OptionObject {
    constructor(e1){
        super(Nn, "encryptionMethod", [
            "",
            "AES256-CBC",
            "TRIPLEDES-CBC",
            "AES128-CBC",
            "AES192-CBC"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class EncryptionMethods extends XFAObject {
    constructor(e1){
        super(Nn, "encryptionMethods", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.encryptionMethod = new XFAObjectArray;
    }
}
class Event extends XFAObject {
    constructor(e1){
        super(Nn, "event", !0);
        this.activity = getStringOption(e1.activity, [
            "click",
            "change",
            "docClose",
            "docReady",
            "enter",
            "exit",
            "full",
            "indexChange",
            "initialize",
            "mouseDown",
            "mouseEnter",
            "mouseExit",
            "mouseUp",
            "postExecute",
            "postOpen",
            "postPrint",
            "postSave",
            "postSign",
            "postSubmit",
            "preExecute",
            "preOpen",
            "prePrint",
            "preSave",
            "preSign",
            "preSubmit",
            "ready",
            "validationState"
        ]);
        this.id = e1.id || "";
        this.listen = getStringOption(e1.listen, [
            "refOnly",
            "refAndDescendents"
        ]);
        this.name = e1.name || "";
        this.ref = e1.ref || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.encryptData = null;
        this.execute = null;
        this.script = null;
        this.signData = null;
        this.submit = null;
    }
}
class ExData extends ContentObject {
    constructor(e1){
        super(Nn, "exData");
        this.contentType = e1.contentType || "";
        this.href = e1.href || "";
        this.id = e1.id || "";
        this.maxLength = getInteger({
            data: e1.maxLength,
            defaultValue: -1,
            validate: (e1)=>e1 >= -1
        });
        this.name = e1.name || "";
        this.rid = e1.rid || "";
        this.transferEncoding = getStringOption(e1.transferEncoding, [
            "none",
            "base64",
            "package"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [ur]() {
        return "text/html" === this.contentType;
    }
    [Nr](e1) {
        if ("text/html" === this.contentType && e1[Sr] === _r.xhtml.id) {
            this[Os] = e1;
            return !0;
        }
        if ("text/xml" === this.contentType) {
            this[Os] = e1;
            return !0;
        }
        return !1;
    }
    [jr](e1) {
        return "text/html" === this.contentType && this[Os] ? this[Os][jr](e1) : HTMLResult.EMPTY;
    }
}
class ExObject extends XFAObject {
    constructor(e1){
        super(Nn, "exObject", !0);
        this.archive = e1.archive || "";
        this.classId = e1.classId || "";
        this.codeBase = e1.codeBase || "";
        this.codeType = e1.codeType || "";
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.exObject = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
}
class ExclGroup extends XFAObject {
    constructor(e1){
        super(Nn, "exclGroup", !0);
        this.access = getStringOption(e1.access, [
            "open",
            "nonInteractive",
            "protected",
            "readOnly"
        ]);
        this.accessKey = e1.accessKey || "";
        this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.h = e1.h ? getMeasurement(e1.h) : "";
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.layout = getStringOption(e1.layout, [
            "position",
            "lr-tb",
            "rl-row",
            "rl-tb",
            "row",
            "table",
            "tb"
        ]);
        this.maxH = getMeasurement(e1.maxH, "0pt");
        this.maxW = getMeasurement(e1.maxW, "0pt");
        this.minH = getMeasurement(e1.minH, "0pt");
        this.minW = getMeasurement(e1.minW, "0pt");
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = e1.w ? getMeasurement(e1.w) : "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.assist = null;
        this.bind = null;
        this.border = null;
        this.calculate = null;
        this.caption = null;
        this.desc = null;
        this.extras = null;
        this.margin = null;
        this.para = null;
        this.traversal = null;
        this.validate = null;
        this.connect = new XFAObjectArray;
        this.event = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.setProperty = new XFAObjectArray;
    }
    [dr]() {
        return !0;
    }
    [hr]() {
        return !0;
    }
    [qr](e1) {
        for (const t of this.field.children){
            if (!t.value) {
                const e1 = new Value({});
                t[Hs](e1);
                t.value = e1;
            }
            t.value[qr](e1);
        }
    }
    [wr]() {
        return this.layout.endsWith("-tb") && 0 === this[Xs].attempt && this[Xs].numberInLine > 0 || this[Ir]()[wr]();
    }
    [yr]() {
        const e1 = this[or]();
        if (!e1[yr]()) return !1;
        if (void 0 !== this[Xs]._isSplittable) return this[Xs]._isSplittable;
        if ("position" === this.layout || this.layout.includes("row")) {
            this[Xs]._isSplittable = !1;
            return !1;
        }
        if (e1.layout?.endsWith("-tb") && 0 !== e1[Xs].numberInLine) return !1;
        this[Xs]._isSplittable = !0;
        return !0;
    }
    [Vs]() {
        return flushHTML(this);
    }
    [Ls](e1, t) {
        addHTML(this, e1, t);
    }
    [$s]() {
        return getAvailableSpace(this);
    }
    [jr](e1) {
        setTabIndex(this);
        if ("hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
        fixDimensions(this);
        const t = [], i = {
            id: this[Vr],
            class: []
        };
        setAccess(this, i.class);
        this[Xs] || (this[Xs] = Object.create(null));
        Object.assign(this[Xs], {
            children: t,
            attributes: i,
            attempt: 0,
            line: null,
            numberInLine: 0,
            availableSpace: {
                width: Math.min(this.w || 1 / 0, e1.width),
                height: Math.min(this.h || 1 / 0, e1.height)
            },
            width: 0,
            height: 0,
            prevHeight: 0,
            currentWidth: 0
        });
        const a = this[yr]();
        a || setFirstUnsplittable(this);
        if (!checkDimensions(this, e1)) return HTMLResult.FAILURE;
        const s = new Set([
            "field"
        ]);
        if (this.layout.includes("row")) {
            const e1 = this[or]().columnWidths;
            if (Array.isArray(e1) && e1.length > 0) {
                this[Xs].columnWidths = e1;
                this[Xs].currentColumn = 0;
            }
        }
        const r = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), n = [
            "xfaExclgroup"
        ], g = layoutClass(this);
        g && n.push(g);
        isPrintOnly(this) && n.push("xfaPrintOnly");
        i.style = r;
        i.class = n;
        this.name && (i.xfaName = this.name);
        this[Lr]();
        const o = "lr-tb" === this.layout || "rl-tb" === this.layout, c = o ? 2 : 1;
        for(; this[Xs].attempt < c; this[Xs].attempt++){
            o && 1 === this[Xs].attempt && (this[Xs].numberInLine = 0);
            const e1 = this[Js]({
                filter: s,
                include: !0
            });
            if (e1.success) break;
            if (e1.isBreak()) {
                this[xr]();
                return e1;
            }
            if (o && 0 === this[Xs].attempt && 0 === this[Xs].numberInLine && !this[cr]()[Xs].noLayoutFailure) {
                this[Xs].attempt = c;
                break;
            }
        }
        this[xr]();
        a || unsetFirstUnsplittable(this);
        if (this[Xs].attempt === c) {
            a || delete this[Xs];
            return HTMLResult.FAILURE;
        }
        let C = 0, h = 0;
        if (this.margin) {
            C = this.margin.leftInset + this.margin.rightInset;
            h = this.margin.topInset + this.margin.bottomInset;
        }
        const l = Math.max(this[Xs].width + C, this.w || 0), Q = Math.max(this[Xs].height + h, this.h || 0), E = [
            this.x,
            this.y,
            l,
            Q
        ];
        "" === this.w && (r.width = measureToString(l));
        "" === this.h && (r.height = measureToString(Q));
        const u = {
            name: "div",
            attributes: i,
            children: t
        };
        applyAssist(this, i);
        delete this[Xs];
        return HTMLResult.success(createWrapper(this, u), E);
    }
}
class Execute extends XFAObject {
    constructor(e1){
        super(Nn, "execute");
        this.connection = e1.connection || "";
        this.executeType = getStringOption(e1.executeType, [
            "import",
            "remerge"
        ]);
        this.id = e1.id || "";
        this.runAt = getStringOption(e1.runAt, [
            "client",
            "both",
            "server"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Extras extends XFAObject {
    constructor(e1){
        super(Nn, "extras", !0);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.extras = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
}
class Field extends XFAObject {
    constructor(e1){
        super(Nn, "field", !0);
        this.access = getStringOption(e1.access, [
            "open",
            "nonInteractive",
            "protected",
            "readOnly"
        ]);
        this.accessKey = e1.accessKey || "";
        this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.h = e1.h ? getMeasurement(e1.h) : "";
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.locale = e1.locale || "";
        this.maxH = getMeasurement(e1.maxH, "0pt");
        this.maxW = getMeasurement(e1.maxW, "0pt");
        this.minH = getMeasurement(e1.minH, "0pt");
        this.minW = getMeasurement(e1.minW, "0pt");
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.rotate = getInteger({
            data: e1.rotate,
            defaultValue: 0,
            validate: (e1)=>e1 % 90 == 0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = e1.w ? getMeasurement(e1.w) : "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.assist = null;
        this.bind = null;
        this.border = null;
        this.calculate = null;
        this.caption = null;
        this.desc = null;
        this.extras = null;
        this.font = null;
        this.format = null;
        this.items = new XFAObjectArray(2);
        this.keep = null;
        this.margin = null;
        this.para = null;
        this.traversal = null;
        this.ui = null;
        this.validate = null;
        this.value = null;
        this.bindItems = new XFAObjectArray;
        this.connect = new XFAObjectArray;
        this.event = new XFAObjectArray;
        this.setProperty = new XFAObjectArray;
    }
    [dr]() {
        return !0;
    }
    [qr](e1) {
        _setValue(this, e1);
    }
    [jr](e1) {
        setTabIndex(this);
        if (!this.ui) {
            this.ui = new Ui({});
            this.ui[Cr] = this[Cr];
            this[Hs](this.ui);
            let e1;
            switch(this.items.children.length){
                case 0:
                    e1 = new TextEdit({});
                    this.ui.textEdit = e1;
                    break;
                case 1:
                    e1 = new CheckButton({});
                    this.ui.checkButton = e1;
                    break;
                case 2:
                    e1 = new ChoiceList({});
                    this.ui.choiceList = e1;
            }
            this.ui[Hs](e1);
        }
        if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
        this.caption && delete this.caption[Xs];
        this[Lr]();
        const t = this.caption ? this.caption[jr](e1).html : null, i = this.w, a = this.h;
        let s = 0, r = 0;
        if (this.margin) {
            s = this.margin.leftInset + this.margin.rightInset;
            r = this.margin.topInset + this.margin.bottomInset;
        }
        let n = null;
        if ("" === this.w || "" === this.h) {
            let t = null, i = null, a = 0, g = 0;
            if (this.ui.checkButton) a = g = this.ui.checkButton.size;
            else {
                const { w: t, h: i } = layoutNode(this, e1);
                if (null !== t) {
                    a = t;
                    g = i;
                } else g = function fonts_getMetrics(e1, t = !1) {
                    let i = null;
                    if (e1) {
                        const t = stripQuotes(e1.typeface), a = e1[Cr].fontFinder.find(t);
                        i = selectFont(e1, a);
                    }
                    if (!i) return {
                        lineHeight: 12,
                        lineGap: 2,
                        lineNoGap: 10
                    };
                    const a = e1.size || 10, s = i.lineHeight ? Math.max(t ? 0 : 1.2, i.lineHeight) : 1.2, r = void 0 === i.lineGap ? .2 : i.lineGap;
                    return {
                        lineHeight: s * a,
                        lineGap: r * a,
                        lineNoGap: Math.max(1, s - r) * a
                    };
                }(this.font, !0).lineNoGap;
            }
            n = getBorderDims(this.ui[ar]());
            a += n.w;
            g += n.h;
            if (this.caption) {
                const { w: s, h: r, isBroken: n } = this.caption[ar](e1);
                if (n && this[or]()[wr]()) {
                    this[xr]();
                    return HTMLResult.FAILURE;
                }
                t = s;
                i = r;
                switch(this.caption.placement){
                    case "left":
                    case "right":
                    case "inline":
                        t += a;
                        break;
                    case "top":
                    case "bottom":
                        i += g;
                }
            } else {
                t = a;
                i = g;
            }
            if (t && "" === this.w) {
                t += s;
                this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t ? t : this.minW);
            }
            if (i && "" === this.h) {
                i += r;
                this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < i ? i : this.minH);
            }
        }
        this[xr]();
        fixDimensions(this);
        setFirstUnsplittable(this);
        if (!checkDimensions(this, e1)) {
            this.w = i;
            this.h = a;
            this[xr]();
            return HTMLResult.FAILURE;
        }
        unsetFirstUnsplittable(this);
        const g = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
        setMinMaxDimensions(this, g);
        const o = [
            "xfaField"
        ];
        this.font && o.push("xfaFont");
        isPrintOnly(this) && o.push("xfaPrintOnly");
        const c = {
            style: g,
            id: this[Vr],
            class: o
        };
        if (g.margin) {
            g.padding = g.margin;
            delete g.margin;
        }
        setAccess(this, o);
        this.name && (c.xfaName = this.name);
        const C = [], h = {
            name: "div",
            attributes: c,
            children: C
        };
        applyAssist(this, c);
        const l = this.border ? this.border[Zr]() : null, Q = computeBbox(this, h, e1), E = this.ui[jr]().html;
        if (!E) {
            Object.assign(g, l);
            return HTMLResult.success(createWrapper(this, h), Q);
        }
        this[Or] && (E.children?.[0] ? E.children[0].attributes.tabindex = this[Or] : E.attributes.tabindex = this[Or]);
        E.attributes.style || (E.attributes.style = Object.create(null));
        let u = null;
        if (this.ui.button) {
            1 === E.children.length && ([u] = E.children.splice(0, 1));
            Object.assign(E.attributes.style, l);
        } else Object.assign(g, l);
        C.push(E);
        if (this.value) {
            if (this.ui.imageEdit) E.children.push(this.value[jr]().html);
            else if (!this.ui.button) {
                let e1 = "";
                if (this.value.exData) e1 = this.value.exData[Pr]();
                else if (this.value.text) e1 = this.value.text[ar]();
                else {
                    const t = this.value[jr]().html;
                    null !== t && (e1 = t.children[0].value);
                }
                this.ui.textEdit && this.value.text?.maxChars && (E.children[0].attributes.maxLength = this.value.text.maxChars);
                if (e1) {
                    if (this.ui.numericEdit) {
                        e1 = parseFloat(e1);
                        e1 = isNaN(e1) ? "" : e1.toString();
                    }
                    "textarea" === E.children[0].name ? E.children[0].attributes.textContent = e1 : E.children[0].attributes.value = e1;
                }
            }
        }
        if (!this.ui.imageEdit && E.children?.[0] && this.h) {
            n = n || getBorderDims(this.ui[ar]());
            let t = 0;
            if (this.caption && [
                "top",
                "bottom"
            ].includes(this.caption.placement)) {
                t = this.caption.reserve;
                t <= 0 && (t = this.caption[ar](e1).h);
                const i = this.h - t - r - n.h;
                E.children[0].attributes.style.height = measureToString(i);
            } else E.children[0].attributes.style.height = "100%";
        }
        u && E.children.push(u);
        if (!t) {
            E.attributes.class && E.attributes.class.push("xfaLeft");
            this.w = i;
            this.h = a;
            return HTMLResult.success(createWrapper(this, h), Q);
        }
        if (this.ui.button) {
            g.padding && delete g.padding;
            "div" === t.name && (t.name = "span");
            E.children.push(t);
            return HTMLResult.success(h, Q);
        }
        this.ui.checkButton && (t.attributes.class[0] = "xfaCaptionForCheckButton");
        E.attributes.class || (E.attributes.class = []);
        E.children.splice(0, 0, t);
        switch(this.caption.placement){
            case "left":
            case "inline":
                E.attributes.class.push("xfaLeft");
                break;
            case "right":
                E.attributes.class.push("xfaRight");
                break;
            case "top":
                E.attributes.class.push("xfaTop");
                break;
            case "bottom":
                E.attributes.class.push("xfaBottom");
        }
        this.w = i;
        this.h = a;
        return HTMLResult.success(createWrapper(this, h), Q);
    }
}
class Fill extends XFAObject {
    constructor(e1){
        super(Nn, "fill", !0);
        this.id = e1.id || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
        this.linear = null;
        this.pattern = null;
        this.radial = null;
        this.solid = null;
        this.stipple = null;
    }
    [Zr]() {
        const e1 = this[Ir](), t = e1[Ir]()[Ir](), i = Object.create(null);
        let a = "color", s = a;
        if (e1 instanceof Border) {
            a = "background-color";
            s = "background";
            t instanceof Ui && (i.backgroundColor = "white");
        }
        if (e1 instanceof Rectangle || e1 instanceof Arc) {
            a = s = "fill";
            i.fill = "white";
        }
        for (const e1 of Object.getOwnPropertyNames(this)){
            if ("extras" === e1 || "color" === e1) continue;
            const t = this[e1];
            if (!(t instanceof XFAObject)) continue;
            const r = t[Zr](this.color);
            r && (i[r.startsWith("#") ? a : s] = r);
            return i;
        }
        if (this.color?.value) {
            const e1 = this.color[Zr]();
            i[e1.startsWith("#") ? a : s] = e1;
        }
        return i;
    }
}
class Filter extends XFAObject {
    constructor(e1){
        super(Nn, "filter", !0);
        this.addRevocationInfo = getStringOption(e1.addRevocationInfo, [
            "",
            "required",
            "optional",
            "none"
        ]);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.version = getInteger({
            data: this.version,
            defaultValue: 5,
            validate: (e1)=>e1 >= 1 && e1 <= 5
        });
        this.appearanceFilter = null;
        this.certificates = null;
        this.digestMethods = null;
        this.encodings = null;
        this.encryptionMethods = null;
        this.handler = null;
        this.lockDocument = null;
        this.mdp = null;
        this.reasons = null;
        this.timeStamp = null;
    }
}
class Float extends ContentObject {
    constructor(e1){
        super(Nn, "float");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Zs]() {
        const e1 = parseFloat(this[Os].trim());
        this[Os] = isNaN(e1) ? null : e1;
    }
    [jr](e1) {
        return valueToHtml(null !== this[Os] ? this[Os].toString() : "");
    }
}
class template_Font extends XFAObject {
    constructor(e1){
        super(Nn, "font", !0);
        this.baselineShift = getMeasurement(e1.baselineShift);
        this.fontHorizontalScale = getFloat({
            data: e1.fontHorizontalScale,
            defaultValue: 100,
            validate: (e1)=>e1 >= 0
        });
        this.fontVerticalScale = getFloat({
            data: e1.fontVerticalScale,
            defaultValue: 100,
            validate: (e1)=>e1 >= 0
        });
        this.id = e1.id || "";
        this.kerningMode = getStringOption(e1.kerningMode, [
            "none",
            "pair"
        ]);
        this.letterSpacing = getMeasurement(e1.letterSpacing, "0");
        this.lineThrough = getInteger({
            data: e1.lineThrough,
            defaultValue: 0,
            validate: (e1)=>1 === e1 || 2 === e1
        });
        this.lineThroughPeriod = getStringOption(e1.lineThroughPeriod, [
            "all",
            "word"
        ]);
        this.overline = getInteger({
            data: e1.overline,
            defaultValue: 0,
            validate: (e1)=>1 === e1 || 2 === e1
        });
        this.overlinePeriod = getStringOption(e1.overlinePeriod, [
            "all",
            "word"
        ]);
        this.posture = getStringOption(e1.posture, [
            "normal",
            "italic"
        ]);
        this.size = getMeasurement(e1.size, "10pt");
        this.typeface = e1.typeface || "Courier";
        this.underline = getInteger({
            data: e1.underline,
            defaultValue: 0,
            validate: (e1)=>1 === e1 || 2 === e1
        });
        this.underlinePeriod = getStringOption(e1.underlinePeriod, [
            "all",
            "word"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.weight = getStringOption(e1.weight, [
            "normal",
            "bold"
        ]);
        this.extras = null;
        this.fill = null;
    }
    [Ys](e1) {
        super[Ys](e1);
        this[Cr].usedTypefaces.add(this.typeface);
    }
    [Zr]() {
        const e1 = toStyle(this, "fill"), t = e1.color;
        if (t) {
            if ("#000000" === t) delete e1.color;
            else if (!t.startsWith("#")) {
                e1.background = t;
                e1.backgroundClip = "text";
                e1.color = "transparent";
            }
        }
        this.baselineShift && (e1.verticalAlign = measureToString(this.baselineShift));
        e1.fontKerning = "none" === this.kerningMode ? "none" : "normal";
        e1.letterSpacing = measureToString(this.letterSpacing);
        if (0 !== this.lineThrough) {
            e1.textDecoration = "line-through";
            2 === this.lineThrough && (e1.textDecorationStyle = "double");
        }
        if (0 !== this.overline) {
            e1.textDecoration = "overline";
            2 === this.overline && (e1.textDecorationStyle = "double");
        }
        e1.fontStyle = this.posture;
        e1.fontSize = measureToString(.99 * this.size);
        setFontFamily(this, this, this[Cr].fontFinder, e1);
        if (0 !== this.underline) {
            e1.textDecoration = "underline";
            2 === this.underline && (e1.textDecorationStyle = "double");
        }
        e1.fontWeight = this.weight;
        return e1;
    }
}
class Format extends XFAObject {
    constructor(e1){
        super(Nn, "format", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.picture = null;
    }
}
class Handler extends StringObject {
    constructor(e1){
        super(Nn, "handler");
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Hyphenation extends XFAObject {
    constructor(e1){
        super(Nn, "hyphenation");
        this.excludeAllCaps = getInteger({
            data: e1.excludeAllCaps,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.excludeInitialCap = getInteger({
            data: e1.excludeInitialCap,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.hyphenate = getInteger({
            data: e1.hyphenate,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.id = e1.id || "";
        this.pushCharacterCount = getInteger({
            data: e1.pushCharacterCount,
            defaultValue: 3,
            validate: (e1)=>e1 >= 0
        });
        this.remainCharacterCount = getInteger({
            data: e1.remainCharacterCount,
            defaultValue: 3,
            validate: (e1)=>e1 >= 0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.wordCharacterCount = getInteger({
            data: e1.wordCharacterCount,
            defaultValue: 7,
            validate: (e1)=>e1 >= 0
        });
    }
}
class Image extends StringObject {
    constructor(e1){
        super(Nn, "image");
        this.aspect = getStringOption(e1.aspect, [
            "fit",
            "actual",
            "height",
            "none",
            "width"
        ]);
        this.contentType = e1.contentType || "";
        this.href = e1.href || "";
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.transferEncoding = getStringOption(e1.transferEncoding, [
            "base64",
            "none",
            "package"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [jr]() {
        if (this.contentType && !Un.has(this.contentType.toLowerCase())) return HTMLResult.EMPTY;
        let e1 = this[Cr].images && this[Cr].images.get(this.href);
        if (!e1 && (this.href || !this[Os])) return HTMLResult.EMPTY;
        e1 || "base64" !== this.transferEncoding || (e1 = function fromBase64Util(e1) {
            return Uint8Array.fromBase64 ? Uint8Array.fromBase64(e1) : stringToBytes(atob(e1));
        }(this[Os]));
        if (!e1) return HTMLResult.EMPTY;
        if (!this.contentType) {
            for (const [t, i] of xn)if (e1.length > t.length && t.every((t, i)=>t === e1[i])) {
                this.contentType = i;
                break;
            }
            if (!this.contentType) return HTMLResult.EMPTY;
        }
        const t = new Blob([
            e1
        ], {
            type: this.contentType
        });
        let i;
        switch(this.aspect){
            case "fit":
            case "actual":
                break;
            case "height":
                i = {
                    height: "100%",
                    objectFit: "fill"
                };
                break;
            case "none":
                i = {
                    width: "100%",
                    height: "100%",
                    objectFit: "fill"
                };
                break;
            case "width":
                i = {
                    width: "100%",
                    objectFit: "fill"
                };
        }
        const a = this[Ir]();
        return HTMLResult.success({
            name: "img",
            attributes: {
                class: [
                    "xfaImage"
                ],
                style: i,
                src: URL.createObjectURL(t),
                alt: a ? ariaLabel(a[Ir]()) : null
            }
        });
    }
}
class ImageEdit extends XFAObject {
    constructor(e1){
        super(Nn, "imageEdit", !0);
        this.data = getStringOption(e1.data, [
            "link",
            "embed"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
    }
    [jr](e1) {
        return "embed" === this.data ? HTMLResult.success({
            name: "div",
            children: [],
            attributes: {}
        }) : HTMLResult.EMPTY;
    }
}
class Integer extends ContentObject {
    constructor(e1){
        super(Nn, "integer");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Zs]() {
        const e1 = parseInt(this[Os].trim(), 10);
        this[Os] = isNaN(e1) ? null : e1;
    }
    [jr](e1) {
        return valueToHtml(null !== this[Os] ? this[Os].toString() : "");
    }
}
class Issuers extends XFAObject {
    constructor(e1){
        super(Nn, "issuers", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.certificate = new XFAObjectArray;
    }
}
class Items extends XFAObject {
    constructor(e1){
        super(Nn, "items", !0);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.ref = e1.ref || "";
        this.save = getInteger({
            data: e1.save,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
    [jr]() {
        const e1 = [];
        for (const t of this[rr]())e1.push(t[Pr]());
        return HTMLResult.success(e1);
    }
}
class Keep extends XFAObject {
    constructor(e1){
        super(Nn, "keep", !0);
        this.id = e1.id || "";
        const t = [
            "none",
            "contentArea",
            "pageArea"
        ];
        this.intact = getStringOption(e1.intact, t);
        this.next = getStringOption(e1.next, t);
        this.previous = getStringOption(e1.previous, t);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
}
class KeyUsage extends XFAObject {
    constructor(e1){
        super(Nn, "keyUsage");
        const t = [
            "",
            "yes",
            "no"
        ];
        this.crlSign = getStringOption(e1.crlSign, t);
        this.dataEncipherment = getStringOption(e1.dataEncipherment, t);
        this.decipherOnly = getStringOption(e1.decipherOnly, t);
        this.digitalSignature = getStringOption(e1.digitalSignature, t);
        this.encipherOnly = getStringOption(e1.encipherOnly, t);
        this.id = e1.id || "";
        this.keyAgreement = getStringOption(e1.keyAgreement, t);
        this.keyCertSign = getStringOption(e1.keyCertSign, t);
        this.keyEncipherment = getStringOption(e1.keyEncipherment, t);
        this.nonRepudiation = getStringOption(e1.nonRepudiation, t);
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Line extends XFAObject {
    constructor(e1){
        super(Nn, "line", !0);
        this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]);
        this.id = e1.id || "";
        this.slope = getStringOption(e1.slope, [
            "\\",
            "/"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.edge = null;
    }
    [jr]() {
        const e1 = this[Ir]()[Ir](), t = this.edge || new Edge({}), i = t[Zr](), a = Object.create(null), s = "visible" === t.presence ? t.thickness : 0;
        a.strokeWidth = measureToString(s);
        a.stroke = i.color;
        let r, n, g, o, c = "100%", C = "100%";
        if (e1.w <= s) {
            [r, n, g, o] = [
                "50%",
                0,
                "50%",
                "100%"
            ];
            c = a.strokeWidth;
        } else if (e1.h <= s) {
            [r, n, g, o] = [
                0,
                "50%",
                "100%",
                "50%"
            ];
            C = a.strokeWidth;
        } else "\\" === this.slope ? [r, n, g, o] = [
            0,
            0,
            "100%",
            "100%"
        ] : [r, n, g, o] = [
            0,
            "100%",
            "100%",
            0
        ];
        const h = {
            name: "svg",
            children: [
                {
                    name: "line",
                    attributes: {
                        xmlns: Gn,
                        x1: r,
                        y1: n,
                        x2: g,
                        y2: o,
                        style: a
                    }
                }
            ],
            attributes: {
                xmlns: Gn,
                width: c,
                height: C,
                style: {
                    overflow: "visible"
                }
            }
        };
        if (hasMargin(e1)) return HTMLResult.success({
            name: "div",
            attributes: {
                style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                }
            },
            children: [
                h
            ]
        });
        h.attributes.style.position = "absolute";
        return HTMLResult.success(h);
    }
}
class Linear extends XFAObject {
    constructor(e1){
        super(Nn, "linear", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "toRight",
            "toBottom",
            "toLeft",
            "toTop"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Zr](e1) {
        e1 = e1 ? e1[Zr]() : "#FFFFFF";
        return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e1}, ${this.color ? this.color[Zr]() : "#000000"})`;
    }
}
class LockDocument extends ContentObject {
    constructor(e1){
        super(Nn, "lockDocument");
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Zs]() {
        this[Os] = getStringOption(this[Os], [
            "auto",
            "0",
            "1"
        ]);
    }
}
class Manifest extends XFAObject {
    constructor(e1){
        super(Nn, "manifest", !0);
        this.action = getStringOption(e1.action, [
            "include",
            "all",
            "exclude"
        ]);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.ref = new XFAObjectArray;
    }
}
class Margin extends XFAObject {
    constructor(e1){
        super(Nn, "margin", !0);
        this.bottomInset = getMeasurement(e1.bottomInset, "0");
        this.id = e1.id || "";
        this.leftInset = getMeasurement(e1.leftInset, "0");
        this.rightInset = getMeasurement(e1.rightInset, "0");
        this.topInset = getMeasurement(e1.topInset, "0");
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
    [Zr]() {
        return {
            margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset)
        };
    }
}
class Mdp extends XFAObject {
    constructor(e1){
        super(Nn, "mdp");
        this.id = e1.id || "";
        this.permissions = getInteger({
            data: e1.permissions,
            defaultValue: 2,
            validate: (e1)=>1 === e1 || 3 === e1
        });
        this.signatureType = getStringOption(e1.signatureType, [
            "filler",
            "author"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Medium extends XFAObject {
    constructor(e1){
        super(Nn, "medium");
        this.id = e1.id || "";
        this.imagingBBox = function getBBox(e1) {
            const t = -1;
            if (!e1) return {
                x: t,
                y: t,
                width: t,
                height: t
            };
            const i = e1.trim().split(/\s*,\s*/).map((e1)=>getMeasurement(e1, "-1"));
            if (i.length < 4 || i[2] < 0 || i[3] < 0) return {
                x: t,
                y: t,
                width: t,
                height: t
            };
            const [a, s, r, n] = i;
            return {
                x: a,
                y: s,
                width: r,
                height: n
            };
        }(e1.imagingBBox);
        this.long = getMeasurement(e1.long);
        this.orientation = getStringOption(e1.orientation, [
            "portrait",
            "landscape"
        ]);
        this.short = getMeasurement(e1.short);
        this.stock = e1.stock || "";
        this.trayIn = getStringOption(e1.trayIn, [
            "auto",
            "delegate",
            "pageFront"
        ]);
        this.trayOut = getStringOption(e1.trayOut, [
            "auto",
            "delegate"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Message extends XFAObject {
    constructor(e1){
        super(Nn, "message", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.text = new XFAObjectArray;
    }
}
class NumericEdit extends XFAObject {
    constructor(e1){
        super(Nn, "numericEdit", !0);
        this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.comb = null;
        this.extras = null;
        this.margin = null;
    }
    [jr](e1) {
        const t = toStyle(this, "border", "font", "margin"), i = this[Ir]()[Ir](), a = {
            name: "input",
            attributes: {
                type: "text",
                fieldId: i[Vr],
                dataId: i[Ws]?.[Vr] || i[Vr],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(i),
                "aria-required": !1
            }
        };
        if (isRequired(i)) {
            a.attributes["aria-required"] = !0;
            a.attributes.required = !0;
        }
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                a
            ]
        });
    }
}
class Occur extends XFAObject {
    constructor(e1){
        super(Nn, "occur", !0);
        this.id = e1.id || "";
        this.initial = "" !== e1.initial ? getInteger({
            data: e1.initial,
            defaultValue: "",
            validate: (e1)=>!0
        }) : "";
        this.max = "" !== e1.max ? getInteger({
            data: e1.max,
            defaultValue: 1,
            validate: (e1)=>!0
        }) : "";
        this.min = "" !== e1.min ? getInteger({
            data: e1.min,
            defaultValue: 1,
            validate: (e1)=>!0
        }) : "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
    [Ys]() {
        const e1 = this[Ir](), t = this.min;
        "" === this.min && (this.min = e1 instanceof PageArea || e1 instanceof PageSet ? 0 : 1);
        "" === this.max && (this.max = "" === t ? e1 instanceof PageArea || e1 instanceof PageSet ? -1 : 1 : this.min);
        -1 !== this.max && this.max < this.min && (this.max = this.min);
        "" === this.initial && (this.initial = e1 instanceof Template ? 1 : this.min);
    }
}
class Oid extends StringObject {
    constructor(e1){
        super(Nn, "oid");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Oids extends XFAObject {
    constructor(e1){
        super(Nn, "oids", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.oid = new XFAObjectArray;
    }
}
class Overflow extends XFAObject {
    constructor(e1){
        super(Nn, "overflow");
        this.id = e1.id || "";
        this.leader = e1.leader || "";
        this.target = e1.target || "";
        this.trailer = e1.trailer || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [ar]() {
        if (!this[Xs]) {
            const e1 = this[Ir](), t = this[cr](), i = t[vr](this.target, e1), a = t[vr](this.leader, e1), s = t[vr](this.trailer, e1);
            this[Xs] = {
                target: i?.[0] || null,
                leader: a?.[0] || null,
                trailer: s?.[0] || null,
                addLeader: !1,
                addTrailer: !1
            };
        }
        return this[Xs];
    }
}
class PageArea extends XFAObject {
    constructor(e1){
        super(Nn, "pageArea", !0);
        this.blankOrNotBlank = getStringOption(e1.blankOrNotBlank, [
            "any",
            "blank",
            "notBlank"
        ]);
        this.id = e1.id || "";
        this.initialNumber = getInteger({
            data: e1.initialNumber,
            defaultValue: 1,
            validate: (e1)=>!0
        });
        this.name = e1.name || "";
        this.numbered = getInteger({
            data: e1.numbered,
            defaultValue: 1,
            validate: (e1)=>!0
        });
        this.oddOrEven = getStringOption(e1.oddOrEven, [
            "any",
            "even",
            "odd"
        ]);
        this.pagePosition = getStringOption(e1.pagePosition, [
            "any",
            "first",
            "last",
            "only",
            "rest"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.desc = null;
        this.extras = null;
        this.medium = null;
        this.occur = null;
        this.area = new XFAObjectArray;
        this.contentArea = new XFAObjectArray;
        this.draw = new XFAObjectArray;
        this.exclGroup = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.subform = new XFAObjectArray;
    }
    [br]() {
        if (!this[Xs]) {
            this[Xs] = {
                numberOfUse: 0
            };
            return !0;
        }
        return !this.occur || -1 === this.occur.max || this[Xs].numberOfUse < this.occur.max;
    }
    [vs]() {
        delete this[Xs];
    }
    [gr]() {
        this[Xs] || (this[Xs] = {
            numberOfUse: 0
        });
        const e1 = this[Ir]();
        if ("orderedOccurrence" === e1.relation && this[br]()) {
            this[Xs].numberOfUse += 1;
            return this;
        }
        return e1[gr]();
    }
    [$s]() {
        return this[Xs].space || {
            width: 0,
            height: 0
        };
    }
    [jr]() {
        this[Xs] || (this[Xs] = {
            numberOfUse: 1
        });
        const e1 = [];
        this[Xs].children = e1;
        const t = Object.create(null);
        if (this.medium && this.medium.short && this.medium.long) {
            t.width = measureToString(this.medium.short);
            t.height = measureToString(this.medium.long);
            this[Xs].space = {
                width: this.medium.short,
                height: this.medium.long
            };
            if ("landscape" === this.medium.orientation) {
                const e1 = t.width;
                t.width = t.height;
                t.height = e1;
                this[Xs].space = {
                    width: this.medium.long,
                    height: this.medium.short
                };
            }
        } else warn("XFA - No medium specified in pageArea: please file a bug.");
        this[Js]({
            filter: new Set([
                "area",
                "draw",
                "field",
                "subform"
            ]),
            include: !0
        });
        this[Js]({
            filter: new Set([
                "contentArea"
            ]),
            include: !0
        });
        return HTMLResult.success({
            name: "div",
            children: e1,
            attributes: {
                class: [
                    "xfaPage"
                ],
                id: this[Vr],
                style: t,
                xfaName: this.name
            }
        });
    }
}
class PageSet extends XFAObject {
    constructor(e1){
        super(Nn, "pageSet", !0);
        this.duplexImposition = getStringOption(e1.duplexImposition, [
            "longEdge",
            "shortEdge"
        ]);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.relation = getStringOption(e1.relation, [
            "orderedOccurrence",
            "duplexPaginated",
            "simplexPaginated"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.occur = null;
        this.pageArea = new XFAObjectArray;
        this.pageSet = new XFAObjectArray;
    }
    [vs]() {
        for (const e1 of this.pageArea.children)e1[vs]();
        for (const e1 of this.pageSet.children)e1[vs]();
    }
    [br]() {
        return !this.occur || -1 === this.occur.max || this[Xs].numberOfUse < this.occur.max;
    }
    [gr]() {
        this[Xs] || (this[Xs] = {
            numberOfUse: 1,
            pageIndex: -1,
            pageSetIndex: -1
        });
        if ("orderedOccurrence" === this.relation) {
            if (this[Xs].pageIndex + 1 < this.pageArea.children.length) {
                this[Xs].pageIndex += 1;
                return this.pageArea.children[this[Xs].pageIndex][gr]();
            }
            if (this[Xs].pageSetIndex + 1 < this.pageSet.children.length) {
                this[Xs].pageSetIndex += 1;
                return this.pageSet.children[this[Xs].pageSetIndex][gr]();
            }
            if (this[br]()) {
                this[Xs].numberOfUse += 1;
                this[Xs].pageIndex = -1;
                this[Xs].pageSetIndex = -1;
                return this[gr]();
            }
            const e1 = this[Ir]();
            if (e1 instanceof PageSet) return e1[gr]();
            this[vs]();
            return this[gr]();
        }
        const e1 = this[cr]()[Xs].pageNumber, t = e1 % 2 == 0 ? "even" : "odd", i = 0 === e1 ? "first" : "rest";
        let a = this.pageArea.children.find((e1)=>e1.oddOrEven === t && e1.pagePosition === i);
        if (a) return a;
        a = this.pageArea.children.find((e1)=>"any" === e1.oddOrEven && e1.pagePosition === i);
        if (a) return a;
        a = this.pageArea.children.find((e1)=>"any" === e1.oddOrEven && "any" === e1.pagePosition);
        return a || this.pageArea.children[0];
    }
}
class Para extends XFAObject {
    constructor(e1){
        super(Nn, "para", !0);
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.lineHeight = e1.lineHeight ? getMeasurement(e1.lineHeight, "0pt") : "";
        this.marginLeft = e1.marginLeft ? getMeasurement(e1.marginLeft, "0pt") : "";
        this.marginRight = e1.marginRight ? getMeasurement(e1.marginRight, "0pt") : "";
        this.orphans = getInteger({
            data: e1.orphans,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        });
        this.preserve = e1.preserve || "";
        this.radixOffset = e1.radixOffset ? getMeasurement(e1.radixOffset, "0pt") : "";
        this.spaceAbove = e1.spaceAbove ? getMeasurement(e1.spaceAbove, "0pt") : "";
        this.spaceBelow = e1.spaceBelow ? getMeasurement(e1.spaceBelow, "0pt") : "";
        this.tabDefault = e1.tabDefault ? getMeasurement(this.tabDefault) : "";
        this.tabStops = (e1.tabStops || "").trim().split(/\s+/).map((e1, t)=>t % 2 == 1 ? getMeasurement(e1) : e1);
        this.textIndent = e1.textIndent ? getMeasurement(e1.textIndent, "0pt") : "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.vAlign = getStringOption(e1.vAlign, [
            "top",
            "bottom",
            "middle"
        ]);
        this.widows = getInteger({
            data: e1.widows,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        });
        this.hyphenation = null;
    }
    [Zr]() {
        const e1 = toStyle(this, "hAlign");
        "" !== this.marginLeft && (e1.paddingLeft = measureToString(this.marginLeft));
        "" !== this.marginRight && (e1.paddingRight = measureToString(this.marginRight));
        "" !== this.spaceAbove && (e1.paddingTop = measureToString(this.spaceAbove));
        "" !== this.spaceBelow && (e1.paddingBottom = measureToString(this.spaceBelow));
        if ("" !== this.textIndent) {
            e1.textIndent = measureToString(this.textIndent);
            fixTextIndent(e1);
        }
        this.lineHeight > 0 && (e1.lineHeight = measureToString(this.lineHeight));
        "" !== this.tabDefault && (e1.tabSize = measureToString(this.tabDefault));
        this.tabStops.length;
        this.hyphenatation && Object.assign(e1, this.hyphenatation[Zr]());
        return e1;
    }
}
class PasswordEdit extends XFAObject {
    constructor(e1){
        super(Nn, "passwordEdit", !0);
        this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.id = e1.id || "";
        this.passwordChar = e1.passwordChar || "*";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
    }
}
class template_Pattern extends XFAObject {
    constructor(e1){
        super(Nn, "pattern", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "crossHatch",
            "crossDiagonal",
            "diagonalLeft",
            "diagonalRight",
            "horizontal",
            "vertical"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Zr](e1) {
        e1 = e1 ? e1[Zr]() : "#FFFFFF";
        const t = this.color ? this.color[Zr]() : "#000000", i = "repeating-linear-gradient", a = `${e1},${e1} 5px,${t} 5px,${t} 10px`;
        switch(this.type){
            case "crossHatch":
                return `${i}(to top,${a}) ${i}(to right,${a})`;
            case "crossDiagonal":
                return `${i}(45deg,${a}) ${i}(-45deg,${a})`;
            case "diagonalLeft":
                return `${i}(45deg,${a})`;
            case "diagonalRight":
                return `${i}(-45deg,${a})`;
            case "horizontal":
                return `${i}(to top,${a})`;
            case "vertical":
                return `${i}(to right,${a})`;
        }
        return "";
    }
}
class Picture extends StringObject {
    constructor(e1){
        super(Nn, "picture");
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Proto extends XFAObject {
    constructor(e1){
        super(Nn, "proto", !0);
        this.appearanceFilter = new XFAObjectArray;
        this.arc = new XFAObjectArray;
        this.area = new XFAObjectArray;
        this.assist = new XFAObjectArray;
        this.barcode = new XFAObjectArray;
        this.bindItems = new XFAObjectArray;
        this.bookend = new XFAObjectArray;
        this.boolean = new XFAObjectArray;
        this.border = new XFAObjectArray;
        this.break = new XFAObjectArray;
        this.breakAfter = new XFAObjectArray;
        this.breakBefore = new XFAObjectArray;
        this.button = new XFAObjectArray;
        this.calculate = new XFAObjectArray;
        this.caption = new XFAObjectArray;
        this.certificate = new XFAObjectArray;
        this.certificates = new XFAObjectArray;
        this.checkButton = new XFAObjectArray;
        this.choiceList = new XFAObjectArray;
        this.color = new XFAObjectArray;
        this.comb = new XFAObjectArray;
        this.connect = new XFAObjectArray;
        this.contentArea = new XFAObjectArray;
        this.corner = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.dateTimeEdit = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.defaultUi = new XFAObjectArray;
        this.desc = new XFAObjectArray;
        this.digestMethod = new XFAObjectArray;
        this.digestMethods = new XFAObjectArray;
        this.draw = new XFAObjectArray;
        this.edge = new XFAObjectArray;
        this.encoding = new XFAObjectArray;
        this.encodings = new XFAObjectArray;
        this.encrypt = new XFAObjectArray;
        this.encryptData = new XFAObjectArray;
        this.encryption = new XFAObjectArray;
        this.encryptionMethod = new XFAObjectArray;
        this.encryptionMethods = new XFAObjectArray;
        this.event = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.exObject = new XFAObjectArray;
        this.exclGroup = new XFAObjectArray;
        this.execute = new XFAObjectArray;
        this.extras = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.fill = new XFAObjectArray;
        this.filter = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.font = new XFAObjectArray;
        this.format = new XFAObjectArray;
        this.handler = new XFAObjectArray;
        this.hyphenation = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.imageEdit = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.issuers = new XFAObjectArray;
        this.items = new XFAObjectArray;
        this.keep = new XFAObjectArray;
        this.keyUsage = new XFAObjectArray;
        this.line = new XFAObjectArray;
        this.linear = new XFAObjectArray;
        this.lockDocument = new XFAObjectArray;
        this.manifest = new XFAObjectArray;
        this.margin = new XFAObjectArray;
        this.mdp = new XFAObjectArray;
        this.medium = new XFAObjectArray;
        this.message = new XFAObjectArray;
        this.numericEdit = new XFAObjectArray;
        this.occur = new XFAObjectArray;
        this.oid = new XFAObjectArray;
        this.oids = new XFAObjectArray;
        this.overflow = new XFAObjectArray;
        this.pageArea = new XFAObjectArray;
        this.pageSet = new XFAObjectArray;
        this.para = new XFAObjectArray;
        this.passwordEdit = new XFAObjectArray;
        this.pattern = new XFAObjectArray;
        this.picture = new XFAObjectArray;
        this.radial = new XFAObjectArray;
        this.reason = new XFAObjectArray;
        this.reasons = new XFAObjectArray;
        this.rectangle = new XFAObjectArray;
        this.ref = new XFAObjectArray;
        this.script = new XFAObjectArray;
        this.setProperty = new XFAObjectArray;
        this.signData = new XFAObjectArray;
        this.signature = new XFAObjectArray;
        this.signing = new XFAObjectArray;
        this.solid = new XFAObjectArray;
        this.speak = new XFAObjectArray;
        this.stipple = new XFAObjectArray;
        this.subform = new XFAObjectArray;
        this.subformSet = new XFAObjectArray;
        this.subjectDN = new XFAObjectArray;
        this.subjectDNs = new XFAObjectArray;
        this.submit = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.textEdit = new XFAObjectArray;
        this.time = new XFAObjectArray;
        this.timeStamp = new XFAObjectArray;
        this.toolTip = new XFAObjectArray;
        this.traversal = new XFAObjectArray;
        this.traverse = new XFAObjectArray;
        this.ui = new XFAObjectArray;
        this.validate = new XFAObjectArray;
        this.value = new XFAObjectArray;
        this.variables = new XFAObjectArray;
    }
}
class Radial extends XFAObject {
    constructor(e1){
        super(Nn, "radial", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "toEdge",
            "toCenter"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Zr](e1) {
        e1 = e1 ? e1[Zr]() : "#FFFFFF";
        const t = this.color ? this.color[Zr]() : "#000000";
        return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e1},${t}` : `${t},${e1}`})`;
    }
}
class Reason extends StringObject {
    constructor(e1){
        super(Nn, "reason");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Reasons extends XFAObject {
    constructor(e1){
        super(Nn, "reasons", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.reason = new XFAObjectArray;
    }
}
class Rectangle extends XFAObject {
    constructor(e1){
        super(Nn, "rectangle", !0);
        this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.corner = new XFAObjectArray(4);
        this.edge = new XFAObjectArray(4);
        this.fill = null;
    }
    [jr]() {
        const e1 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t = e1[Zr](), i = Object.create(null);
        "visible" === this.fill?.presence ? Object.assign(i, this.fill[Zr]()) : i.fill = "transparent";
        i.strokeWidth = measureToString("visible" === e1.presence ? e1.thickness : 0);
        i.stroke = t.color;
        const a = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[Zr](), s = {
            name: "svg",
            children: [
                {
                    name: "rect",
                    attributes: {
                        xmlns: Gn,
                        width: "100%",
                        height: "100%",
                        x: 0,
                        y: 0,
                        rx: a.radius,
                        ry: a.radius,
                        style: i
                    }
                }
            ],
            attributes: {
                xmlns: Gn,
                style: {
                    overflow: "visible"
                },
                width: "100%",
                height: "100%"
            }
        };
        if (hasMargin(this[Ir]()[Ir]())) return HTMLResult.success({
            name: "div",
            attributes: {
                style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                }
            },
            children: [
                s
            ]
        });
        s.attributes.style.position = "absolute";
        return HTMLResult.success(s);
    }
}
class RefElement extends StringObject {
    constructor(e1){
        super(Nn, "ref");
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Script extends StringObject {
    constructor(e1){
        super(Nn, "script");
        this.binding = e1.binding || "";
        this.contentType = e1.contentType || "";
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.runAt = getStringOption(e1.runAt, [
            "client",
            "both",
            "server"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class SetProperty extends XFAObject {
    constructor(e1){
        super(Nn, "setProperty");
        this.connection = e1.connection || "";
        this.ref = e1.ref || "";
        this.target = e1.target || "";
    }
}
class SignData extends XFAObject {
    constructor(e1){
        super(Nn, "signData", !0);
        this.id = e1.id || "";
        this.operation = getStringOption(e1.operation, [
            "sign",
            "clear",
            "verify"
        ]);
        this.ref = e1.ref || "";
        this.target = e1.target || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.filter = null;
        this.manifest = null;
    }
}
class Signature extends XFAObject {
    constructor(e1){
        super(Nn, "signature", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "PDF1.3",
            "PDF1.6"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.filter = null;
        this.manifest = null;
        this.margin = null;
    }
}
class Signing extends XFAObject {
    constructor(e1){
        super(Nn, "signing", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.certificate = new XFAObjectArray;
    }
}
class Solid extends XFAObject {
    constructor(e1){
        super(Nn, "solid", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
    [Zr](e1) {
        return e1 ? e1[Zr]() : "#FFFFFF";
    }
}
class Speak extends StringObject {
    constructor(e1){
        super(Nn, "speak");
        this.disable = getInteger({
            data: e1.disable,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.id = e1.id || "";
        this.priority = getStringOption(e1.priority, [
            "custom",
            "caption",
            "name",
            "toolTip"
        ]);
        this.rid = e1.rid || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Stipple extends XFAObject {
    constructor(e1){
        super(Nn, "stipple", !0);
        this.id = e1.id || "";
        this.rate = getInteger({
            data: e1.rate,
            defaultValue: 50,
            validate: (e1)=>e1 >= 0 && e1 <= 100
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Zr](e1) {
        const t = this.rate / 100;
        return Util.makeHexColor(Math.round(e1.value.r * (1 - t) + this.value.r * t), Math.round(e1.value.g * (1 - t) + this.value.g * t), Math.round(e1.value.b * (1 - t) + this.value.b * t));
    }
}
class Subform extends XFAObject {
    constructor(e1){
        super(Nn, "subform", !0);
        this.access = getStringOption(e1.access, [
            "open",
            "nonInteractive",
            "protected",
            "readOnly"
        ]);
        this.allowMacro = getInteger({
            data: e1.allowMacro,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.columnWidths = (e1.columnWidths || "").trim().split(/\s+/).map((e1)=>"-1" === e1 ? -1 : getMeasurement(e1));
        this.h = e1.h ? getMeasurement(e1.h) : "";
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.layout = getStringOption(e1.layout, [
            "position",
            "lr-tb",
            "rl-row",
            "rl-tb",
            "row",
            "table",
            "tb"
        ]);
        this.locale = e1.locale || "";
        this.maxH = getMeasurement(e1.maxH, "0pt");
        this.maxW = getMeasurement(e1.maxW, "0pt");
        this.mergeMode = getStringOption(e1.mergeMode, [
            "consumeData",
            "matchTemplate"
        ]);
        this.minH = getMeasurement(e1.minH, "0pt");
        this.minW = getMeasurement(e1.minW, "0pt");
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.restoreState = getStringOption(e1.restoreState, [
            "manual",
            "auto"
        ]);
        this.scope = getStringOption(e1.scope, [
            "name",
            "none"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = e1.w ? getMeasurement(e1.w) : "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.assist = null;
        this.bind = null;
        this.bookend = null;
        this.border = null;
        this.break = null;
        this.calculate = null;
        this.desc = null;
        this.extras = null;
        this.keep = null;
        this.margin = null;
        this.occur = null;
        this.overflow = null;
        this.pageSet = null;
        this.para = null;
        this.traversal = null;
        this.validate = null;
        this.variables = null;
        this.area = new XFAObjectArray;
        this.breakAfter = new XFAObjectArray;
        this.breakBefore = new XFAObjectArray;
        this.connect = new XFAObjectArray;
        this.draw = new XFAObjectArray;
        this.event = new XFAObjectArray;
        this.exObject = new XFAObjectArray;
        this.exclGroup = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.proto = new XFAObjectArray;
        this.setProperty = new XFAObjectArray;
        this.subform = new XFAObjectArray;
        this.subformSet = new XFAObjectArray;
    }
    [or]() {
        const e1 = this[Ir]();
        return e1 instanceof SubformSet ? e1[or]() : e1;
    }
    [dr]() {
        return !0;
    }
    [wr]() {
        return this.layout.endsWith("-tb") && 0 === this[Xs].attempt && this[Xs].numberInLine > 0 || this[Ir]()[wr]();
    }
    *[nr]() {
        yield* getContainedChildren(this);
    }
    [Vs]() {
        return flushHTML(this);
    }
    [Ls](e1, t) {
        addHTML(this, e1, t);
    }
    [$s]() {
        return getAvailableSpace(this);
    }
    [yr]() {
        const e1 = this[or]();
        if (!e1[yr]()) return !1;
        if (void 0 !== this[Xs]._isSplittable) return this[Xs]._isSplittable;
        if ("position" === this.layout || this.layout.includes("row")) {
            this[Xs]._isSplittable = !1;
            return !1;
        }
        if (this.keep && "none" !== this.keep.intact) {
            this[Xs]._isSplittable = !1;
            return !1;
        }
        if (e1.layout?.endsWith("-tb") && 0 !== e1[Xs].numberInLine) return !1;
        this[Xs]._isSplittable = !0;
        return !0;
    }
    [jr](e1) {
        setTabIndex(this);
        if (this.break) {
            if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
                const e1 = new BreakAfter({
                    targetType: this.break.after,
                    target: this.break.afterTarget,
                    startNew: this.break.startNew.toString()
                });
                e1[Cr] = this[Cr];
                this[Hs](e1);
                this.breakAfter.push(e1);
            }
            if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
                const e1 = new BreakBefore({
                    targetType: this.break.before,
                    target: this.break.beforeTarget,
                    startNew: this.break.startNew.toString()
                });
                e1[Cr] = this[Cr];
                this[Hs](e1);
                this.breakBefore.push(e1);
            }
            if ("" !== this.break.overflowTarget) {
                const e1 = new Overflow({
                    target: this.break.overflowTarget,
                    leader: this.break.overflowLeader,
                    trailer: this.break.overflowTrailer
                });
                e1[Cr] = this[Cr];
                this[Hs](e1);
                this.overflow.push(e1);
            }
            this[Hr](this.break);
            this.break = null;
        }
        if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
        (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
        if (this.breakBefore.children.length >= 1) {
            const e1 = this.breakBefore.children[0];
            if (handleBreak(e1)) return HTMLResult.breakNode(e1);
        }
        if (this[Xs]?.afterBreakAfter) return HTMLResult.EMPTY;
        fixDimensions(this);
        const t = [], i = {
            id: this[Vr],
            class: []
        };
        setAccess(this, i.class);
        this[Xs] || (this[Xs] = Object.create(null));
        Object.assign(this[Xs], {
            children: t,
            line: null,
            attributes: i,
            attempt: 0,
            numberInLine: 0,
            availableSpace: {
                width: Math.min(this.w || 1 / 0, e1.width),
                height: Math.min(this.h || 1 / 0, e1.height)
            },
            width: 0,
            height: 0,
            prevHeight: 0,
            currentWidth: 0
        });
        const a = this[cr](), s = a[Xs].noLayoutFailure, r = this[yr]();
        r || setFirstUnsplittable(this);
        if (!checkDimensions(this, e1)) return HTMLResult.FAILURE;
        const n = new Set([
            "area",
            "draw",
            "exclGroup",
            "field",
            "subform",
            "subformSet"
        ]);
        if (this.layout.includes("row")) {
            const e1 = this[or]().columnWidths;
            if (Array.isArray(e1) && e1.length > 0) {
                this[Xs].columnWidths = e1;
                this[Xs].currentColumn = 0;
            }
        }
        const g = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), o = [
            "xfaSubform"
        ], c = layoutClass(this);
        c && o.push(c);
        i.style = g;
        i.class = o;
        this.name && (i.xfaName = this.name);
        if (this.overflow) {
            const t = this.overflow[ar]();
            if (t.addLeader) {
                t.addLeader = !1;
                handleOverflow(this, t.leader, e1);
            }
        }
        this[Lr]();
        const C = "lr-tb" === this.layout || "rl-tb" === this.layout, h = C ? 2 : 1;
        for(; this[Xs].attempt < h; this[Xs].attempt++){
            C && 1 === this[Xs].attempt && (this[Xs].numberInLine = 0);
            const e1 = this[Js]({
                filter: n,
                include: !0
            });
            if (e1.success) break;
            if (e1.isBreak()) {
                this[xr]();
                return e1;
            }
            if (C && 0 === this[Xs].attempt && 0 === this[Xs].numberInLine && !a[Xs].noLayoutFailure) {
                this[Xs].attempt = h;
                break;
            }
        }
        this[xr]();
        r || unsetFirstUnsplittable(this);
        a[Xs].noLayoutFailure = s;
        if (this[Xs].attempt === h) {
            this.overflow && (this[cr]()[Xs].overflowNode = this.overflow);
            r || delete this[Xs];
            return HTMLResult.FAILURE;
        }
        if (this.overflow) {
            const t = this.overflow[ar]();
            if (t.addTrailer) {
                t.addTrailer = !1;
                handleOverflow(this, t.trailer, e1);
            }
        }
        let l = 0, Q = 0;
        if (this.margin) {
            l = this.margin.leftInset + this.margin.rightInset;
            Q = this.margin.topInset + this.margin.bottomInset;
        }
        const E = Math.max(this[Xs].width + l, this.w || 0), u = Math.max(this[Xs].height + Q, this.h || 0), d = [
            this.x,
            this.y,
            E,
            u
        ];
        "" === this.w && (g.width = measureToString(E));
        "" === this.h && (g.height = measureToString(u));
        if (("0px" === g.width || "0px" === g.height) && 0 === t.length) return HTMLResult.EMPTY;
        const f = {
            name: "div",
            attributes: i,
            children: t
        };
        applyAssist(this, i);
        const p = HTMLResult.success(createWrapper(this, f), d);
        if (this.breakAfter.children.length >= 1) {
            const e1 = this.breakAfter.children[0];
            if (handleBreak(e1)) {
                this[Xs].afterBreakAfter = p;
                return HTMLResult.breakNode(e1);
            }
        }
        delete this[Xs];
        return p;
    }
}
class SubformSet extends XFAObject {
    constructor(e1){
        super(Nn, "subformSet", !0);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.relation = getStringOption(e1.relation, [
            "ordered",
            "choice",
            "unordered"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.bookend = null;
        this.break = null;
        this.desc = null;
        this.extras = null;
        this.occur = null;
        this.overflow = null;
        this.breakAfter = new XFAObjectArray;
        this.breakBefore = new XFAObjectArray;
        this.subform = new XFAObjectArray;
        this.subformSet = new XFAObjectArray;
    }
    *[nr]() {
        yield* getContainedChildren(this);
    }
    [or]() {
        let e1 = this[Ir]();
        for(; !(e1 instanceof Subform);)e1 = e1[Ir]();
        return e1;
    }
    [dr]() {
        return !0;
    }
}
class SubjectDN extends ContentObject {
    constructor(e1){
        super(Nn, "subjectDN");
        this.delimiter = e1.delimiter || ",";
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Zs]() {
        this[Os] = new Map(this[Os].split(this.delimiter).map((e1)=>{
            (e1 = e1.split("=", 2))[0] = e1[0].trim();
            return e1;
        }));
    }
}
class SubjectDNs extends XFAObject {
    constructor(e1){
        super(Nn, "subjectDNs", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.subjectDN = new XFAObjectArray;
    }
}
class Submit extends XFAObject {
    constructor(e1){
        super(Nn, "submit", !0);
        this.embedPDF = getInteger({
            data: e1.embedPDF,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.format = getStringOption(e1.format, [
            "xdp",
            "formdata",
            "pdf",
            "urlencoded",
            "xfd",
            "xml"
        ]);
        this.id = e1.id || "";
        this.target = e1.target || "";
        this.textEncoding = getKeyword({
            data: e1.textEncoding ? e1.textEncoding.toLowerCase() : "",
            defaultValue: "",
            validate: (e1)=>[
                    "utf-8",
                    "big-five",
                    "fontspecific",
                    "gbk",
                    "gb-18030",
                    "gb-2312",
                    "ksc-5601",
                    "none",
                    "shift-jis",
                    "ucs-2",
                    "utf-16"
                ].includes(e1) || e1.match(/iso-8859-\d{2}/)
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.xdpContent = e1.xdpContent || "";
        this.encrypt = null;
        this.encryptData = new XFAObjectArray;
        this.signData = new XFAObjectArray;
    }
}
class Template extends XFAObject {
    constructor(e1){
        super(Nn, "template", !0);
        this.baseProfile = getStringOption(e1.baseProfile, [
            "full",
            "interactiveForms"
        ]);
        this.extras = null;
        this.subform = new XFAObjectArray;
    }
    [Zs]() {
        0 === this.subform.children.length && warn("XFA - No subforms in template node.");
        this.subform.children.length >= 2 && warn("XFA - Several subforms in template node: please file a bug.");
        this[Or] = 5e3;
    }
    [yr]() {
        return !0;
    }
    [vr](e1, t) {
        return e1.startsWith("#") ? [
            this[lr].get(e1.slice(1))
        ] : searchNode(this, t, e1, !0, !0);
    }
    *[Wr]() {
        if (!this.subform.children.length) return HTMLResult.success({
            name: "div",
            children: []
        });
        this[Xs] = {
            overflowNode: null,
            firstUnsplittable: null,
            currentContentArea: null,
            currentPageArea: null,
            noLayoutFailure: !1,
            pageNumber: 1,
            pagePosition: "first",
            oddOrEven: "odd",
            blankOrNotBlank: "nonBlank",
            paraStack: []
        };
        const e1 = this.subform.children[0];
        e1.pageSet[vs]();
        const t = e1.pageSet.pageArea.children, i = {
            name: "div",
            children: []
        };
        let a = null, s = null, r = null;
        if (e1.breakBefore.children.length >= 1) {
            s = e1.breakBefore.children[0];
            r = s.target;
        } else if (e1.subform.children.length >= 1 && e1.subform.children[0].breakBefore.children.length >= 1) {
            s = e1.subform.children[0].breakBefore.children[0];
            r = s.target;
        } else if (e1.break?.beforeTarget) {
            s = e1.break;
            r = s.beforeTarget;
        } else if (e1.subform.children.length >= 1 && e1.subform.children[0].break?.beforeTarget) {
            s = e1.subform.children[0].break;
            r = s.beforeTarget;
        }
        if (s) {
            const e1 = this[vr](r, s[Ir]());
            if (e1 instanceof PageArea) {
                a = e1;
                s[Xs] = {};
            }
        }
        a || (a = t[0]);
        a[Xs] = {
            numberOfUse: 1
        };
        const n = a[Ir]();
        n[Xs] = {
            numberOfUse: 1,
            pageIndex: n.pageArea.children.indexOf(a),
            pageSetIndex: 0
        };
        let g, o = null, c = null, C = !0, h = 0, l = 0;
        for(;;){
            if (C) h = 0;
            else {
                i.children.pop();
                if (3 == ++h) {
                    warn("XFA - Something goes wrong: please file a bug.");
                    return i;
                }
            }
            g = null;
            this[Xs].currentPageArea = a;
            const t = a[jr]().html;
            i.children.push(t);
            if (o) {
                this[Xs].noLayoutFailure = !0;
                t.children.push(o[jr](a[Xs].space).html);
                o = null;
            }
            if (c) {
                this[Xs].noLayoutFailure = !0;
                t.children.push(c[jr](a[Xs].space).html);
                c = null;
            }
            const s = a.contentArea.children, r = t.children.filter((e1)=>e1.attributes.class.includes("xfaContentarea"));
            C = !1;
            this[Xs].firstUnsplittable = null;
            this[Xs].noLayoutFailure = !1;
            const flush = (t)=>{
                const i = e1[Vs]();
                if (i) {
                    C ||= i.children?.length > 0;
                    r[t].children.push(i);
                }
            };
            for(let t = l, a = s.length; t < a; t++){
                const a = this[Xs].currentContentArea = s[t], n = {
                    width: a.w,
                    height: a.h
                };
                l = 0;
                if (o) {
                    r[t].children.push(o[jr](n).html);
                    o = null;
                }
                if (c) {
                    r[t].children.push(c[jr](n).html);
                    c = null;
                }
                const h = e1[jr](n);
                if (h.success) {
                    if (h.html) {
                        C ||= h.html.children?.length > 0;
                        r[t].children.push(h.html);
                    } else !C && i.children.length > 1 && i.children.pop();
                    return i;
                }
                if (h.isBreak()) {
                    const e1 = h.breakNode;
                    flush(t);
                    if ("auto" === e1.targetType) continue;
                    if (e1.leader) {
                        o = this[vr](e1.leader, e1[Ir]());
                        o = o ? o[0] : null;
                    }
                    if (e1.trailer) {
                        c = this[vr](e1.trailer, e1[Ir]());
                        c = c ? c[0] : null;
                    }
                    if ("pageArea" === e1.targetType) {
                        g = e1[Xs].target;
                        t = 1 / 0;
                    } else if (e1[Xs].target) {
                        g = e1[Xs].target;
                        l = e1[Xs].index + 1;
                        t = 1 / 0;
                    } else t = e1[Xs].index;
                } else if (this[Xs].overflowNode) {
                    const e1 = this[Xs].overflowNode;
                    this[Xs].overflowNode = null;
                    const i = e1[ar](), a = i.target;
                    i.addLeader = null !== i.leader;
                    i.addTrailer = null !== i.trailer;
                    flush(t);
                    const r = t;
                    t = 1 / 0;
                    if (a instanceof PageArea) g = a;
                    else if (a instanceof ContentArea) {
                        const e1 = s.indexOf(a);
                        if (-1 !== e1) e1 > r ? t = e1 - 1 : l = e1;
                        else {
                            g = a[Ir]();
                            l = g.contentArea.children.indexOf(a);
                        }
                    }
                } else flush(t);
            }
            this[Xs].pageNumber += 1;
            g && (g[br]() ? g[Xs].numberOfUse += 1 : g = null);
            a = g || a[gr]();
            yield null;
        }
    }
}
class Text extends ContentObject {
    constructor(e1){
        super(Nn, "text");
        this.id = e1.id || "";
        this.maxChars = getInteger({
            data: e1.maxChars,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        });
        this.name = e1.name || "";
        this.rid = e1.rid || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [xs]() {
        return !0;
    }
    [Nr](e1) {
        if (e1[Sr] === _r.xhtml.id) {
            this[Os] = e1;
            return !0;
        }
        warn(`XFA - Invalid content in Text: ${e1[kr]}.`);
        return !1;
    }
    [Mr](e1) {
        this[Os] instanceof XFAObject || super[Mr](e1);
    }
    [Zs]() {
        "string" == typeof this[Os] && (this[Os] = this[Os].replaceAll("\r\n", "\n"));
    }
    [ar]() {
        return "string" == typeof this[Os] ? this[Os].split(/[\u2029\u2028\n]/).reduce((e1, t)=>{
            t && e1.push(t);
            return e1;
        }, []).join("\n") : this[Os][Pr]();
    }
    [jr](e1) {
        if ("string" == typeof this[Os]) {
            const e1 = valueToHtml(this[Os]).html;
            if (this[Os].includes("\u2029")) {
                e1.name = "div";
                e1.children = [];
                this[Os].split("\u2029").map((e1)=>e1.split(/[\u2028\n]/).reduce((e1, t)=>{
                        e1.push({
                            name: "span",
                            value: t
                        }, {
                            name: "br"
                        });
                        return e1;
                    }, [])).forEach((t)=>{
                    e1.children.push({
                        name: "p",
                        children: t
                    });
                });
            } else if (/[\u2028\n]/.test(this[Os])) {
                e1.name = "div";
                e1.children = [];
                this[Os].split(/[\u2028\n]/).forEach((t)=>{
                    e1.children.push({
                        name: "span",
                        value: t
                    }, {
                        name: "br"
                    });
                });
            }
            return HTMLResult.success(e1);
        }
        return this[Os][jr](e1);
    }
}
class TextEdit extends XFAObject {
    constructor(e1){
        super(Nn, "textEdit", !0);
        this.allowRichText = getInteger({
            data: e1.allowRichText,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.id = e1.id || "";
        this.multiLine = getInteger({
            data: e1.multiLine,
            defaultValue: "",
            validate: (e1)=>0 === e1 || 1 === e1
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.vScrollPolicy = getStringOption(e1.vScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.border = null;
        this.comb = null;
        this.extras = null;
        this.margin = null;
    }
    [jr](e1) {
        const t = toStyle(this, "border", "font", "margin");
        let i;
        const a = this[Ir]()[Ir]();
        "" === this.multiLine && (this.multiLine = a instanceof Draw ? 1 : 0);
        i = 1 === this.multiLine ? {
            name: "textarea",
            attributes: {
                dataId: a[Ws]?.[Vr] || a[Vr],
                fieldId: a[Vr],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(a),
                "aria-required": !1
            }
        } : {
            name: "input",
            attributes: {
                type: "text",
                dataId: a[Ws]?.[Vr] || a[Vr],
                fieldId: a[Vr],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(a),
                "aria-required": !1
            }
        };
        if (isRequired(a)) {
            i.attributes["aria-required"] = !0;
            i.attributes.required = !0;
        }
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                i
            ]
        });
    }
}
class Time extends StringObject {
    constructor(e1){
        super(Nn, "time");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Zs]() {
        const e1 = this[Os].trim();
        this[Os] = e1 ? new Date(e1) : null;
    }
    [jr](e1) {
        return valueToHtml(this[Os] ? this[Os].toString() : "");
    }
}
class TimeStamp extends XFAObject {
    constructor(e1){
        super(Nn, "timeStamp");
        this.id = e1.id || "";
        this.server = e1.server || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class ToolTip extends StringObject {
    constructor(e1){
        super(Nn, "toolTip");
        this.id = e1.id || "";
        this.rid = e1.rid || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Traversal extends XFAObject {
    constructor(e1){
        super(Nn, "traversal", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.traverse = new XFAObjectArray;
    }
}
class Traverse extends XFAObject {
    constructor(e1){
        super(Nn, "traverse", !0);
        this.id = e1.id || "";
        this.operation = getStringOption(e1.operation, [
            "next",
            "back",
            "down",
            "first",
            "left",
            "right",
            "up"
        ]);
        this.ref = e1.ref || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.script = null;
    }
    get name() {
        return this.operation;
    }
    [Dr]() {
        return !1;
    }
}
class Ui extends XFAObject {
    constructor(e1){
        super(Nn, "ui", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.picture = null;
        this.barcode = null;
        this.button = null;
        this.checkButton = null;
        this.choiceList = null;
        this.dateTimeEdit = null;
        this.defaultUi = null;
        this.imageEdit = null;
        this.numericEdit = null;
        this.passwordEdit = null;
        this.signature = null;
        this.textEdit = null;
    }
    [ar]() {
        if (void 0 === this[Xs]) {
            for (const e1 of Object.getOwnPropertyNames(this)){
                if ("extras" === e1 || "picture" === e1) continue;
                const t = this[e1];
                if (t instanceof XFAObject) {
                    this[Xs] = t;
                    return t;
                }
            }
            this[Xs] = null;
        }
        return this[Xs];
    }
    [jr](e1) {
        const t = this[ar]();
        return t ? t[jr](e1) : HTMLResult.EMPTY;
    }
}
class Validate extends XFAObject {
    constructor(e1){
        super(Nn, "validate", !0);
        this.formatTest = getStringOption(e1.formatTest, [
            "warning",
            "disabled",
            "error"
        ]);
        this.id = e1.id || "";
        this.nullTest = getStringOption(e1.nullTest, [
            "disabled",
            "error",
            "warning"
        ]);
        this.scriptTest = getStringOption(e1.scriptTest, [
            "error",
            "disabled",
            "warning"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.message = null;
        this.picture = null;
        this.script = null;
    }
}
class Value extends XFAObject {
    constructor(e1){
        super(Nn, "value", !0);
        this.id = e1.id || "";
        this.override = getInteger({
            data: e1.override,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.arc = null;
        this.boolean = null;
        this.date = null;
        this.dateTime = null;
        this.decimal = null;
        this.exData = null;
        this.float = null;
        this.image = null;
        this.integer = null;
        this.line = null;
        this.rectangle = null;
        this.text = null;
        this.time = null;
    }
    [qr](e1) {
        const t = this[Ir]();
        if (t instanceof Field && t.ui?.imageEdit) {
            if (!this.image) {
                this.image = new Image({});
                this[Hs](this.image);
            }
            this.image[Os] = e1[Os];
            return;
        }
        const i = e1[kr];
        if (null === this[i]) {
            for (const e1 of Object.getOwnPropertyNames(this)){
                const t = this[e1];
                if (t instanceof XFAObject) {
                    this[e1] = null;
                    this[Hr](t);
                }
            }
            this[e1[kr]] = e1;
            this[Hs](e1);
        } else this[i][Os] = e1[Os];
    }
    [Pr]() {
        if (this.exData) return "string" == typeof this.exData[Os] ? this.exData[Os].trim() : this.exData[Os][Pr]().trim();
        for (const e1 of Object.getOwnPropertyNames(this)){
            if ("image" === e1) continue;
            const t = this[e1];
            if (t instanceof XFAObject) return (t[Os] || "").toString().trim();
        }
        return null;
    }
    [jr](e1) {
        for (const t of Object.getOwnPropertyNames(this)){
            const i = this[t];
            if (i instanceof XFAObject) return i[jr](e1);
        }
        return HTMLResult.EMPTY;
    }
}
class Variables extends XFAObject {
    constructor(e1){
        super(Nn, "variables", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.manifest = new XFAObjectArray;
        this.script = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
    [Dr]() {
        return !0;
    }
}
class TemplateNamespace {
    static [zr](e1, t) {
        if (TemplateNamespace.hasOwnProperty(e1)) {
            const i = TemplateNamespace[e1](t);
            i[Tr](t);
            return i;
        }
    }
    static appearanceFilter(e1) {
        return new AppearanceFilter(e1);
    }
    static arc(e1) {
        return new Arc(e1);
    }
    static area(e1) {
        return new Area(e1);
    }
    static assist(e1) {
        return new Assist(e1);
    }
    static barcode(e1) {
        return new Barcode(e1);
    }
    static bind(e1) {
        return new Bind(e1);
    }
    static bindItems(e1) {
        return new BindItems(e1);
    }
    static bookend(e1) {
        return new Bookend(e1);
    }
    static boolean(e1) {
        return new BooleanElement(e1);
    }
    static border(e1) {
        return new Border(e1);
    }
    static break(e1) {
        return new Break(e1);
    }
    static breakAfter(e1) {
        return new BreakAfter(e1);
    }
    static breakBefore(e1) {
        return new BreakBefore(e1);
    }
    static button(e1) {
        return new Button(e1);
    }
    static calculate(e1) {
        return new Calculate(e1);
    }
    static caption(e1) {
        return new Caption(e1);
    }
    static certificate(e1) {
        return new Certificate(e1);
    }
    static certificates(e1) {
        return new Certificates(e1);
    }
    static checkButton(e1) {
        return new CheckButton(e1);
    }
    static choiceList(e1) {
        return new ChoiceList(e1);
    }
    static color(e1) {
        return new Color(e1);
    }
    static comb(e1) {
        return new Comb(e1);
    }
    static connect(e1) {
        return new Connect(e1);
    }
    static contentArea(e1) {
        return new ContentArea(e1);
    }
    static corner(e1) {
        return new Corner(e1);
    }
    static date(e1) {
        return new DateElement(e1);
    }
    static dateTime(e1) {
        return new DateTime(e1);
    }
    static dateTimeEdit(e1) {
        return new DateTimeEdit(e1);
    }
    static decimal(e1) {
        return new Decimal(e1);
    }
    static defaultUi(e1) {
        return new DefaultUi(e1);
    }
    static desc(e1) {
        return new Desc(e1);
    }
    static digestMethod(e1) {
        return new DigestMethod(e1);
    }
    static digestMethods(e1) {
        return new DigestMethods(e1);
    }
    static draw(e1) {
        return new Draw(e1);
    }
    static edge(e1) {
        return new Edge(e1);
    }
    static encoding(e1) {
        return new Encoding(e1);
    }
    static encodings(e1) {
        return new Encodings(e1);
    }
    static encrypt(e1) {
        return new Encrypt(e1);
    }
    static encryptData(e1) {
        return new EncryptData(e1);
    }
    static encryption(e1) {
        return new Encryption(e1);
    }
    static encryptionMethod(e1) {
        return new EncryptionMethod(e1);
    }
    static encryptionMethods(e1) {
        return new EncryptionMethods(e1);
    }
    static event(e1) {
        return new Event(e1);
    }
    static exData(e1) {
        return new ExData(e1);
    }
    static exObject(e1) {
        return new ExObject(e1);
    }
    static exclGroup(e1) {
        return new ExclGroup(e1);
    }
    static execute(e1) {
        return new Execute(e1);
    }
    static extras(e1) {
        return new Extras(e1);
    }
    static field(e1) {
        return new Field(e1);
    }
    static fill(e1) {
        return new Fill(e1);
    }
    static filter(e1) {
        return new Filter(e1);
    }
    static float(e1) {
        return new Float(e1);
    }
    static font(e1) {
        return new template_Font(e1);
    }
    static format(e1) {
        return new Format(e1);
    }
    static handler(e1) {
        return new Handler(e1);
    }
    static hyphenation(e1) {
        return new Hyphenation(e1);
    }
    static image(e1) {
        return new Image(e1);
    }
    static imageEdit(e1) {
        return new ImageEdit(e1);
    }
    static integer(e1) {
        return new Integer(e1);
    }
    static issuers(e1) {
        return new Issuers(e1);
    }
    static items(e1) {
        return new Items(e1);
    }
    static keep(e1) {
        return new Keep(e1);
    }
    static keyUsage(e1) {
        return new KeyUsage(e1);
    }
    static line(e1) {
        return new Line(e1);
    }
    static linear(e1) {
        return new Linear(e1);
    }
    static lockDocument(e1) {
        return new LockDocument(e1);
    }
    static manifest(e1) {
        return new Manifest(e1);
    }
    static margin(e1) {
        return new Margin(e1);
    }
    static mdp(e1) {
        return new Mdp(e1);
    }
    static medium(e1) {
        return new Medium(e1);
    }
    static message(e1) {
        return new Message(e1);
    }
    static numericEdit(e1) {
        return new NumericEdit(e1);
    }
    static occur(e1) {
        return new Occur(e1);
    }
    static oid(e1) {
        return new Oid(e1);
    }
    static oids(e1) {
        return new Oids(e1);
    }
    static overflow(e1) {
        return new Overflow(e1);
    }
    static pageArea(e1) {
        return new PageArea(e1);
    }
    static pageSet(e1) {
        return new PageSet(e1);
    }
    static para(e1) {
        return new Para(e1);
    }
    static passwordEdit(e1) {
        return new PasswordEdit(e1);
    }
    static pattern(e1) {
        return new template_Pattern(e1);
    }
    static picture(e1) {
        return new Picture(e1);
    }
    static proto(e1) {
        return new Proto(e1);
    }
    static radial(e1) {
        return new Radial(e1);
    }
    static reason(e1) {
        return new Reason(e1);
    }
    static reasons(e1) {
        return new Reasons(e1);
    }
    static rectangle(e1) {
        return new Rectangle(e1);
    }
    static ref(e1) {
        return new RefElement(e1);
    }
    static script(e1) {
        return new Script(e1);
    }
    static setProperty(e1) {
        return new SetProperty(e1);
    }
    static signData(e1) {
        return new SignData(e1);
    }
    static signature(e1) {
        return new Signature(e1);
    }
    static signing(e1) {
        return new Signing(e1);
    }
    static solid(e1) {
        return new Solid(e1);
    }
    static speak(e1) {
        return new Speak(e1);
    }
    static stipple(e1) {
        return new Stipple(e1);
    }
    static subform(e1) {
        return new Subform(e1);
    }
    static subformSet(e1) {
        return new SubformSet(e1);
    }
    static subjectDN(e1) {
        return new SubjectDN(e1);
    }
    static subjectDNs(e1) {
        return new SubjectDNs(e1);
    }
    static submit(e1) {
        return new Submit(e1);
    }
    static template(e1) {
        return new Template(e1);
    }
    static text(e1) {
        return new Text(e1);
    }
    static textEdit(e1) {
        return new TextEdit(e1);
    }
    static time(e1) {
        return new Time(e1);
    }
    static timeStamp(e1) {
        return new TimeStamp(e1);
    }
    static toolTip(e1) {
        return new ToolTip(e1);
    }
    static traversal(e1) {
        return new Traversal(e1);
    }
    static traverse(e1) {
        return new Traverse(e1);
    }
    static ui(e1) {
        return new Ui(e1);
    }
    static validate(e1) {
        return new Validate(e1);
    }
    static value(e1) {
        return new Value(e1);
    }
    static variables(e1) {
        return new Variables(e1);
    }
}
const Ln = _r.datasets.id;
function createText(e1) {
    const t = new Text({});
    t[Os] = e1;
    return t;
}
class Binder {
    constructor(e1){
        this.root = e1;
        this.datasets = e1.datasets;
        this.data = e1.datasets?.data || new XmlObject(_r.datasets.id, "data");
        this.emptyMerge = 0 === this.data[rr]().length;
        this.root.form = this.form = e1.template[Ts]();
    }
    _isConsumeData() {
        return !this.emptyMerge && this._mergeMode;
    }
    _isMatchTemplate() {
        return !this._isConsumeData();
    }
    bind() {
        this._bindElement(this.form, this.data);
        return this.form;
    }
    getData() {
        return this.data;
    }
    _bindValue(e1, t, i) {
        e1[Ws] = t;
        if (e1[hr]()) if (t[fr]()) {
            const i = t[ir]();
            e1[qr](createText(i));
        } else if (e1 instanceof Field && "multiSelect" === e1.ui?.choiceList?.open) {
            const i = t[rr]().map((e1)=>e1[Os].trim()).join("\n");
            e1[qr](createText(i));
        } else this._isConsumeData() && warn("XFA - Nodes haven't the same type.");
        else !t[fr]() || this._isMatchTemplate() ? this._bindElement(e1, t) : warn("XFA - Nodes haven't the same type.");
    }
    _findDataByNameToConsume(e1, t, i, a) {
        if (!e1) return null;
        let s, r;
        for(let a = 0; a < 3; a++){
            s = i[sr](e1, !1, !0);
            for(;;){
                r = s.next().value;
                if (!r) break;
                if (t === r[fr]()) return r;
            }
            if (i[Sr] === _r.datasets.id && "data" === i[kr]) break;
            i = i[Ir]();
        }
        if (!a) return null;
        s = this.data[sr](e1, !0, !1);
        r = s.next().value;
        if (r) return r;
        s = this.data[zs](e1, !0);
        r = s.next().value;
        return r?.[fr]() ? r : null;
    }
    _setProperties(e1, t) {
        if (e1.hasOwnProperty("setProperty")) for (const { ref: i, target: a, connection: s } of e1.setProperty.children){
            if (s) continue;
            if (!i) continue;
            const r = searchNode(this.root, t, i, !1, !1);
            if (!r) {
                warn(`XFA - Invalid reference: ${i}.`);
                continue;
            }
            const [n] = r;
            if (!n[pr](this.data)) {
                warn("XFA - Invalid node: must be a data node.");
                continue;
            }
            const g = searchNode(this.root, e1, a, !1, !1);
            if (!g) {
                warn(`XFA - Invalid target: ${a}.`);
                continue;
            }
            const [o] = g;
            if (!o[pr](e1)) {
                warn("XFA - Invalid target: must be a property or subproperty.");
                continue;
            }
            const c = o[Ir]();
            if (o instanceof SetProperty || c instanceof SetProperty) {
                warn("XFA - Invalid target: cannot be a setProperty or one of its properties.");
                continue;
            }
            if (o instanceof BindItems || c instanceof BindItems) {
                warn("XFA - Invalid target: cannot be a bindItems or one of its properties.");
                continue;
            }
            const C = n[Pr](), h = o[kr];
            if (o instanceof XFAAttribute) {
                const e1 = Object.create(null);
                e1[h] = C;
                const t = Reflect.construct(Object.getPrototypeOf(c).constructor, [
                    e1
                ]);
                c[h] = t[h];
            } else if (o.hasOwnProperty(Os)) {
                o[Ws] = n;
                o[Os] = C;
                o[Zs]();
            } else warn("XFA - Invalid node to use in setProperty");
        }
    }
    _bindItems(e1, t) {
        if (!e1.hasOwnProperty("items") || !e1.hasOwnProperty("bindItems") || e1.bindItems.isEmpty()) return;
        for (const t of e1.items.children)e1[Hr](t);
        e1.items.clear();
        const i = new Items({}), a = new Items({});
        e1[Hs](i);
        e1.items.push(i);
        e1[Hs](a);
        e1.items.push(a);
        for (const { ref: s, labelRef: r, valueRef: n, connection: g } of e1.bindItems.children){
            if (g) continue;
            if (!s) continue;
            const e1 = searchNode(this.root, t, s, !1, !1);
            if (e1) for (const t of e1){
                if (!t[pr](this.datasets)) {
                    warn(`XFA - Invalid ref (${s}): must be a datasets child.`);
                    continue;
                }
                const e1 = searchNode(this.root, t, r, !0, !1);
                if (!e1) {
                    warn(`XFA - Invalid label: ${r}.`);
                    continue;
                }
                const [g] = e1;
                if (!g[pr](this.datasets)) {
                    warn("XFA - Invalid label: must be a datasets child.");
                    continue;
                }
                const o = searchNode(this.root, t, n, !0, !1);
                if (!o) {
                    warn(`XFA - Invalid value: ${n}.`);
                    continue;
                }
                const [c] = o;
                if (!c[pr](this.datasets)) {
                    warn("XFA - Invalid value: must be a datasets child.");
                    continue;
                }
                const C = createText(g[Pr]()), h = createText(c[Pr]());
                i[Hs](C);
                i.text.push(C);
                a[Hs](h);
                a.text.push(h);
            }
            else warn(`XFA - Invalid reference: ${s}.`);
        }
    }
    _bindOccurrences(e1, t, i) {
        let a;
        if (t.length > 1) {
            a = e1[Ts]();
            a[Hr](a.occur);
            a.occur = null;
        }
        this._bindValue(e1, t[0], i);
        this._setProperties(e1, t[0]);
        this._bindItems(e1, t[0]);
        if (1 === t.length) return;
        const s = e1[Ir](), r = e1[kr], n = s[Qr](e1);
        for(let e1 = 1, g = t.length; e1 < g; e1++){
            const g = t[e1], o = a[Ts]();
            s[r].push(o);
            s[Er](n + e1, o);
            this._bindValue(o, g, i);
            this._setProperties(o, g);
            this._bindItems(o, g);
        }
    }
    _createOccurrences(e1) {
        if (!this.emptyMerge) return;
        const { occur: t } = e1;
        if (!t || t.initial <= 1) return;
        const i = e1[Ir](), a = e1[kr];
        if (!(i[a] instanceof XFAObjectArray)) return;
        let s;
        s = e1.name ? i[a].children.filter((t)=>t.name === e1.name).length : i[a].children.length;
        const r = i[Qr](e1) + 1, n = t.initial - s;
        if (n) {
            const t = e1[Ts]();
            t[Hr](t.occur);
            t.occur = null;
            i[a].push(t);
            i[Er](r, t);
            for(let e1 = 1; e1 < n; e1++){
                const s = t[Ts]();
                i[a].push(s);
                i[Er](r + e1, s);
            }
        }
    }
    _getOccurInfo(e1) {
        const { name: t, occur: i } = e1;
        if (!i || !t) return [
            1,
            1
        ];
        const a = -1 === i.max ? 1 / 0 : i.max;
        return [
            i.min,
            a
        ];
    }
    _setAndBind(e1, t) {
        this._setProperties(e1, t);
        this._bindItems(e1, t);
        this._bindElement(e1, t);
    }
    _bindElement(e1, t) {
        const i = [];
        this._createOccurrences(e1);
        for (const a of e1[rr]()){
            if (a[Ws]) continue;
            if (void 0 === this._mergeMode && "subform" === a[kr]) {
                this._mergeMode = "consumeData" === a.mergeMode;
                const e1 = t[rr]();
                if (e1.length > 0) this._bindOccurrences(a, [
                    e1[0]
                ], null);
                else if (this.emptyMerge) {
                    const e1 = t[Sr] === Ln ? -1 : t[Sr], i = a[Ws] = new XmlObject(e1, a.name || "root");
                    t[Hs](i);
                    this._bindElement(a, i);
                }
                continue;
            }
            if (!a[dr]()) continue;
            let e1 = !1, s = null, r = null, n = null;
            if (a.bind) {
                switch(a.bind.match){
                    case "none":
                        this._setAndBind(a, t);
                        continue;
                    case "global":
                        e1 = !0;
                        break;
                    case "dataRef":
                        if (!a.bind.ref) {
                            warn(`XFA - ref is empty in node ${a[kr]}.`);
                            this._setAndBind(a, t);
                            continue;
                        }
                        r = a.bind.ref;
                }
                a.bind.picture && (s = a.bind.picture[Os]);
            }
            const [g, o] = this._getOccurInfo(a);
            if (r) {
                n = searchNode(this.root, t, r, !0, !1);
                if (null === n) {
                    n = createDataNode(this.data, t, r);
                    if (!n) continue;
                    this._isConsumeData() && (n[qs] = !0);
                    this._setAndBind(a, n);
                    continue;
                }
                this._isConsumeData() && (n = n.filter((e1)=>!e1[qs]));
                n.length > o ? n = n.slice(0, o) : 0 === n.length && (n = null);
                n && this._isConsumeData() && n.forEach((e1)=>{
                    e1[qs] = !0;
                });
            } else {
                if (!a.name) {
                    this._setAndBind(a, t);
                    continue;
                }
                if (this._isConsumeData()) {
                    const i = [];
                    for(; i.length < o;){
                        const s = this._findDataByNameToConsume(a.name, a[hr](), t, e1);
                        if (!s) break;
                        s[qs] = !0;
                        i.push(s);
                    }
                    n = i.length > 0 ? i : null;
                } else {
                    n = t[sr](a.name, !1, this.emptyMerge).next().value;
                    if (!n) {
                        if (0 === g) {
                            i.push(a);
                            continue;
                        }
                        const e1 = t[Sr] === Ln ? -1 : t[Sr];
                        n = a[Ws] = new XmlObject(e1, a.name);
                        this.emptyMerge && (n[qs] = !0);
                        t[Hs](n);
                        this._setAndBind(a, n);
                        continue;
                    }
                    this.emptyMerge && (n[qs] = !0);
                    n = [
                        n
                    ];
                }
            }
            n ? this._bindOccurrences(a, n, s) : g > 0 ? this._setAndBind(a, t) : i.push(a);
        }
        i.forEach((e1)=>e1[Ir]()[Hr](e1));
    }
}
class DataHandler {
    constructor(e1, t){
        this.data = t;
        this.dataset = e1.datasets || null;
    }
    serialize(e1) {
        const t = [
            [
                -1,
                this.data[rr]()
            ]
        ];
        for(; t.length > 0;){
            const i = t.at(-1), [a, s] = i;
            if (a + 1 === s.length) {
                t.pop();
                continue;
            }
            const r = s[++i[0]], n = e1.get(r[Vr]);
            if (n) r[qr](n);
            else {
                const t = r[_s]();
                for (const i of t.values()){
                    const t = e1.get(i[Vr]);
                    if (t) {
                        i[qr](t);
                        break;
                    }
                }
            }
            const g = r[rr]();
            g.length > 0 && t.push([
                -1,
                g
            ]);
        }
        const i = [
            '<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'
        ];
        if (this.dataset) for (const e1 of this.dataset[rr]())"data" !== e1[kr] && e1[Xr](i);
        this.data[Xr](i);
        i.push("</xfa:datasets>");
        return i.join("");
    }
}
const Hn = _r.config.id;
class Acrobat extends XFAObject {
    constructor(e1){
        super(Hn, "acrobat", !0);
        this.acrobat7 = null;
        this.autoSave = null;
        this.common = null;
        this.validate = null;
        this.validateApprovalSignatures = null;
        this.submitUrl = new XFAObjectArray;
    }
}
class Acrobat7 extends XFAObject {
    constructor(e1){
        super(Hn, "acrobat7", !0);
        this.dynamicRender = null;
    }
}
class ADBE_JSConsole extends OptionObject {
    constructor(e1){
        super(Hn, "ADBE_JSConsole", [
            "delegate",
            "Enable",
            "Disable"
        ]);
    }
}
class ADBE_JSDebugger extends OptionObject {
    constructor(e1){
        super(Hn, "ADBE_JSDebugger", [
            "delegate",
            "Enable",
            "Disable"
        ]);
    }
}
class AddSilentPrint extends Option01 {
    constructor(e1){
        super(Hn, "addSilentPrint");
    }
}
class AddViewerPreferences extends Option01 {
    constructor(e1){
        super(Hn, "addViewerPreferences");
    }
}
class AdjustData extends Option10 {
    constructor(e1){
        super(Hn, "adjustData");
    }
}
class AdobeExtensionLevel extends IntegerObject {
    constructor(e1){
        super(Hn, "adobeExtensionLevel", 0, (e1)=>e1 >= 1 && e1 <= 8);
    }
}
class Agent extends XFAObject {
    constructor(e1){
        super(Hn, "agent", !0);
        this.name = e1.name ? e1.name.trim() : "";
        this.common = new XFAObjectArray;
    }
}
class AlwaysEmbed extends ContentObject {
    constructor(e1){
        super(Hn, "alwaysEmbed");
    }
}
class Amd extends StringObject {
    constructor(e1){
        super(Hn, "amd");
    }
}
class config_Area extends XFAObject {
    constructor(e1){
        super(Hn, "area");
        this.level = getInteger({
            data: e1.level,
            defaultValue: 0,
            validate: (e1)=>e1 >= 1 && e1 <= 3
        });
        this.name = getStringOption(e1.name, [
            "",
            "barcode",
            "coreinit",
            "deviceDriver",
            "font",
            "general",
            "layout",
            "merge",
            "script",
            "signature",
            "sourceSet",
            "templateCache"
        ]);
    }
}
class Attributes extends OptionObject {
    constructor(e1){
        super(Hn, "attributes", [
            "preserve",
            "delegate",
            "ignore"
        ]);
    }
}
class AutoSave extends OptionObject {
    constructor(e1){
        super(Hn, "autoSave", [
            "disabled",
            "enabled"
        ]);
    }
}
class Base extends StringObject {
    constructor(e1){
        super(Hn, "base");
    }
}
class BatchOutput extends XFAObject {
    constructor(e1){
        super(Hn, "batchOutput");
        this.format = getStringOption(e1.format, [
            "none",
            "concat",
            "zip",
            "zipCompress"
        ]);
    }
}
class BehaviorOverride extends ContentObject {
    constructor(e1){
        super(Hn, "behaviorOverride");
    }
    [Zs]() {
        this[Os] = new Map(this[Os].trim().split(/\s+/).filter((e1)=>e1.includes(":")).map((e1)=>e1.split(":", 2)));
    }
}
class Cache extends XFAObject {
    constructor(e1){
        super(Hn, "cache", !0);
        this.templateCache = null;
    }
}
class Change extends Option01 {
    constructor(e1){
        super(Hn, "change");
    }
}
class Common extends XFAObject {
    constructor(e1){
        super(Hn, "common", !0);
        this.data = null;
        this.locale = null;
        this.localeSet = null;
        this.messaging = null;
        this.suppressBanner = null;
        this.template = null;
        this.validationMessaging = null;
        this.versionControl = null;
        this.log = new XFAObjectArray;
    }
}
class Compress extends XFAObject {
    constructor(e1){
        super(Hn, "compress");
        this.scope = getStringOption(e1.scope, [
            "imageOnly",
            "document"
        ]);
    }
}
class CompressLogicalStructure extends Option01 {
    constructor(e1){
        super(Hn, "compressLogicalStructure");
    }
}
class CompressObjectStream extends Option10 {
    constructor(e1){
        super(Hn, "compressObjectStream");
    }
}
class Compression extends XFAObject {
    constructor(e1){
        super(Hn, "compression", !0);
        this.compressLogicalStructure = null;
        this.compressObjectStream = null;
        this.level = null;
        this.type = null;
    }
}
class Config extends XFAObject {
    constructor(e1){
        super(Hn, "config", !0);
        this.acrobat = null;
        this.present = null;
        this.trace = null;
        this.agent = new XFAObjectArray;
    }
}
class Conformance extends OptionObject {
    constructor(e1){
        super(Hn, "conformance", [
            "A",
            "B"
        ]);
    }
}
class ContentCopy extends Option01 {
    constructor(e1){
        super(Hn, "contentCopy");
    }
}
class Copies extends IntegerObject {
    constructor(e1){
        super(Hn, "copies", 1, (e1)=>e1 >= 1);
    }
}
class Creator extends StringObject {
    constructor(e1){
        super(Hn, "creator");
    }
}
class CurrentPage extends IntegerObject {
    constructor(e1){
        super(Hn, "currentPage", 0, (e1)=>e1 >= 0);
    }
}
class Data extends XFAObject {
    constructor(e1){
        super(Hn, "data", !0);
        this.adjustData = null;
        this.attributes = null;
        this.incrementalLoad = null;
        this.outputXSL = null;
        this.range = null;
        this.record = null;
        this.startNode = null;
        this.uri = null;
        this.window = null;
        this.xsl = null;
        this.excludeNS = new XFAObjectArray;
        this.transform = new XFAObjectArray;
    }
}
class Debug extends XFAObject {
    constructor(e1){
        super(Hn, "debug", !0);
        this.uri = null;
    }
}
class DefaultTypeface extends ContentObject {
    constructor(e1){
        super(Hn, "defaultTypeface");
        this.writingScript = getStringOption(e1.writingScript, [
            "*",
            "Arabic",
            "Cyrillic",
            "EastEuropeanRoman",
            "Greek",
            "Hebrew",
            "Japanese",
            "Korean",
            "Roman",
            "SimplifiedChinese",
            "Thai",
            "TraditionalChinese",
            "Vietnamese"
        ]);
    }
}
class Destination extends OptionObject {
    constructor(e1){
        super(Hn, "destination", [
            "pdf",
            "pcl",
            "ps",
            "webClient",
            "zpl"
        ]);
    }
}
class DocumentAssembly extends Option01 {
    constructor(e1){
        super(Hn, "documentAssembly");
    }
}
class Driver extends XFAObject {
    constructor(e1){
        super(Hn, "driver", !0);
        this.name = e1.name ? e1.name.trim() : "";
        this.fontInfo = null;
        this.xdc = null;
    }
}
class DuplexOption extends OptionObject {
    constructor(e1){
        super(Hn, "duplexOption", [
            "simplex",
            "duplexFlipLongEdge",
            "duplexFlipShortEdge"
        ]);
    }
}
class DynamicRender extends OptionObject {
    constructor(e1){
        super(Hn, "dynamicRender", [
            "forbidden",
            "required"
        ]);
    }
}
class Embed extends Option01 {
    constructor(e1){
        super(Hn, "embed");
    }
}
class config_Encrypt extends Option01 {
    constructor(e1){
        super(Hn, "encrypt");
    }
}
class config_Encryption extends XFAObject {
    constructor(e1){
        super(Hn, "encryption", !0);
        this.encrypt = null;
        this.encryptionLevel = null;
        this.permissions = null;
    }
}
class EncryptionLevel extends OptionObject {
    constructor(e1){
        super(Hn, "encryptionLevel", [
            "40bit",
            "128bit"
        ]);
    }
}
class Enforce extends StringObject {
    constructor(e1){
        super(Hn, "enforce");
    }
}
class Equate extends XFAObject {
    constructor(e1){
        super(Hn, "equate");
        this.force = getInteger({
            data: e1.force,
            defaultValue: 1,
            validate: (e1)=>0 === e1
        });
        this.from = e1.from || "";
        this.to = e1.to || "";
    }
}
class EquateRange extends XFAObject {
    constructor(e1){
        super(Hn, "equateRange");
        this.from = e1.from || "";
        this.to = e1.to || "";
        this._unicodeRange = e1.unicodeRange || "";
    }
    get unicodeRange() {
        const e1 = [], t = /U\+([0-9a-fA-F]+)/, i = this._unicodeRange;
        for (let a of i.split(",").map((e1)=>e1.trim()).filter((e1)=>!!e1)){
            a = a.split("-", 2).map((e1)=>{
                const i = e1.match(t);
                return i ? parseInt(i[1], 16) : 0;
            });
            1 === a.length && a.push(a[0]);
            e1.push(a);
        }
        return shadow(this, "unicodeRange", e1);
    }
}
class Exclude extends ContentObject {
    constructor(e1){
        super(Hn, "exclude");
    }
    [Zs]() {
        this[Os] = this[Os].trim().split(/\s+/).filter((e1)=>e1 && [
                "calculate",
                "close",
                "enter",
                "exit",
                "initialize",
                "ready",
                "validate"
            ].includes(e1));
    }
}
class ExcludeNS extends StringObject {
    constructor(e1){
        super(Hn, "excludeNS");
    }
}
class FlipLabel extends OptionObject {
    constructor(e1){
        super(Hn, "flipLabel", [
            "usePrinterSetting",
            "on",
            "off"
        ]);
    }
}
class config_FontInfo extends XFAObject {
    constructor(e1){
        super(Hn, "fontInfo", !0);
        this.embed = null;
        this.map = null;
        this.subsetBelow = null;
        this.alwaysEmbed = new XFAObjectArray;
        this.defaultTypeface = new XFAObjectArray;
        this.neverEmbed = new XFAObjectArray;
    }
}
class FormFieldFilling extends Option01 {
    constructor(e1){
        super(Hn, "formFieldFilling");
    }
}
class GroupParent extends StringObject {
    constructor(e1){
        super(Hn, "groupParent");
    }
}
class IfEmpty extends OptionObject {
    constructor(e1){
        super(Hn, "ifEmpty", [
            "dataValue",
            "dataGroup",
            "ignore",
            "remove"
        ]);
    }
}
class IncludeXDPContent extends StringObject {
    constructor(e1){
        super(Hn, "includeXDPContent");
    }
}
class IncrementalLoad extends OptionObject {
    constructor(e1){
        super(Hn, "incrementalLoad", [
            "none",
            "forwardOnly"
        ]);
    }
}
class IncrementalMerge extends Option01 {
    constructor(e1){
        super(Hn, "incrementalMerge");
    }
}
class Interactive extends Option01 {
    constructor(e1){
        super(Hn, "interactive");
    }
}
class Jog extends OptionObject {
    constructor(e1){
        super(Hn, "jog", [
            "usePrinterSetting",
            "none",
            "pageSet"
        ]);
    }
}
class LabelPrinter extends XFAObject {
    constructor(e1){
        super(Hn, "labelPrinter", !0);
        this.name = getStringOption(e1.name, [
            "zpl",
            "dpl",
            "ipl",
            "tcpl"
        ]);
        this.batchOutput = null;
        this.flipLabel = null;
        this.fontInfo = null;
        this.xdc = null;
    }
}
class Layout extends OptionObject {
    constructor(e1){
        super(Hn, "layout", [
            "paginate",
            "panel"
        ]);
    }
}
class Level extends IntegerObject {
    constructor(e1){
        super(Hn, "level", 0, (e1)=>e1 > 0);
    }
}
class Linearized extends Option01 {
    constructor(e1){
        super(Hn, "linearized");
    }
}
class Locale extends StringObject {
    constructor(e1){
        super(Hn, "locale");
    }
}
class LocaleSet extends StringObject {
    constructor(e1){
        super(Hn, "localeSet");
    }
}
class Log extends XFAObject {
    constructor(e1){
        super(Hn, "log", !0);
        this.mode = null;
        this.threshold = null;
        this.to = null;
        this.uri = null;
    }
}
class MapElement extends XFAObject {
    constructor(e1){
        super(Hn, "map", !0);
        this.equate = new XFAObjectArray;
        this.equateRange = new XFAObjectArray;
    }
}
class MediumInfo extends XFAObject {
    constructor(e1){
        super(Hn, "mediumInfo", !0);
        this.map = null;
    }
}
class config_Message extends XFAObject {
    constructor(e1){
        super(Hn, "message", !0);
        this.msgId = null;
        this.severity = null;
    }
}
class Messaging extends XFAObject {
    constructor(e1){
        super(Hn, "messaging", !0);
        this.message = new XFAObjectArray;
    }
}
class Mode extends OptionObject {
    constructor(e1){
        super(Hn, "mode", [
            "append",
            "overwrite"
        ]);
    }
}
class ModifyAnnots extends Option01 {
    constructor(e1){
        super(Hn, "modifyAnnots");
    }
}
class MsgId extends IntegerObject {
    constructor(e1){
        super(Hn, "msgId", 1, (e1)=>e1 >= 1);
    }
}
class NameAttr extends StringObject {
    constructor(e1){
        super(Hn, "nameAttr");
    }
}
class NeverEmbed extends ContentObject {
    constructor(e1){
        super(Hn, "neverEmbed");
    }
}
class NumberOfCopies extends IntegerObject {
    constructor(e1){
        super(Hn, "numberOfCopies", null, (e1)=>e1 >= 2 && e1 <= 5);
    }
}
class OpenAction extends XFAObject {
    constructor(e1){
        super(Hn, "openAction", !0);
        this.destination = null;
    }
}
class Output extends XFAObject {
    constructor(e1){
        super(Hn, "output", !0);
        this.to = null;
        this.type = null;
        this.uri = null;
    }
}
class OutputBin extends StringObject {
    constructor(e1){
        super(Hn, "outputBin");
    }
}
class OutputXSL extends XFAObject {
    constructor(e1){
        super(Hn, "outputXSL", !0);
        this.uri = null;
    }
}
class Overprint extends OptionObject {
    constructor(e1){
        super(Hn, "overprint", [
            "none",
            "both",
            "draw",
            "field"
        ]);
    }
}
class Packets extends StringObject {
    constructor(e1){
        super(Hn, "packets");
    }
    [Zs]() {
        "*" !== this[Os] && (this[Os] = this[Os].trim().split(/\s+/).filter((e1)=>[
                "config",
                "datasets",
                "template",
                "xfdf",
                "xslt"
            ].includes(e1)));
    }
}
class PageOffset extends XFAObject {
    constructor(e1){
        super(Hn, "pageOffset");
        this.x = getInteger({
            data: e1.x,
            defaultValue: "useXDCSetting",
            validate: (e1)=>!0
        });
        this.y = getInteger({
            data: e1.y,
            defaultValue: "useXDCSetting",
            validate: (e1)=>!0
        });
    }
}
class PageRange extends StringObject {
    constructor(e1){
        super(Hn, "pageRange");
    }
    [Zs]() {
        const e1 = this[Os].trim().split(/\s+/).map((e1)=>parseInt(e1, 10)), t = [];
        for(let i = 0, a = e1.length; i < a; i += 2)t.push(e1.slice(i, i + 2));
        this[Os] = t;
    }
}
class Pagination extends OptionObject {
    constructor(e1){
        super(Hn, "pagination", [
            "simplex",
            "duplexShortEdge",
            "duplexLongEdge"
        ]);
    }
}
class PaginationOverride extends OptionObject {
    constructor(e1){
        super(Hn, "paginationOverride", [
            "none",
            "forceDuplex",
            "forceDuplexLongEdge",
            "forceDuplexShortEdge",
            "forceSimplex"
        ]);
    }
}
class Part extends IntegerObject {
    constructor(e1){
        super(Hn, "part", 1, (e1)=>!1);
    }
}
class Pcl extends XFAObject {
    constructor(e1){
        super(Hn, "pcl", !0);
        this.name = e1.name || "";
        this.batchOutput = null;
        this.fontInfo = null;
        this.jog = null;
        this.mediumInfo = null;
        this.outputBin = null;
        this.pageOffset = null;
        this.staple = null;
        this.xdc = null;
    }
}
class Pdf extends XFAObject {
    constructor(e1){
        super(Hn, "pdf", !0);
        this.name = e1.name || "";
        this.adobeExtensionLevel = null;
        this.batchOutput = null;
        this.compression = null;
        this.creator = null;
        this.encryption = null;
        this.fontInfo = null;
        this.interactive = null;
        this.linearized = null;
        this.openAction = null;
        this.pdfa = null;
        this.producer = null;
        this.renderPolicy = null;
        this.scriptModel = null;
        this.silentPrint = null;
        this.submitFormat = null;
        this.tagged = null;
        this.version = null;
        this.viewerPreferences = null;
        this.xdc = null;
    }
}
class Pdfa extends XFAObject {
    constructor(e1){
        super(Hn, "pdfa", !0);
        this.amd = null;
        this.conformance = null;
        this.includeXDPContent = null;
        this.part = null;
    }
}
class Permissions extends XFAObject {
    constructor(e1){
        super(Hn, "permissions", !0);
        this.accessibleContent = null;
        this.change = null;
        this.contentCopy = null;
        this.documentAssembly = null;
        this.formFieldFilling = null;
        this.modifyAnnots = null;
        this.plaintextMetadata = null;
        this.print = null;
        this.printHighQuality = null;
    }
}
class PickTrayByPDFSize extends Option01 {
    constructor(e1){
        super(Hn, "pickTrayByPDFSize");
    }
}
class config_Picture extends StringObject {
    constructor(e1){
        super(Hn, "picture");
    }
}
class PlaintextMetadata extends Option01 {
    constructor(e1){
        super(Hn, "plaintextMetadata");
    }
}
class Presence extends OptionObject {
    constructor(e1){
        super(Hn, "presence", [
            "preserve",
            "dissolve",
            "dissolveStructure",
            "ignore",
            "remove"
        ]);
    }
}
class Present extends XFAObject {
    constructor(e1){
        super(Hn, "present", !0);
        this.behaviorOverride = null;
        this.cache = null;
        this.common = null;
        this.copies = null;
        this.destination = null;
        this.incrementalMerge = null;
        this.layout = null;
        this.output = null;
        this.overprint = null;
        this.pagination = null;
        this.paginationOverride = null;
        this.script = null;
        this.validate = null;
        this.xdp = null;
        this.driver = new XFAObjectArray;
        this.labelPrinter = new XFAObjectArray;
        this.pcl = new XFAObjectArray;
        this.pdf = new XFAObjectArray;
        this.ps = new XFAObjectArray;
        this.submitUrl = new XFAObjectArray;
        this.webClient = new XFAObjectArray;
        this.zpl = new XFAObjectArray;
    }
}
class Print extends Option01 {
    constructor(e1){
        super(Hn, "print");
    }
}
class PrintHighQuality extends Option01 {
    constructor(e1){
        super(Hn, "printHighQuality");
    }
}
class PrintScaling extends OptionObject {
    constructor(e1){
        super(Hn, "printScaling", [
            "appdefault",
            "noScaling"
        ]);
    }
}
class PrinterName extends StringObject {
    constructor(e1){
        super(Hn, "printerName");
    }
}
class Producer extends StringObject {
    constructor(e1){
        super(Hn, "producer");
    }
}
class Ps extends XFAObject {
    constructor(e1){
        super(Hn, "ps", !0);
        this.name = e1.name || "";
        this.batchOutput = null;
        this.fontInfo = null;
        this.jog = null;
        this.mediumInfo = null;
        this.outputBin = null;
        this.staple = null;
        this.xdc = null;
    }
}
class Range extends ContentObject {
    constructor(e1){
        super(Hn, "range");
    }
    [Zs]() {
        this[Os] = this[Os].trim().split(/\s*,\s*/, 2).map((e1)=>e1.split("-").map((e1)=>parseInt(e1.trim(), 10))).filter((e1)=>e1.every((e1)=>!isNaN(e1))).map((e1)=>{
            1 === e1.length && e1.push(e1[0]);
            return e1;
        });
    }
}
class Record extends ContentObject {
    constructor(e1){
        super(Hn, "record");
    }
    [Zs]() {
        this[Os] = this[Os].trim();
        const e1 = parseInt(this[Os], 10);
        !isNaN(e1) && e1 >= 0 && (this[Os] = e1);
    }
}
class Relevant extends ContentObject {
    constructor(e1){
        super(Hn, "relevant");
    }
    [Zs]() {
        this[Os] = this[Os].trim().split(/\s+/);
    }
}
class Rename extends ContentObject {
    constructor(e1){
        super(Hn, "rename");
    }
    [Zs]() {
        this[Os] = this[Os].trim();
        (this[Os].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[Os])) && warn("XFA - Rename: invalid XFA name");
    }
}
class RenderPolicy extends OptionObject {
    constructor(e1){
        super(Hn, "renderPolicy", [
            "server",
            "client"
        ]);
    }
}
class RunScripts extends OptionObject {
    constructor(e1){
        super(Hn, "runScripts", [
            "both",
            "client",
            "none",
            "server"
        ]);
    }
}
class config_Script extends XFAObject {
    constructor(e1){
        super(Hn, "script", !0);
        this.currentPage = null;
        this.exclude = null;
        this.runScripts = null;
    }
}
class ScriptModel extends OptionObject {
    constructor(e1){
        super(Hn, "scriptModel", [
            "XFA",
            "none"
        ]);
    }
}
class Severity extends OptionObject {
    constructor(e1){
        super(Hn, "severity", [
            "ignore",
            "error",
            "information",
            "trace",
            "warning"
        ]);
    }
}
class SilentPrint extends XFAObject {
    constructor(e1){
        super(Hn, "silentPrint", !0);
        this.addSilentPrint = null;
        this.printerName = null;
    }
}
class Staple extends XFAObject {
    constructor(e1){
        super(Hn, "staple");
        this.mode = getStringOption(e1.mode, [
            "usePrinterSetting",
            "on",
            "off"
        ]);
    }
}
class StartNode extends StringObject {
    constructor(e1){
        super(Hn, "startNode");
    }
}
class StartPage extends IntegerObject {
    constructor(e1){
        super(Hn, "startPage", 0, (e1)=>!0);
    }
}
class SubmitFormat extends OptionObject {
    constructor(e1){
        super(Hn, "submitFormat", [
            "html",
            "delegate",
            "fdf",
            "xml",
            "pdf"
        ]);
    }
}
class SubmitUrl extends StringObject {
    constructor(e1){
        super(Hn, "submitUrl");
    }
}
class SubsetBelow extends IntegerObject {
    constructor(e1){
        super(Hn, "subsetBelow", 100, (e1)=>e1 >= 0 && e1 <= 100);
    }
}
class SuppressBanner extends Option01 {
    constructor(e1){
        super(Hn, "suppressBanner");
    }
}
class Tagged extends Option01 {
    constructor(e1){
        super(Hn, "tagged");
    }
}
class config_Template extends XFAObject {
    constructor(e1){
        super(Hn, "template", !0);
        this.base = null;
        this.relevant = null;
        this.startPage = null;
        this.uri = null;
        this.xsl = null;
    }
}
class Threshold extends OptionObject {
    constructor(e1){
        super(Hn, "threshold", [
            "trace",
            "error",
            "information",
            "warning"
        ]);
    }
}
class To extends OptionObject {
    constructor(e1){
        super(Hn, "to", [
            "null",
            "memory",
            "stderr",
            "stdout",
            "system",
            "uri"
        ]);
    }
}
class TemplateCache extends XFAObject {
    constructor(e1){
        super(Hn, "templateCache");
        this.maxEntries = getInteger({
            data: e1.maxEntries,
            defaultValue: 5,
            validate: (e1)=>e1 >= 0
        });
    }
}
class Trace extends XFAObject {
    constructor(e1){
        super(Hn, "trace", !0);
        this.area = new XFAObjectArray;
    }
}
class Transform extends XFAObject {
    constructor(e1){
        super(Hn, "transform", !0);
        this.groupParent = null;
        this.ifEmpty = null;
        this.nameAttr = null;
        this.picture = null;
        this.presence = null;
        this.rename = null;
        this.whitespace = null;
    }
}
class Type extends OptionObject {
    constructor(e1){
        super(Hn, "type", [
            "none",
            "ascii85",
            "asciiHex",
            "ccittfax",
            "flate",
            "lzw",
            "runLength",
            "native",
            "xdp",
            "mergedXDP"
        ]);
    }
}
class Uri extends StringObject {
    constructor(e1){
        super(Hn, "uri");
    }
}
class config_Validate extends OptionObject {
    constructor(e1){
        super(Hn, "validate", [
            "preSubmit",
            "prePrint",
            "preExecute",
            "preSave"
        ]);
    }
}
class ValidateApprovalSignatures extends ContentObject {
    constructor(e1){
        super(Hn, "validateApprovalSignatures");
    }
    [Zs]() {
        this[Os] = this[Os].trim().split(/\s+/).filter((e1)=>[
                "docReady",
                "postSign"
            ].includes(e1));
    }
}
class ValidationMessaging extends OptionObject {
    constructor(e1){
        super(Hn, "validationMessaging", [
            "allMessagesIndividually",
            "allMessagesTogether",
            "firstMessageOnly",
            "noMessages"
        ]);
    }
}
class Version extends OptionObject {
    constructor(e1){
        super(Hn, "version", [
            "1.7",
            "1.6",
            "1.5",
            "1.4",
            "1.3",
            "1.2"
        ]);
    }
}
class VersionControl extends XFAObject {
    constructor(e1){
        super(Hn, "VersionControl");
        this.outputBelow = getStringOption(e1.outputBelow, [
            "warn",
            "error",
            "update"
        ]);
        this.sourceAbove = getStringOption(e1.sourceAbove, [
            "warn",
            "error"
        ]);
        this.sourceBelow = getStringOption(e1.sourceBelow, [
            "update",
            "maintain"
        ]);
    }
}
class ViewerPreferences extends XFAObject {
    constructor(e1){
        super(Hn, "viewerPreferences", !0);
        this.ADBE_JSConsole = null;
        this.ADBE_JSDebugger = null;
        this.addViewerPreferences = null;
        this.duplexOption = null;
        this.enforce = null;
        this.numberOfCopies = null;
        this.pageRange = null;
        this.pickTrayByPDFSize = null;
        this.printScaling = null;
    }
}
class WebClient extends XFAObject {
    constructor(e1){
        super(Hn, "webClient", !0);
        this.name = e1.name ? e1.name.trim() : "";
        this.fontInfo = null;
        this.xdc = null;
    }
}
class Whitespace extends OptionObject {
    constructor(e1){
        super(Hn, "whitespace", [
            "preserve",
            "ltrim",
            "normalize",
            "rtrim",
            "trim"
        ]);
    }
}
class Window extends ContentObject {
    constructor(e1){
        super(Hn, "window");
    }
    [Zs]() {
        const e1 = this[Os].trim().split(/\s*,\s*/, 2).map((e1)=>parseInt(e1, 10));
        if (e1.some((e1)=>isNaN(e1))) this[Os] = [
            0,
            0
        ];
        else {
            1 === e1.length && e1.push(e1[0]);
            this[Os] = e1;
        }
    }
}
class Xdc extends XFAObject {
    constructor(e1){
        super(Hn, "xdc", !0);
        this.uri = new XFAObjectArray;
        this.xsl = new XFAObjectArray;
    }
}
class Xdp extends XFAObject {
    constructor(e1){
        super(Hn, "xdp", !0);
        this.packets = null;
    }
}
class Xsl extends XFAObject {
    constructor(e1){
        super(Hn, "xsl", !0);
        this.debug = null;
        this.uri = null;
    }
}
class Zpl extends XFAObject {
    constructor(e1){
        super(Hn, "zpl", !0);
        this.name = e1.name ? e1.name.trim() : "";
        this.batchOutput = null;
        this.flipLabel = null;
        this.fontInfo = null;
        this.xdc = null;
    }
}
class ConfigNamespace {
    static [zr](e1, t) {
        if (ConfigNamespace.hasOwnProperty(e1)) return ConfigNamespace[e1](t);
    }
    static acrobat(e1) {
        return new Acrobat(e1);
    }
    static acrobat7(e1) {
        return new Acrobat7(e1);
    }
    static ADBE_JSConsole(e1) {
        return new ADBE_JSConsole(e1);
    }
    static ADBE_JSDebugger(e1) {
        return new ADBE_JSDebugger(e1);
    }
    static addSilentPrint(e1) {
        return new AddSilentPrint(e1);
    }
    static addViewerPreferences(e1) {
        return new AddViewerPreferences(e1);
    }
    static adjustData(e1) {
        return new AdjustData(e1);
    }
    static adobeExtensionLevel(e1) {
        return new AdobeExtensionLevel(e1);
    }
    static agent(e1) {
        return new Agent(e1);
    }
    static alwaysEmbed(e1) {
        return new AlwaysEmbed(e1);
    }
    static amd(e1) {
        return new Amd(e1);
    }
    static area(e1) {
        return new config_Area(e1);
    }
    static attributes(e1) {
        return new Attributes(e1);
    }
    static autoSave(e1) {
        return new AutoSave(e1);
    }
    static base(e1) {
        return new Base(e1);
    }
    static batchOutput(e1) {
        return new BatchOutput(e1);
    }
    static behaviorOverride(e1) {
        return new BehaviorOverride(e1);
    }
    static cache(e1) {
        return new Cache(e1);
    }
    static change(e1) {
        return new Change(e1);
    }
    static common(e1) {
        return new Common(e1);
    }
    static compress(e1) {
        return new Compress(e1);
    }
    static compressLogicalStructure(e1) {
        return new CompressLogicalStructure(e1);
    }
    static compressObjectStream(e1) {
        return new CompressObjectStream(e1);
    }
    static compression(e1) {
        return new Compression(e1);
    }
    static config(e1) {
        return new Config(e1);
    }
    static conformance(e1) {
        return new Conformance(e1);
    }
    static contentCopy(e1) {
        return new ContentCopy(e1);
    }
    static copies(e1) {
        return new Copies(e1);
    }
    static creator(e1) {
        return new Creator(e1);
    }
    static currentPage(e1) {
        return new CurrentPage(e1);
    }
    static data(e1) {
        return new Data(e1);
    }
    static debug(e1) {
        return new Debug(e1);
    }
    static defaultTypeface(e1) {
        return new DefaultTypeface(e1);
    }
    static destination(e1) {
        return new Destination(e1);
    }
    static documentAssembly(e1) {
        return new DocumentAssembly(e1);
    }
    static driver(e1) {
        return new Driver(e1);
    }
    static duplexOption(e1) {
        return new DuplexOption(e1);
    }
    static dynamicRender(e1) {
        return new DynamicRender(e1);
    }
    static embed(e1) {
        return new Embed(e1);
    }
    static encrypt(e1) {
        return new config_Encrypt(e1);
    }
    static encryption(e1) {
        return new config_Encryption(e1);
    }
    static encryptionLevel(e1) {
        return new EncryptionLevel(e1);
    }
    static enforce(e1) {
        return new Enforce(e1);
    }
    static equate(e1) {
        return new Equate(e1);
    }
    static equateRange(e1) {
        return new EquateRange(e1);
    }
    static exclude(e1) {
        return new Exclude(e1);
    }
    static excludeNS(e1) {
        return new ExcludeNS(e1);
    }
    static flipLabel(e1) {
        return new FlipLabel(e1);
    }
    static fontInfo(e1) {
        return new config_FontInfo(e1);
    }
    static formFieldFilling(e1) {
        return new FormFieldFilling(e1);
    }
    static groupParent(e1) {
        return new GroupParent(e1);
    }
    static ifEmpty(e1) {
        return new IfEmpty(e1);
    }
    static includeXDPContent(e1) {
        return new IncludeXDPContent(e1);
    }
    static incrementalLoad(e1) {
        return new IncrementalLoad(e1);
    }
    static incrementalMerge(e1) {
        return new IncrementalMerge(e1);
    }
    static interactive(e1) {
        return new Interactive(e1);
    }
    static jog(e1) {
        return new Jog(e1);
    }
    static labelPrinter(e1) {
        return new LabelPrinter(e1);
    }
    static layout(e1) {
        return new Layout(e1);
    }
    static level(e1) {
        return new Level(e1);
    }
    static linearized(e1) {
        return new Linearized(e1);
    }
    static locale(e1) {
        return new Locale(e1);
    }
    static localeSet(e1) {
        return new LocaleSet(e1);
    }
    static log(e1) {
        return new Log(e1);
    }
    static map(e1) {
        return new MapElement(e1);
    }
    static mediumInfo(e1) {
        return new MediumInfo(e1);
    }
    static message(e1) {
        return new config_Message(e1);
    }
    static messaging(e1) {
        return new Messaging(e1);
    }
    static mode(e1) {
        return new Mode(e1);
    }
    static modifyAnnots(e1) {
        return new ModifyAnnots(e1);
    }
    static msgId(e1) {
        return new MsgId(e1);
    }
    static nameAttr(e1) {
        return new NameAttr(e1);
    }
    static neverEmbed(e1) {
        return new NeverEmbed(e1);
    }
    static numberOfCopies(e1) {
        return new NumberOfCopies(e1);
    }
    static openAction(e1) {
        return new OpenAction(e1);
    }
    static output(e1) {
        return new Output(e1);
    }
    static outputBin(e1) {
        return new OutputBin(e1);
    }
    static outputXSL(e1) {
        return new OutputXSL(e1);
    }
    static overprint(e1) {
        return new Overprint(e1);
    }
    static packets(e1) {
        return new Packets(e1);
    }
    static pageOffset(e1) {
        return new PageOffset(e1);
    }
    static pageRange(e1) {
        return new PageRange(e1);
    }
    static pagination(e1) {
        return new Pagination(e1);
    }
    static paginationOverride(e1) {
        return new PaginationOverride(e1);
    }
    static part(e1) {
        return new Part(e1);
    }
    static pcl(e1) {
        return new Pcl(e1);
    }
    static pdf(e1) {
        return new Pdf(e1);
    }
    static pdfa(e1) {
        return new Pdfa(e1);
    }
    static permissions(e1) {
        return new Permissions(e1);
    }
    static pickTrayByPDFSize(e1) {
        return new PickTrayByPDFSize(e1);
    }
    static picture(e1) {
        return new config_Picture(e1);
    }
    static plaintextMetadata(e1) {
        return new PlaintextMetadata(e1);
    }
    static presence(e1) {
        return new Presence(e1);
    }
    static present(e1) {
        return new Present(e1);
    }
    static print(e1) {
        return new Print(e1);
    }
    static printHighQuality(e1) {
        return new PrintHighQuality(e1);
    }
    static printScaling(e1) {
        return new PrintScaling(e1);
    }
    static printerName(e1) {
        return new PrinterName(e1);
    }
    static producer(e1) {
        return new Producer(e1);
    }
    static ps(e1) {
        return new Ps(e1);
    }
    static range(e1) {
        return new Range(e1);
    }
    static record(e1) {
        return new Record(e1);
    }
    static relevant(e1) {
        return new Relevant(e1);
    }
    static rename(e1) {
        return new Rename(e1);
    }
    static renderPolicy(e1) {
        return new RenderPolicy(e1);
    }
    static runScripts(e1) {
        return new RunScripts(e1);
    }
    static script(e1) {
        return new config_Script(e1);
    }
    static scriptModel(e1) {
        return new ScriptModel(e1);
    }
    static severity(e1) {
        return new Severity(e1);
    }
    static silentPrint(e1) {
        return new SilentPrint(e1);
    }
    static staple(e1) {
        return new Staple(e1);
    }
    static startNode(e1) {
        return new StartNode(e1);
    }
    static startPage(e1) {
        return new StartPage(e1);
    }
    static submitFormat(e1) {
        return new SubmitFormat(e1);
    }
    static submitUrl(e1) {
        return new SubmitUrl(e1);
    }
    static subsetBelow(e1) {
        return new SubsetBelow(e1);
    }
    static suppressBanner(e1) {
        return new SuppressBanner(e1);
    }
    static tagged(e1) {
        return new Tagged(e1);
    }
    static template(e1) {
        return new config_Template(e1);
    }
    static templateCache(e1) {
        return new TemplateCache(e1);
    }
    static threshold(e1) {
        return new Threshold(e1);
    }
    static to(e1) {
        return new To(e1);
    }
    static trace(e1) {
        return new Trace(e1);
    }
    static transform(e1) {
        return new Transform(e1);
    }
    static type(e1) {
        return new Type(e1);
    }
    static uri(e1) {
        return new Uri(e1);
    }
    static validate(e1) {
        return new config_Validate(e1);
    }
    static validateApprovalSignatures(e1) {
        return new ValidateApprovalSignatures(e1);
    }
    static validationMessaging(e1) {
        return new ValidationMessaging(e1);
    }
    static version(e1) {
        return new Version(e1);
    }
    static versionControl(e1) {
        return new VersionControl(e1);
    }
    static viewerPreferences(e1) {
        return new ViewerPreferences(e1);
    }
    static webClient(e1) {
        return new WebClient(e1);
    }
    static whitespace(e1) {
        return new Whitespace(e1);
    }
    static window(e1) {
        return new Window(e1);
    }
    static xdc(e1) {
        return new Xdc(e1);
    }
    static xdp(e1) {
        return new Xdp(e1);
    }
    static xsl(e1) {
        return new Xsl(e1);
    }
    static zpl(e1) {
        return new Zpl(e1);
    }
}
const Jn = _r.connectionSet.id;
class ConnectionSet extends XFAObject {
    constructor(e1){
        super(Jn, "connectionSet", !0);
        this.wsdlConnection = new XFAObjectArray;
        this.xmlConnection = new XFAObjectArray;
        this.xsdConnection = new XFAObjectArray;
    }
}
class EffectiveInputPolicy extends XFAObject {
    constructor(e1){
        super(Jn, "effectiveInputPolicy");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class EffectiveOutputPolicy extends XFAObject {
    constructor(e1){
        super(Jn, "effectiveOutputPolicy");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Operation extends StringObject {
    constructor(e1){
        super(Jn, "operation");
        this.id = e1.id || "";
        this.input = e1.input || "";
        this.name = e1.name || "";
        this.output = e1.output || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class RootElement extends StringObject {
    constructor(e1){
        super(Jn, "rootElement");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class SoapAction extends StringObject {
    constructor(e1){
        super(Jn, "soapAction");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class SoapAddress extends StringObject {
    constructor(e1){
        super(Jn, "soapAddress");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class connection_set_Uri extends StringObject {
    constructor(e1){
        super(Jn, "uri");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class WsdlAddress extends StringObject {
    constructor(e1){
        super(Jn, "wsdlAddress");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class WsdlConnection extends XFAObject {
    constructor(e1){
        super(Jn, "wsdlConnection", !0);
        this.dataDescription = e1.dataDescription || "";
        this.name = e1.name || "";
        this.effectiveInputPolicy = null;
        this.effectiveOutputPolicy = null;
        this.operation = null;
        this.soapAction = null;
        this.soapAddress = null;
        this.wsdlAddress = null;
    }
}
class XmlConnection extends XFAObject {
    constructor(e1){
        super(Jn, "xmlConnection", !0);
        this.dataDescription = e1.dataDescription || "";
        this.name = e1.name || "";
        this.uri = null;
    }
}
class XsdConnection extends XFAObject {
    constructor(e1){
        super(Jn, "xsdConnection", !0);
        this.dataDescription = e1.dataDescription || "";
        this.name = e1.name || "";
        this.rootElement = null;
        this.uri = null;
    }
}
class ConnectionSetNamespace {
    static [zr](e1, t) {
        if (ConnectionSetNamespace.hasOwnProperty(e1)) return ConnectionSetNamespace[e1](t);
    }
    static connectionSet(e1) {
        return new ConnectionSet(e1);
    }
    static effectiveInputPolicy(e1) {
        return new EffectiveInputPolicy(e1);
    }
    static effectiveOutputPolicy(e1) {
        return new EffectiveOutputPolicy(e1);
    }
    static operation(e1) {
        return new Operation(e1);
    }
    static rootElement(e1) {
        return new RootElement(e1);
    }
    static soapAction(e1) {
        return new SoapAction(e1);
    }
    static soapAddress(e1) {
        return new SoapAddress(e1);
    }
    static uri(e1) {
        return new connection_set_Uri(e1);
    }
    static wsdlAddress(e1) {
        return new WsdlAddress(e1);
    }
    static wsdlConnection(e1) {
        return new WsdlConnection(e1);
    }
    static xmlConnection(e1) {
        return new XmlConnection(e1);
    }
    static xsdConnection(e1) {
        return new XsdConnection(e1);
    }
}
const Yn = _r.datasets.id;
class datasets_Data extends XmlObject {
    constructor(e1){
        super(Yn, "data", e1);
    }
    [mr]() {
        return !0;
    }
}
class Datasets extends XFAObject {
    constructor(e1){
        super(Yn, "datasets", !0);
        this.data = null;
        this.Signature = null;
    }
    [Nr](e1) {
        const t = e1[kr];
        ("data" === t && e1[Sr] === Yn || "Signature" === t && e1[Sr] === _r.signature.id) && (this[t] = e1);
        this[Hs](e1);
    }
}
class DatasetsNamespace {
    static [zr](e1, t) {
        if (DatasetsNamespace.hasOwnProperty(e1)) return DatasetsNamespace[e1](t);
    }
    static datasets(e1) {
        return new Datasets(e1);
    }
    static data(e1) {
        return new datasets_Data(e1);
    }
}
const vn = _r.localeSet.id;
class CalendarSymbols extends XFAObject {
    constructor(e1){
        super(vn, "calendarSymbols", !0);
        this.name = "gregorian";
        this.dayNames = new XFAObjectArray(2);
        this.eraNames = null;
        this.meridiemNames = null;
        this.monthNames = new XFAObjectArray(2);
    }
}
class CurrencySymbol extends StringObject {
    constructor(e1){
        super(vn, "currencySymbol");
        this.name = getStringOption(e1.name, [
            "symbol",
            "isoname",
            "decimal"
        ]);
    }
}
class CurrencySymbols extends XFAObject {
    constructor(e1){
        super(vn, "currencySymbols", !0);
        this.currencySymbol = new XFAObjectArray(3);
    }
}
class DatePattern extends StringObject {
    constructor(e1){
        super(vn, "datePattern");
        this.name = getStringOption(e1.name, [
            "full",
            "long",
            "med",
            "short"
        ]);
    }
}
class DatePatterns extends XFAObject {
    constructor(e1){
        super(vn, "datePatterns", !0);
        this.datePattern = new XFAObjectArray(4);
    }
}
class DateTimeSymbols extends ContentObject {
    constructor(e1){
        super(vn, "dateTimeSymbols");
    }
}
class Day extends StringObject {
    constructor(e1){
        super(vn, "day");
    }
}
class DayNames extends XFAObject {
    constructor(e1){
        super(vn, "dayNames", !0);
        this.abbr = getInteger({
            data: e1.abbr,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.day = new XFAObjectArray(7);
    }
}
class Era extends StringObject {
    constructor(e1){
        super(vn, "era");
    }
}
class EraNames extends XFAObject {
    constructor(e1){
        super(vn, "eraNames", !0);
        this.era = new XFAObjectArray(2);
    }
}
class locale_set_Locale extends XFAObject {
    constructor(e1){
        super(vn, "locale", !0);
        this.desc = e1.desc || "";
        this.name = "isoname";
        this.calendarSymbols = null;
        this.currencySymbols = null;
        this.datePatterns = null;
        this.dateTimeSymbols = null;
        this.numberPatterns = null;
        this.numberSymbols = null;
        this.timePatterns = null;
        this.typeFaces = null;
    }
}
class locale_set_LocaleSet extends XFAObject {
    constructor(e1){
        super(vn, "localeSet", !0);
        this.locale = new XFAObjectArray;
    }
}
class Meridiem extends StringObject {
    constructor(e1){
        super(vn, "meridiem");
    }
}
class MeridiemNames extends XFAObject {
    constructor(e1){
        super(vn, "meridiemNames", !0);
        this.meridiem = new XFAObjectArray(2);
    }
}
class Month extends StringObject {
    constructor(e1){
        super(vn, "month");
    }
}
class MonthNames extends XFAObject {
    constructor(e1){
        super(vn, "monthNames", !0);
        this.abbr = getInteger({
            data: e1.abbr,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.month = new XFAObjectArray(12);
    }
}
class NumberPattern extends StringObject {
    constructor(e1){
        super(vn, "numberPattern");
        this.name = getStringOption(e1.name, [
            "full",
            "long",
            "med",
            "short"
        ]);
    }
}
class NumberPatterns extends XFAObject {
    constructor(e1){
        super(vn, "numberPatterns", !0);
        this.numberPattern = new XFAObjectArray(4);
    }
}
class NumberSymbol extends StringObject {
    constructor(e1){
        super(vn, "numberSymbol");
        this.name = getStringOption(e1.name, [
            "decimal",
            "grouping",
            "percent",
            "minus",
            "zero"
        ]);
    }
}
class NumberSymbols extends XFAObject {
    constructor(e1){
        super(vn, "numberSymbols", !0);
        this.numberSymbol = new XFAObjectArray(5);
    }
}
class TimePattern extends StringObject {
    constructor(e1){
        super(vn, "timePattern");
        this.name = getStringOption(e1.name, [
            "full",
            "long",
            "med",
            "short"
        ]);
    }
}
class TimePatterns extends XFAObject {
    constructor(e1){
        super(vn, "timePatterns", !0);
        this.timePattern = new XFAObjectArray(4);
    }
}
class TypeFace extends XFAObject {
    constructor(e1){
        super(vn, "typeFace", !0);
        this.name = "" | e1.name;
    }
}
class TypeFaces extends XFAObject {
    constructor(e1){
        super(vn, "typeFaces", !0);
        this.typeFace = new XFAObjectArray;
    }
}
class LocaleSetNamespace {
    static [zr](e1, t) {
        if (LocaleSetNamespace.hasOwnProperty(e1)) return LocaleSetNamespace[e1](t);
    }
    static calendarSymbols(e1) {
        return new CalendarSymbols(e1);
    }
    static currencySymbol(e1) {
        return new CurrencySymbol(e1);
    }
    static currencySymbols(e1) {
        return new CurrencySymbols(e1);
    }
    static datePattern(e1) {
        return new DatePattern(e1);
    }
    static datePatterns(e1) {
        return new DatePatterns(e1);
    }
    static dateTimeSymbols(e1) {
        return new DateTimeSymbols(e1);
    }
    static day(e1) {
        return new Day(e1);
    }
    static dayNames(e1) {
        return new DayNames(e1);
    }
    static era(e1) {
        return new Era(e1);
    }
    static eraNames(e1) {
        return new EraNames(e1);
    }
    static locale(e1) {
        return new locale_set_Locale(e1);
    }
    static localeSet(e1) {
        return new locale_set_LocaleSet(e1);
    }
    static meridiem(e1) {
        return new Meridiem(e1);
    }
    static meridiemNames(e1) {
        return new MeridiemNames(e1);
    }
    static month(e1) {
        return new Month(e1);
    }
    static monthNames(e1) {
        return new MonthNames(e1);
    }
    static numberPattern(e1) {
        return new NumberPattern(e1);
    }
    static numberPatterns(e1) {
        return new NumberPatterns(e1);
    }
    static numberSymbol(e1) {
        return new NumberSymbol(e1);
    }
    static numberSymbols(e1) {
        return new NumberSymbols(e1);
    }
    static timePattern(e1) {
        return new TimePattern(e1);
    }
    static timePatterns(e1) {
        return new TimePatterns(e1);
    }
    static typeFace(e1) {
        return new TypeFace(e1);
    }
    static typeFaces(e1) {
        return new TypeFaces(e1);
    }
}
const Kn = _r.signature.id;
class signature_Signature extends XFAObject {
    constructor(e1){
        super(Kn, "signature", !0);
    }
}
class SignatureNamespace {
    static [zr](e1, t) {
        if (SignatureNamespace.hasOwnProperty(e1)) return SignatureNamespace[e1](t);
    }
    static signature(e1) {
        return new signature_Signature(e1);
    }
}
const Tn = _r.stylesheet.id;
class Stylesheet extends XFAObject {
    constructor(e1){
        super(Tn, "stylesheet", !0);
    }
}
class StylesheetNamespace {
    static [zr](e1, t) {
        if (StylesheetNamespace.hasOwnProperty(e1)) return StylesheetNamespace[e1](t);
    }
    static stylesheet(e1) {
        return new Stylesheet(e1);
    }
}
const qn = _r.xdp.id;
class xdp_Xdp extends XFAObject {
    constructor(e1){
        super(qn, "xdp", !0);
        this.uuid = e1.uuid || "";
        this.timeStamp = e1.timeStamp || "";
        this.config = null;
        this.connectionSet = null;
        this.datasets = null;
        this.localeSet = null;
        this.stylesheet = new XFAObjectArray;
        this.template = null;
    }
    [Gr](e1) {
        const t = _r[e1[kr]];
        return t && e1[Sr] === t.id;
    }
}
class XdpNamespace {
    static [zr](e1, t) {
        if (XdpNamespace.hasOwnProperty(e1)) return XdpNamespace[e1](t);
    }
    static xdp(e1) {
        return new xdp_Xdp(e1);
    }
}
const On = _r.xhtml.id, Pn = Symbol(), Wn = new Set([
    "color",
    "font",
    "font-family",
    "font-size",
    "font-stretch",
    "font-style",
    "font-weight",
    "margin",
    "margin-bottom",
    "margin-left",
    "margin-right",
    "margin-top",
    "letter-spacing",
    "line-height",
    "orphans",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "tab-interval",
    "tab-stop",
    "text-align",
    "text-decoration",
    "text-indent",
    "vertical-align",
    "widows",
    "kerning-mode",
    "xfa-font-horizontal-scale",
    "xfa-font-vertical-scale",
    "xfa-spacerun",
    "xfa-tab-stops"
]), jn = new Map([
    [
        "page-break-after",
        "breakAfter"
    ],
    [
        "page-break-before",
        "breakBefore"
    ],
    [
        "page-break-inside",
        "breakInside"
    ],
    [
        "kerning-mode",
        (e1)=>"none" === e1 ? "none" : "normal"
    ],
    [
        "xfa-font-horizontal-scale",
        (e1)=>`scaleX(${Math.max(0, Math.min(parseInt(e1) / 100)).toFixed(2)})`
    ],
    [
        "xfa-font-vertical-scale",
        (e1)=>`scaleY(${Math.max(0, Math.min(parseInt(e1) / 100)).toFixed(2)})`
    ],
    [
        "xfa-spacerun",
        ""
    ],
    [
        "xfa-tab-stops",
        ""
    ],
    [
        "font-size",
        (e1, t)=>measureToString(.99 * (e1 = t.fontSize = Math.abs(getMeasurement(e1))))
    ],
    [
        "letter-spacing",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "line-height",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-bottom",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-left",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-right",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-top",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "text-indent",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "font-family",
        (e1)=>e1
    ],
    [
        "vertical-align",
        (e1)=>measureToString(getMeasurement(e1))
    ]
]), Xn = /\s+/g, Zn = /[\r\n]+/g, Vn = /\r\n?/g;
function mapStyle(e1, t, i) {
    const a = Object.create(null);
    if (!e1) return a;
    const s = Object.create(null);
    for (const [t, i] of e1.split(";").map((e1)=>e1.split(":", 2))){
        const e1 = jn.get(t);
        if ("" === e1) continue;
        let r = i;
        e1 && (r = "string" == typeof e1 ? e1 : e1(i, s));
        t.endsWith("scale") ? a.transform = a.transform ? `${a[t]} ${r}` : r : a[t.replaceAll(/-([a-zA-Z])/g, (e1, t)=>t.toUpperCase())] = r;
    }
    a.fontFamily && setFontFamily({
        typeface: a.fontFamily,
        weight: a.fontWeight || "normal",
        posture: a.fontStyle || "normal",
        size: s.fontSize || 0
    }, t, t[Cr].fontFinder, a);
    if (i && a.verticalAlign && "0px" !== a.verticalAlign && a.fontSize) {
        const e1 = .583, t = .333, i = getMeasurement(a.fontSize);
        a.fontSize = measureToString(i * e1);
        a.verticalAlign = measureToString(Math.sign(getMeasurement(a.verticalAlign)) * i * t);
    }
    i && a.fontSize && (a.fontSize = `calc(${a.fontSize} * var(--scale-factor))`);
    fixTextIndent(a);
    return a;
}
const zn = new Set([
    "body",
    "html"
]);
class XhtmlObject extends XmlObject {
    constructor(e1, t){
        super(On, t);
        this[Pn] = !1;
        this.style = e1.style || "";
    }
    [Ys](e1) {
        super[Ys](e1);
        this.style = function checkStyle(e1) {
            return e1.style ? e1.style.trim().split(/\s*;\s*/).filter((e1)=>!!e1).map((e1)=>e1.split(/\s*:\s*/, 2)).filter(([t, i])=>{
                "font-family" === t && e1[Cr].usedTypefaces.add(i);
                return Wn.has(t);
            }).map((e1)=>e1.join(":")).join(";") : "";
        }(this);
    }
    [xs]() {
        return !zn.has(this[kr]);
    }
    [Mr](e1, t = !1) {
        if (t) this[Pn] = !0;
        else {
            e1 = e1.replaceAll(Zn, "");
            this.style.includes("xfa-spacerun:yes") || (e1 = e1.replaceAll(Xn, " "));
        }
        e1 && (this[Os] += e1);
    }
    [Ur](e1, t = !0) {
        const i = Object.create(null), a = {
            top: NaN,
            bottom: NaN,
            left: NaN,
            right: NaN
        };
        let s = null;
        for (const [e1, t] of this.style.split(";").map((e1)=>e1.split(":", 2)))switch(e1){
            case "font-family":
                i.typeface = stripQuotes(t);
                break;
            case "font-size":
                i.size = getMeasurement(t);
                break;
            case "font-weight":
                i.weight = t;
                break;
            case "font-style":
                i.posture = t;
                break;
            case "letter-spacing":
                i.letterSpacing = getMeasurement(t);
                break;
            case "margin":
                const e2 = t.split(/ \t/).map((e1)=>getMeasurement(e1));
                switch(e2.length){
                    case 1:
                        a.top = a.bottom = a.left = a.right = e2[0];
                        break;
                    case 2:
                        a.top = a.bottom = e2[0];
                        a.left = a.right = e2[1];
                        break;
                    case 3:
                        a.top = e2[0];
                        a.bottom = e2[2];
                        a.left = a.right = e2[1];
                        break;
                    case 4:
                        a.top = e2[0];
                        a.left = e2[1];
                        a.bottom = e2[2];
                        a.right = e2[3];
                }
                break;
            case "margin-top":
                a.top = getMeasurement(t);
                break;
            case "margin-bottom":
                a.bottom = getMeasurement(t);
                break;
            case "margin-left":
                a.left = getMeasurement(t);
                break;
            case "margin-right":
                a.right = getMeasurement(t);
                break;
            case "line-height":
                s = getMeasurement(t);
        }
        e1.pushData(i, a, s);
        if (this[Os]) e1.addString(this[Os]);
        else for (const t of this[rr]())"#text" !== t[kr] ? t[Ur](e1) : e1.addString(t[Os]);
        t && e1.popFont();
    }
    [jr](e1) {
        const t = [];
        this[Xs] = {
            children: t
        };
        this[Js]({});
        if (0 === t.length && !this[Os]) return HTMLResult.EMPTY;
        let i;
        i = this[Pn] ? this[Os] ? this[Os].replaceAll(Vn, "\n") : void 0 : this[Os] || void 0;
        return HTMLResult.success({
            name: this[kr],
            attributes: {
                href: this.href,
                style: mapStyle(this.style, this, this[Pn])
            },
            children: t,
            value: i
        });
    }
}
class A extends XhtmlObject {
    constructor(e1){
        super(e1, "a");
        this.href = fixURL(e1.href) || "";
    }
}
class B extends XhtmlObject {
    constructor(e1){
        super(e1, "b");
    }
    [Ur](e1) {
        e1.pushFont({
            weight: "bold"
        });
        super[Ur](e1);
        e1.popFont();
    }
}
class Body extends XhtmlObject {
    constructor(e1){
        super(e1, "body");
    }
    [jr](e1) {
        const t = super[jr](e1), { html: i } = t;
        if (!i) return HTMLResult.EMPTY;
        i.name = "div";
        i.attributes.class = [
            "xfaRich"
        ];
        return t;
    }
}
class Br extends XhtmlObject {
    constructor(e1){
        super(e1, "br");
    }
    [Pr]() {
        return "\n";
    }
    [Ur](e1) {
        e1.addString("\n");
    }
    [jr](e1) {
        return HTMLResult.success({
            name: "br"
        });
    }
}
class Html extends XhtmlObject {
    constructor(e1){
        super(e1, "html");
    }
    [jr](e1) {
        const t = [];
        this[Xs] = {
            children: t
        };
        this[Js]({});
        if (0 === t.length) return HTMLResult.success({
            name: "div",
            attributes: {
                class: [
                    "xfaRich"
                ],
                style: {}
            },
            value: this[Os] || ""
        });
        if (1 === t.length) {
            const e1 = t[0];
            if (e1.attributes?.class.includes("xfaRich")) return HTMLResult.success(e1);
        }
        return HTMLResult.success({
            name: "div",
            attributes: {
                class: [
                    "xfaRich"
                ],
                style: {}
            },
            children: t
        });
    }
}
class I extends XhtmlObject {
    constructor(e1){
        super(e1, "i");
    }
    [Ur](e1) {
        e1.pushFont({
            posture: "italic"
        });
        super[Ur](e1);
        e1.popFont();
    }
}
class Li extends XhtmlObject {
    constructor(e1){
        super(e1, "li");
    }
}
class Ol extends XhtmlObject {
    constructor(e1){
        super(e1, "ol");
    }
}
class P extends XhtmlObject {
    constructor(e1){
        super(e1, "p");
    }
    [Ur](e1) {
        super[Ur](e1, !1);
        e1.addString("\n");
        e1.addPara();
        e1.popFont();
    }
    [Pr]() {
        return this[Ir]()[rr]().at(-1) === this ? super[Pr]() : super[Pr]() + "\n";
    }
}
class Span extends XhtmlObject {
    constructor(e1){
        super(e1, "span");
    }
}
class Sub extends XhtmlObject {
    constructor(e1){
        super(e1, "sub");
    }
}
class Sup extends XhtmlObject {
    constructor(e1){
        super(e1, "sup");
    }
}
class Ul extends XhtmlObject {
    constructor(e1){
        super(e1, "ul");
    }
}
class XhtmlNamespace {
    static [zr](e1, t) {
        if (XhtmlNamespace.hasOwnProperty(e1)) return XhtmlNamespace[e1](t);
    }
    static a(e1) {
        return new A(e1);
    }
    static b(e1) {
        return new B(e1);
    }
    static body(e1) {
        return new Body(e1);
    }
    static br(e1) {
        return new Br(e1);
    }
    static html(e1) {
        return new Html(e1);
    }
    static i(e1) {
        return new I(e1);
    }
    static li(e1) {
        return new Li(e1);
    }
    static ol(e1) {
        return new Ol(e1);
    }
    static p(e1) {
        return new P(e1);
    }
    static span(e1) {
        return new Span(e1);
    }
    static sub(e1) {
        return new Sub(e1);
    }
    static sup(e1) {
        return new Sup(e1);
    }
    static ul(e1) {
        return new Ul(e1);
    }
}
const _n = {
    config: ConfigNamespace,
    connection: ConnectionSetNamespace,
    datasets: DatasetsNamespace,
    localeSet: LocaleSetNamespace,
    signature: SignatureNamespace,
    stylesheet: StylesheetNamespace,
    template: TemplateNamespace,
    xdp: XdpNamespace,
    xhtml: XhtmlNamespace
};
class UnknownNamespace {
    constructor(e1){
        this.namespaceId = e1;
    }
    [zr](e1, t) {
        return new XmlObject(this.namespaceId, e1, t);
    }
}
class Root extends XFAObject {
    constructor(e1){
        super(-1, "root", Object.create(null));
        this.element = null;
        this[lr] = e1;
    }
    [Nr](e1) {
        this.element = e1;
        return !0;
    }
    [Zs]() {
        super[Zs]();
        if (this.element.template instanceof Template) {
            this[lr].set(Jr, this.element);
            this.element.template[Yr](this[lr]);
            this.element.template[lr] = this[lr];
        }
    }
}
class Empty extends XFAObject {
    constructor(){
        super(-1, "", Object.create(null));
    }
    [Nr](e1) {
        return !1;
    }
}
class Builder {
    constructor(e1 = null){
        this._namespaceStack = [];
        this._nsAgnosticLevel = 0;
        this._namespacePrefixes = new Map;
        this._namespaces = new Map;
        this._nextNsId = Math.max(...Object.values(_r).map(({ id: e1 })=>e1));
        this._currentNamespace = e1 || new UnknownNamespace(++this._nextNsId);
    }
    buildRoot(e1) {
        return new Root(e1);
    }
    build({ nsPrefix: e1, name: t, attributes: i, namespace: a, prefixes: s }) {
        const r = null !== a;
        if (r) {
            this._namespaceStack.push(this._currentNamespace);
            this._currentNamespace = this._searchNamespace(a);
        }
        s && this._addNamespacePrefix(s);
        if (i.hasOwnProperty(Rr)) {
            const e1 = _n.datasets, t = i[Rr];
            let a = null;
            for (const [i, s] of Object.entries(t)){
                if (this._getNamespaceToUse(i) === e1) {
                    a = {
                        xfa: s
                    };
                    break;
                }
            }
            a ? i[Rr] = a : delete i[Rr];
        }
        const n = this._getNamespaceToUse(e1), g = n?.[zr](t, i) || new Empty;
        g[mr]() && this._nsAgnosticLevel++;
        (r || s || g[mr]()) && (g[Ks] = {
            hasNamespace: r,
            prefixes: s,
            nsAgnostic: g[mr]()
        });
        return g;
    }
    isNsAgnostic() {
        return this._nsAgnosticLevel > 0;
    }
    _searchNamespace(e1) {
        let t = this._namespaces.get(e1);
        if (t) return t;
        for (const [i, { check: a }] of Object.entries(_r))if (a(e1)) {
            t = _n[i];
            if (t) {
                this._namespaces.set(e1, t);
                return t;
            }
            break;
        }
        t = new UnknownNamespace(++this._nextNsId);
        this._namespaces.set(e1, t);
        return t;
    }
    _addNamespacePrefix(e1) {
        for (const { prefix: t, value: i } of e1){
            const e1 = this._searchNamespace(i);
            let a = this._namespacePrefixes.get(t);
            if (!a) {
                a = [];
                this._namespacePrefixes.set(t, a);
            }
            a.push(e1);
        }
    }
    _getNamespaceToUse(e1) {
        if (!e1) return this._currentNamespace;
        const t = this._namespacePrefixes.get(e1);
        if (t?.length > 0) return t.at(-1);
        warn(`Unknown namespace prefix: ${e1}.`);
        return null;
    }
    clean(e1) {
        const { hasNamespace: t, prefixes: i, nsAgnostic: a } = e1;
        t && (this._currentNamespace = this._namespaceStack.pop());
        i && i.forEach(({ prefix: e1 })=>{
            this._namespacePrefixes.get(e1).pop();
        });
        a && this._nsAgnosticLevel--;
    }
}
class XFAParser extends XMLParserBase {
    constructor(e1 = null, t = !1){
        super();
        this._builder = new Builder(e1);
        this._stack = [];
        this._globalData = {
            usedTypefaces: new Set
        };
        this._ids = new Map;
        this._current = this._builder.buildRoot(this._ids);
        this._errorCode = ys;
        this._whiteRegex = /^\s+$/;
        this._nbsps = /\xa0+/g;
        this._richText = t;
    }
    parse(e1) {
        this.parseXml(e1);
        if (this._errorCode === ys) {
            this._current[Zs]();
            return this._current.element;
        }
    }
    onText(e1) {
        e1 = e1.replace(this._nbsps, (e1)=>e1.slice(1) + " ");
        this._richText || this._current[xs]() ? this._current[Mr](e1, this._richText) : this._whiteRegex.test(e1) || this._current[Mr](e1.trim());
    }
    onCdata(e1) {
        this._current[Mr](e1);
    }
    _mkAttributes(e1, t) {
        let i = null, a = null;
        const s = Object.create({});
        for (const { name: r, value: n } of e1)if ("xmlns" === r) i ? warn(`XFA - multiple namespace definition in <${t}>`) : i = n;
        else if (r.startsWith("xmlns:")) {
            const e1 = r.substring(6);
            a || (a = []);
            a.push({
                prefix: e1,
                value: n
            });
        } else {
            const e1 = r.indexOf(":");
            if (-1 === e1) s[r] = n;
            else {
                let t = s[Rr];
                t || (t = s[Rr] = Object.create(null));
                const [i, a] = [
                    r.slice(0, e1),
                    r.slice(e1 + 1)
                ];
                (t[i] ||= Object.create(null))[a] = n;
            }
        }
        return [
            i,
            a,
            s
        ];
    }
    _getNameAndPrefix(e1, t) {
        const i = e1.indexOf(":");
        return -1 === i ? [
            e1,
            null
        ] : [
            e1.substring(i + 1),
            t ? "" : e1.substring(0, i)
        ];
    }
    onBeginElement(e1, t, i) {
        const [a, s, r] = this._mkAttributes(t, e1), [n, g] = this._getNameAndPrefix(e1, this._builder.isNsAgnostic()), o = this._builder.build({
            nsPrefix: g,
            name: n,
            attributes: r,
            namespace: a,
            prefixes: s
        });
        o[Cr] = this._globalData;
        if (i) {
            o[Zs]();
            this._current[Nr](o) && o[Kr](this._ids);
            o[Ys](this._builder);
        } else {
            this._stack.push(this._current);
            this._current = o;
        }
    }
    onEndElement(e1) {
        const t = this._current;
        if (t[ur]() && "string" == typeof t[Os]) {
            const e1 = new XFAParser;
            e1._globalData = this._globalData;
            const i = e1.parse(t[Os]);
            t[Os] = null;
            t[Nr](i);
        }
        t[Zs]();
        this._current = this._stack.pop();
        this._current[Nr](t) && t[Kr](this._ids);
        t[Ys](this._builder);
    }
    onError(e1) {
        this._errorCode = e1;
    }
}
class XFAFactory {
    constructor(e1){
        try {
            this.root = (new XFAParser).parse(XFAFactory._createDocument(e1));
            const t = new Binder(this.root);
            this.form = t.bind();
            this.dataHandler = new DataHandler(this.root, t.getData());
            this.form[Cr].template = this.form;
        } catch (e1) {
            warn(`XFA - an error occurred during parsing and binding: ${e1}`);
        }
    }
    isValid() {
        return this.root && this.form;
    }
    _createPagesHelper() {
        const e1 = this.form[Wr]();
        return new Promise((t, i)=>{
            const nextIteration = ()=>{
                try {
                    const i = e1.next();
                    i.done ? t(i.value) : setTimeout(nextIteration, 0);
                } catch (e1) {
                    i(e1);
                }
            };
            setTimeout(nextIteration, 0);
        });
    }
    async _createPages() {
        try {
            this.pages = await this._createPagesHelper();
            this.dims = this.pages.children.map((e1)=>{
                const { width: t, height: i } = e1.attributes.style;
                return [
                    0,
                    0,
                    parseInt(t),
                    parseInt(i)
                ];
            });
        } catch (e1) {
            warn(`XFA - an error occurred during layout: ${e1}`);
        }
    }
    getBoundingBox(e1) {
        return this.dims[e1];
    }
    async getNumPages() {
        this.pages || await this._createPages();
        return this.dims.length;
    }
    setImages(e1) {
        this.form[Cr].images = e1;
    }
    setFonts(e1) {
        this.form[Cr].fontFinder = new FontFinder(e1);
        const t = [];
        for (let e1 of this.form[Cr].usedTypefaces){
            e1 = stripQuotes(e1);
            this.form[Cr].fontFinder.find(e1) || t.push(e1);
        }
        return t.length > 0 ? t : null;
    }
    appendFonts(e1, t) {
        this.form[Cr].fontFinder.add(e1, t);
    }
    async getPages() {
        this.pages || await this._createPages();
        const e1 = this.pages;
        this.pages = null;
        return e1;
    }
    serializeData(e1) {
        return this.dataHandler.serialize(e1);
    }
    static _createDocument(e1) {
        return e1["/xdp:xdp"] ? Object.values(e1).join("") : e1["xdp:xdp"];
    }
    static getRichTextAsHtml(e1) {
        if (!e1 || "string" != typeof e1) return null;
        try {
            let t = new XFAParser(XhtmlNamespace, !0).parse(e1);
            if (![
                "body",
                "xhtml"
            ].includes(t[kr])) {
                const e1 = XhtmlNamespace.body({});
                e1[Hs](t);
                t = e1;
            }
            const i = t[jr]();
            if (!i.success) return null;
            const { html: a } = i, { attributes: s } = a;
            if (s) {
                s.class && (s.class = s.class.filter((e1)=>!e1.startsWith("xfa")));
                s.dir = "auto";
            }
            return {
                html: a,
                str: t[Pr]()
            };
        } catch (e1) {
            warn(`XFA - an error occurred during parsing of rich text: ${e1}`);
        }
        return null;
    }
}
class AnnotationFactory {
    static createGlobals(e1) {
        return Promise.all([
            e1.ensureCatalog("acroForm"),
            e1.ensureDoc("xfaDatasets"),
            e1.ensureCatalog("structTreeRoot"),
            e1.ensureCatalog("baseUrl"),
            e1.ensureCatalog("attachments")
        ]).then(([t, i, a, s, r])=>({
                pdfManager: e1,
                acroForm: t instanceof Dict ? t : Dict.empty,
                xfaDatasets: i,
                structTreeRoot: a,
                baseUrl: s,
                attachments: r
            }), (e1)=>{
            warn(`createGlobals: "${e1}".`);
            return null;
        });
    }
    static async create(e1, t, i, a, s, r, n) {
        const g = s ? await this._getPageIndex(e1, t, i.pdfManager) : null;
        return i.pdfManager.ensure(this, "_create", [
            e1,
            t,
            i,
            a,
            s,
            r,
            g,
            n
        ]);
    }
    static _create(e1, t, i, a, s = !1, r = null, n = null, g = null) {
        const o = e1.fetchIfRef(t);
        if (!(o instanceof Dict)) return;
        const { acroForm: c, pdfManager: C } = i, h = t instanceof Ref ? t.toString() : `annot_${a.createObjId()}`;
        let l = o.get("Subtype");
        l = l instanceof Name ? l.name : null;
        const Q = {
            xref: e1,
            ref: t,
            dict: o,
            subtype: l,
            id: h,
            annotationGlobals: i,
            collectFields: s,
            orphanFields: r,
            needAppearances: !s && !0 === c.get("NeedAppearances"),
            pageIndex: n,
            evaluatorOptions: C.evaluatorOptions,
            pageRef: g
        };
        switch(l){
            case "Link":
                return new LinkAnnotation(Q);
            case "Text":
                return new TextAnnotation(Q);
            case "Widget":
                let e2 = getInheritableProperty({
                    dict: o,
                    key: "FT"
                });
                e2 = e2 instanceof Name ? e2.name : null;
                switch(e2){
                    case "Tx":
                        return new TextWidgetAnnotation(Q);
                    case "Btn":
                        return new ButtonWidgetAnnotation(Q);
                    case "Ch":
                        return new ChoiceWidgetAnnotation(Q);
                    case "Sig":
                        return new SignatureWidgetAnnotation(Q);
                }
                warn(`Unimplemented widget field type "${e2}", falling back to base field type.`);
                return new WidgetAnnotation(Q);
            case "Popup":
                return new PopupAnnotation(Q);
            case "FreeText":
                return new FreeTextAnnotation(Q);
            case "Line":
                return new LineAnnotation(Q);
            case "Square":
                return new SquareAnnotation(Q);
            case "Circle":
                return new CircleAnnotation(Q);
            case "PolyLine":
                return new PolylineAnnotation(Q);
            case "Polygon":
                return new PolygonAnnotation(Q);
            case "Caret":
                return new CaretAnnotation(Q);
            case "Ink":
                return new InkAnnotation(Q);
            case "Highlight":
                return new HighlightAnnotation(Q);
            case "Underline":
                return new UnderlineAnnotation(Q);
            case "Squiggly":
                return new SquigglyAnnotation(Q);
            case "StrikeOut":
                return new StrikeOutAnnotation(Q);
            case "Stamp":
                return new StampAnnotation(Q);
            case "FileAttachment":
                return new FileAttachmentAnnotation(Q);
            default:
                s || warn(l ? `Unimplemented annotation type "${l}", falling back to base annotation.` : "Annotation is missing the required /Subtype.");
                return new Annotation(Q);
        }
    }
    static async _getPageIndex(e1, t, i) {
        try {
            const a = await e1.fetchIfRefAsync(t);
            if (!(a instanceof Dict)) return -1;
            const s = a.getRaw("P");
            if (s instanceof Ref) try {
                return await i.ensureCatalog("getPageIndex", [
                    s
                ]);
            } catch (e1) {
                info(`_getPageIndex -- not a valid page reference: "${e1}".`);
            }
            if (a.has("Kids")) return -1;
            const r = await i.ensureDoc("numPages");
            for(let e1 = 0; e1 < r; e1++){
                const a = await i.getPage(e1), s = await i.ensure(a, "annotations");
                for (const i of s)if (i instanceof Ref && isRefsEqual(i, t)) return e1;
            }
        } catch (e1) {
            warn(`_getPageIndex: "${e1}".`);
        }
        return -1;
    }
    static generateImages(e1, t, i) {
        if (!i) {
            warn("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");
            return null;
        }
        let a;
        for (const { bitmapId: i, bitmap: s } of e1)if (s) {
            a ||= new Map;
            a.set(i, StampAnnotation.createImage(s, t));
        }
        return a;
    }
    static async saveNewAnnotations(e1, t, i, a, s) {
        const r = e1.xref;
        let n;
        const g = [], { isOffscreenCanvasSupported: o } = e1.options;
        for (const c of i)if (!c.deleted) switch(c.annotationType){
            case d:
                if (!n) {
                    const e1 = new Dict(r);
                    e1.set("BaseFont", Name.get("Helvetica"));
                    e1.set("Type", Name.get("Font"));
                    e1.set("Subtype", Name.get("Type1"));
                    e1.set("Encoding", Name.get("WinAnsiEncoding"));
                    n = r.getNewTemporaryRef();
                    s.put(n, {
                        data: e1
                    });
                }
                g.push(FreeTextAnnotation.createNewAnnotation(r, c, s, {
                    evaluator: e1,
                    task: t,
                    baseFontRef: n
                }));
                break;
            case f:
                c.quadPoints ? g.push(HighlightAnnotation.createNewAnnotation(r, c, s)) : g.push(InkAnnotation.createNewAnnotation(r, c, s));
                break;
            case m:
                g.push(InkAnnotation.createNewAnnotation(r, c, s));
                break;
            case p:
                const i = o ? await a?.get(c.bitmapId) : null;
                if (i?.imageStream) {
                    const { imageStream: e1, smaskStream: t } = i;
                    if (t) {
                        const i = r.getNewTemporaryRef();
                        s.put(i, {
                            data: t
                        });
                        e1.dict.set("SMask", i);
                    }
                    const a = i.imageRef = r.getNewTemporaryRef();
                    s.put(a, {
                        data: e1
                    });
                    i.imageStream = i.smaskStream = null;
                }
                g.push(StampAnnotation.createNewAnnotation(r, c, s, {
                    image: i
                }));
        }
        return {
            annotations: await Promise.all(g)
        };
    }
    static async printNewAnnotations(e1, t, i, a, s) {
        if (!a) return null;
        const { options: r, xref: n } = t, g = [];
        for (const o of a)if (!o.deleted) switch(o.annotationType){
            case d:
                g.push(FreeTextAnnotation.createNewPrintAnnotation(e1, n, o, {
                    evaluator: t,
                    task: i,
                    evaluatorOptions: r
                }));
                break;
            case f:
                o.quadPoints ? g.push(HighlightAnnotation.createNewPrintAnnotation(e1, n, o, {
                    evaluatorOptions: r
                })) : g.push(InkAnnotation.createNewPrintAnnotation(e1, n, o, {
                    evaluatorOptions: r
                }));
                break;
            case m:
                g.push(InkAnnotation.createNewPrintAnnotation(e1, n, o, {
                    evaluatorOptions: r
                }));
                break;
            case p:
                const a = r.isOffscreenCanvasSupported ? await s?.get(o.bitmapId) : null;
                if (a?.imageStream) {
                    const { imageStream: e1, smaskStream: t } = a;
                    t && e1.dict.set("SMask", t);
                    a.imageRef = new JpegStream(e1, e1.length);
                    a.imageStream = a.smaskStream = null;
                }
                g.push(StampAnnotation.createNewPrintAnnotation(e1, n, o, {
                    image: a,
                    evaluatorOptions: r
                }));
        }
        return Promise.all(g);
    }
}
function getRgbColor(e1, t = new Uint8ClampedArray(3)) {
    if (!Array.isArray(e1)) return t;
    const i = t || new Uint8ClampedArray(3);
    switch(e1.length){
        case 0:
            return null;
        case 1:
            ColorSpace.singletons.gray.getRgbItem(e1, 0, i, 0);
            return i;
        case 3:
            ColorSpace.singletons.rgb.getRgbItem(e1, 0, i, 0);
            return i;
        case 4:
            ColorSpace.singletons.cmyk.getRgbItem(e1, 0, i, 0);
            return i;
        default:
            return t;
    }
}
function getPdfColorArray(e1) {
    return Array.from(e1, (e1)=>e1 / 255);
}
function getQuadPoints(e1, t) {
    const i = e1.getArray("QuadPoints");
    if (!isNumberArray(i, null) || 0 === i.length || i.length % 8 > 0) return null;
    const a = new Float32Array(i.length);
    for(let e1 = 0, s = i.length; e1 < s; e1 += 8){
        const [s, r, n, g, o, c, C, h] = i.slice(e1, e1 + 8), l = Math.min(s, n, o, C), Q = Math.max(s, n, o, C), E = Math.min(r, g, c, h), u = Math.max(r, g, c, h);
        if (null !== t && (l < t[0] || Q > t[2] || E < t[1] || u > t[3])) return null;
        a.set([
            l,
            u,
            Q,
            u,
            l,
            E,
            Q,
            E
        ], e1);
    }
    return a;
}
function getTransformMatrix(e1, t, i) {
    const [a, s, r, n] = Util.getAxialAlignedBoundingBox(t, i);
    if (a === r || s === n) return [
        1,
        0,
        0,
        1,
        e1[0],
        e1[1]
    ];
    const g = (e1[2] - e1[0]) / (r - a), o = (e1[3] - e1[1]) / (n - s);
    return [
        g,
        0,
        0,
        o,
        e1[0] - a * g,
        e1[1] - s * o
    ];
}
class Annotation {
    constructor(e1){
        const { dict: t, xref: i, annotationGlobals: a, ref: s, orphanFields: r } = e1, n = r?.get(s);
        n && t.set("Parent", n);
        this.setTitle(t.get("T"));
        this.setContents(t.get("Contents"));
        this.setModificationDate(t.get("M"));
        this.setFlags(t.get("F"));
        this.setRectangle(t.getArray("Rect"));
        this.setColor(t.getArray("C"));
        this.setBorderStyle(t);
        this.setAppearance(t);
        this.setOptionalContent(t);
        const g = t.get("MK");
        this.setBorderAndBackgroundColors(g);
        this.setRotation(g, t);
        this.ref = e1.ref instanceof Ref ? e1.ref : null;
        this._streams = [];
        this.appearance && this._streams.push(this.appearance);
        const o = !!(this.flags & eA), c = !!(this.flags & tA);
        this.data = {
            annotationFlags: this.flags,
            borderStyle: this.borderStyle,
            color: this.color,
            backgroundColor: this.backgroundColor,
            borderColor: this.borderColor,
            rotation: this.rotation,
            contentsObj: this._contents,
            hasAppearance: !!this.appearance,
            id: e1.id,
            modificationDate: this.modificationDate,
            rect: this.rectangle,
            subtype: e1.subtype,
            hasOwnCanvas: !1,
            noRotate: !!(this.flags & $),
            noHTML: o && c,
            isEditable: !1,
            structParent: -1
        };
        if (a.structTreeRoot) {
            let i = t.get("StructParent");
            this.data.structParent = i = Number.isInteger(i) && i >= 0 ? i : -1;
            a.structTreeRoot.addAnnotationIdToPage(e1.pageRef, i);
        }
        if (e1.collectFields) {
            const a = t.get("Kids");
            if (Array.isArray(a)) {
                const e1 = [];
                for (const t of a)t instanceof Ref && e1.push(t.toString());
                0 !== e1.length && (this.data.kidIds = e1);
            }
            this.data.actions = collectActions(i, t, dA);
            this.data.fieldName = this._constructFieldName(t);
            this.data.pageIndex = e1.pageIndex;
        }
        const C = t.get("IT");
        C instanceof Name && (this.data.it = C.name);
        this._isOffscreenCanvasSupported = e1.evaluatorOptions.isOffscreenCanvasSupported;
        this._fallbackFontDict = null;
        this._needAppearances = !1;
    }
    _hasFlag(e1, t) {
        return !!(e1 & t);
    }
    _buildFlags(e1, t) {
        let { flags: i } = this;
        if (void 0 === e1) {
            if (void 0 === t) return;
            return t ? i & ~_ : i & ~z | _;
        }
        if (e1) {
            i |= _;
            return t ? i & ~AA | z : i & ~z | AA;
        }
        i &= ~(z | AA);
        return t ? i & ~_ : i | _;
    }
    _isViewable(e1) {
        return !this._hasFlag(e1, V) && !this._hasFlag(e1, AA);
    }
    _isPrintable(e1) {
        return this._hasFlag(e1, _) && !this._hasFlag(e1, z) && !this._hasFlag(e1, V);
    }
    mustBeViewed(e1, t) {
        const i = e1?.get(this.data.id)?.noView;
        return void 0 !== i ? !i : this.viewable && !this._hasFlag(this.flags, z);
    }
    mustBePrinted(e1) {
        const t = e1?.get(this.data.id)?.noPrint;
        return void 0 !== t ? !t : this.printable;
    }
    mustBeViewedWhenEditing(e1, t = null) {
        return e1 ? !this.data.isEditable : !t?.has(this.data.id);
    }
    get viewable() {
        return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
    }
    get printable() {
        return null !== this.data.quadPoints && 0 !== this.flags && this._isPrintable(this.flags);
    }
    _parseStringHelper(e1) {
        const t = "string" == typeof e1 ? stringToPDFString(e1) : "";
        return {
            str: t,
            dir: t && "rtl" === bidi(t).dir ? "rtl" : "ltr"
        };
    }
    setDefaultAppearance(e1) {
        const { dict: t, annotationGlobals: i } = e1, a = getInheritableProperty({
            dict: t,
            key: "DA"
        }) || i.acroForm.get("DA");
        this._defaultAppearance = "string" == typeof a ? a : "";
        this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
    }
    setTitle(e1) {
        this._title = this._parseStringHelper(e1);
    }
    setContents(e1) {
        this._contents = this._parseStringHelper(e1);
    }
    setModificationDate(e1) {
        this.modificationDate = "string" == typeof e1 ? e1 : null;
    }
    setFlags(e1) {
        this.flags = Number.isInteger(e1) && e1 > 0 ? e1 : 0;
        this.flags & V && "Annotation" !== this.constructor.name && (this.flags ^= V);
    }
    hasFlag(e1) {
        return this._hasFlag(this.flags, e1);
    }
    setRectangle(e1) {
        this.rectangle = lookupNormalRect(e1, [
            0,
            0,
            0,
            0
        ]);
    }
    setColor(e1) {
        this.color = getRgbColor(e1);
    }
    setLineEndings(e1) {
        this.lineEndings = [
            "None",
            "None"
        ];
        if (Array.isArray(e1) && 2 === e1.length) for(let t = 0; t < 2; t++){
            const i = e1[t];
            if (i instanceof Name) switch(i.name){
                case "None":
                    continue;
                case "Square":
                case "Circle":
                case "Diamond":
                case "OpenArrow":
                case "ClosedArrow":
                case "Butt":
                case "ROpenArrow":
                case "RClosedArrow":
                case "Slash":
                    this.lineEndings[t] = i.name;
                    continue;
            }
            warn(`Ignoring invalid lineEnding: ${i}`);
        }
    }
    setRotation(e1, t) {
        this.rotation = 0;
        let i = e1 instanceof Dict ? e1.get("R") || 0 : t.get("Rotate") || 0;
        if (Number.isInteger(i) && 0 !== i) {
            i %= 360;
            i < 0 && (i += 360);
            i % 90 == 0 && (this.rotation = i);
        }
    }
    setBorderAndBackgroundColors(e1) {
        if (e1 instanceof Dict) {
            this.borderColor = getRgbColor(e1.getArray("BC"), null);
            this.backgroundColor = getRgbColor(e1.getArray("BG"), null);
        } else this.borderColor = this.backgroundColor = null;
    }
    setBorderStyle(e1) {
        this.borderStyle = new AnnotationBorderStyle;
        if (e1 instanceof Dict) if (e1.has("BS")) {
            const t = e1.get("BS");
            if (t instanceof Dict) {
                const e1 = t.get("Type");
                if (!e1 || isName(e1, "Border")) {
                    this.borderStyle.setWidth(t.get("W"), this.rectangle);
                    this.borderStyle.setStyle(t.get("S"));
                    this.borderStyle.setDashArray(t.getArray("D"));
                }
            }
        } else if (e1.has("Border")) {
            const t = e1.getArray("Border");
            if (Array.isArray(t) && t.length >= 3) {
                this.borderStyle.setHorizontalCornerRadius(t[0]);
                this.borderStyle.setVerticalCornerRadius(t[1]);
                this.borderStyle.setWidth(t[2], this.rectangle);
                4 === t.length && this.borderStyle.setDashArray(t[3], !0);
            }
        } else this.borderStyle.setWidth(0);
    }
    setAppearance(e1) {
        this.appearance = null;
        const t = e1.get("AP");
        if (!(t instanceof Dict)) return;
        const i = t.get("N");
        if (i instanceof BaseStream) {
            this.appearance = i;
            return;
        }
        if (!(i instanceof Dict)) return;
        const a = e1.get("AS");
        if (!(a instanceof Name && i.has(a.name))) return;
        const s = i.get(a.name);
        s instanceof BaseStream && (this.appearance = s);
    }
    setOptionalContent(e1) {
        this.oc = null;
        const t = e1.get("OC");
        t instanceof Name ? warn("setOptionalContent: Support for /Name-entry is not implemented.") : t instanceof Dict && (this.oc = t);
    }
    loadResources(e1, t) {
        return t.dict.getAsync("Resources").then((t)=>{
            if (!t) return;
            return new ObjectLoader(t, e1, t.xref).load().then(function() {
                return t;
            });
        });
    }
    async getOperatorList(e1, t, a, s) {
        const { hasOwnCanvas: r, id: n, rect: g } = this.data;
        let c = this.appearance;
        const C = !!(r && a & o);
        if (C && (g[0] === g[2] || g[1] === g[3])) {
            this.data.hasOwnCanvas = !1;
            return {
                opList: new OperatorList,
                separateForm: !1,
                separateCanvas: !1
            };
        }
        if (!c) {
            if (!C) return {
                opList: new OperatorList,
                separateForm: !1,
                separateCanvas: !1
            };
            c = new StringStream("");
            c.dict = new Dict;
        }
        const h = c.dict, l = await this.loadResources([
            "ExtGState",
            "ColorSpace",
            "Pattern",
            "Shading",
            "XObject",
            "Font"
        ], c), Q = lookupRect(h.getArray("BBox"), [
            0,
            0,
            1,
            1
        ]), E = lookupMatrix(h.getArray("Matrix"), i), u = getTransformMatrix(g, Q, E), d = new OperatorList;
        let f;
        this.oc && (f = await e1.parseMarkedContentProps(this.oc, null));
        void 0 !== f && d.addOp(Ye, [
            "OC",
            f
        ]);
        d.addOp(je, [
            n,
            g,
            u,
            E,
            C
        ]);
        await e1.getOperatorList({
            stream: c,
            task: t,
            resources: l,
            operatorList: d,
            fallbackFontDict: this._fallbackFontDict
        });
        d.addOp(Xe, []);
        void 0 !== f && d.addOp(ve, []);
        this.reset();
        return {
            opList: d,
            separateForm: !1,
            separateCanvas: C
        };
    }
    async save(e1, t, i, a) {
        return null;
    }
    get hasTextContent() {
        return !1;
    }
    async extractTextContent(e1, t, i) {
        if (!this.appearance) return;
        const a = await this.loadResources([
            "ExtGState",
            "Font",
            "Properties",
            "XObject"
        ], this.appearance), s = [], r = [];
        let n = null;
        const g = {
            desiredSize: Math.Infinity,
            ready: !0,
            enqueue (e1, t) {
                for (const t of e1.items)if (void 0 !== t.str) {
                    n ||= t.transform.slice(-2);
                    r.push(t.str);
                    if (t.hasEOL) {
                        s.push(r.join("").trimEnd());
                        r.length = 0;
                    }
                }
            }
        };
        await e1.getTextContent({
            stream: this.appearance,
            task: t,
            resources: a,
            includeMarkedContent: !0,
            keepWhiteSpace: !0,
            sink: g,
            viewBox: i
        });
        this.reset();
        r.length && s.push(r.join("").trimEnd());
        if (s.length > 1 || s[0]) {
            const e1 = this.appearance.dict, t = lookupRect(e1.getArray("BBox"), null), i = lookupMatrix(e1.getArray("Matrix"), null);
            this.data.textPosition = this._transformPoint(n, t, i);
            this.data.textContent = s;
        }
    }
    _transformPoint(e1, t, i) {
        const { rect: a } = this.data;
        t ||= [
            0,
            0,
            1,
            1
        ];
        i ||= [
            1,
            0,
            0,
            1,
            0,
            0
        ];
        const s = getTransformMatrix(a, t, i);
        s[4] -= a[0];
        s[5] -= a[1];
        e1 = Util.applyTransform(e1, s);
        return Util.applyTransform(e1, i);
    }
    getFieldObject() {
        return this.data.kidIds ? {
            id: this.data.id,
            actions: this.data.actions,
            name: this.data.fieldName,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            type: "",
            kidIds: this.data.kidIds,
            page: this.data.pageIndex,
            rotation: this.rotation
        } : null;
    }
    reset() {
        for (const e1 of this._streams)e1.reset();
    }
    _constructFieldName(e1) {
        if (!e1.has("T") && !e1.has("Parent")) {
            warn("Unknown field name, falling back to empty field name.");
            return "";
        }
        if (!e1.has("Parent")) return stringToPDFString(e1.get("T"));
        const t = [];
        e1.has("T") && t.unshift(stringToPDFString(e1.get("T")));
        let i = e1;
        const a = new RefSet;
        e1.objId && a.put(e1.objId);
        for(; i.has("Parent");){
            i = i.get("Parent");
            if (!(i instanceof Dict) || i.objId && a.has(i.objId)) break;
            i.objId && a.put(i.objId);
            i.has("T") && t.unshift(stringToPDFString(i.get("T")));
        }
        return t.join(".");
    }
}
class AnnotationBorderStyle {
    constructor(){
        this.width = 1;
        this.rawWidth = 1;
        this.style = lA;
        this.dashArray = [
            3
        ];
        this.horizontalCornerRadius = 0;
        this.verticalCornerRadius = 0;
    }
    setWidth(e1, t = [
        0,
        0,
        0,
        0
    ]) {
        if (e1 instanceof Name) this.width = 0;
        else if ("number" == typeof e1) {
            if (e1 > 0) {
                this.rawWidth = e1;
                const i = (t[2] - t[0]) / 2, a = (t[3] - t[1]) / 2;
                if (i > 0 && a > 0 && (e1 > i || e1 > a)) {
                    warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e1}`);
                    e1 = 1;
                }
            }
            this.width = e1;
        }
    }
    setStyle(e1) {
        if (e1 instanceof Name) switch(e1.name){
            case "S":
                this.style = lA;
                break;
            case "D":
                this.style = BA;
                break;
            case "B":
                this.style = QA;
                break;
            case "I":
                this.style = EA;
                break;
            case "U":
                this.style = uA;
        }
    }
    setDashArray(e1, t = !1) {
        if (Array.isArray(e1)) {
            let i = !0, a = !0;
            for (const t of e1){
                if (!(+t >= 0)) {
                    i = !1;
                    break;
                }
                t > 0 && (a = !1);
            }
            if (0 === e1.length || i && !a) {
                this.dashArray = e1;
                t && this.setStyle(Name.get("D"));
            } else this.width = 0;
        } else e1 && (this.width = 0);
    }
    setHorizontalCornerRadius(e1) {
        Number.isInteger(e1) && (this.horizontalCornerRadius = e1);
    }
    setVerticalCornerRadius(e1) {
        Number.isInteger(e1) && (this.verticalCornerRadius = e1);
    }
}
class MarkupAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t } = e1;
        if (t.has("IRT")) {
            const e1 = t.getRaw("IRT");
            this.data.inReplyTo = e1 instanceof Ref ? e1.toString() : null;
            const i = t.get("RT");
            this.data.replyType = i instanceof Name ? i.name : Z;
        }
        let i = null;
        if (this.data.replyType === X) {
            const e1 = t.get("IRT");
            this.setTitle(e1.get("T"));
            this.data.titleObj = this._title;
            this.setContents(e1.get("Contents"));
            this.data.contentsObj = this._contents;
            if (e1.has("CreationDate")) {
                this.setCreationDate(e1.get("CreationDate"));
                this.data.creationDate = this.creationDate;
            } else this.data.creationDate = null;
            if (e1.has("M")) {
                this.setModificationDate(e1.get("M"));
                this.data.modificationDate = this.modificationDate;
            } else this.data.modificationDate = null;
            i = e1.getRaw("Popup");
            if (e1.has("C")) {
                this.setColor(e1.getArray("C"));
                this.data.color = this.color;
            } else this.data.color = null;
        } else {
            this.data.titleObj = this._title;
            this.setCreationDate(t.get("CreationDate"));
            this.data.creationDate = this.creationDate;
            i = t.getRaw("Popup");
            t.has("C") || (this.data.color = null);
        }
        this.data.popupRef = i instanceof Ref ? i.toString() : null;
        t.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t.get("RC")));
    }
    setCreationDate(e1) {
        this.creationDate = "string" == typeof e1 ? e1 : null;
    }
    _setDefaultAppearance({ xref: e1, extra: t, strokeColor: i, fillColor: a, blendMode: s, strokeAlpha: r, fillAlpha: n, pointsCallback: g }) {
        let o = Number.MAX_VALUE, c = Number.MAX_VALUE, C = Number.MIN_VALUE, h = Number.MIN_VALUE;
        const l = [
            "q"
        ];
        t && l.push(t);
        i && l.push(`${i[0]} ${i[1]} ${i[2]} RG`);
        a && l.push(`${a[0]} ${a[1]} ${a[2]} rg`);
        const Q = this.data.quadPoints || Float32Array.from([
            this.rectangle[0],
            this.rectangle[3],
            this.rectangle[2],
            this.rectangle[3],
            this.rectangle[0],
            this.rectangle[1],
            this.rectangle[2],
            this.rectangle[1]
        ]);
        for(let e1 = 0, t = Q.length; e1 < t; e1 += 8){
            const [t, i, a, s] = g(l, Q.subarray(e1, e1 + 8));
            o = Math.min(o, t);
            C = Math.max(C, i);
            c = Math.min(c, a);
            h = Math.max(h, s);
        }
        l.push("Q");
        const E = new Dict(e1), u = new Dict(e1);
        u.set("Subtype", Name.get("Form"));
        const d = new StringStream(l.join(" "));
        d.dict = u;
        E.set("Fm0", d);
        const f = new Dict(e1);
        s && f.set("BM", Name.get(s));
        "number" == typeof r && f.set("CA", r);
        "number" == typeof n && f.set("ca", n);
        const p = new Dict(e1);
        p.set("GS0", f);
        const m = new Dict(e1);
        m.set("ExtGState", p);
        m.set("XObject", E);
        const y = new Dict(e1);
        y.set("Resources", m);
        const w = this.data.rect = [
            o,
            c,
            C,
            h
        ];
        y.set("BBox", w);
        this.appearance = new StringStream("/GS0 gs /Fm0 Do");
        this.appearance.dict = y;
        this._streams.push(this.appearance, d);
    }
    static async createNewAnnotation(e1, t, i, a) {
        const s = t.ref ||= e1.getNewTemporaryRef(), r = await this.createNewAppearanceStream(t, e1, a);
        let n;
        if (r) {
            const a = e1.getNewTemporaryRef();
            n = this.createNewDict(t, e1, {
                apRef: a
            });
            i.put(a, {
                data: r
            });
        } else n = this.createNewDict(t, e1, {});
        Number.isInteger(t.parentTreeId) && n.set("StructParent", t.parentTreeId);
        i.put(s, {
            data: n
        });
        return {
            ref: s
        };
    }
    static async createNewPrintAnnotation(e1, t, i, a) {
        const s = await this.createNewAppearanceStream(i, t, a), r = this.createNewDict(i, t, s ? {
            ap: s
        } : {}), n = new this.prototype.constructor({
            dict: r,
            xref: t,
            annotationGlobals: e1,
            evaluatorOptions: a.evaluatorOptions
        });
        i.ref && (n.ref = n.refToReplace = i.ref);
        return n;
    }
}
class WidgetAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i, annotationGlobals: a } = e1, s = this.data;
        this._needAppearances = e1.needAppearances;
        s.annotationType = j;
        void 0 === s.fieldName && (s.fieldName = this._constructFieldName(t));
        void 0 === s.actions && (s.actions = collectActions(i, t, dA));
        let r = getInheritableProperty({
            dict: t,
            key: "V",
            getArray: !0
        });
        s.fieldValue = this._decodeFormValue(r);
        const n = getInheritableProperty({
            dict: t,
            key: "DV",
            getArray: !0
        });
        s.defaultFieldValue = this._decodeFormValue(n);
        if (void 0 === r && a.xfaDatasets) {
            const e1 = this._title.str;
            if (e1) {
                this._hasValueFromXFA = !0;
                s.fieldValue = r = a.xfaDatasets.getValue(e1);
            }
        }
        void 0 === r && null !== s.defaultFieldValue && (s.fieldValue = s.defaultFieldValue);
        s.alternativeText = stringToPDFString(t.get("TU") || "");
        this.setDefaultAppearance(e1);
        s.hasAppearance ||= this._needAppearances && void 0 !== s.fieldValue && null !== s.fieldValue;
        const g = getInheritableProperty({
            dict: t,
            key: "FT"
        });
        s.fieldType = g instanceof Name ? g.name : null;
        const o = getInheritableProperty({
            dict: t,
            key: "DR"
        }), c = a.acroForm.get("DR"), C = this.appearance?.dict.get("Resources");
        this._fieldResources = {
            localResources: o,
            acroFormResources: c,
            appearanceResources: C,
            mergedResources: Dict.merge({
                xref: i,
                dictArray: [
                    o,
                    C,
                    c
                ],
                mergeSubDicts: !0
            })
        };
        s.fieldFlags = getInheritableProperty({
            dict: t,
            key: "Ff"
        });
        (!Number.isInteger(s.fieldFlags) || s.fieldFlags < 0) && (s.fieldFlags = 0);
        s.readOnly = this.hasFieldFlag(iA);
        s.required = this.hasFieldFlag(aA);
        s.hidden = this._hasFlag(s.annotationFlags, z) || this._hasFlag(s.annotationFlags, AA);
    }
    _decodeFormValue(e1) {
        return Array.isArray(e1) ? e1.filter((e1)=>"string" == typeof e1).map((e1)=>stringToPDFString(e1)) : e1 instanceof Name ? stringToPDFString(e1.name) : "string" == typeof e1 ? stringToPDFString(e1) : null;
    }
    hasFieldFlag(e1) {
        return !!(this.data.fieldFlags & e1);
    }
    _isViewable(e1) {
        return !0;
    }
    mustBeViewed(e1, t) {
        return t ? this.viewable : super.mustBeViewed(e1, t) && !this._hasFlag(this.flags, AA);
    }
    getRotationMatrix(e1) {
        let t = e1?.get(this.data.id)?.rotation;
        void 0 === t && (t = this.rotation);
        if (0 === t) return i;
        return getRotationMatrix(t, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]);
    }
    getBorderAndBackgroundAppearances(e1) {
        let t = e1?.get(this.data.id)?.rotation;
        void 0 === t && (t = this.rotation);
        if (!this.backgroundColor && !this.borderColor) return "";
        const i = this.data.rect[2] - this.data.rect[0], a = this.data.rect[3] - this.data.rect[1], s = 0 === t || 180 === t ? `0 0 ${i} ${a} re` : `0 0 ${a} ${i} re`;
        let r = "";
        this.backgroundColor && (r = `${getPdfColor(this.backgroundColor, !0)} ${s} f `);
        if (this.borderColor) {
            r += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, !1)} ${s} S `;
        }
        return r;
    }
    async getOperatorList(e1, t, i, a) {
        if (i & h && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) return {
            opList: new OperatorList,
            separateForm: !0,
            separateCanvas: !1
        };
        if (!this._hasText) return super.getOperatorList(e1, t, i, a);
        const s = await this._getAppearance(e1, t, i, a);
        if (this.appearance && null === s) return super.getOperatorList(e1, t, i, a);
        const r = new OperatorList;
        if (!this._defaultAppearance || null === s) return {
            opList: r,
            separateForm: !1,
            separateCanvas: !1
        };
        const n = !!(this.data.hasOwnCanvas && i & o), g = [
            0,
            0,
            this.data.rect[2] - this.data.rect[0],
            this.data.rect[3] - this.data.rect[1]
        ], c = getTransformMatrix(this.data.rect, g, [
            1,
            0,
            0,
            1,
            0,
            0
        ]);
        let C;
        this.oc && (C = await e1.parseMarkedContentProps(this.oc, null));
        void 0 !== C && r.addOp(Ye, [
            "OC",
            C
        ]);
        r.addOp(je, [
            this.data.id,
            this.data.rect,
            c,
            this.getRotationMatrix(a),
            n
        ]);
        const l = new StringStream(s);
        await e1.getOperatorList({
            stream: l,
            task: t,
            resources: this._fieldResources.mergedResources,
            operatorList: r
        });
        r.addOp(Xe, []);
        void 0 !== C && r.addOp(ve, []);
        return {
            opList: r,
            separateForm: !1,
            separateCanvas: n
        };
    }
    _getMKDict(e1) {
        const t = new Dict(null);
        e1 && t.set("R", e1);
        this.borderColor && t.set("BC", getPdfColorArray(this.borderColor));
        this.backgroundColor && t.set("BG", getPdfColorArray(this.backgroundColor));
        return t.size > 0 ? t : null;
    }
    amendSavedDict(e1, t) {}
    setValue(e1, t, i, a) {
        const { dict: s, ref: r } = function getParentToUpdate(e1, t, i) {
            const a = new RefSet, s = e1, r = {
                dict: null,
                ref: null
            };
            for(; e1 instanceof Dict && !a.has(t);){
                a.put(t);
                if (e1.has("T")) break;
                if (!((t = e1.getRaw("Parent")) instanceof Ref)) return r;
                e1 = i.fetch(t);
            }
            if (e1 instanceof Dict && e1 !== s) {
                r.dict = e1;
                r.ref = t;
            }
            return r;
        }(e1, this.ref, i);
        if (s) {
            if (!a.has(r)) {
                const e1 = s.clone();
                e1.set("V", t);
                a.put(r, {
                    data: e1
                });
                return e1;
            }
        } else e1.set("V", t);
        return null;
    }
    async save(e1, t, a, s) {
        const r = a?.get(this.data.id), n = this._buildFlags(r?.noView, r?.noPrint);
        let g = r?.value, o = r?.rotation;
        if (g === this.data.fieldValue || void 0 === g) {
            if (!this._hasValueFromXFA && void 0 === o && void 0 === n) return;
            g ||= this.data.fieldValue;
        }
        if (void 0 === o && !this._hasValueFromXFA && Array.isArray(g) && Array.isArray(this.data.fieldValue) && isArrayEqual(g, this.data.fieldValue) && void 0 === n) return;
        void 0 === o && (o = this.rotation);
        let c = null;
        if (!this._needAppearances) {
            c = await this._getAppearance(e1, t, C, a);
            if (null === c && void 0 === n) return;
        }
        let h = !1;
        if (c?.needAppearances) {
            h = !0;
            c = null;
        }
        const { xref: l } = e1, Q = l.fetchIfRef(this.ref);
        if (!(Q instanceof Dict)) return;
        const E = new Dict(l);
        for (const e1 of Q.getKeys())"AP" !== e1 && E.set(e1, Q.getRaw(e1));
        if (void 0 !== n) {
            E.set("F", n);
            if (null === c && !h) {
                const e1 = Q.getRaw("AP");
                e1 && E.set("AP", e1);
            }
        }
        const u = {
            path: this.data.fieldName,
            value: g
        }, d = this.setValue(E, Array.isArray(g) ? g.map(stringToAsciiOrUTF16BE) : stringToAsciiOrUTF16BE(g), l, s);
        this.amendSavedDict(a, d || E);
        const f = this._getMKDict(o);
        f && E.set("MK", f);
        s.put(this.ref, {
            data: E,
            xfa: u,
            needAppearances: h
        });
        if (null !== c) {
            const e1 = l.getNewTemporaryRef(), t = new Dict(l);
            E.set("AP", t);
            t.set("N", e1);
            const r = this._getSaveFieldResources(l), n = new StringStream(c), g = n.dict = new Dict(l);
            g.set("Subtype", Name.get("Form"));
            g.set("Resources", r);
            g.set("BBox", [
                0,
                0,
                this.data.rect[2] - this.data.rect[0],
                this.data.rect[3] - this.data.rect[1]
            ]);
            const o = this.getRotationMatrix(a);
            o !== i && g.set("Matrix", o);
            s.put(e1, {
                data: n,
                xfa: null,
                needAppearances: !1
            });
        }
        E.set("M", `D:${getModificationDate()}`);
    }
    async _getAppearance(e1, t, i, a) {
        if (this.hasFieldFlag(rA)) return null;
        const s = a?.get(this.data.id);
        let r, g;
        if (s) {
            r = s.formattedValue || s.value;
            g = s.rotation;
        }
        if (void 0 === g && void 0 === r && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
        const o = this.getBorderAndBackgroundAppearances(a);
        if (void 0 === r) {
            r = this.data.fieldValue;
            if (!r) return `/Tx BMC q ${o}Q EMC`;
        }
        Array.isArray(r) && 1 === r.length && (r = r[0]);
        assert("string" == typeof r, "Expected `value` to be a string.");
        r = r.trimEnd();
        if (this.data.combo) {
            const e1 = this.data.options.find(({ exportValue: e1 })=>r === e1);
            r = e1?.displayValue || r;
        }
        if ("" === r) return `/Tx BMC q ${o}Q EMC`;
        void 0 === g && (g = this.rotation);
        let c, h = -1;
        if (this.data.multiLine) {
            c = r.split(/\r\n?|\n/).map((e1)=>e1.normalize("NFC"));
            h = c.length;
        } else c = [
            r.replace(/\r\n?|\n/, "").normalize("NFC")
        ];
        let l = this.data.rect[3] - this.data.rect[1], Q = this.data.rect[2] - this.data.rect[0];
        90 !== g && 270 !== g || ([Q, l] = [
            l,
            Q
        ]);
        this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        let E, u, d, f = await WidgetAnnotation._getFontData(e1, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        const p = [];
        let m = !1;
        for (const e1 of c){
            const t = f.encodeString(e1);
            t.length > 1 && (m = !0);
            p.push(t.join(""));
        }
        if (m && i & C) return {
            needAppearances: !0
        };
        if (m && this._isOffscreenCanvasSupported) {
            const i = this.data.comb ? "monospace" : "sans-serif", a = new FakeUnicodeFont(e1.xref, i), s = a.createFontResources(c.join("")), n = s.getRaw("Font");
            if (this._fieldResources.mergedResources.has("Font")) {
                const e1 = this._fieldResources.mergedResources.get("Font");
                for (const t of n.getKeys())e1.set(t, n.getRaw(t));
            } else this._fieldResources.mergedResources.set("Font", n);
            const g = a.fontName.name;
            f = await WidgetAnnotation._getFontData(e1, t, {
                fontName: g,
                fontSize: 0
            }, s);
            for(let e1 = 0, t = p.length; e1 < t; e1++)p[e1] = stringToUTF16String(c[e1]);
            const o = Object.assign(Object.create(null), this.data.defaultAppearanceData);
            this.data.defaultAppearanceData.fontSize = 0;
            this.data.defaultAppearanceData.fontName = g;
            [E, u, d] = this._computeFontSize(l - 2, Q - 4, r, f, h);
            this.data.defaultAppearanceData = o;
        } else {
            this._isOffscreenCanvasSupported || warn("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");
            [E, u, d] = this._computeFontSize(l - 2, Q - 4, r, f, h);
        }
        let y = f.descent;
        y = isNaN(y) ? n * d : Math.max(n * d, Math.abs(y) * u);
        const w = Math.min(Math.floor((l - u) / 2), 1), D = this.data.textAlignment;
        if (this.data.multiLine) return this._getMultilineAppearance(E, p, f, u, Q, l, D, 2, w, y, d, a);
        if (this.data.comb) return this._getCombAppearance(E, f, p[0], u, Q, l, 2, w, y, d, a);
        const b = w + y;
        if (0 === D || D > 2) return `/Tx BMC q ${o}BT ` + E + ` 1 0 0 1 ${numberToString(2)} ${numberToString(b)} Tm (${escapeString(p[0])}) Tj ET Q EMC`;
        return `/Tx BMC q ${o}BT ` + E + ` 1 0 0 1 0 0 Tm ${this._renderText(p[0], f, u, Q, D, {
            shift: 0
        }, 2, b)} ET Q EMC`;
    }
    static async _getFontData(e1, t, i, a) {
        const s = new OperatorList, r = {
            font: null,
            clone () {
                return this;
            }
        }, { fontName: n, fontSize: g } = i;
        await e1.handleSetFont(a, [
            n && Name.get(n),
            g
        ], null, s, t, r, null);
        return r.font;
    }
    _getTextWidth(e1, t) {
        return t.charsToGlyphs(e1).reduce((e1, t)=>e1 + t.width, 0) / 1e3;
    }
    _computeFontSize(e1, t, i, a, r) {
        let { fontSize: n } = this.data.defaultAppearanceData, g = (n || 12) * s, o = Math.round(e1 / g);
        if (!n) {
            const roundWithTwoDigits = (e1)=>Math.floor(100 * e1) / 100;
            if (-1 === r) {
                const r = this._getTextWidth(i, a);
                n = roundWithTwoDigits(Math.min(e1 / s, t / r));
                o = 1;
            } else {
                const c = i.split(/\r\n?|\n/), C = [];
                for (const e1 of c){
                    const t = a.encodeString(e1).join(""), i = a.charsToGlyphs(t), s = a.getCharPositions(t);
                    C.push({
                        line: t,
                        glyphs: i,
                        positions: s
                    });
                }
                const isTooBig = (i)=>{
                    let s = 0;
                    for (const r of C){
                        s += this._splitLine(null, a, i, t, r).length * i;
                        if (s > e1) return !0;
                    }
                    return !1;
                };
                o = Math.max(o, r);
                for(;;){
                    g = e1 / o;
                    n = roundWithTwoDigits(g / s);
                    if (!isTooBig(n)) break;
                    o++;
                }
            }
            const { fontName: c, fontColor: C } = this.data.defaultAppearanceData;
            this._defaultAppearance = function createDefaultAppearance({ fontSize: e1, fontName: t, fontColor: i }) {
                return `/${escapePDFName(t)} ${e1} Tf ${getPdfColor(i, !0)}`;
            }({
                fontSize: n,
                fontName: c,
                fontColor: C
            });
        }
        return [
            this._defaultAppearance,
            n,
            e1 / o
        ];
    }
    _renderText(e1, t, i, a, s, r, n, g) {
        let o;
        if (1 === s) {
            o = (a - this._getTextWidth(e1, t) * i) / 2;
        } else if (2 === s) {
            o = a - this._getTextWidth(e1, t) * i - n;
        } else o = n;
        const c = numberToString(o - r.shift);
        r.shift = o;
        return `${c} ${g = numberToString(g)} Td (${escapeString(e1)}) Tj`;
    }
    _getSaveFieldResources(e1) {
        const { localResources: t, appearanceResources: i, acroFormResources: a } = this._fieldResources, s = this.data.defaultAppearanceData?.fontName;
        if (!s) return t || Dict.empty;
        for (const e1 of [
            t,
            i
        ])if (e1 instanceof Dict) {
            const t = e1.get("Font");
            if (t instanceof Dict && t.has(s)) return e1;
        }
        if (a instanceof Dict) {
            const i = a.get("Font");
            if (i instanceof Dict && i.has(s)) {
                const a = new Dict(e1);
                a.set(s, i.getRaw(s));
                const r = new Dict(e1);
                r.set("Font", a);
                return Dict.merge({
                    xref: e1,
                    dictArray: [
                        r,
                        t
                    ],
                    mergeSubDicts: !0
                });
            }
        }
        return t || Dict.empty;
    }
    getFieldObject() {
        return null;
    }
}
class TextWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t } = e1;
        if (t.has("PMD")) {
            this.flags |= z;
            this.data.hidden = !0;
            warn("Barcodes are not supported");
        }
        this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
        this._hasText = !0;
        "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
        let i = getInheritableProperty({
            dict: t,
            key: "Q"
        });
        (!Number.isInteger(i) || i < 0 || i > 2) && (i = null);
        this.data.textAlignment = i;
        let a = getInheritableProperty({
            dict: t,
            key: "MaxLen"
        });
        (!Number.isInteger(a) || a < 0) && (a = 0);
        this.data.maxLen = a;
        this.data.multiLine = this.hasFieldFlag(sA);
        this.data.comb = this.hasFieldFlag(hA) && !this.hasFieldFlag(sA) && !this.hasFieldFlag(rA) && !this.hasFieldFlag(IA) && 0 !== this.data.maxLen;
        this.data.doNotScroll = this.hasFieldFlag(CA);
    }
    get hasTextContent() {
        return !!this.appearance && !this._needAppearances;
    }
    _getCombAppearance(e1, t, i, a, s, r, n, g, o, c, C) {
        const h = s / this.data.maxLen, l = this.getBorderAndBackgroundAppearances(C), Q = [], E = t.getCharPositions(i);
        for (const [e1, t] of E)Q.push(`(${escapeString(i.substring(e1, t))}) Tj`);
        const u = Q.join(` ${numberToString(h)} 0 Td `);
        return `/Tx BMC q ${l}BT ` + e1 + ` 1 0 0 1 ${numberToString(n)} ${numberToString(g + o)} Tm ${u} ET Q EMC`;
    }
    _getMultilineAppearance(e1, t, i, a, s, r, n, g, o, c, C, h) {
        const l = [], Q = s - 2 * g, E = {
            shift: 0
        };
        for(let e1 = 0, r = t.length; e1 < r; e1++){
            const r = t[e1], h = this._splitLine(r, i, a, Q);
            for(let t = 0, r = h.length; t < r; t++){
                const r = h[t], Q = 0 === e1 && 0 === t ? -o - (C - c) : -C;
                l.push(this._renderText(r, i, a, s, n, E, g, Q));
            }
        }
        const u = this.getBorderAndBackgroundAppearances(h), d = l.join("\n");
        return `/Tx BMC q ${u}BT ` + e1 + ` 1 0 0 1 0 ${numberToString(r)} Tm ${d} ET Q EMC`;
    }
    _splitLine(e1, t, i, a, s = {}) {
        e1 = s.line || e1;
        const r = s.glyphs || t.charsToGlyphs(e1);
        if (r.length <= 1) return [
            e1
        ];
        const n = s.positions || t.getCharPositions(e1), g = i / 1e3, o = [];
        let c = -1, C = -1, h = -1, l = 0, Q = 0;
        for(let t = 0, i = r.length; t < i; t++){
            const [i, s] = n[t], E = r[t], u = E.width * g;
            if (" " === E.unicode) if (Q + u > a) {
                o.push(e1.substring(l, i));
                l = i;
                Q = u;
                c = -1;
                h = -1;
            } else {
                Q += u;
                c = i;
                C = s;
                h = t;
            }
            else if (Q + u > a) if (-1 !== c) {
                o.push(e1.substring(l, C));
                l = C;
                t = h + 1;
                c = -1;
                Q = 0;
            } else {
                o.push(e1.substring(l, i));
                l = i;
                Q = u;
            }
            else Q += u;
        }
        l < e1.length && o.push(e1.substring(l, e1.length));
        return o;
    }
    async extractTextContent(e1, t, i) {
        await super.extractTextContent(e1, t, i);
        const a = this.data.textContent;
        if (!a) return;
        const s = a.join("\n");
        if (s === this.data.fieldValue) return;
        const r = s.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (e1, t)=>t ? `\\${t}` : "\\s+");
        new RegExp(`^\\s*${r}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split("\n"));
    }
    getFieldObject() {
        return {
            id: this.data.id,
            value: this.data.fieldValue,
            defaultValue: this.data.defaultFieldValue || "",
            multiline: this.data.multiLine,
            password: this.hasFieldFlag(rA),
            charLimit: this.data.maxLen,
            comb: this.data.comb,
            editable: !this.data.readOnly,
            hidden: this.data.hidden,
            name: this.data.fieldName,
            rect: this.data.rect,
            actions: this.data.actions,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            rotation: this.rotation,
            type: "text"
        };
    }
}
class ButtonWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        this.checkedAppearance = null;
        this.uncheckedAppearance = null;
        this.data.checkBox = !this.hasFieldFlag(nA) && !this.hasFieldFlag(gA);
        this.data.radioButton = this.hasFieldFlag(nA) && !this.hasFieldFlag(gA);
        this.data.pushButton = this.hasFieldFlag(gA);
        this.data.isTooltipOnly = !1;
        if (this.data.checkBox) this._processCheckBox(e1);
        else if (this.data.radioButton) this._processRadioButton(e1);
        else if (this.data.pushButton) {
            this.data.hasOwnCanvas = !0;
            this.data.noHTML = !1;
            this._processPushButton(e1);
        } else warn("Invalid field flags for button widget annotation");
    }
    async getOperatorList(e1, t, a, s) {
        if (this.data.pushButton) return super.getOperatorList(e1, t, a, !1, s);
        let r = null, n = null;
        if (s) {
            const e1 = s.get(this.data.id);
            r = e1 ? e1.value : null;
            n = e1 ? e1.rotation : null;
        }
        if (null === r && this.appearance) return super.getOperatorList(e1, t, a, s);
        null == r && (r = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
        const g = r ? this.checkedAppearance : this.uncheckedAppearance;
        if (g) {
            const r = this.appearance, o = lookupMatrix(g.dict.getArray("Matrix"), i);
            n && g.dict.set("Matrix", this.getRotationMatrix(s));
            this.appearance = g;
            const c = super.getOperatorList(e1, t, a, s);
            this.appearance = r;
            g.dict.set("Matrix", o);
            return c;
        }
        return {
            opList: new OperatorList,
            separateForm: !1,
            separateCanvas: !1
        };
    }
    async save(e1, t, i, a) {
        this.data.checkBox ? this._saveCheckbox(e1, t, i, a) : this.data.radioButton && this._saveRadioButton(e1, t, i, a);
    }
    async _saveCheckbox(e1, t, i, a) {
        if (!i) return;
        const s = i.get(this.data.id), r = this._buildFlags(s?.noView, s?.noPrint);
        let n = s?.rotation, g = s?.value;
        if (void 0 === n && void 0 === r) {
            if (void 0 === g) return;
            if (this.data.fieldValue === this.data.exportValue === g) return;
        }
        let o = e1.xref.fetchIfRef(this.ref);
        if (!(o instanceof Dict)) return;
        o = o.clone();
        void 0 === n && (n = this.rotation);
        void 0 === g && (g = this.data.fieldValue === this.data.exportValue);
        const c = {
            path: this.data.fieldName,
            value: g ? this.data.exportValue : ""
        }, C = Name.get(g ? this.data.exportValue : "Off");
        this.setValue(o, C, e1.xref, a);
        o.set("AS", C);
        o.set("M", `D:${getModificationDate()}`);
        void 0 !== r && o.set("F", r);
        const h = this._getMKDict(n);
        h && o.set("MK", h);
        a.put(this.ref, {
            data: o,
            xfa: c,
            needAppearances: !1
        });
    }
    async _saveRadioButton(e1, t, i, a) {
        if (!i) return;
        const s = i.get(this.data.id), r = this._buildFlags(s?.noView, s?.noPrint);
        let n = s?.rotation, g = s?.value;
        if (void 0 === n && void 0 === r) {
            if (void 0 === g) return;
            if (this.data.fieldValue === this.data.buttonValue === g) return;
        }
        let o = e1.xref.fetchIfRef(this.ref);
        if (!(o instanceof Dict)) return;
        o = o.clone();
        void 0 === g && (g = this.data.fieldValue === this.data.buttonValue);
        void 0 === n && (n = this.rotation);
        const c = {
            path: this.data.fieldName,
            value: g ? this.data.buttonValue : ""
        }, C = Name.get(g ? this.data.buttonValue : "Off");
        g && this.setValue(o, C, e1.xref, a);
        o.set("AS", C);
        o.set("M", `D:${getModificationDate()}`);
        void 0 !== r && o.set("F", r);
        const h = this._getMKDict(n);
        h && o.set("MK", h);
        a.put(this.ref, {
            data: o,
            xfa: c,
            needAppearances: !1
        });
    }
    _getDefaultCheckedAppearance(e1, t) {
        const i = this.data.rect[2] - this.data.rect[0], a = this.data.rect[3] - this.data.rect[1], s = [
            0,
            0,
            i,
            a
        ], r = .8 * Math.min(i, a);
        let n, g;
        if ("check" === t) {
            n = {
                width: .755 * r,
                height: .705 * r
            };
            g = "3";
        } else if ("disc" === t) {
            n = {
                width: .791 * r,
                height: .705 * r
            };
            g = "l";
        } else unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t}`);
        const o = `q BT /PdfJsZaDb ${r} Tf 0 g ${numberToString((i - n.width) / 2)} ${numberToString((a - n.height) / 2)} Td (${g}) Tj ET Q`, c = new Dict(e1.xref);
        c.set("FormType", 1);
        c.set("Subtype", Name.get("Form"));
        c.set("Type", Name.get("XObject"));
        c.set("BBox", s);
        c.set("Matrix", [
            1,
            0,
            0,
            1,
            0,
            0
        ]);
        c.set("Length", o.length);
        const C = new Dict(e1.xref), h = new Dict(e1.xref);
        h.set("PdfJsZaDb", this.fallbackFontDict);
        C.set("Font", h);
        c.set("Resources", C);
        this.checkedAppearance = new StringStream(o);
        this.checkedAppearance.dict = c;
        this._streams.push(this.checkedAppearance);
    }
    _processCheckBox(e1) {
        const t = e1.dict.get("AP");
        if (!(t instanceof Dict)) return;
        const i = t.get("N");
        if (!(i instanceof Dict)) return;
        const a = this._decodeFormValue(e1.dict.get("AS"));
        "string" == typeof a && (this.data.fieldValue = a);
        const s = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", r = i.getKeys();
        if (0 === r.length) r.push("Off", s);
        else if (1 === r.length) "Off" === r[0] ? r.push(s) : r.unshift("Off");
        else if (r.includes(s)) {
            r.length = 0;
            r.push("Off", s);
        } else {
            const e1 = r.find((e1)=>"Off" !== e1);
            r.length = 0;
            r.push("Off", e1);
        }
        r.includes(this.data.fieldValue) || (this.data.fieldValue = "Off");
        this.data.exportValue = r[1];
        const n = i.get(this.data.exportValue);
        this.checkedAppearance = n instanceof BaseStream ? n : null;
        const g = i.get("Off");
        this.uncheckedAppearance = g instanceof BaseStream ? g : null;
        this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e1, "check");
        this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
        this._fallbackFontDict = this.fallbackFontDict;
        null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
    }
    _processRadioButton(e1) {
        this.data.buttonValue = null;
        const t = e1.dict.get("Parent");
        if (t instanceof Dict) {
            this.parent = e1.dict.getRaw("Parent");
            const i = t.get("V");
            i instanceof Name && (this.data.fieldValue = this._decodeFormValue(i));
        }
        const i = e1.dict.get("AP");
        if (!(i instanceof Dict)) return;
        const a = i.get("N");
        if (!(a instanceof Dict)) return;
        for (const e1 of a.getKeys())if ("Off" !== e1) {
            this.data.buttonValue = this._decodeFormValue(e1);
            break;
        }
        const s = a.get(this.data.buttonValue);
        this.checkedAppearance = s instanceof BaseStream ? s : null;
        const r = a.get("Off");
        this.uncheckedAppearance = r instanceof BaseStream ? r : null;
        this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e1, "disc");
        this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
        this._fallbackFontDict = this.fallbackFontDict;
        null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
    }
    _processPushButton(e1) {
        const { dict: t, annotationGlobals: i } = e1;
        if (t.has("A") || t.has("AA") || this.data.alternativeText) {
            this.data.isTooltipOnly = !t.has("A") && !t.has("AA");
            Catalog.parseDestDictionary({
                destDict: t,
                resultObj: this.data,
                docBaseUrl: i.baseUrl,
                docAttachments: i.attachments
            });
        } else warn("Push buttons without action dictionaries are not supported");
    }
    getFieldObject() {
        let e1, t = "button";
        if (this.data.checkBox) {
            t = "checkbox";
            e1 = this.data.exportValue;
        } else if (this.data.radioButton) {
            t = "radiobutton";
            e1 = this.data.buttonValue;
        }
        return {
            id: this.data.id,
            value: this.data.fieldValue || "Off",
            defaultValue: this.data.defaultFieldValue,
            exportValues: e1,
            editable: !this.data.readOnly,
            name: this.data.fieldName,
            rect: this.data.rect,
            hidden: this.data.hidden,
            actions: this.data.actions,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            rotation: this.rotation,
            type: t
        };
    }
    get fallbackFontDict() {
        const e1 = new Dict;
        e1.set("BaseFont", Name.get("ZapfDingbats"));
        e1.set("Type", Name.get("FallbackType"));
        e1.set("Subtype", Name.get("FallbackType"));
        e1.set("Encoding", Name.get("ZapfDingbatsEncoding"));
        return shadow(this, "fallbackFontDict", e1);
    }
}
class ChoiceWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.indices = t.getArray("I");
        this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
        this.data.options = [];
        const a = getInheritableProperty({
            dict: t,
            key: "Opt"
        });
        if (Array.isArray(a)) for(let e1 = 0, t = a.length; e1 < t; e1++){
            const t = i.fetchIfRef(a[e1]), s = Array.isArray(t);
            this.data.options[e1] = {
                exportValue: this._decodeFormValue(s ? i.fetchIfRef(t[0]) : t),
                displayValue: this._decodeFormValue(s ? i.fetchIfRef(t[1]) : t)
            };
        }
        if (this.hasIndices) {
            this.data.fieldValue = [];
            const e1 = this.data.options.length;
            for (const t of this.indices)Number.isInteger(t) && t >= 0 && t < e1 && this.data.fieldValue.push(this.data.options[t].exportValue);
        } else "string" == typeof this.data.fieldValue ? this.data.fieldValue = [
            this.data.fieldValue
        ] : this.data.fieldValue || (this.data.fieldValue = []);
        0 === this.data.options.length && this.data.fieldValue.length > 0 && (this.data.options = this.data.fieldValue.map((e1)=>({
                exportValue: e1,
                displayValue: e1
            })));
        this.data.combo = this.hasFieldFlag(oA);
        this.data.multiSelect = this.hasFieldFlag(cA);
        this._hasText = !0;
    }
    getFieldObject() {
        const e1 = this.data.combo ? "combobox" : "listbox", t = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
        return {
            id: this.data.id,
            value: t,
            defaultValue: this.data.defaultFieldValue,
            editable: !this.data.readOnly,
            name: this.data.fieldName,
            rect: this.data.rect,
            numItems: this.data.fieldValue.length,
            multipleSelection: this.data.multiSelect,
            hidden: this.data.hidden,
            actions: this.data.actions,
            items: this.data.options,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            rotation: this.rotation,
            type: e1
        };
    }
    amendSavedDict(e1, t) {
        if (!this.hasIndices) return;
        let i = e1?.get(this.data.id)?.value;
        Array.isArray(i) || (i = [
            i
        ]);
        const a = [], { options: s } = this.data;
        for(let e1 = 0, t = 0, r = s.length; e1 < r; e1++)if (s[e1].exportValue === i[t]) {
            a.push(e1);
            t += 1;
        }
        t.set("I", a);
    }
    async _getAppearance(e1, t, i, a) {
        if (this.data.combo) return super._getAppearance(e1, t, i, a);
        let r, n;
        const g = a?.get(this.data.id);
        if (g) {
            n = g.rotation;
            r = g.value;
        }
        if (void 0 === n && void 0 === r && !this._needAppearances) return null;
        void 0 === r ? r = this.data.fieldValue : Array.isArray(r) || (r = [
            r
        ]);
        let o = this.data.rect[3] - this.data.rect[1], c = this.data.rect[2] - this.data.rect[0];
        90 !== n && 270 !== n || ([c, o] = [
            o,
            c
        ]);
        const C = this.data.options.length, h = [];
        for(let e1 = 0; e1 < C; e1++){
            const { exportValue: t } = this.data.options[e1];
            r.includes(t) && h.push(e1);
        }
        this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        const l = await WidgetAnnotation._getFontData(e1, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        let Q, { fontSize: E } = this.data.defaultAppearanceData;
        if (E) Q = this._defaultAppearance;
        else {
            const e1 = (o - 1) / C;
            let t, i = -1;
            for (const { displayValue: e1 } of this.data.options){
                const a = this._getTextWidth(e1, l);
                if (a > i) {
                    i = a;
                    t = e1;
                }
            }
            [Q, E] = this._computeFontSize(e1, c - 4, t, l, -1);
        }
        const u = E * s, d = (u - E) / 2, f = Math.floor(o / u);
        let p = 0;
        if (h.length > 0) {
            const e1 = Math.min(...h), t = Math.max(...h);
            p = Math.max(0, t - f + 1);
            p > e1 && (p = e1);
        }
        const m = Math.min(p + f + 1, C), y = [
            "/Tx BMC q",
            `1 1 ${c} ${o} re W n`
        ];
        if (h.length) {
            y.push("0.600006 0.756866 0.854904 rg");
            for (const e1 of h)p <= e1 && e1 < m && y.push(`1 ${o - (e1 - p + 1) * u} ${c} ${u} re f`);
        }
        y.push("BT", Q, `1 0 0 1 0 ${o} Tm`);
        const w = {
            shift: 0
        };
        for(let e1 = p; e1 < m; e1++){
            const { displayValue: t } = this.data.options[e1], i = e1 === p ? d : 0;
            y.push(this._renderText(t, l, E, c, 0, w, 2, -u + i));
        }
        y.push("ET Q EMC");
        return y.join("\n");
    }
}
class SignatureWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        this.data.fieldValue = null;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !this.data.hasOwnCanvas;
    }
    getFieldObject() {
        return {
            id: this.data.id,
            value: null,
            page: this.data.pageIndex,
            type: "signature"
        };
    }
}
class TextAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        this.data.noRotate = !0;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        const { dict: t } = e1;
        this.data.annotationType = k;
        if (this.data.hasAppearance) this.data.name = "NoIcon";
        else {
            this.data.rect[1] = this.data.rect[3] - 22;
            this.data.rect[2] = this.data.rect[0] + 22;
            this.data.name = t.has("Name") ? t.get("Name").name : "Note";
        }
        if (t.has("State")) {
            this.data.state = t.get("State") || null;
            this.data.stateModel = t.get("StateModel") || null;
        } else {
            this.data.state = null;
            this.data.stateModel = null;
        }
    }
}
class LinkAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t, annotationGlobals: i } = e1;
        this.data.annotationType = R;
        this.data.noHTML = !1;
        const a = getQuadPoints(t, this.rectangle);
        a && (this.data.quadPoints = a);
        this.data.borderColor ||= this.data.color;
        Catalog.parseDestDictionary({
            destDict: t,
            resultObj: this.data,
            docBaseUrl: i.baseUrl,
            docAttachments: i.attachments
        });
    }
}
class PopupAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t } = e1;
        this.data.annotationType = O;
        this.data.noHTML = !1;
        this.data.rect[0] !== this.data.rect[2] && this.data.rect[1] !== this.data.rect[3] || (this.data.rect = null);
        let i = t.get("Parent");
        if (!i) {
            warn("Popup annotation has a missing or invalid parent annotation.");
            return;
        }
        this.data.parentRect = lookupNormalRect(i.getArray("Rect"), null);
        isName(i.get("RT"), X) && (i = i.get("IRT"));
        if (i.has("M")) {
            this.setModificationDate(i.get("M"));
            this.data.modificationDate = this.modificationDate;
        } else this.data.modificationDate = null;
        if (i.has("C")) {
            this.setColor(i.getArray("C"));
            this.data.color = this.color;
        } else this.data.color = null;
        if (!this.viewable) {
            const e1 = i.get("F");
            this._isViewable(e1) && this.setFlags(e1);
        }
        this.setTitle(i.get("T"));
        this.data.titleObj = this._title;
        this.setContents(i.get("Contents"));
        this.data.contentsObj = this._contents;
        i.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(i.get("RC")));
        this.data.open = !!t.get("Open");
    }
}
class FreeTextAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.isEditable = !this.data.noHTML;
        this.data.noHTML = !1;
        const { evaluatorOptions: t, xref: i } = e1;
        this.data.annotationType = N;
        this.setDefaultAppearance(e1);
        this._hasAppearance = !!this.appearance;
        if (this._hasAppearance) {
            const { fontColor: e1, fontSize: a } = function parseAppearanceStream(e1, t, i) {
                return new AppearanceStreamEvaluator(e1, t, i).parse();
            }(this.appearance, t, i);
            this.data.defaultAppearanceData.fontColor = e1;
            this.data.defaultAppearanceData.fontSize = a || 10;
        } else {
            this.data.defaultAppearanceData.fontSize ||= 10;
            const { fontColor: t, fontSize: a } = this.data.defaultAppearanceData;
            if (this._contents.str) {
                this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((e1)=>e1.trimEnd());
                const { coords: e1, bbox: t, matrix: i } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, a);
                this.data.textPosition = this._transformPoint(e1, t, i);
            }
            if (this._isOffscreenCanvasSupported) {
                const s = e1.dict.get("CA"), r = new FakeUnicodeFont(i, "sans-serif");
                this.appearance = r.createAppearance(this._contents.str, this.rectangle, this.rotation, a, t, s);
                this._streams.push(this.appearance);
            } else warn("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
        }
    }
    get hasTextContent() {
        return this._hasAppearance;
    }
    static createNewDict(e1, t, { apRef: i, ap: a }) {
        const { color: s, fontSize: r, oldAnnotation: n, rect: g, rotation: o, user: c, value: C } = e1, h = n || new Dict(t);
        h.set("Type", Name.get("Annot"));
        h.set("Subtype", Name.get("FreeText"));
        if (n) {
            h.set("M", `D:${getModificationDate()}`);
            h.delete("RC");
        } else h.set("CreationDate", `D:${getModificationDate()}`);
        h.set("Rect", g);
        const l = `/Helv ${r} Tf ${getPdfColor(s, !0)}`;
        h.set("DA", l);
        h.set("Contents", stringToAsciiOrUTF16BE(C));
        h.set("F", 4);
        h.set("Border", [
            0,
            0,
            0
        ]);
        h.set("Rotate", o);
        c && h.set("T", stringToAsciiOrUTF16BE(c));
        if (i || a) {
            const e1 = new Dict(t);
            h.set("AP", e1);
            i ? e1.set("N", i) : e1.set("N", a);
        }
        return h;
    }
    static async createNewAppearanceStream(e1, t, i) {
        const { baseFontRef: a, evaluator: r, task: n } = i, { color: g, fontSize: o, rect: c, rotation: C, value: h } = e1, l = new Dict(t), Q = new Dict(t);
        if (a) Q.set("Helv", a);
        else {
            const e1 = new Dict(t);
            e1.set("BaseFont", Name.get("Helvetica"));
            e1.set("Type", Name.get("Font"));
            e1.set("Subtype", Name.get("Type1"));
            e1.set("Encoding", Name.get("WinAnsiEncoding"));
            Q.set("Helv", e1);
        }
        l.set("Font", Q);
        const E = await WidgetAnnotation._getFontData(r, n, {
            fontName: "Helv",
            fontSize: o
        }, l), [u, d, f, p] = c;
        let m = f - u, y = p - d;
        C % 180 != 0 && ([m, y] = [
            y,
            m
        ]);
        const w = h.split("\n"), D = o / 1e3;
        let b = -1 / 0;
        const F = [];
        for (let e1 of w){
            const t = E.encodeString(e1);
            if (t.length > 1) return null;
            e1 = t.join("");
            F.push(e1);
            let i = 0;
            const a = E.charsToGlyphs(e1);
            for (const e1 of a)i += e1.width * D;
            b = Math.max(b, i);
        }
        let S = 1;
        b > m && (S = m / b);
        let k = 1;
        const R = s * o, N = 1 * o, G = R * w.length;
        G > y && (k = y / G);
        const M = o * Math.min(S, k);
        let U, x, L;
        switch(C){
            case 0:
                L = [
                    1,
                    0,
                    0,
                    1
                ];
                x = [
                    c[0],
                    c[1],
                    m,
                    y
                ];
                U = [
                    c[0],
                    c[3] - N
                ];
                break;
            case 90:
                L = [
                    0,
                    1,
                    -1,
                    0
                ];
                x = [
                    c[1],
                    -c[2],
                    m,
                    y
                ];
                U = [
                    c[1],
                    -c[0] - N
                ];
                break;
            case 180:
                L = [
                    -1,
                    0,
                    0,
                    -1
                ];
                x = [
                    -c[2],
                    -c[3],
                    m,
                    y
                ];
                U = [
                    -c[2],
                    -c[1] - N
                ];
                break;
            case 270:
                L = [
                    0,
                    -1,
                    1,
                    0
                ];
                x = [
                    -c[3],
                    c[0],
                    m,
                    y
                ];
                U = [
                    -c[3],
                    c[2] - N
                ];
        }
        const H = [
            "q",
            `${L.join(" ")} 0 0 cm`,
            `${x.join(" ")} re W n`,
            "BT",
            `${getPdfColor(g, !0)}`,
            `0 Tc /Helv ${numberToString(M)} Tf`
        ];
        H.push(`${U.join(" ")} Td (${escapeString(F[0])}) Tj`);
        const J = numberToString(R);
        for(let e1 = 1, t = F.length; e1 < t; e1++){
            const t = F[e1];
            H.push(`0 -${J} Td (${escapeString(t)}) Tj`);
        }
        H.push("ET", "Q");
        const Y = H.join("\n"), v = new Dict(t);
        v.set("FormType", 1);
        v.set("Subtype", Name.get("Form"));
        v.set("Type", Name.get("XObject"));
        v.set("BBox", c);
        v.set("Resources", l);
        v.set("Matrix", [
            1,
            0,
            0,
            1,
            -c[0],
            -c[1]
        ]);
        const K = new StringStream(Y);
        K.dict = v;
        return K;
    }
}
class LineAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = G;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        const a = lookupRect(t.getArray("L"), [
            0,
            0,
            0,
            0
        ]);
        this.data.lineCoordinates = Util.normalizeRect(a);
        this.setLineEndings(t.getArray("LE"));
        this.data.lineEndings = this.lineEndings;
        if (!this.appearance) {
            const e1 = this.color ? getPdfColorArray(this.color) : [
                0,
                0,
                0
            ], s = t.get("CA"), r = getRgbColor(t.getArray("IC"), null), n = r ? getPdfColorArray(r) : null, g = n ? s : null, o = this.borderStyle.width || 1, c = 2 * o, C = [
                this.data.lineCoordinates[0] - c,
                this.data.lineCoordinates[1] - c,
                this.data.lineCoordinates[2] + c,
                this.data.lineCoordinates[3] + c
            ];
            Util.intersect(this.rectangle, C) || (this.rectangle = C);
            this._setDefaultAppearance({
                xref: i,
                extra: `${o} w`,
                strokeColor: e1,
                fillColor: n,
                strokeAlpha: s,
                fillAlpha: g,
                pointsCallback: (e1, t)=>{
                    e1.push(`${a[0]} ${a[1]} m`, `${a[2]} ${a[3]} l`, "S");
                    return [
                        t[0] - o,
                        t[2] + o,
                        t[7] - o,
                        t[3] + o
                    ];
                }
            });
        }
    }
}
class SquareAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = M;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        if (!this.appearance) {
            const e1 = this.color ? getPdfColorArray(this.color) : [
                0,
                0,
                0
            ], a = t.get("CA"), s = getRgbColor(t.getArray("IC"), null), r = s ? getPdfColorArray(s) : null, n = r ? a : null;
            if (0 === this.borderStyle.width && !r) return;
            this._setDefaultAppearance({
                xref: i,
                extra: `${this.borderStyle.width} w`,
                strokeColor: e1,
                fillColor: r,
                strokeAlpha: a,
                fillAlpha: n,
                pointsCallback: (e1, t)=>{
                    const i = t[4] + this.borderStyle.width / 2, a = t[5] + this.borderStyle.width / 2, s = t[6] - t[4] - this.borderStyle.width, n = t[3] - t[7] - this.borderStyle.width;
                    e1.push(`${i} ${a} ${s} ${n} re`);
                    r ? e1.push("B") : e1.push("S");
                    return [
                        t[0],
                        t[2],
                        t[7],
                        t[3]
                    ];
                }
            });
        }
    }
}
class CircleAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = U;
        if (!this.appearance) {
            const e1 = this.color ? getPdfColorArray(this.color) : [
                0,
                0,
                0
            ], a = t.get("CA"), s = getRgbColor(t.getArray("IC"), null), r = s ? getPdfColorArray(s) : null, n = r ? a : null;
            if (0 === this.borderStyle.width && !r) return;
            const g = 4 / 3 * Math.tan(Math.PI / 8);
            this._setDefaultAppearance({
                xref: i,
                extra: `${this.borderStyle.width} w`,
                strokeColor: e1,
                fillColor: r,
                strokeAlpha: a,
                fillAlpha: n,
                pointsCallback: (e1, t)=>{
                    const i = t[0] + this.borderStyle.width / 2, a = t[1] - this.borderStyle.width / 2, s = t[6] - this.borderStyle.width / 2, n = t[7] + this.borderStyle.width / 2, o = i + (s - i) / 2, c = a + (n - a) / 2, C = (s - i) / 2 * g, h = (n - a) / 2 * g;
                    e1.push(`${o} ${n} m`, `${o + C} ${n} ${s} ${c + h} ${s} ${c} c`, `${s} ${c - h} ${o + C} ${a} ${o} ${a} c`, `${o - C} ${a} ${i} ${c - h} ${i} ${c} c`, `${i} ${c + h} ${o - C} ${n} ${o} ${n} c`, "h");
                    r ? e1.push("B") : e1.push("S");
                    return [
                        t[0],
                        t[2],
                        t[7],
                        t[3]
                    ];
                }
            });
        }
    }
}
class PolylineAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = L;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        this.data.vertices = null;
        if (!(this instanceof PolygonAnnotation)) {
            this.setLineEndings(t.getArray("LE"));
            this.data.lineEndings = this.lineEndings;
        }
        const a = t.getArray("Vertices");
        if (!isNumberArray(a, null)) return;
        const s = this.data.vertices = Float32Array.from(a);
        if (!this.appearance) {
            const e1 = this.color ? getPdfColorArray(this.color) : [
                0,
                0,
                0
            ], a = t.get("CA"), r = this.borderStyle.width || 1, n = 2 * r, g = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            for(let e1 = 0, t = s.length; e1 < t; e1 += 2){
                g[0] = Math.min(g[0], s[e1] - n);
                g[1] = Math.min(g[1], s[e1 + 1] - n);
                g[2] = Math.max(g[2], s[e1] + n);
                g[3] = Math.max(g[3], s[e1 + 1] + n);
            }
            Util.intersect(this.rectangle, g) || (this.rectangle = g);
            this._setDefaultAppearance({
                xref: i,
                extra: `${r} w`,
                strokeColor: e1,
                strokeAlpha: a,
                pointsCallback: (e1, t)=>{
                    for(let t = 0, i = s.length; t < i; t += 2)e1.push(`${s[t]} ${s[t + 1]} ${0 === t ? "m" : "l"}`);
                    e1.push("S");
                    return [
                        t[0],
                        t[2],
                        t[7],
                        t[3]
                    ];
                }
            });
        }
    }
}
class PolygonAnnotation extends PolylineAnnotation {
    constructor(e1){
        super(e1);
        this.data.annotationType = x;
    }
}
class CaretAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        this.data.annotationType = T;
    }
}
class InkAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        const { dict: t, xref: i } = e1;
        this.data.annotationType = q;
        this.data.inkLists = [];
        this.data.isEditable = !this.data.noHTML;
        this.data.noHTML = !1;
        this.data.opacity = t.get("CA") || 1;
        const a = t.getArray("InkList");
        if (Array.isArray(a)) {
            for(let e1 = 0, t = a.length; e1 < t; ++e1){
                if (!Array.isArray(a[e1])) continue;
                const t = new Float32Array(a[e1].length);
                this.data.inkLists.push(t);
                for(let s = 0, r = a[e1].length; s < r; s += 2){
                    const r = i.fetchIfRef(a[e1][s]), n = i.fetchIfRef(a[e1][s + 1]);
                    if ("number" == typeof r && "number" == typeof n) {
                        t[s] = r;
                        t[s + 1] = n;
                    }
                }
            }
            if (!this.appearance) {
                const e1 = this.color ? getPdfColorArray(this.color) : [
                    0,
                    0,
                    0
                ], a = t.get("CA"), s = this.borderStyle.width || 1, r = 2 * s, n = [
                    1 / 0,
                    1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const e1 of this.data.inkLists)for(let t = 0, i = e1.length; t < i; t += 2){
                    n[0] = Math.min(n[0], e1[t] - r);
                    n[1] = Math.min(n[1], e1[t + 1] - r);
                    n[2] = Math.max(n[2], e1[t] + r);
                    n[3] = Math.max(n[3], e1[t + 1] + r);
                }
                Util.intersect(this.rectangle, n) || (this.rectangle = n);
                this._setDefaultAppearance({
                    xref: i,
                    extra: `${s} w`,
                    strokeColor: e1,
                    strokeAlpha: a,
                    pointsCallback: (e1, t)=>{
                        for (const t of this.data.inkLists){
                            for(let i = 0, a = t.length; i < a; i += 2)e1.push(`${t[i]} ${t[i + 1]} ${0 === i ? "m" : "l"}`);
                            e1.push("S");
                        }
                        return [
                            t[0],
                            t[2],
                            t[7],
                            t[3]
                        ];
                    }
                });
            }
        }
    }
    static createNewDict(e1, t, { apRef: i, ap: a }) {
        const { oldAnnotation: s, color: r, opacity: n, paths: g, outlines: o, rect: c, rotation: C, thickness: h, user: l } = e1, Q = s || new Dict(t);
        Q.set("Type", Name.get("Annot"));
        Q.set("Subtype", Name.get("Ink"));
        Q.set(s ? "M" : "CreationDate", `D:${getModificationDate()}`);
        Q.set("Rect", c);
        Q.set("InkList", o?.points || g.points);
        Q.set("F", 4);
        Q.set("Rotate", C);
        l && Q.set("T", stringToAsciiOrUTF16BE(l));
        o && Q.set("IT", Name.get("InkHighlight"));
        const E = new Dict(t);
        Q.set("BS", E);
        E.set("W", h);
        Q.set("C", Array.from(r, (e1)=>e1 / 255));
        Q.set("CA", n);
        const u = new Dict(t);
        Q.set("AP", u);
        i ? u.set("N", i) : u.set("N", a);
        return Q;
    }
    static async createNewAppearanceStream(e1, t, i) {
        if (e1.outlines) return this.createNewAppearanceStreamForHighlight(e1, t, i);
        const { color: a, rect: s, paths: r, thickness: n, opacity: g } = e1, o = [
            `${n} w 1 J 1 j`,
            `${getPdfColor(a, !1)}`
        ];
        1 !== g && o.push("/R0 gs");
        for (const e1 of r.lines){
            o.push(`${numberToString(e1[4])} ${numberToString(e1[5])} m`);
            for(let t = 6, i = e1.length; t < i; t += 6)if (isNaN(e1[t])) o.push(`${numberToString(e1[t + 4])} ${numberToString(e1[t + 5])} l`);
            else {
                const [i, a, s, r, n, g] = e1.slice(t, t + 6);
                o.push([
                    i,
                    a,
                    s,
                    r,
                    n,
                    g
                ].map(numberToString).join(" ") + " c");
            }
            6 === e1.length && o.push(`${numberToString(e1[4])} ${numberToString(e1[5])} l`);
        }
        o.push("S");
        const c = o.join("\n"), C = new Dict(t);
        C.set("FormType", 1);
        C.set("Subtype", Name.get("Form"));
        C.set("Type", Name.get("XObject"));
        C.set("BBox", s);
        C.set("Length", c.length);
        if (1 !== g) {
            const e1 = new Dict(t), i = new Dict(t), a = new Dict(t);
            a.set("CA", g);
            a.set("Type", Name.get("ExtGState"));
            i.set("R0", a);
            e1.set("ExtGState", i);
            C.set("Resources", e1);
        }
        const h = new StringStream(c);
        h.dict = C;
        return h;
    }
    static async createNewAppearanceStreamForHighlight(e1, t, i) {
        const { color: a, rect: s, outlines: { outline: r }, opacity: n } = e1, g = [
            `${getPdfColor(a, !0)}`,
            "/R0 gs"
        ];
        g.push(`${numberToString(r[4])} ${numberToString(r[5])} m`);
        for(let e1 = 6, t = r.length; e1 < t; e1 += 6)if (isNaN(r[e1])) g.push(`${numberToString(r[e1 + 4])} ${numberToString(r[e1 + 5])} l`);
        else {
            const [t, i, a, s, n, o] = r.slice(e1, e1 + 6);
            g.push([
                t,
                i,
                a,
                s,
                n,
                o
            ].map(numberToString).join(" ") + " c");
        }
        g.push("h f");
        const o = g.join("\n"), c = new Dict(t);
        c.set("FormType", 1);
        c.set("Subtype", Name.get("Form"));
        c.set("Type", Name.get("XObject"));
        c.set("BBox", s);
        c.set("Length", o.length);
        const C = new Dict(t), h = new Dict(t);
        C.set("ExtGState", h);
        c.set("Resources", C);
        const l = new Dict(t);
        h.set("R0", l);
        l.set("BM", Name.get("Multiply"));
        if (1 !== n) {
            l.set("ca", n);
            l.set("Type", Name.get("ExtGState"));
        }
        const Q = new StringStream(o);
        Q.dict = c;
        return Q;
    }
}
class HighlightAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = H;
        this.data.isEditable = !this.data.noHTML;
        this.data.noHTML = !1;
        this.data.opacity = t.get("CA") || 1;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            const e1 = this.appearance?.dict.get("Resources");
            if (!this.appearance || !e1?.has("ExtGState")) {
                this.appearance && warn("HighlightAnnotation - ignoring built-in appearance stream.");
                const e1 = this.color ? getPdfColorArray(this.color) : [
                    1,
                    1,
                    0
                ], a = t.get("CA");
                this._setDefaultAppearance({
                    xref: i,
                    fillColor: e1,
                    blendMode: "Multiply",
                    fillAlpha: a,
                    pointsCallback: (e1, t)=>{
                        e1.push(`${t[0]} ${t[1]} m`, `${t[2]} ${t[3]} l`, `${t[6]} ${t[7]} l`, `${t[4]} ${t[5]} l`, "f");
                        return [
                            t[0],
                            t[2],
                            t[7],
                            t[3]
                        ];
                    }
                });
            }
        } else this.data.popupRef = null;
    }
    static createNewDict(e1, t, { apRef: i, ap: a }) {
        const { color: s, oldAnnotation: r, opacity: n, rect: g, rotation: o, user: c, quadPoints: C } = e1, h = r || new Dict(t);
        h.set("Type", Name.get("Annot"));
        h.set("Subtype", Name.get("Highlight"));
        h.set(r ? "M" : "CreationDate", `D:${getModificationDate()}`);
        h.set("CreationDate", `D:${getModificationDate()}`);
        h.set("Rect", g);
        h.set("F", 4);
        h.set("Border", [
            0,
            0,
            0
        ]);
        h.set("Rotate", o);
        h.set("QuadPoints", C);
        h.set("C", Array.from(s, (e1)=>e1 / 255));
        h.set("CA", n);
        c && h.set("T", stringToAsciiOrUTF16BE(c));
        if (i || a) {
            const e1 = new Dict(t);
            h.set("AP", e1);
            e1.set("N", i || a);
        }
        return h;
    }
    static async createNewAppearanceStream(e1, t, i) {
        const { color: a, rect: s, outlines: r, opacity: n } = e1, g = [
            `${getPdfColor(a, !0)}`,
            "/R0 gs"
        ], o = [];
        for (const e1 of r){
            o.length = 0;
            o.push(`${numberToString(e1[0])} ${numberToString(e1[1])} m`);
            for(let t = 2, i = e1.length; t < i; t += 2)o.push(`${numberToString(e1[t])} ${numberToString(e1[t + 1])} l`);
            o.push("h");
            g.push(o.join("\n"));
        }
        g.push("f*");
        const c = g.join("\n"), C = new Dict(t);
        C.set("FormType", 1);
        C.set("Subtype", Name.get("Form"));
        C.set("Type", Name.get("XObject"));
        C.set("BBox", s);
        C.set("Length", c.length);
        const h = new Dict(t), l = new Dict(t);
        h.set("ExtGState", l);
        C.set("Resources", h);
        const Q = new Dict(t);
        l.set("R0", Q);
        Q.set("BM", Name.get("Multiply"));
        if (1 !== n) {
            Q.set("ca", n);
            Q.set("Type", Name.get("ExtGState"));
        }
        const E = new StringStream(c);
        E.dict = C;
        return E;
    }
}
class UnderlineAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = J;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            if (!this.appearance) {
                const e1 = this.color ? getPdfColorArray(this.color) : [
                    0,
                    0,
                    0
                ], a = t.get("CA");
                this._setDefaultAppearance({
                    xref: i,
                    extra: "[] 0 d 0.571 w",
                    strokeColor: e1,
                    strokeAlpha: a,
                    pointsCallback: (e1, t)=>{
                        e1.push(`${t[4]} ${t[5] + 1.3} m`, `${t[6]} ${t[7] + 1.3} l`, "S");
                        return [
                            t[0],
                            t[2],
                            t[7],
                            t[3]
                        ];
                    }
                });
            }
        } else this.data.popupRef = null;
    }
}
class SquigglyAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = Y;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            if (!this.appearance) {
                const e1 = this.color ? getPdfColorArray(this.color) : [
                    0,
                    0,
                    0
                ], a = t.get("CA");
                this._setDefaultAppearance({
                    xref: i,
                    extra: "[] 0 d 1 w",
                    strokeColor: e1,
                    strokeAlpha: a,
                    pointsCallback: (e1, t)=>{
                        const i = (t[1] - t[5]) / 6;
                        let a = i, s = t[4];
                        const r = t[5], n = t[6];
                        e1.push(`${s} ${r + a} m`);
                        do {
                            s += 2;
                            a = 0 === a ? i : 0;
                            e1.push(`${s} ${r + a} l`);
                        }while (s < n)
                        e1.push("S");
                        return [
                            t[4],
                            n,
                            r - 2 * i,
                            r + 2 * i
                        ];
                    }
                });
            }
        } else this.data.popupRef = null;
    }
}
class StrikeOutAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = v;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            if (!this.appearance) {
                const e1 = this.color ? getPdfColorArray(this.color) : [
                    0,
                    0,
                    0
                ], a = t.get("CA");
                this._setDefaultAppearance({
                    xref: i,
                    extra: "[] 0 d 1 w",
                    strokeColor: e1,
                    strokeAlpha: a,
                    pointsCallback: (e1, t)=>{
                        e1.push((t[0] + t[4]) / 2 + " " + (t[1] + t[5]) / 2 + " m", (t[2] + t[6]) / 2 + " " + (t[3] + t[7]) / 2 + " l", "S");
                        return [
                            t[0],
                            t[2],
                            t[7],
                            t[3]
                        ];
                    }
                });
            }
        } else this.data.popupRef = null;
    }
}
class StampAnnotation extends MarkupAnnotation {
    #T;
    constructor(e1){
        super(e1);
        this.data.annotationType = K;
        this.#T = this.data.hasOwnCanvas = this.data.noRotate;
        this.data.isEditable = !this.data.noHTML;
        this.data.noHTML = !1;
    }
    mustBeViewedWhenEditing(e1, t = null) {
        if (e1) {
            if (!this.data.isEditable) return !1;
            this.#T = this.data.hasOwnCanvas;
            this.data.hasOwnCanvas = !0;
            return !0;
        }
        this.data.hasOwnCanvas = this.#T;
        return !t?.has(this.data.id);
    }
    static async createImage(e1, t) {
        const { width: i, height: a } = e1, s = new OffscreenCanvas(i, a), r = s.getContext("2d", {
            alpha: !0
        });
        r.drawImage(e1, 0, 0);
        const n = r.getImageData(0, 0, i, a).data, g = new Uint32Array(n.buffer), o = g.some(FeatureTest.isLittleEndian ? (e1)=>e1 >>> 24 != 255 : (e1)=>!!(255 & ~e1));
        if (o) {
            r.fillStyle = "white";
            r.fillRect(0, 0, i, a);
            r.drawImage(e1, 0, 0);
        }
        const c = s.convertToBlob({
            type: "image/jpeg",
            quality: 1
        }).then((e1)=>e1.arrayBuffer()), C = Name.get("XObject"), h = Name.get("Image"), l = new Dict(t);
        l.set("Type", C);
        l.set("Subtype", h);
        l.set("BitsPerComponent", 8);
        l.set("ColorSpace", Name.get("DeviceRGB"));
        l.set("Filter", Name.get("DCTDecode"));
        l.set("BBox", [
            0,
            0,
            i,
            a
        ]);
        l.set("Width", i);
        l.set("Height", a);
        let Q = null;
        if (o) {
            const e1 = new Uint8Array(g.length);
            if (FeatureTest.isLittleEndian) for(let t = 0, i = g.length; t < i; t++)e1[t] = g[t] >>> 24;
            else for(let t = 0, i = g.length; t < i; t++)e1[t] = 255 & g[t];
            const s = new Dict(t);
            s.set("Type", C);
            s.set("Subtype", h);
            s.set("BitsPerComponent", 8);
            s.set("ColorSpace", Name.get("DeviceGray"));
            s.set("Width", i);
            s.set("Height", a);
            Q = new Stream(e1, 0, 0, s);
        }
        return {
            imageStream: new Stream(await c, 0, 0, l),
            smaskStream: Q,
            width: i,
            height: a
        };
    }
    static createNewDict(e1, t, { apRef: i, ap: a }) {
        const { oldAnnotation: s, rect: r, rotation: n, user: g } = e1, o = s || new Dict(t);
        o.set("Type", Name.get("Annot"));
        o.set("Subtype", Name.get("Stamp"));
        o.set(s ? "M" : "CreationDate", `D:${getModificationDate()}`);
        o.set("Rect", r);
        o.set("F", 4);
        o.set("Border", [
            0,
            0,
            0
        ]);
        o.set("Rotate", n);
        g && o.set("T", stringToAsciiOrUTF16BE(g));
        if (i || a) {
            const e1 = new Dict(t);
            o.set("AP", e1);
            i ? e1.set("N", i) : e1.set("N", a);
        }
        return o;
    }
    static async createNewAppearanceStream(e1, t, i) {
        if (e1.oldAnnotation) return null;
        const { rotation: a } = e1, { imageRef: s, width: r, height: n } = i.image, g = new Dict(t), o = new Dict(t);
        g.set("XObject", o);
        o.set("Im0", s);
        const c = `q ${r} 0 0 ${n} 0 0 cm /Im0 Do Q`, C = new Dict(t);
        C.set("FormType", 1);
        C.set("Subtype", Name.get("Form"));
        C.set("Type", Name.get("XObject"));
        C.set("BBox", [
            0,
            0,
            r,
            n
        ]);
        C.set("Resources", g);
        if (a) {
            const e1 = getRotationMatrix(a, r, n);
            C.set("Matrix", e1);
        }
        const h = new StringStream(c);
        h.dict = C;
        return h;
    }
}
class FileAttachmentAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1, a = new FileSpec(t.get("FS"), i);
        this.data.annotationType = W;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        this.data.file = a.serializable;
        const s = t.get("Name");
        this.data.name = s instanceof Name ? stringToPDFString(s.name) : "PushPin";
        const r = t.get("ca");
        this.data.fillAlpha = "number" == typeof r && r >= 0 && r <= 1 ? r : null;
    }
}
class DecryptStream extends DecodeStream {
    constructor(e1, t, i){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        this.decrypt = i;
        this.nextChunk = null;
        this.initialized = !1;
    }
    readBlock() {
        let e1;
        if (this.initialized) e1 = this.nextChunk;
        else {
            e1 = this.str.getBytes(512);
            this.initialized = !0;
        }
        if (!e1?.length) {
            this.eof = !0;
            return;
        }
        this.nextChunk = this.str.getBytes(512);
        const t = this.nextChunk?.length > 0;
        e1 = (0, this.decrypt)(e1, !t);
        const i = this.bufferLength, a = i + e1.length;
        this.ensureBuffer(a).set(e1, i);
        this.bufferLength = a;
    }
}
class ARCFourCipher {
    constructor(e1){
        this.a = 0;
        this.b = 0;
        const t = new Uint8Array(256), i = e1.length;
        for(let e1 = 0; e1 < 256; ++e1)t[e1] = e1;
        for(let a = 0, s = 0; a < 256; ++a){
            const r = t[a];
            s = s + r + e1[a % i] & 255;
            t[a] = t[s];
            t[s] = r;
        }
        this.s = t;
    }
    encryptBlock(e1) {
        let t = this.a, i = this.b;
        const a = this.s, s = e1.length, r = new Uint8Array(s);
        for(let n = 0; n < s; ++n){
            t = t + 1 & 255;
            const s = a[t];
            i = i + s & 255;
            const g = a[i];
            a[t] = g;
            a[i] = s;
            r[n] = e1[n] ^ a[s + g & 255];
        }
        this.a = t;
        this.b = i;
        return r;
    }
    decryptBlock(e1) {
        return this.encryptBlock(e1);
    }
    encrypt(e1) {
        return this.encryptBlock(e1);
    }
}
const $n = function calculateMD5Closure() {
    const e1 = new Uint8Array([
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
    ]), t = new Int32Array([
        -680876936,
        -389564586,
        606105819,
        -1044525330,
        -176418897,
        1200080426,
        -1473231341,
        -45705983,
        1770035416,
        -1958414417,
        -42063,
        -1990404162,
        1804603682,
        -40341101,
        -1502002290,
        1236535329,
        -165796510,
        -1069501632,
        643717713,
        -373897302,
        -701558691,
        38016083,
        -660478335,
        -405537848,
        568446438,
        -1019803690,
        -187363961,
        1163531501,
        -1444681467,
        -51403784,
        1735328473,
        -1926607734,
        -378558,
        -2022574463,
        1839030562,
        -35309556,
        -1530992060,
        1272893353,
        -155497632,
        -1094730640,
        681279174,
        -358537222,
        -722521979,
        76029189,
        -640364487,
        -421815835,
        530742520,
        -995338651,
        -198630844,
        1126891415,
        -1416354905,
        -57434055,
        1700485571,
        -1894986606,
        -1051523,
        -2054922799,
        1873313359,
        -30611744,
        -1560198380,
        1309151649,
        -145523070,
        -1120210379,
        718787259,
        -343485551
    ]);
    return function hash(i, a, s) {
        let r = 1732584193, n = -271733879, g = -1732584194, o = 271733878;
        const c = s + 72 & -64, C = new Uint8Array(c);
        let h, l;
        for(h = 0; h < s; ++h)C[h] = i[a++];
        C[h++] = 128;
        const Q = c - 8;
        for(; h < Q;)C[h++] = 0;
        C[h++] = s << 3 & 255;
        C[h++] = s >> 5 & 255;
        C[h++] = s >> 13 & 255;
        C[h++] = s >> 21 & 255;
        C[h++] = s >>> 29 & 255;
        C[h++] = 0;
        C[h++] = 0;
        C[h++] = 0;
        const E = new Int32Array(16);
        for(h = 0; h < c;){
            for(l = 0; l < 16; ++l, h += 4)E[l] = C[h] | C[h + 1] << 8 | C[h + 2] << 16 | C[h + 3] << 24;
            let i, a, s = r, c = n, Q = g, u = o;
            for(l = 0; l < 64; ++l){
                if (l < 16) {
                    i = c & Q | ~c & u;
                    a = l;
                } else if (l < 32) {
                    i = u & c | ~u & Q;
                    a = 5 * l + 1 & 15;
                } else if (l < 48) {
                    i = c ^ Q ^ u;
                    a = 3 * l + 5 & 15;
                } else {
                    i = Q ^ (c | ~u);
                    a = 7 * l & 15;
                }
                const r = u, n = s + i + t[l] + E[a] | 0, g = e1[l];
                u = Q;
                Q = c;
                c = c + (n << g | n >>> 32 - g) | 0;
                s = r;
            }
            r = r + s | 0;
            n = n + c | 0;
            g = g + Q | 0;
            o = o + u | 0;
        }
        return new Uint8Array([
            255 & r,
            r >> 8 & 255,
            r >> 16 & 255,
            r >>> 24 & 255,
            255 & n,
            n >> 8 & 255,
            n >> 16 & 255,
            n >>> 24 & 255,
            255 & g,
            g >> 8 & 255,
            g >> 16 & 255,
            g >>> 24 & 255,
            255 & o,
            o >> 8 & 255,
            o >> 16 & 255,
            o >>> 24 & 255
        ]);
    };
}();
class Word64 {
    constructor(e1, t){
        this.high = 0 | e1;
        this.low = 0 | t;
    }
    and(e1) {
        this.high &= e1.high;
        this.low &= e1.low;
    }
    xor(e1) {
        this.high ^= e1.high;
        this.low ^= e1.low;
    }
    or(e1) {
        this.high |= e1.high;
        this.low |= e1.low;
    }
    shiftRight(e1) {
        if (e1 >= 32) {
            this.low = this.high >>> e1 - 32 | 0;
            this.high = 0;
        } else {
            this.low = this.low >>> e1 | this.high << 32 - e1;
            this.high = this.high >>> e1 | 0;
        }
    }
    shiftLeft(e1) {
        if (e1 >= 32) {
            this.high = this.low << e1 - 32;
            this.low = 0;
        } else {
            this.high = this.high << e1 | this.low >>> 32 - e1;
            this.low <<= e1;
        }
    }
    rotateRight(e1) {
        let t, i;
        if (32 & e1) {
            i = this.low;
            t = this.high;
        } else {
            t = this.low;
            i = this.high;
        }
        e1 &= 31;
        this.low = t >>> e1 | i << 32 - e1;
        this.high = i >>> e1 | t << 32 - e1;
    }
    not() {
        this.high = ~this.high;
        this.low = ~this.low;
    }
    add(e1) {
        const t = (this.low >>> 0) + (e1.low >>> 0);
        let i = (this.high >>> 0) + (e1.high >>> 0);
        t > 4294967295 && (i += 1);
        this.low = 0 | t;
        this.high = 0 | i;
    }
    copyTo(e1, t) {
        e1[t] = this.high >>> 24 & 255;
        e1[t + 1] = this.high >> 16 & 255;
        e1[t + 2] = this.high >> 8 & 255;
        e1[t + 3] = 255 & this.high;
        e1[t + 4] = this.low >>> 24 & 255;
        e1[t + 5] = this.low >> 16 & 255;
        e1[t + 6] = this.low >> 8 & 255;
        e1[t + 7] = 255 & this.low;
    }
    assign(e1) {
        this.high = e1.high;
        this.low = e1.low;
    }
}
const Ag = function calculateSHA256Closure() {
    function rotr(e1, t) {
        return e1 >>> t | e1 << 32 - t;
    }
    function ch(e1, t, i) {
        return e1 & t ^ ~e1 & i;
    }
    function maj(e1, t, i) {
        return e1 & t ^ e1 & i ^ t & i;
    }
    function sigma(e1) {
        return rotr(e1, 2) ^ rotr(e1, 13) ^ rotr(e1, 22);
    }
    function sigmaPrime(e1) {
        return rotr(e1, 6) ^ rotr(e1, 11) ^ rotr(e1, 25);
    }
    function littleSigma(e1) {
        return rotr(e1, 7) ^ rotr(e1, 18) ^ e1 >>> 3;
    }
    const e1 = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ];
    return function hash(t, i, a) {
        let s = 1779033703, r = 3144134277, n = 1013904242, g = 2773480762, o = 1359893119, c = 2600822924, C = 528734635, h = 1541459225;
        const l = 64 * Math.ceil((a + 9) / 64), Q = new Uint8Array(l);
        let E, u;
        for(E = 0; E < a; ++E)Q[E] = t[i++];
        Q[E++] = 128;
        const d = l - 8;
        for(; E < d;)Q[E++] = 0;
        Q[E++] = 0;
        Q[E++] = 0;
        Q[E++] = 0;
        Q[E++] = a >>> 29 & 255;
        Q[E++] = a >> 21 & 255;
        Q[E++] = a >> 13 & 255;
        Q[E++] = a >> 5 & 255;
        Q[E++] = a << 3 & 255;
        const f = new Uint32Array(64);
        for(E = 0; E < l;){
            for(u = 0; u < 16; ++u){
                f[u] = Q[E] << 24 | Q[E + 1] << 16 | Q[E + 2] << 8 | Q[E + 3];
                E += 4;
            }
            for(u = 16; u < 64; ++u)f[u] = (rotr(p = f[u - 2], 17) ^ rotr(p, 19) ^ p >>> 10) + f[u - 7] + littleSigma(f[u - 15]) + f[u - 16] | 0;
            let t, i, a = s, l = r, d = n, m = g, y = o, w = c, D = C, b = h;
            for(u = 0; u < 64; ++u){
                t = b + sigmaPrime(y) + ch(y, w, D) + e1[u] + f[u];
                i = sigma(a) + maj(a, l, d);
                b = D;
                D = w;
                w = y;
                y = m + t | 0;
                m = d;
                d = l;
                l = a;
                a = t + i | 0;
            }
            s = s + a | 0;
            r = r + l | 0;
            n = n + d | 0;
            g = g + m | 0;
            o = o + y | 0;
            c = c + w | 0;
            C = C + D | 0;
            h = h + b | 0;
        }
        var p;
        return new Uint8Array([
            s >> 24 & 255,
            s >> 16 & 255,
            s >> 8 & 255,
            255 & s,
            r >> 24 & 255,
            r >> 16 & 255,
            r >> 8 & 255,
            255 & r,
            n >> 24 & 255,
            n >> 16 & 255,
            n >> 8 & 255,
            255 & n,
            g >> 24 & 255,
            g >> 16 & 255,
            g >> 8 & 255,
            255 & g,
            o >> 24 & 255,
            o >> 16 & 255,
            o >> 8 & 255,
            255 & o,
            c >> 24 & 255,
            c >> 16 & 255,
            c >> 8 & 255,
            255 & c,
            C >> 24 & 255,
            C >> 16 & 255,
            C >> 8 & 255,
            255 & C,
            h >> 24 & 255,
            h >> 16 & 255,
            h >> 8 & 255,
            255 & h
        ]);
    };
}(), eg = function calculateSHA512Closure() {
    function ch(e1, t, i, a, s) {
        e1.assign(t);
        e1.and(i);
        s.assign(t);
        s.not();
        s.and(a);
        e1.xor(s);
    }
    function maj(e1, t, i, a, s) {
        e1.assign(t);
        e1.and(i);
        s.assign(t);
        s.and(a);
        e1.xor(s);
        s.assign(i);
        s.and(a);
        e1.xor(s);
    }
    function sigma(e1, t, i) {
        e1.assign(t);
        e1.rotateRight(28);
        i.assign(t);
        i.rotateRight(34);
        e1.xor(i);
        i.assign(t);
        i.rotateRight(39);
        e1.xor(i);
    }
    function sigmaPrime(e1, t, i) {
        e1.assign(t);
        e1.rotateRight(14);
        i.assign(t);
        i.rotateRight(18);
        e1.xor(i);
        i.assign(t);
        i.rotateRight(41);
        e1.xor(i);
    }
    function littleSigma(e1, t, i) {
        e1.assign(t);
        e1.rotateRight(1);
        i.assign(t);
        i.rotateRight(8);
        e1.xor(i);
        i.assign(t);
        i.shiftRight(7);
        e1.xor(i);
    }
    function littleSigmaPrime(e1, t, i) {
        e1.assign(t);
        e1.rotateRight(19);
        i.assign(t);
        i.rotateRight(61);
        e1.xor(i);
        i.assign(t);
        i.shiftRight(6);
        e1.xor(i);
    }
    const e1 = [
        new Word64(1116352408, 3609767458),
        new Word64(1899447441, 602891725),
        new Word64(3049323471, 3964484399),
        new Word64(3921009573, 2173295548),
        new Word64(961987163, 4081628472),
        new Word64(1508970993, 3053834265),
        new Word64(2453635748, 2937671579),
        new Word64(2870763221, 3664609560),
        new Word64(3624381080, 2734883394),
        new Word64(310598401, 1164996542),
        new Word64(607225278, 1323610764),
        new Word64(1426881987, 3590304994),
        new Word64(1925078388, 4068182383),
        new Word64(2162078206, 991336113),
        new Word64(2614888103, 633803317),
        new Word64(3248222580, 3479774868),
        new Word64(3835390401, 2666613458),
        new Word64(4022224774, 944711139),
        new Word64(264347078, 2341262773),
        new Word64(604807628, 2007800933),
        new Word64(770255983, 1495990901),
        new Word64(1249150122, 1856431235),
        new Word64(1555081692, 3175218132),
        new Word64(1996064986, 2198950837),
        new Word64(2554220882, 3999719339),
        new Word64(2821834349, 766784016),
        new Word64(2952996808, 2566594879),
        new Word64(3210313671, 3203337956),
        new Word64(3336571891, 1034457026),
        new Word64(3584528711, 2466948901),
        new Word64(113926993, 3758326383),
        new Word64(338241895, 168717936),
        new Word64(666307205, 1188179964),
        new Word64(773529912, 1546045734),
        new Word64(1294757372, 1522805485),
        new Word64(1396182291, 2643833823),
        new Word64(1695183700, 2343527390),
        new Word64(1986661051, 1014477480),
        new Word64(2177026350, 1206759142),
        new Word64(2456956037, 344077627),
        new Word64(2730485921, 1290863460),
        new Word64(2820302411, 3158454273),
        new Word64(3259730800, 3505952657),
        new Word64(3345764771, 106217008),
        new Word64(3516065817, 3606008344),
        new Word64(3600352804, 1432725776),
        new Word64(4094571909, 1467031594),
        new Word64(275423344, 851169720),
        new Word64(430227734, 3100823752),
        new Word64(506948616, 1363258195),
        new Word64(659060556, 3750685593),
        new Word64(883997877, 3785050280),
        new Word64(958139571, 3318307427),
        new Word64(1322822218, 3812723403),
        new Word64(1537002063, 2003034995),
        new Word64(1747873779, 3602036899),
        new Word64(1955562222, 1575990012),
        new Word64(2024104815, 1125592928),
        new Word64(2227730452, 2716904306),
        new Word64(2361852424, 442776044),
        new Word64(2428436474, 593698344),
        new Word64(2756734187, 3733110249),
        new Word64(3204031479, 2999351573),
        new Word64(3329325298, 3815920427),
        new Word64(3391569614, 3928383900),
        new Word64(3515267271, 566280711),
        new Word64(3940187606, 3454069534),
        new Word64(4118630271, 4000239992),
        new Word64(116418474, 1914138554),
        new Word64(174292421, 2731055270),
        new Word64(289380356, 3203993006),
        new Word64(460393269, 320620315),
        new Word64(685471733, 587496836),
        new Word64(852142971, 1086792851),
        new Word64(1017036298, 365543100),
        new Word64(1126000580, 2618297676),
        new Word64(1288033470, 3409855158),
        new Word64(1501505948, 4234509866),
        new Word64(1607167915, 987167468),
        new Word64(1816402316, 1246189591)
    ];
    return function hash(t, i, a, s = !1) {
        let r, n, g, o, c, C, h, l;
        if (s) {
            r = new Word64(3418070365, 3238371032);
            n = new Word64(1654270250, 914150663);
            g = new Word64(2438529370, 812702999);
            o = new Word64(355462360, 4144912697);
            c = new Word64(1731405415, 4290775857);
            C = new Word64(2394180231, 1750603025);
            h = new Word64(3675008525, 1694076839);
            l = new Word64(1203062813, 3204075428);
        } else {
            r = new Word64(1779033703, 4089235720);
            n = new Word64(3144134277, 2227873595);
            g = new Word64(1013904242, 4271175723);
            o = new Word64(2773480762, 1595750129);
            c = new Word64(1359893119, 2917565137);
            C = new Word64(2600822924, 725511199);
            h = new Word64(528734635, 4215389547);
            l = new Word64(1541459225, 327033209);
        }
        const Q = 128 * Math.ceil((a + 17) / 128), E = new Uint8Array(Q);
        let u, d;
        for(u = 0; u < a; ++u)E[u] = t[i++];
        E[u++] = 128;
        const f = Q - 16;
        for(; u < f;)E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = 0;
        E[u++] = a >>> 29 & 255;
        E[u++] = a >> 21 & 255;
        E[u++] = a >> 13 & 255;
        E[u++] = a >> 5 & 255;
        E[u++] = a << 3 & 255;
        const p = new Array(80);
        for(u = 0; u < 80; u++)p[u] = new Word64(0, 0);
        let m = new Word64(0, 0), y = new Word64(0, 0), w = new Word64(0, 0), D = new Word64(0, 0), b = new Word64(0, 0), F = new Word64(0, 0), S = new Word64(0, 0), k = new Word64(0, 0);
        const R = new Word64(0, 0), N = new Word64(0, 0), G = new Word64(0, 0), M = new Word64(0, 0);
        let U, x;
        for(u = 0; u < Q;){
            for(d = 0; d < 16; ++d){
                p[d].high = E[u] << 24 | E[u + 1] << 16 | E[u + 2] << 8 | E[u + 3];
                p[d].low = E[u + 4] << 24 | E[u + 5] << 16 | E[u + 6] << 8 | E[u + 7];
                u += 8;
            }
            for(d = 16; d < 80; ++d){
                U = p[d];
                littleSigmaPrime(U, p[d - 2], M);
                U.add(p[d - 7]);
                littleSigma(G, p[d - 15], M);
                U.add(G);
                U.add(p[d - 16]);
            }
            m.assign(r);
            y.assign(n);
            w.assign(g);
            D.assign(o);
            b.assign(c);
            F.assign(C);
            S.assign(h);
            k.assign(l);
            for(d = 0; d < 80; ++d){
                R.assign(k);
                sigmaPrime(G, b, M);
                R.add(G);
                ch(G, b, F, S, M);
                R.add(G);
                R.add(e1[d]);
                R.add(p[d]);
                sigma(N, m, M);
                maj(G, m, y, w, M);
                N.add(G);
                U = k;
                k = S;
                S = F;
                F = b;
                D.add(R);
                b = D;
                D = w;
                w = y;
                y = m;
                U.assign(R);
                U.add(N);
                m = U;
            }
            r.add(m);
            n.add(y);
            g.add(w);
            o.add(D);
            c.add(b);
            C.add(F);
            h.add(S);
            l.add(k);
        }
        if (s) {
            x = new Uint8Array(48);
            r.copyTo(x, 0);
            n.copyTo(x, 8);
            g.copyTo(x, 16);
            o.copyTo(x, 24);
            c.copyTo(x, 32);
            C.copyTo(x, 40);
        } else {
            x = new Uint8Array(64);
            r.copyTo(x, 0);
            n.copyTo(x, 8);
            g.copyTo(x, 16);
            o.copyTo(x, 24);
            c.copyTo(x, 32);
            C.copyTo(x, 40);
            h.copyTo(x, 48);
            l.copyTo(x, 56);
        }
        return x;
    };
}();
class NullCipher {
    decryptBlock(e1) {
        return e1;
    }
    encrypt(e1) {
        return e1;
    }
}
class AESBaseCipher {
    constructor(){
        this._s = new Uint8Array([
            99,
            124,
            119,
            123,
            242,
            107,
            111,
            197,
            48,
            1,
            103,
            43,
            254,
            215,
            171,
            118,
            202,
            130,
            201,
            125,
            250,
            89,
            71,
            240,
            173,
            212,
            162,
            175,
            156,
            164,
            114,
            192,
            183,
            253,
            147,
            38,
            54,
            63,
            247,
            204,
            52,
            165,
            229,
            241,
            113,
            216,
            49,
            21,
            4,
            199,
            35,
            195,
            24,
            150,
            5,
            154,
            7,
            18,
            128,
            226,
            235,
            39,
            178,
            117,
            9,
            131,
            44,
            26,
            27,
            110,
            90,
            160,
            82,
            59,
            214,
            179,
            41,
            227,
            47,
            132,
            83,
            209,
            0,
            237,
            32,
            252,
            177,
            91,
            106,
            203,
            190,
            57,
            74,
            76,
            88,
            207,
            208,
            239,
            170,
            251,
            67,
            77,
            51,
            133,
            69,
            249,
            2,
            127,
            80,
            60,
            159,
            168,
            81,
            163,
            64,
            143,
            146,
            157,
            56,
            245,
            188,
            182,
            218,
            33,
            16,
            255,
            243,
            210,
            205,
            12,
            19,
            236,
            95,
            151,
            68,
            23,
            196,
            167,
            126,
            61,
            100,
            93,
            25,
            115,
            96,
            129,
            79,
            220,
            34,
            42,
            144,
            136,
            70,
            238,
            184,
            20,
            222,
            94,
            11,
            219,
            224,
            50,
            58,
            10,
            73,
            6,
            36,
            92,
            194,
            211,
            172,
            98,
            145,
            149,
            228,
            121,
            231,
            200,
            55,
            109,
            141,
            213,
            78,
            169,
            108,
            86,
            244,
            234,
            101,
            122,
            174,
            8,
            186,
            120,
            37,
            46,
            28,
            166,
            180,
            198,
            232,
            221,
            116,
            31,
            75,
            189,
            139,
            138,
            112,
            62,
            181,
            102,
            72,
            3,
            246,
            14,
            97,
            53,
            87,
            185,
            134,
            193,
            29,
            158,
            225,
            248,
            152,
            17,
            105,
            217,
            142,
            148,
            155,
            30,
            135,
            233,
            206,
            85,
            40,
            223,
            140,
            161,
            137,
            13,
            191,
            230,
            66,
            104,
            65,
            153,
            45,
            15,
            176,
            84,
            187,
            22
        ]);
        this._inv_s = new Uint8Array([
            82,
            9,
            106,
            213,
            48,
            54,
            165,
            56,
            191,
            64,
            163,
            158,
            129,
            243,
            215,
            251,
            124,
            227,
            57,
            130,
            155,
            47,
            255,
            135,
            52,
            142,
            67,
            68,
            196,
            222,
            233,
            203,
            84,
            123,
            148,
            50,
            166,
            194,
            35,
            61,
            238,
            76,
            149,
            11,
            66,
            250,
            195,
            78,
            8,
            46,
            161,
            102,
            40,
            217,
            36,
            178,
            118,
            91,
            162,
            73,
            109,
            139,
            209,
            37,
            114,
            248,
            246,
            100,
            134,
            104,
            152,
            22,
            212,
            164,
            92,
            204,
            93,
            101,
            182,
            146,
            108,
            112,
            72,
            80,
            253,
            237,
            185,
            218,
            94,
            21,
            70,
            87,
            167,
            141,
            157,
            132,
            144,
            216,
            171,
            0,
            140,
            188,
            211,
            10,
            247,
            228,
            88,
            5,
            184,
            179,
            69,
            6,
            208,
            44,
            30,
            143,
            202,
            63,
            15,
            2,
            193,
            175,
            189,
            3,
            1,
            19,
            138,
            107,
            58,
            145,
            17,
            65,
            79,
            103,
            220,
            234,
            151,
            242,
            207,
            206,
            240,
            180,
            230,
            115,
            150,
            172,
            116,
            34,
            231,
            173,
            53,
            133,
            226,
            249,
            55,
            232,
            28,
            117,
            223,
            110,
            71,
            241,
            26,
            113,
            29,
            41,
            197,
            137,
            111,
            183,
            98,
            14,
            170,
            24,
            190,
            27,
            252,
            86,
            62,
            75,
            198,
            210,
            121,
            32,
            154,
            219,
            192,
            254,
            120,
            205,
            90,
            244,
            31,
            221,
            168,
            51,
            136,
            7,
            199,
            49,
            177,
            18,
            16,
            89,
            39,
            128,
            236,
            95,
            96,
            81,
            127,
            169,
            25,
            181,
            74,
            13,
            45,
            229,
            122,
            159,
            147,
            201,
            156,
            239,
            160,
            224,
            59,
            77,
            174,
            42,
            245,
            176,
            200,
            235,
            187,
            60,
            131,
            83,
            153,
            97,
            23,
            43,
            4,
            126,
            186,
            119,
            214,
            38,
            225,
            105,
            20,
            99,
            85,
            33,
            12,
            125
        ]);
        this._mix = new Uint32Array([
            0,
            235474187,
            470948374,
            303765277,
            941896748,
            908933415,
            607530554,
            708780849,
            1883793496,
            2118214995,
            1817866830,
            1649639237,
            1215061108,
            1181045119,
            1417561698,
            1517767529,
            3767586992,
            4003061179,
            4236429990,
            4069246893,
            3635733660,
            3602770327,
            3299278474,
            3400528769,
            2430122216,
            2664543715,
            2362090238,
            2193862645,
            2835123396,
            2801107407,
            3035535058,
            3135740889,
            3678124923,
            3576870512,
            3341394285,
            3374361702,
            3810496343,
            3977675356,
            4279080257,
            4043610186,
            2876494627,
            2776292904,
            3076639029,
            3110650942,
            2472011535,
            2640243204,
            2403728665,
            2169303058,
            1001089995,
            899835584,
            666464733,
            699432150,
            59727847,
            226906860,
            530400753,
            294930682,
            1273168787,
            1172967064,
            1475418501,
            1509430414,
            1942435775,
            2110667444,
            1876241833,
            1641816226,
            2910219766,
            2743034109,
            2976151520,
            3211623147,
            2505202138,
            2606453969,
            2302690252,
            2269728455,
            3711829422,
            3543599269,
            3240894392,
            3475313331,
            3843699074,
            3943906441,
            4178062228,
            4144047775,
            1306967366,
            1139781709,
            1374988112,
            1610459739,
            1975683434,
            2076935265,
            1775276924,
            1742315127,
            1034867998,
            866637845,
            566021896,
            800440835,
            92987698,
            193195065,
            429456164,
            395441711,
            1984812685,
            2017778566,
            1784663195,
            1683407248,
            1315562145,
            1080094634,
            1383856311,
            1551037884,
            101039829,
            135050206,
            437757123,
            337553864,
            1042385657,
            807962610,
            573804783,
            742039012,
            2531067453,
            2564033334,
            2328828971,
            2227573024,
            2935566865,
            2700099354,
            3001755655,
            3168937228,
            3868552805,
            3902563182,
            4203181171,
            4102977912,
            3736164937,
            3501741890,
            3265478751,
            3433712980,
            1106041591,
            1340463100,
            1576976609,
            1408749034,
            2043211483,
            2009195472,
            1708848333,
            1809054150,
            832877231,
            1068351396,
            766945465,
            599762354,
            159417987,
            126454664,
            361929877,
            463180190,
            2709260871,
            2943682380,
            3178106961,
            3009879386,
            2572697195,
            2538681184,
            2236228733,
            2336434550,
            3509871135,
            3745345300,
            3441850377,
            3274667266,
            3910161971,
            3877198648,
            4110568485,
            4211818798,
            2597806476,
            2497604743,
            2261089178,
            2295101073,
            2733856160,
            2902087851,
            3202437046,
            2968011453,
            3936291284,
            3835036895,
            4136440770,
            4169408201,
            3535486456,
            3702665459,
            3467192302,
            3231722213,
            2051518780,
            1951317047,
            1716890410,
            1750902305,
            1113818384,
            1282050075,
            1584504582,
            1350078989,
            168810852,
            67556463,
            371049330,
            404016761,
            841739592,
            1008918595,
            775550814,
            540080725,
            3969562369,
            3801332234,
            4035489047,
            4269907996,
            3569255213,
            3669462566,
            3366754619,
            3332740144,
            2631065433,
            2463879762,
            2160117071,
            2395588676,
            2767645557,
            2868897406,
            3102011747,
            3069049960,
            202008497,
            33778362,
            270040487,
            504459436,
            875451293,
            975658646,
            675039627,
            641025152,
            2084704233,
            1917518562,
            1615861247,
            1851332852,
            1147550661,
            1248802510,
            1484005843,
            1451044056,
            933301370,
            967311729,
            733156972,
            632953703,
            260388950,
            25965917,
            328671808,
            496906059,
            1206477858,
            1239443753,
            1543208500,
            1441952575,
            2144161806,
            1908694277,
            1675577880,
            1842759443,
            3610369226,
            3644379585,
            3408119516,
            3307916247,
            4011190502,
            3776767469,
            4077384432,
            4245618683,
            2809771154,
            2842737049,
            3144396420,
            3043140495,
            2673705150,
            2438237621,
            2203032232,
            2370213795
        ]);
        this._mixCol = new Uint8Array(256);
        for(let e1 = 0; e1 < 256; e1++)this._mixCol[e1] = e1 < 128 ? e1 << 1 : e1 << 1 ^ 27;
        this.buffer = new Uint8Array(16);
        this.bufferPosition = 0;
    }
    _expandKey(e1) {
        unreachable("Cannot call `_expandKey` on the base class");
    }
    _decrypt(e1, t) {
        let i, a, s;
        const r = new Uint8Array(16);
        r.set(e1);
        for(let e1 = 0, i = this._keySize; e1 < 16; ++e1, ++i)r[e1] ^= t[i];
        for(let e1 = this._cyclesOfRepetition - 1; e1 >= 1; --e1){
            i = r[13];
            r[13] = r[9];
            r[9] = r[5];
            r[5] = r[1];
            r[1] = i;
            i = r[14];
            a = r[10];
            r[14] = r[6];
            r[10] = r[2];
            r[6] = i;
            r[2] = a;
            i = r[15];
            a = r[11];
            s = r[7];
            r[15] = r[3];
            r[11] = i;
            r[7] = a;
            r[3] = s;
            for(let e1 = 0; e1 < 16; ++e1)r[e1] = this._inv_s[r[e1]];
            for(let i = 0, a = 16 * e1; i < 16; ++i, ++a)r[i] ^= t[a];
            for(let e1 = 0; e1 < 16; e1 += 4){
                const t = this._mix[r[e1]], a = this._mix[r[e1 + 1]], s = this._mix[r[e1 + 2]], n = this._mix[r[e1 + 3]];
                i = t ^ a >>> 8 ^ a << 24 ^ s >>> 16 ^ s << 16 ^ n >>> 24 ^ n << 8;
                r[e1] = i >>> 24 & 255;
                r[e1 + 1] = i >> 16 & 255;
                r[e1 + 2] = i >> 8 & 255;
                r[e1 + 3] = 255 & i;
            }
        }
        i = r[13];
        r[13] = r[9];
        r[9] = r[5];
        r[5] = r[1];
        r[1] = i;
        i = r[14];
        a = r[10];
        r[14] = r[6];
        r[10] = r[2];
        r[6] = i;
        r[2] = a;
        i = r[15];
        a = r[11];
        s = r[7];
        r[15] = r[3];
        r[11] = i;
        r[7] = a;
        r[3] = s;
        for(let e1 = 0; e1 < 16; ++e1){
            r[e1] = this._inv_s[r[e1]];
            r[e1] ^= t[e1];
        }
        return r;
    }
    _encrypt(e1, t) {
        const i = this._s;
        let a, s, r;
        const n = new Uint8Array(16);
        n.set(e1);
        for(let e1 = 0; e1 < 16; ++e1)n[e1] ^= t[e1];
        for(let e1 = 1; e1 < this._cyclesOfRepetition; e1++){
            for(let e1 = 0; e1 < 16; ++e1)n[e1] = i[n[e1]];
            r = n[1];
            n[1] = n[5];
            n[5] = n[9];
            n[9] = n[13];
            n[13] = r;
            r = n[2];
            s = n[6];
            n[2] = n[10];
            n[6] = n[14];
            n[10] = r;
            n[14] = s;
            r = n[3];
            s = n[7];
            a = n[11];
            n[3] = n[15];
            n[7] = r;
            n[11] = s;
            n[15] = a;
            for(let e1 = 0; e1 < 16; e1 += 4){
                const t = n[e1 + 0], i = n[e1 + 1], s = n[e1 + 2], r = n[e1 + 3];
                a = t ^ i ^ s ^ r;
                n[e1 + 0] ^= a ^ this._mixCol[t ^ i];
                n[e1 + 1] ^= a ^ this._mixCol[i ^ s];
                n[e1 + 2] ^= a ^ this._mixCol[s ^ r];
                n[e1 + 3] ^= a ^ this._mixCol[r ^ t];
            }
            for(let i = 0, a = 16 * e1; i < 16; ++i, ++a)n[i] ^= t[a];
        }
        for(let e1 = 0; e1 < 16; ++e1)n[e1] = i[n[e1]];
        r = n[1];
        n[1] = n[5];
        n[5] = n[9];
        n[9] = n[13];
        n[13] = r;
        r = n[2];
        s = n[6];
        n[2] = n[10];
        n[6] = n[14];
        n[10] = r;
        n[14] = s;
        r = n[3];
        s = n[7];
        a = n[11];
        n[3] = n[15];
        n[7] = r;
        n[11] = s;
        n[15] = a;
        for(let e1 = 0, i = this._keySize; e1 < 16; ++e1, ++i)n[e1] ^= t[i];
        return n;
    }
    _decryptBlock2(e1, t) {
        const i = e1.length;
        let a = this.buffer, s = this.bufferPosition;
        const r = [];
        let n = this.iv;
        for(let t = 0; t < i; ++t){
            a[s] = e1[t];
            ++s;
            if (s < 16) continue;
            const i = this._decrypt(a, this._key);
            for(let e1 = 0; e1 < 16; ++e1)i[e1] ^= n[e1];
            n = a;
            r.push(i);
            a = new Uint8Array(16);
            s = 0;
        }
        this.buffer = a;
        this.bufferLength = s;
        this.iv = n;
        if (0 === r.length) return new Uint8Array(0);
        let g = 16 * r.length;
        if (t) {
            const e1 = r.at(-1);
            let t = e1[15];
            if (t <= 16) {
                for(let i = 15, a = 16 - t; i >= a; --i)if (e1[i] !== t) {
                    t = 0;
                    break;
                }
                g -= t;
                r[r.length - 1] = e1.subarray(0, 16 - t);
            }
        }
        const o = new Uint8Array(g);
        for(let e1 = 0, t = 0, i = r.length; e1 < i; ++e1, t += 16)o.set(r[e1], t);
        return o;
    }
    decryptBlock(e1, t, i = null) {
        const a = e1.length, s = this.buffer;
        let r = this.bufferPosition;
        if (i) this.iv = i;
        else {
            for(let t = 0; r < 16 && t < a; ++t, ++r)s[r] = e1[t];
            if (r < 16) {
                this.bufferLength = r;
                return new Uint8Array(0);
            }
            this.iv = s;
            e1 = e1.subarray(16);
        }
        this.buffer = new Uint8Array(16);
        this.bufferLength = 0;
        this.decryptBlock = this._decryptBlock2;
        return this.decryptBlock(e1, t);
    }
    encrypt(e1, t) {
        const i = e1.length;
        let a = this.buffer, s = this.bufferPosition;
        const r = [];
        t || (t = new Uint8Array(16));
        for(let n = 0; n < i; ++n){
            a[s] = e1[n];
            ++s;
            if (s < 16) continue;
            for(let e1 = 0; e1 < 16; ++e1)a[e1] ^= t[e1];
            const i = this._encrypt(a, this._key);
            t = i;
            r.push(i);
            a = new Uint8Array(16);
            s = 0;
        }
        this.buffer = a;
        this.bufferLength = s;
        this.iv = t;
        if (0 === r.length) return new Uint8Array(0);
        const n = 16 * r.length, g = new Uint8Array(n);
        for(let e1 = 0, t = 0, i = r.length; e1 < i; ++e1, t += 16)g.set(r[e1], t);
        return g;
    }
}
class AES128Cipher extends AESBaseCipher {
    constructor(e1){
        super();
        this._cyclesOfRepetition = 10;
        this._keySize = 160;
        this._rcon = new Uint8Array([
            141,
            1,
            2,
            4,
            8,
            16,
            32,
            64,
            128,
            27,
            54,
            108,
            216,
            171,
            77,
            154,
            47,
            94,
            188,
            99,
            198,
            151,
            53,
            106,
            212,
            179,
            125,
            250,
            239,
            197,
            145,
            57,
            114,
            228,
            211,
            189,
            97,
            194,
            159,
            37,
            74,
            148,
            51,
            102,
            204,
            131,
            29,
            58,
            116,
            232,
            203,
            141,
            1,
            2,
            4,
            8,
            16,
            32,
            64,
            128,
            27,
            54,
            108,
            216,
            171,
            77,
            154,
            47,
            94,
            188,
            99,
            198,
            151,
            53,
            106,
            212,
            179,
            125,
            250,
            239,
            197,
            145,
            57,
            114,
            228,
            211,
            189,
            97,
            194,
            159,
            37,
            74,
            148,
            51,
            102,
            204,
            131,
            29,
            58,
            116,
            232,
            203,
            141,
            1,
            2,
            4,
            8,
            16,
            32,
            64,
            128,
            27,
            54,
            108,
            216,
            171,
            77,
            154,
            47,
            94,
            188,
            99,
            198,
            151,
            53,
            106,
            212,
            179,
            125,
            250,
            239,
            197,
            145,
            57,
            114,
            228,
            211,
            189,
            97,
            194,
            159,
            37,
            74,
            148,
            51,
            102,
            204,
            131,
            29,
            58,
            116,
            232,
            203,
            141,
            1,
            2,
            4,
            8,
            16,
            32,
            64,
            128,
            27,
            54,
            108,
            216,
            171,
            77,
            154,
            47,
            94,
            188,
            99,
            198,
            151,
            53,
            106,
            212,
            179,
            125,
            250,
            239,
            197,
            145,
            57,
            114,
            228,
            211,
            189,
            97,
            194,
            159,
            37,
            74,
            148,
            51,
            102,
            204,
            131,
            29,
            58,
            116,
            232,
            203,
            141,
            1,
            2,
            4,
            8,
            16,
            32,
            64,
            128,
            27,
            54,
            108,
            216,
            171,
            77,
            154,
            47,
            94,
            188,
            99,
            198,
            151,
            53,
            106,
            212,
            179,
            125,
            250,
            239,
            197,
            145,
            57,
            114,
            228,
            211,
            189,
            97,
            194,
            159,
            37,
            74,
            148,
            51,
            102,
            204,
            131,
            29,
            58,
            116,
            232,
            203,
            141
        ]);
        this._key = this._expandKey(e1);
    }
    _expandKey(e1) {
        const t = this._s, i = this._rcon, a = new Uint8Array(176);
        a.set(e1);
        for(let e1 = 16, s = 1; e1 < 176; ++s){
            let r = a[e1 - 3], n = a[e1 - 2], g = a[e1 - 1], o = a[e1 - 4];
            r = t[r];
            n = t[n];
            g = t[g];
            o = t[o];
            r ^= i[s];
            for(let t = 0; t < 4; ++t){
                a[e1] = r ^= a[e1 - 16];
                e1++;
                a[e1] = n ^= a[e1 - 16];
                e1++;
                a[e1] = g ^= a[e1 - 16];
                e1++;
                a[e1] = o ^= a[e1 - 16];
                e1++;
            }
        }
        return a;
    }
}
class AES256Cipher extends AESBaseCipher {
    constructor(e1){
        super();
        this._cyclesOfRepetition = 14;
        this._keySize = 224;
        this._key = this._expandKey(e1);
    }
    _expandKey(e1) {
        const t = this._s, i = new Uint8Array(240);
        i.set(e1);
        let a, s, r, n, g = 1;
        for(let e1 = 32, o = 1; e1 < 240; ++o){
            if (e1 % 32 == 16) {
                a = t[a];
                s = t[s];
                r = t[r];
                n = t[n];
            } else if (e1 % 32 == 0) {
                a = i[e1 - 3];
                s = i[e1 - 2];
                r = i[e1 - 1];
                n = i[e1 - 4];
                a = t[a];
                s = t[s];
                r = t[r];
                n = t[n];
                a ^= g;
                (g <<= 1) >= 256 && (g = 255 & (27 ^ g));
            }
            for(let t = 0; t < 4; ++t){
                i[e1] = a ^= i[e1 - 32];
                e1++;
                i[e1] = s ^= i[e1 - 32];
                e1++;
                i[e1] = r ^= i[e1 - 32];
                e1++;
                i[e1] = n ^= i[e1 - 32];
                e1++;
            }
        }
        return i;
    }
}
class PDF17 {
    checkOwnerPassword(e1, t, i, a) {
        const s = new Uint8Array(e1.length + 56);
        s.set(e1, 0);
        s.set(t, e1.length);
        s.set(i, e1.length + t.length);
        return isArrayEqual(Ag(s, 0, s.length), a);
    }
    checkUserPassword(e1, t, i) {
        const a = new Uint8Array(e1.length + 8);
        a.set(e1, 0);
        a.set(t, e1.length);
        return isArrayEqual(Ag(a, 0, a.length), i);
    }
    getOwnerKey(e1, t, i, a) {
        const s = new Uint8Array(e1.length + 56);
        s.set(e1, 0);
        s.set(t, e1.length);
        s.set(i, e1.length + t.length);
        const r = Ag(s, 0, s.length);
        return new AES256Cipher(r).decryptBlock(a, !1, new Uint8Array(16));
    }
    getUserKey(e1, t, i) {
        const a = new Uint8Array(e1.length + 8);
        a.set(e1, 0);
        a.set(t, e1.length);
        const s = Ag(a, 0, a.length);
        return new AES256Cipher(s).decryptBlock(i, !1, new Uint8Array(16));
    }
}
class PDF20 {
    _hash(e1, t, i) {
        let a = Ag(t, 0, t.length).subarray(0, 32), s = [
            0
        ], r = 0;
        for(; r < 64 || s.at(-1) > r - 32;){
            const t = e1.length + a.length + i.length, c = new Uint8Array(t);
            let C = 0;
            c.set(e1, C);
            C += e1.length;
            c.set(a, C);
            C += a.length;
            c.set(i, C);
            const h = new Uint8Array(64 * t);
            for(let e1 = 0, i = 0; e1 < 64; e1++, i += t)h.set(c, i);
            s = new AES128Cipher(a.subarray(0, 16)).encrypt(h, a.subarray(16, 32));
            const l = s.slice(0, 16).reduce((e1, t)=>e1 + t, 0) % 3;
            0 === l ? a = Ag(s, 0, s.length) : 1 === l ? a = (n = s, g = 0, o = s.length, eg(n, g, o, !0)) : 2 === l && (a = eg(s, 0, s.length));
            r++;
        }
        var n, g, o;
        return a.subarray(0, 32);
    }
    checkOwnerPassword(e1, t, i, a) {
        const s = new Uint8Array(e1.length + 56);
        s.set(e1, 0);
        s.set(t, e1.length);
        s.set(i, e1.length + t.length);
        return isArrayEqual(this._hash(e1, s, i), a);
    }
    checkUserPassword(e1, t, i) {
        const a = new Uint8Array(e1.length + 8);
        a.set(e1, 0);
        a.set(t, e1.length);
        return isArrayEqual(this._hash(e1, a, []), i);
    }
    getOwnerKey(e1, t, i, a) {
        const s = new Uint8Array(e1.length + 56);
        s.set(e1, 0);
        s.set(t, e1.length);
        s.set(i, e1.length + t.length);
        const r = this._hash(e1, s, i);
        return new AES256Cipher(r).decryptBlock(a, !1, new Uint8Array(16));
    }
    getUserKey(e1, t, i) {
        const a = new Uint8Array(e1.length + 8);
        a.set(e1, 0);
        a.set(t, e1.length);
        const s = this._hash(e1, a, []);
        return new AES256Cipher(s).decryptBlock(i, !1, new Uint8Array(16));
    }
}
class CipherTransform {
    constructor(e1, t){
        this.StringCipherConstructor = e1;
        this.StreamCipherConstructor = t;
    }
    createStream(e1, t) {
        const i = new this.StreamCipherConstructor;
        return new DecryptStream(e1, t, function cipherTransformDecryptStream(e1, t) {
            return i.decryptBlock(e1, t);
        });
    }
    decryptString(e1) {
        const t = new this.StringCipherConstructor;
        let i = stringToBytes(e1);
        i = t.decryptBlock(i, !0);
        return bytesToString(i);
    }
    encryptString(e1) {
        const t = new this.StringCipherConstructor;
        if (t instanceof AESBaseCipher) {
            const i = 16 - e1.length % 16;
            e1 += String.fromCharCode(i).repeat(i);
            const a = new Uint8Array(16);
            if ("undefined" != typeof crypto) crypto.getRandomValues(a);
            else for(let e1 = 0; e1 < 16; e1++)a[e1] = Math.floor(256 * Math.random());
            let s = stringToBytes(e1);
            s = t.encrypt(s, a);
            const r = new Uint8Array(16 + s.length);
            r.set(a);
            r.set(s, 16);
            return bytesToString(r);
        }
        let i = stringToBytes(e1);
        i = t.encrypt(i);
        return bytesToString(i);
    }
}
class CipherTransformFactory {
    static #q = new Uint8Array([
        40,
        191,
        78,
        94,
        78,
        117,
        138,
        65,
        100,
        0,
        78,
        86,
        255,
        250,
        1,
        8,
        46,
        46,
        0,
        182,
        208,
        104,
        62,
        128,
        47,
        12,
        169,
        254,
        100,
        83,
        105,
        122
    ]);
    #O(e1, t, i, a, s, r, n, g, o, c, C, h) {
        if (t) {
            const e1 = Math.min(127, t.length);
            t = t.subarray(0, e1);
        } else t = [];
        const l = 6 === e1 ? new PDF20 : new PDF17;
        return l.checkUserPassword(t, g, n) ? l.getUserKey(t, o, C) : t.length && l.checkOwnerPassword(t, a, r, i) ? l.getOwnerKey(t, s, r, c) : null;
    }
    #P(e1, t, i, a, s, r, n, g) {
        const o = 40 + i.length + e1.length, c = new Uint8Array(o);
        let C, h, l = 0;
        if (t) {
            h = Math.min(32, t.length);
            for(; l < h; ++l)c[l] = t[l];
        }
        C = 0;
        for(; l < 32;)c[l++] = CipherTransformFactory.#q[C++];
        for(C = 0, h = i.length; C < h; ++C)c[l++] = i[C];
        c[l++] = 255 & s;
        c[l++] = s >> 8 & 255;
        c[l++] = s >> 16 & 255;
        c[l++] = s >>> 24 & 255;
        for(C = 0, h = e1.length; C < h; ++C)c[l++] = e1[C];
        if (r >= 4 && !g) {
            c[l++] = 255;
            c[l++] = 255;
            c[l++] = 255;
            c[l++] = 255;
        }
        let Q = $n(c, 0, l);
        const E = n >> 3;
        if (r >= 3) for(C = 0; C < 50; ++C)Q = $n(Q, 0, E);
        const u = Q.subarray(0, E);
        let d, f;
        if (r >= 3) {
            for(l = 0; l < 32; ++l)c[l] = CipherTransformFactory.#q[l];
            for(C = 0, h = e1.length; C < h; ++C)c[l++] = e1[C];
            d = new ARCFourCipher(u);
            f = d.encryptBlock($n(c, 0, l));
            h = u.length;
            const t = new Uint8Array(h);
            for(C = 1; C <= 19; ++C){
                for(let e1 = 0; e1 < h; ++e1)t[e1] = u[e1] ^ C;
                d = new ARCFourCipher(t);
                f = d.encryptBlock(f);
            }
            for(C = 0, h = f.length; C < h; ++C)if (a[C] !== f[C]) return null;
        } else {
            d = new ARCFourCipher(u);
            f = d.encryptBlock(CipherTransformFactory.#q);
            for(C = 0, h = f.length; C < h; ++C)if (a[C] !== f[C]) return null;
        }
        return u;
    }
    #W(e1, t, i, a) {
        const s = new Uint8Array(32);
        let r = 0;
        const n = Math.min(32, e1.length);
        for(; r < n; ++r)s[r] = e1[r];
        let g = 0;
        for(; r < 32;)s[r++] = CipherTransformFactory.#q[g++];
        let o = $n(s, 0, r);
        const c = a >> 3;
        if (i >= 3) for(g = 0; g < 50; ++g)o = $n(o, 0, o.length);
        let C, h;
        if (i >= 3) {
            h = t;
            const e1 = new Uint8Array(c);
            for(g = 19; g >= 0; g--){
                for(let t = 0; t < c; ++t)e1[t] = o[t] ^ g;
                C = new ARCFourCipher(e1);
                h = C.encryptBlock(h);
            }
        } else {
            C = new ARCFourCipher(o.subarray(0, c));
            h = C.encryptBlock(t);
        }
        return h;
    }
    #j(e1, t, i, a = !1) {
        const s = new Uint8Array(i.length + 9), r = i.length;
        let n;
        for(n = 0; n < r; ++n)s[n] = i[n];
        s[n++] = 255 & e1;
        s[n++] = e1 >> 8 & 255;
        s[n++] = e1 >> 16 & 255;
        s[n++] = 255 & t;
        s[n++] = t >> 8 & 255;
        if (a) {
            s[n++] = 115;
            s[n++] = 65;
            s[n++] = 108;
            s[n++] = 84;
        }
        return $n(s, 0, n).subarray(0, Math.min(i.length + 5, 16));
    }
    #X(e1, t, i, a, s) {
        if (!(t instanceof Name)) throw new FormatError("Invalid crypt filter name.");
        const r = this, n = e1.get(t.name), g = n?.get("CFM");
        if (!g || "None" === g.name) return function() {
            return new NullCipher;
        };
        if ("V2" === g.name) return function() {
            return new ARCFourCipher(r.#j(i, a, s, !1));
        };
        if ("AESV2" === g.name) return function() {
            return new AES128Cipher(r.#j(i, a, s, !0));
        };
        if ("AESV3" === g.name) return function() {
            return new AES256Cipher(s);
        };
        throw new FormatError("Unknown crypto method");
    }
    constructor(e1, t, i){
        const a = e1.get("Filter");
        if (!isName(a, "Standard")) throw new FormatError("unknown encryption method");
        this.filterName = a.name;
        this.dict = e1;
        const s = e1.get("V");
        if (!Number.isInteger(s) || 1 !== s && 2 !== s && 4 !== s && 5 !== s) throw new FormatError("unsupported encryption algorithm");
        this.algorithm = s;
        let r = e1.get("Length");
        if (!r) if (s <= 3) r = 40;
        else {
            const t = e1.get("CF"), i = e1.get("StmF");
            if (t instanceof Dict && i instanceof Name) {
                t.suppressEncryption = !0;
                const e1 = t.get(i.name);
                r = e1?.get("Length") || 128;
                r < 40 && (r <<= 3);
            }
        }
        if (!Number.isInteger(r) || r < 40 || r % 8 != 0) throw new FormatError("invalid key length");
        const n = stringToBytes(e1.get("O")), g = stringToBytes(e1.get("U")), o = n.subarray(0, 32), c = g.subarray(0, 32), C = e1.get("P"), h = e1.get("R"), l = (4 === s || 5 === s) && !1 !== e1.get("EncryptMetadata");
        this.encryptMetadata = l;
        const Q = stringToBytes(t);
        let E, u;
        if (i) {
            if (6 === h) try {
                i = utf8StringToString(i);
            } catch  {
                warn("CipherTransformFactory: Unable to convert UTF8 encoded password.");
            }
            E = stringToBytes(i);
        }
        if (5 !== s) u = this.#P(Q, E, o, c, C, h, r, l);
        else {
            const t = n.subarray(32, 40), i = n.subarray(40, 48), a = g.subarray(0, 48), s = g.subarray(32, 40), r = g.subarray(40, 48), C = stringToBytes(e1.get("OE")), l = stringToBytes(e1.get("UE")), Q = stringToBytes(e1.get("Perms"));
            u = this.#O(h, E, o, t, i, a, c, s, r, C, l, Q);
        }
        if (!u && !i) throw new PasswordException("No password given", rt);
        if (!u && i) {
            const e1 = this.#W(E, o, h, r);
            u = this.#P(Q, e1, o, c, C, h, r, l);
        }
        if (!u) throw new PasswordException("Incorrect Password", nt);
        this.encryptionKey = u;
        if (s >= 4) {
            const t = e1.get("CF");
            t instanceof Dict && (t.suppressEncryption = !0);
            this.cf = t;
            this.stmf = e1.get("StmF") || Name.get("Identity");
            this.strf = e1.get("StrF") || Name.get("Identity");
            this.eff = e1.get("EFF") || this.stmf;
        }
    }
    createCipherTransform(e1, t) {
        if (4 === this.algorithm || 5 === this.algorithm) return new CipherTransform(this.#X(this.cf, this.strf, e1, t, this.encryptionKey), this.#X(this.cf, this.stmf, e1, t, this.encryptionKey));
        const i = this.#j(e1, t, this.encryptionKey, !1), cipherConstructor = function() {
            return new ARCFourCipher(i);
        };
        return new CipherTransform(cipherConstructor, cipherConstructor);
    }
}
function decodeString(e1) {
    try {
        return stringToUTF8String(e1);
    } catch (t) {
        warn(`UTF-8 decoding failed: "${t}".`);
        return e1;
    }
}
class DatasetXMLParser extends SimpleXMLParser {
    constructor(e1){
        super(e1);
        this.node = null;
    }
    onEndElement(e1) {
        const t = super.onEndElement(e1);
        if (t && "xfa:datasets" === e1) {
            this.node = t;
            throw new Error("Aborting DatasetXMLParser.");
        }
    }
}
class DatasetReader {
    constructor(e1){
        if (e1.datasets) this.node = new SimpleXMLParser({
            hasAttributes: !0
        }).parseFromString(e1.datasets).documentElement;
        else {
            const t = new DatasetXMLParser({
                hasAttributes: !0
            });
            try {
                t.parseFromString(e1["xdp:xdp"]);
            } catch  {}
            this.node = t.node;
        }
    }
    getValue(e1) {
        if (!this.node || !e1) return "";
        const t = this.node.searchNode(parseXFAPath(e1), 0);
        if (!t) return "";
        const i = t.firstChild;
        return "value" === i?.nodeName ? t.children.map((e1)=>decodeString(e1.textContent)) : decodeString(t.textContent);
    }
}
class XRef {
    #Z = null;
    constructor(e1, t){
        this.stream = e1;
        this.pdfManager = t;
        this.entries = [];
        this._xrefStms = new Set;
        this._cacheMap = new Map;
        this._pendingRefs = new RefSet;
        this._newPersistentRefNum = null;
        this._newTemporaryRefNum = null;
        this._persistentRefsCache = null;
    }
    getNewPersistentRef(e1) {
        null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
        const t = this._newPersistentRefNum++;
        this._cacheMap.set(t, e1);
        return Ref.get(t, 0);
    }
    getNewTemporaryRef() {
        if (null === this._newTemporaryRefNum) {
            this._newTemporaryRefNum = this.entries.length || 1;
            if (this._newPersistentRefNum) {
                this._persistentRefsCache = new Map;
                for(let e1 = this._newTemporaryRefNum; e1 < this._newPersistentRefNum; e1++){
                    this._persistentRefsCache.set(e1, this._cacheMap.get(e1));
                    this._cacheMap.delete(e1);
                }
            }
        }
        return Ref.get(this._newTemporaryRefNum++, 0);
    }
    resetNewTemporaryRef() {
        this._newTemporaryRefNum = null;
        if (this._persistentRefsCache) for (const [e1, t] of this._persistentRefsCache)this._cacheMap.set(e1, t);
        this._persistentRefsCache = null;
    }
    setStartXRef(e1) {
        this.startXRefQueue = [
            e1
        ];
    }
    parse(e1 = !1) {
        let t, i, a;
        if (e1) {
            warn("Indexing all PDF objects");
            t = this.indexObjects();
        } else t = this.readXRef();
        t.assignXref(this);
        this.trailer = t;
        try {
            i = t.get("Encrypt");
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`XRef.parse - Invalid "Encrypt" reference: "${e1}".`);
        }
        if (i instanceof Dict) {
            const e1 = t.get("ID"), a = e1?.length ? e1[0] : "";
            i.suppressEncryption = !0;
            this.encrypt = new CipherTransformFactory(i, a, this.pdfManager.password);
        }
        try {
            a = t.get("Root");
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`XRef.parse - Invalid "Root" reference: "${e1}".`);
        }
        if (a instanceof Dict) try {
            if (a.get("Pages") instanceof Dict) {
                this.root = a;
                return;
            }
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`XRef.parse - Invalid "Pages" reference: "${e1}".`);
        }
        if (!e1) throw new XRefParseException;
        throw new InvalidPDFException("Invalid Root reference.");
    }
    processXRefTable(e1) {
        "tableState" in this || (this.tableState = {
            entryNum: 0,
            streamPos: e1.lexer.stream.pos,
            parserBuf1: e1.buf1,
            parserBuf2: e1.buf2
        });
        if (!isCmd(this.readXRefTable(e1), "trailer")) throw new FormatError("Invalid XRef table: could not find trailer dictionary");
        let t = e1.getObj();
        t instanceof Dict || !t.dict || (t = t.dict);
        if (!(t instanceof Dict)) throw new FormatError("Invalid XRef table: could not parse trailer dictionary");
        delete this.tableState;
        return t;
    }
    readXRefTable(e1) {
        const t = e1.lexer.stream, i = this.tableState;
        t.pos = i.streamPos;
        e1.buf1 = i.parserBuf1;
        e1.buf2 = i.parserBuf2;
        let a;
        for(;;){
            if (!("firstEntryNum" in i) || !("entryCount" in i)) {
                if (isCmd(a = e1.getObj(), "trailer")) break;
                i.firstEntryNum = a;
                i.entryCount = e1.getObj();
            }
            let s = i.firstEntryNum;
            const r = i.entryCount;
            if (!Number.isInteger(s) || !Number.isInteger(r)) throw new FormatError("Invalid XRef table: wrong types in subsection header");
            for(let a = i.entryNum; a < r; a++){
                i.streamPos = t.pos;
                i.entryNum = a;
                i.parserBuf1 = e1.buf1;
                i.parserBuf2 = e1.buf2;
                const n = {};
                n.offset = e1.getObj();
                n.gen = e1.getObj();
                const g = e1.getObj();
                if (g instanceof Cmd) switch(g.cmd){
                    case "f":
                        n.free = !0;
                        break;
                    case "n":
                        n.uncompressed = !0;
                }
                if (!Number.isInteger(n.offset) || !Number.isInteger(n.gen) || !n.free && !n.uncompressed) throw new FormatError(`Invalid entry in XRef subsection: ${s}, ${r}`);
                0 === a && n.free && 1 === s && (s = 0);
                this.entries[a + s] || (this.entries[a + s] = n);
            }
            i.entryNum = 0;
            i.streamPos = t.pos;
            i.parserBuf1 = e1.buf1;
            i.parserBuf2 = e1.buf2;
            delete i.firstEntryNum;
            delete i.entryCount;
        }
        if (this.entries[0] && !this.entries[0].free) throw new FormatError("Invalid XRef table: unexpected first object");
        return a;
    }
    processXRefStream(e1) {
        if (!("streamState" in this)) {
            const { dict: t, pos: i } = e1, a = t.get("W"), s = t.get("Index") || [
                0,
                t.get("Size")
            ];
            this.streamState = {
                entryRanges: s,
                byteWidths: a,
                entryNum: 0,
                streamPos: i
            };
        }
        this.readXRefStream(e1);
        delete this.streamState;
        return e1.dict;
    }
    readXRefStream(e1) {
        const t = this.streamState;
        e1.pos = t.streamPos;
        const [i, a, s] = t.byteWidths, r = t.entryRanges;
        for(; r.length > 0;){
            const [n, g] = r;
            if (!Number.isInteger(n) || !Number.isInteger(g)) throw new FormatError(`Invalid XRef range fields: ${n}, ${g}`);
            if (!Number.isInteger(i) || !Number.isInteger(a) || !Number.isInteger(s)) throw new FormatError(`Invalid XRef entry fields length: ${n}, ${g}`);
            for(let r = t.entryNum; r < g; ++r){
                t.entryNum = r;
                t.streamPos = e1.pos;
                let g = 0, o = 0, c = 0;
                for(let t = 0; t < i; ++t){
                    const t = e1.getByte();
                    if (-1 === t) throw new FormatError("Invalid XRef byteWidths 'type'.");
                    g = g << 8 | t;
                }
                0 === i && (g = 1);
                for(let t = 0; t < a; ++t){
                    const t = e1.getByte();
                    if (-1 === t) throw new FormatError("Invalid XRef byteWidths 'offset'.");
                    o = o << 8 | t;
                }
                for(let t = 0; t < s; ++t){
                    const t = e1.getByte();
                    if (-1 === t) throw new FormatError("Invalid XRef byteWidths 'generation'.");
                    c = c << 8 | t;
                }
                const C = {};
                C.offset = o;
                C.gen = c;
                switch(g){
                    case 0:
                        C.free = !0;
                        break;
                    case 1:
                        C.uncompressed = !0;
                        break;
                    case 2:
                        break;
                    default:
                        throw new FormatError(`Invalid XRef entry type: ${g}`);
                }
                this.entries[n + r] || (this.entries[n + r] = C);
            }
            t.entryNum = 0;
            t.streamPos = e1.pos;
            r.splice(0, 2);
        }
    }
    indexObjects() {
        function readToken(e1, t) {
            let i = "", a = e1[t];
            for(; 10 !== a && 13 !== a && 60 !== a && !(++t >= e1.length);){
                i += String.fromCharCode(a);
                a = e1[t];
            }
            return i;
        }
        function skipUntil(e1, t, i) {
            const a = i.length, s = e1.length;
            let r = 0;
            for(; t < s;){
                let s = 0;
                for(; s < a && e1[t + s] === i[s];)++s;
                if (s >= a) break;
                t++;
                r++;
            }
            return r;
        }
        const e1 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t = /\b(startxref|\d+\s+\d+\s+obj)\b/g, i = /^(\d+)\s+(\d+)\s+obj\b/, a = new Uint8Array([
            116,
            114,
            97,
            105,
            108,
            101,
            114
        ]), s = new Uint8Array([
            115,
            116,
            97,
            114,
            116,
            120,
            114,
            101,
            102
        ]), r = new Uint8Array([
            47,
            88,
            82,
            101,
            102
        ]);
        this.entries.length = 0;
        this._cacheMap.clear();
        const n = this.stream;
        n.pos = 0;
        const g = n.getBytes(), o = bytesToString(g), c = g.length;
        let C = n.start;
        const h = [], l = [];
        for(; C < c;){
            let Q = g[C];
            if (9 === Q || 10 === Q || 13 === Q || 32 === Q) {
                ++C;
                continue;
            }
            if (37 === Q) {
                do {
                    ++C;
                    if (C >= c) break;
                    Q = g[C];
                }while (10 !== Q && 13 !== Q)
                continue;
            }
            const E = readToken(g, C);
            let u;
            if (E.startsWith("xref") && (4 === E.length || /\s/.test(E[4]))) {
                C += skipUntil(g, C, a);
                h.push(C);
                C += skipUntil(g, C, s);
            } else if (u = i.exec(E)) {
                const t = 0 | u[1], i = 0 | u[2], a = C + E.length;
                let s, h = !1;
                if (this.entries[t]) {
                    if (this.entries[t].gen === i) try {
                        new Parser({
                            lexer: new Lexer(n.makeSubStream(a))
                        }).getObj();
                        h = !0;
                    } catch (e1) {
                        e1 instanceof ParserEOFException ? warn(`indexObjects -- checking object (${E}): "${e1}".`) : h = !0;
                    }
                } else h = !0;
                h && (this.entries[t] = {
                    offset: C - n.start,
                    gen: i,
                    uncompressed: !0
                });
                e1.lastIndex = a;
                const Q = e1.exec(o);
                if (Q) {
                    s = e1.lastIndex + 1 - C;
                    if ("endobj" !== Q[1]) {
                        warn(`indexObjects: Found "${Q[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`);
                        s -= Q[1].length + 1;
                    }
                } else s = c - C;
                const d = g.subarray(C, C + s), f = skipUntil(d, 0, r);
                if (f < s && d[f + 5] < 64) {
                    l.push(C - n.start);
                    this._xrefStms.add(C - n.start);
                }
                C += s;
            } else if (E.startsWith("trailer") && (7 === E.length || /\s/.test(E[7]))) {
                h.push(C);
                const e1 = C + E.length;
                let i;
                t.lastIndex = e1;
                const a = t.exec(o);
                if (a) {
                    i = t.lastIndex + 1 - C;
                    if ("startxref" !== a[1]) {
                        warn(`indexObjects: Found "${a[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`);
                        i -= a[1].length + 1;
                    }
                } else i = c - C;
                C += i;
            } else C += E.length + 1;
        }
        for (const e1 of l){
            this.startXRefQueue.push(e1);
            this.readXRef(!0);
        }
        const Q = [];
        let E, u, d = !1;
        for (const e1 of h){
            n.pos = e1;
            const t = new Parser({
                lexer: new Lexer(n),
                xref: this,
                allowStreams: !0,
                recoveryMode: !0
            });
            if (!isCmd(t.getObj(), "trailer")) continue;
            const i = t.getObj();
            if (i instanceof Dict) {
                Q.push(i);
                i.has("Encrypt") && (d = !0);
            }
        }
        for (const e1 of [
            ...Q,
            "genFallback",
            ...Q
        ]){
            if ("genFallback" === e1) {
                if (!u) break;
                this._generationFallback = !0;
                continue;
            }
            let t = !1;
            try {
                const i = e1.get("Root");
                if (!(i instanceof Dict)) continue;
                const a = i.get("Pages");
                if (!(a instanceof Dict)) continue;
                const s = a.get("Count");
                Number.isInteger(s) && (t = !0);
            } catch (e1) {
                u = e1;
                continue;
            }
            if (t && (!d || e1.has("Encrypt")) && e1.has("ID")) return e1;
            E = e1;
        }
        if (E) return E;
        if (this.topDict) return this.topDict;
        if (!Q.length) for (const [e1, t] of this.entries.entries()){
            if (!t) continue;
            const i = Ref.get(e1, t.gen);
            let a;
            try {
                a = this.fetch(i);
            } catch  {
                continue;
            }
            a instanceof BaseStream && (a = a.dict);
            if (a instanceof Dict && a.has("Root")) return a;
        }
        throw new InvalidPDFException("Invalid PDF structure.");
    }
    readXRef(e1 = !1) {
        const t = this.stream, i = new Set;
        for(; this.startXRefQueue.length;){
            try {
                const e1 = this.startXRefQueue[0];
                if (i.has(e1)) {
                    warn("readXRef - skipping XRef table since it was already parsed.");
                    this.startXRefQueue.shift();
                    continue;
                }
                i.add(e1);
                t.pos = e1 + t.start;
                const a = new Parser({
                    lexer: new Lexer(t),
                    xref: this,
                    allowStreams: !0
                });
                let s, r = a.getObj();
                if (isCmd(r, "xref")) {
                    s = this.processXRefTable(a);
                    this.topDict || (this.topDict = s);
                    r = s.get("XRefStm");
                    if (Number.isInteger(r) && !this._xrefStms.has(r)) {
                        this._xrefStms.add(r);
                        this.startXRefQueue.push(r);
                        this.#Z ??= r;
                    }
                } else {
                    if (!Number.isInteger(r)) throw new FormatError("Invalid XRef stream header");
                    if (!(Number.isInteger(a.getObj()) && isCmd(a.getObj(), "obj") && (r = a.getObj()) instanceof BaseStream)) throw new FormatError("Invalid XRef stream");
                    s = this.processXRefStream(r);
                    this.topDict || (this.topDict = s);
                    if (!s) throw new FormatError("Failed to read XRef stream");
                }
                r = s.get("Prev");
                Number.isInteger(r) ? this.startXRefQueue.push(r) : r instanceof Ref && this.startXRefQueue.push(r.num);
            } catch (e1) {
                if (e1 instanceof MissingDataException) throw e1;
                info("(while reading XRef): " + e1);
            }
            this.startXRefQueue.shift();
        }
        if (this.topDict) return this.topDict;
        if (!e1) throw new XRefParseException;
    }
    get lastXRefStreamPos() {
        return this.#Z ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
    }
    getEntry(e1) {
        const t = this.entries[e1];
        return t && !t.free && t.offset ? t : null;
    }
    fetchIfRef(e1, t = !1) {
        return e1 instanceof Ref ? this.fetch(e1, t) : e1;
    }
    fetch(e1, t = !1) {
        if (!(e1 instanceof Ref)) throw new Error("ref object is not a reference");
        const i = e1.num, a = this._cacheMap.get(i);
        if (void 0 !== a) {
            a instanceof Dict && !a.objId && (a.objId = e1.toString());
            return a;
        }
        let s = this.getEntry(i);
        if (null === s) {
            this._cacheMap.set(i, s);
            return s;
        }
        if (this._pendingRefs.has(e1)) {
            this._pendingRefs.remove(e1);
            warn(`Ignoring circular reference: ${e1}.`);
            return lt;
        }
        this._pendingRefs.put(e1);
        try {
            s = s.uncompressed ? this.fetchUncompressed(e1, s, t) : this.fetchCompressed(e1, s, t);
            this._pendingRefs.remove(e1);
        } catch (t) {
            this._pendingRefs.remove(e1);
            throw t;
        }
        s instanceof Dict ? s.objId = e1.toString() : s instanceof BaseStream && (s.dict.objId = e1.toString());
        return s;
    }
    fetchUncompressed(e1, t, i = !1) {
        const a = e1.gen;
        let s = e1.num;
        if (t.gen !== a) {
            const r = `Inconsistent generation in XRef: ${e1}`;
            if (this._generationFallback && t.gen < a) {
                warn(r);
                return this.fetchUncompressed(Ref.get(s, t.gen), t, i);
            }
            throw new XRefEntryException(r);
        }
        const r = this.stream.makeSubStream(t.offset + this.stream.start), n = new Parser({
            lexer: new Lexer(r),
            xref: this,
            allowStreams: !0
        }), g = n.getObj(), o = n.getObj(), c = n.getObj();
        if (g !== s || o !== a || !(c instanceof Cmd)) throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e1}`);
        if ("obj" !== c.cmd) {
            if (c.cmd.startsWith("obj")) {
                s = parseInt(c.cmd.substring(3), 10);
                if (!Number.isNaN(s)) return s;
            }
            throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e1}`);
        }
        (t = this.encrypt && !i ? n.getObj(this.encrypt.createCipherTransform(s, a)) : n.getObj()) instanceof BaseStream || this._cacheMap.set(s, t);
        return t;
    }
    fetchCompressed(e1, t, i = !1) {
        const a = t.offset, s = this.fetch(Ref.get(a, 0));
        if (!(s instanceof BaseStream)) throw new FormatError("bad ObjStm stream");
        const r = s.dict.get("First"), n = s.dict.get("N");
        if (!Number.isInteger(r) || !Number.isInteger(n)) throw new FormatError("invalid first and n parameters for ObjStm stream");
        let g = new Parser({
            lexer: new Lexer(s),
            xref: this,
            allowStreams: !0
        });
        const o = new Array(n), c = new Array(n);
        for(let e1 = 0; e1 < n; ++e1){
            const t = g.getObj();
            if (!Number.isInteger(t)) throw new FormatError(`invalid object number in the ObjStm stream: ${t}`);
            const i = g.getObj();
            if (!Number.isInteger(i)) throw new FormatError(`invalid object offset in the ObjStm stream: ${i}`);
            o[e1] = t;
            c[e1] = i;
        }
        const C = (s.start || 0) + r, h = new Array(n);
        for(let e1 = 0; e1 < n; ++e1){
            const t = e1 < n - 1 ? c[e1 + 1] - c[e1] : void 0;
            if (t < 0) throw new FormatError("Invalid offset in the ObjStm stream.");
            g = new Parser({
                lexer: new Lexer(s.makeSubStream(C + c[e1], t, s.dict)),
                xref: this,
                allowStreams: !0
            });
            const i = g.getObj();
            h[e1] = i;
            if (i instanceof BaseStream) continue;
            const r = o[e1], l = this.entries[r];
            l && l.offset === a && l.gen === e1 && this._cacheMap.set(r, i);
        }
        if (void 0 === (t = h[t.gen])) throw new XRefEntryException(`Bad (compressed) XRef entry: ${e1}`);
        return t;
    }
    async fetchIfRefAsync(e1, t) {
        return e1 instanceof Ref ? this.fetchAsync(e1, t) : e1;
    }
    async fetchAsync(e1, t) {
        try {
            return this.fetch(e1, t);
        } catch (i) {
            if (!(i instanceof MissingDataException)) throw i;
            await this.pdfManager.requestRange(i.begin, i.end);
            return this.fetchAsync(e1, t);
        }
    }
    getCatalogObj() {
        return this.root;
    }
}
const tg = [
    0,
    0,
    612,
    792
];
class Page {
    constructor({ pdfManager: e1, xref: t, pageIndex: i, pageDict: a, ref: s, globalIdFactory: r, fontCache: n, builtInCMapCache: g, standardFontDataCache: o, globalImageCache: c, systemFontCache: C, nonBlendModesSet: h, xfaFactory: l }){
        this.pdfManager = e1;
        this.pageIndex = i;
        this.pageDict = a;
        this.xref = t;
        this.ref = s;
        this.fontCache = n;
        this.builtInCMapCache = g;
        this.standardFontDataCache = o;
        this.globalImageCache = c;
        this.systemFontCache = C;
        this.nonBlendModesSet = h;
        this.evaluatorOptions = e1.evaluatorOptions;
        this.resourcesPromise = null;
        this.xfaFactory = l;
        const Q = {
            obj: 0
        };
        this._localIdFactory = class extends r {
            static createObjId() {
                return `p${i}_${++Q.obj}`;
            }
            static getPageObjId() {
                return `p${s.toString()}`;
            }
        };
    }
    _getInheritableProperty(e1, t = !1) {
        const i = getInheritableProperty({
            dict: this.pageDict,
            key: e1,
            getArray: t,
            stopWhenFound: !1
        });
        return Array.isArray(i) ? 1 !== i.length && i[0] instanceof Dict ? Dict.merge({
            xref: this.xref,
            dictArray: i
        }) : i[0] : i;
    }
    get content() {
        return this.pageDict.getArray("Contents");
    }
    get resources() {
        const e1 = this._getInheritableProperty("Resources");
        return shadow(this, "resources", e1 instanceof Dict ? e1 : Dict.empty);
    }
    _getBoundingBox(e1) {
        if (this.xfaData) return this.xfaData.bbox;
        const t = lookupNormalRect(this._getInheritableProperty(e1, !0), null);
        if (t) {
            if (t[2] - t[0] > 0 && t[3] - t[1] > 0) return t;
            warn(`Empty, or invalid, /${e1} entry.`);
        }
        return null;
    }
    get mediaBox() {
        return shadow(this, "mediaBox", this._getBoundingBox("MediaBox") || tg);
    }
    get cropBox() {
        return shadow(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
    }
    get userUnit() {
        const e1 = this.pageDict.get("UserUnit");
        return shadow(this, "userUnit", "number" == typeof e1 && e1 > 0 ? e1 : 1);
    }
    get view() {
        const { cropBox: e1, mediaBox: t } = this;
        if (e1 !== t && !isArrayEqual(e1, t)) {
            const i = Util.intersect(e1, t);
            if (i && i[2] - i[0] > 0 && i[3] - i[1] > 0) return shadow(this, "view", i);
            warn("Empty /CropBox and /MediaBox intersection.");
        }
        return shadow(this, "view", t);
    }
    get rotate() {
        let e1 = this._getInheritableProperty("Rotate") || 0;
        e1 % 90 != 0 ? e1 = 0 : e1 >= 360 ? e1 %= 360 : e1 < 0 && (e1 = (e1 % 360 + 360) % 360);
        return shadow(this, "rotate", e1);
    }
    _onSubStreamError(e1, t) {
        if (!this.evaluatorOptions.ignoreErrors) throw e1;
        warn(`getContentStream - ignoring sub-stream (${t}): "${e1}".`);
    }
    getContentStream() {
        return this.pdfManager.ensure(this, "content").then((e1)=>e1 instanceof BaseStream ? e1 : Array.isArray(e1) ? new StreamsSequenceStream(e1, this._onSubStreamError.bind(this)) : new NullStream);
    }
    get xfaData() {
        return shadow(this, "xfaData", this.xfaFactory ? {
            bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
        } : null);
    }
    async #V(e1, t, i) {
        const a = [];
        for (const s of e1)if (s.id) {
            const e1 = Ref.fromString(s.id);
            if (!e1) {
                warn(`A non-linked annotation cannot be modified: ${s.id}`);
                continue;
            }
            if (s.deleted) {
                t.put(e1, e1);
                if (s.popupRef) {
                    const e1 = Ref.fromString(s.popupRef);
                    e1 && t.put(e1, e1);
                }
                continue;
            }
            i?.put(e1);
            s.ref = e1;
            a.push(this.xref.fetchAsync(e1).then((e1)=>{
                e1 instanceof Dict && (s.oldAnnotation = e1.clone());
            }, ()=>{
                warn(`Cannot fetch \`oldAnnotation\` for: ${e1}.`);
            }));
            delete s.id;
        }
        await Promise.all(a);
    }
    async saveNewAnnotations(e1, t, i, a, s) {
        if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
        const r = new PartialEvaluator({
            xref: this.xref,
            handler: e1,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalImageCache: this.globalImageCache,
            systemFontCache: this.systemFontCache,
            options: this.evaluatorOptions
        }), n = new RefSetCache, g = new RefSet;
        await this.#V(i, n, g);
        const o = this.pageDict, c = this.annotations.filter((e1)=>!(e1 instanceof Ref && n.has(e1))), C = await AnnotationFactory.saveNewAnnotations(r, t, i, a, s);
        for (const { ref: e1 } of C.annotations)e1 instanceof Ref && !g.has(e1) && c.push(e1);
        const h = o.clone();
        h.set("Annots", c);
        s.put(this.ref, {
            data: h
        });
        for (const e1 of n)s.put(e1, {
            data: null
        });
    }
    save(e1, t, i, a) {
        const s = new PartialEvaluator({
            xref: this.xref,
            handler: e1,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalImageCache: this.globalImageCache,
            systemFontCache: this.systemFontCache,
            options: this.evaluatorOptions
        });
        return this._parsedAnnotations.then(function(e1) {
            const r = [];
            for (const n of e1)r.push(n.save(s, t, i, a).catch(function(e1) {
                warn(`save - ignoring annotation data during "${t.name}" task: "${e1}".`);
                return null;
            }));
            return Promise.all(r);
        });
    }
    loadResources(e1) {
        this.resourcesPromise ||= this.pdfManager.ensure(this, "resources");
        return this.resourcesPromise.then(()=>new ObjectLoader(this.resources, e1, this.xref).load());
    }
    getOperatorList({ handler: e1, sink: t, task: i, intent: a, cacheKey: s, annotationStorage: r = null, modifiedIds: n = null }) {
        const C = this.getContentStream(), E = this.loadResources([
            "ColorSpace",
            "ExtGState",
            "Font",
            "Pattern",
            "Properties",
            "Shading",
            "XObject"
        ]), d = new PartialEvaluator({
            xref: this.xref,
            handler: e1,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalImageCache: this.globalImageCache,
            systemFontCache: this.systemFontCache,
            options: this.evaluatorOptions
        }), f = this.xfaFactory ? null : getNewAnnotationsMap(r), p = f?.get(this.pageIndex);
        let m = Promise.resolve(null), y = null;
        if (p) {
            const e1 = this.pdfManager.ensureDoc("annotationGlobals");
            let t;
            const a = new Set;
            for (const { bitmapId: e1, bitmap: t } of p)!e1 || t || a.has(e1) || a.add(e1);
            const { isOffscreenCanvasSupported: s } = this.evaluatorOptions;
            if (a.size > 0) {
                const e1 = p.slice();
                for (const [t, i] of r)t.startsWith(u) && i.bitmap && a.has(i.bitmapId) && e1.push(i);
                t = AnnotationFactory.generateImages(e1, this.xref, s);
            } else t = AnnotationFactory.generateImages(p, this.xref, s);
            y = new RefSet;
            m = Promise.all([
                e1,
                this.#V(p, y, null)
            ]).then(([e1])=>e1 ? AnnotationFactory.printNewAnnotations(e1, d, i, p, t) : null);
        }
        const w = Promise.all([
            C,
            E
        ]).then(([r])=>{
            const n = new OperatorList(a, t);
            e1.send("StartRenderPage", {
                transparency: d.hasBlendModes(this.resources, this.nonBlendModesSet),
                pageIndex: this.pageIndex,
                cacheKey: s
            });
            return d.getOperatorList({
                stream: r,
                task: i,
                resources: this.resources,
                operatorList: n
            }).then(function() {
                return n;
            });
        });
        return Promise.all([
            w,
            this._parsedAnnotations,
            m
        ]).then(function([e1, t, s]) {
            if (s) {
                t = t.filter((e1)=>!(e1.ref && y.has(e1.ref)));
                for(let e1 = 0, i = s.length; e1 < i; e1++){
                    const a = s[e1];
                    if (a.refToReplace) {
                        const r = t.findIndex((e1)=>e1.ref && isRefsEqual(e1.ref, a.refToReplace));
                        if (r >= 0) {
                            t.splice(r, 1, a);
                            s.splice(e1--, 1);
                            i--;
                        }
                    }
                }
                t = t.concat(s);
            }
            if (0 === t.length || a & l) {
                e1.flush(!0);
                return {
                    length: e1.totalLength
                };
            }
            const C = !!(a & h), E = !!(a & Q), u = !!(a & g), f = !!(a & o), p = !!(a & c), m = [];
            for (const e1 of t)(u || f && e1.mustBeViewed(r, C) && e1.mustBeViewedWhenEditing(E, n) || p && e1.mustBePrinted(r)) && m.push(e1.getOperatorList(d, i, a, r).catch(function(e1) {
                warn(`getOperatorList - ignoring annotation data during "${i.name}" task: "${e1}".`);
                return {
                    opList: null,
                    separateForm: !1,
                    separateCanvas: !1
                };
            }));
            return Promise.all(m).then(function(t) {
                let i = !1, a = !1;
                for (const { opList: s, separateForm: r, separateCanvas: n } of t){
                    e1.addOpList(s);
                    i ||= r;
                    a ||= n;
                }
                e1.flush(!0, {
                    form: i,
                    canvas: a
                });
                return {
                    length: e1.totalLength
                };
            });
        });
    }
    async extractTextContent({ handler: e1, task: t, includeMarkedContent: i, disableNormalization: a, sink: s }) {
        const r = this.getContentStream(), n = this.loadResources([
            "ExtGState",
            "Font",
            "Properties",
            "XObject"
        ]), g = this.pdfManager.ensureCatalog("lang"), [o, , c] = await Promise.all([
            r,
            n,
            g
        ]);
        return new PartialEvaluator({
            xref: this.xref,
            handler: e1,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalImageCache: this.globalImageCache,
            systemFontCache: this.systemFontCache,
            options: this.evaluatorOptions
        }).getTextContent({
            stream: o,
            task: t,
            resources: this.resources,
            includeMarkedContent: i,
            disableNormalization: a,
            sink: s,
            viewBox: this.view,
            lang: c
        });
    }
    async getStructTree() {
        const e1 = await this.pdfManager.ensureCatalog("structTreeRoot");
        if (!e1) return null;
        await this._parsedAnnotations;
        const t = await this.pdfManager.ensure(this, "_parseStructTree", [
            e1
        ]);
        return this.pdfManager.ensure(t, "serializable");
    }
    _parseStructTree(e1) {
        const t = new StructTreePage(e1, this.pageDict);
        t.parse(this.ref);
        return t;
    }
    async getAnnotationsData(e1, t, i) {
        const a = await this._parsedAnnotations;
        if (0 === a.length) return a;
        const s = [], r = [];
        let n;
        const C = !!(i & g), h = !!(i & o), l = !!(i & c);
        for (const i of a){
            const a = C || h && i.viewable;
            (a || l && i.printable) && s.push(i.data);
            if (i.hasTextContent && a) {
                n ||= new PartialEvaluator({
                    xref: this.xref,
                    handler: e1,
                    pageIndex: this.pageIndex,
                    idFactory: this._localIdFactory,
                    fontCache: this.fontCache,
                    builtInCMapCache: this.builtInCMapCache,
                    standardFontDataCache: this.standardFontDataCache,
                    globalImageCache: this.globalImageCache,
                    systemFontCache: this.systemFontCache,
                    options: this.evaluatorOptions
                });
                r.push(i.extractTextContent(n, t, [
                    -1 / 0,
                    -1 / 0,
                    1 / 0,
                    1 / 0
                ]).catch(function(e1) {
                    warn(`getAnnotationsData - ignoring textContent during "${t.name}" task: "${e1}".`);
                }));
            }
        }
        await Promise.all(r);
        return s;
    }
    get annotations() {
        const e1 = this._getInheritableProperty("Annots");
        return shadow(this, "annotations", Array.isArray(e1) ? e1 : []);
    }
    get _parsedAnnotations() {
        return shadow(this, "_parsedAnnotations", this.pdfManager.ensure(this, "annotations").then(async (e1)=>{
            if (0 === e1.length) return e1;
            const [t, i] = await Promise.all([
                this.pdfManager.ensureDoc("annotationGlobals"),
                this.pdfManager.ensureDoc("fieldObjects")
            ]);
            if (!t) return [];
            const a = i?.orphanFields, s = [];
            for (const i of e1)s.push(AnnotationFactory.create(this.xref, i, t, this._localIdFactory, !1, a, this.ref).catch(function(e1) {
                warn(`_parsedAnnotations: "${e1}".`);
                return null;
            }));
            const r = [];
            let n, g;
            for (const e1 of (await Promise.all(s)))e1 && (e1 instanceof WidgetAnnotation ? (g ||= []).push(e1) : e1 instanceof PopupAnnotation ? (n ||= []).push(e1) : r.push(e1));
            g && r.push(...g);
            n && r.push(...n);
            return r;
        }));
    }
    get jsActions() {
        return shadow(this, "jsActions", collectActions(this.xref, this.pageDict, pA));
    }
}
const ig = new Uint8Array([
    37,
    80,
    68,
    70,
    45
]), ag = new Uint8Array([
    115,
    116,
    97,
    114,
    116,
    120,
    114,
    101,
    102
]), sg = new Uint8Array([
    101,
    110,
    100,
    111,
    98,
    106
]);
function find(e1, t, i = 1024, a = !1) {
    const s = t.length, r = e1.peekBytes(i), n = r.length - s;
    if (n <= 0) return !1;
    if (a) {
        const i = s - 1;
        let a = r.length - 1;
        for(; a >= i;){
            let n = 0;
            for(; n < s && r[a - n] === t[i - n];)n++;
            if (n >= s) {
                e1.pos += a - i;
                return !0;
            }
            a--;
        }
    } else {
        let i = 0;
        for(; i <= n;){
            let a = 0;
            for(; a < s && r[i + a] === t[a];)a++;
            if (a >= s) {
                e1.pos += i;
                return !0;
            }
            i++;
        }
    }
    return !1;
}
class PDFDocument {
    constructor(e1, t){
        if (t.length <= 0) throw new InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
        this.pdfManager = e1;
        this.stream = t;
        this.xref = new XRef(t, e1);
        this._pagePromises = new Map;
        this._version = null;
        const i = {
            font: 0
        };
        this._globalIdFactory = class {
            static getDocId() {
                return `g_${e1.docId}`;
            }
            static createFontId() {
                return "f" + ++i.font;
            }
            static createObjId() {
                unreachable("Abstract method `createObjId` called.");
            }
            static getPageObjId() {
                unreachable("Abstract method `getPageObjId` called.");
            }
        };
    }
    parse(e1) {
        this.xref.parse(e1);
        this.catalog = new Catalog(this.pdfManager, this.xref);
    }
    get linearization() {
        let e1 = null;
        try {
            e1 = Linearization.create(this.stream);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info(e1);
        }
        return shadow(this, "linearization", e1);
    }
    get startXRef() {
        const e1 = this.stream;
        let t = 0;
        if (this.linearization) {
            e1.reset();
            if (find(e1, sg)) {
                e1.skip(6);
                let i = e1.peekByte();
                for(; isWhiteSpace(i);){
                    e1.pos++;
                    i = e1.peekByte();
                }
                t = e1.pos - e1.start;
            }
        } else {
            const i = 1024, a = ag.length;
            let s = !1, r = e1.end;
            for(; !s && r > 0;){
                r -= i - a;
                r < 0 && (r = 0);
                e1.pos = r;
                s = find(e1, ag, i, !0);
            }
            if (s) {
                e1.skip(9);
                let i;
                do {
                    i = e1.getByte();
                }while (isWhiteSpace(i))
                let a = "";
                for(; i >= 32 && i <= 57;){
                    a += String.fromCharCode(i);
                    i = e1.getByte();
                }
                t = parseInt(a, 10);
                isNaN(t) && (t = 0);
            }
        }
        return shadow(this, "startXRef", t);
    }
    checkHeader() {
        const e1 = this.stream;
        e1.reset();
        if (!find(e1, ig)) return;
        e1.moveStart();
        e1.skip(ig.length);
        let t, i = "";
        for(; (t = e1.getByte()) > 32 && i.length < 7;)i += String.fromCharCode(t);
        ft.test(i) ? this._version = i : warn(`Invalid PDF header version: ${i}`);
    }
    parseStartXRef() {
        this.xref.setStartXRef(this.startXRef);
    }
    get numPages() {
        let e1 = 0;
        e1 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages;
        return shadow(this, "numPages", e1);
    }
    _hasOnlyDocumentSignatures(e1, t = 0) {
        return !!Array.isArray(e1) && e1.every((e1)=>{
            if (!((e1 = this.xref.fetchIfRef(e1)) instanceof Dict)) return !1;
            if (e1.has("Kids")) {
                if (++t > 10) {
                    warn("_hasOnlyDocumentSignatures: maximum recursion depth reached");
                    return !1;
                }
                return this._hasOnlyDocumentSignatures(e1.get("Kids"), t);
            }
            const i = isName(e1.get("FT"), "Sig"), a = e1.get("Rect"), s = Array.isArray(a) && a.every((e1)=>0 === e1);
            return i && s;
        });
    }
    get _xfaStreams() {
        const e1 = this.catalog.acroForm;
        if (!e1) return null;
        const t = e1.get("XFA"), i = {
            "xdp:xdp": "",
            template: "",
            datasets: "",
            config: "",
            connectionSet: "",
            localeSet: "",
            stylesheet: "",
            "/xdp:xdp": ""
        };
        if (t instanceof BaseStream && !t.isEmpty) {
            i["xdp:xdp"] = t;
            return i;
        }
        if (!Array.isArray(t) || 0 === t.length) return null;
        for(let e1 = 0, a = t.length; e1 < a; e1 += 2){
            let s;
            s = 0 === e1 ? "xdp:xdp" : e1 === a - 2 ? "/xdp:xdp" : t[e1];
            if (!i.hasOwnProperty(s)) continue;
            const r = this.xref.fetchIfRef(t[e1 + 1]);
            r instanceof BaseStream && !r.isEmpty && (i[s] = r);
        }
        return i;
    }
    get xfaDatasets() {
        const e1 = this._xfaStreams;
        if (!e1) return shadow(this, "xfaDatasets", null);
        for (const t of [
            "datasets",
            "xdp:xdp"
        ]){
            const i = e1[t];
            if (i) try {
                const e1 = stringToUTF8String(i.getString());
                return shadow(this, "xfaDatasets", new DatasetReader({
                    [t]: e1
                }));
            } catch  {
                warn("XFA - Invalid utf-8 string.");
                break;
            }
        }
        return shadow(this, "xfaDatasets", null);
    }
    get xfaData() {
        const e1 = this._xfaStreams;
        if (!e1) return null;
        const t = Object.create(null);
        for (const [i, a] of Object.entries(e1))if (a) try {
            t[i] = stringToUTF8String(a.getString());
        } catch  {
            warn("XFA - Invalid utf-8 string.");
            return null;
        }
        return t;
    }
    get xfaFactory() {
        let e1;
        this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e1 = this.xfaData);
        return shadow(this, "xfaFactory", e1 ? new XFAFactory(e1) : null);
    }
    get isPureXfa() {
        return !!this.xfaFactory && this.xfaFactory.isValid();
    }
    get htmlForXfa() {
        return this.xfaFactory ? this.xfaFactory.getPages() : null;
    }
    async loadXfaImages() {
        const e1 = await this.pdfManager.ensureCatalog("xfaImages");
        if (!e1) return;
        const t = e1.getKeys(), i = new ObjectLoader(e1, t, this.xref);
        await i.load();
        const a = new Map;
        for (const i of t){
            const t = e1.get(i);
            t instanceof BaseStream && a.set(i, t.getBytes());
        }
        this.xfaFactory.setImages(a);
    }
    async loadXfaFonts(e1, t) {
        const i = await this.pdfManager.ensureCatalog("acroForm");
        if (!i) return;
        const a = await i.getAsync("DR");
        if (!(a instanceof Dict)) return;
        const s = new ObjectLoader(a, [
            "Font"
        ], this.xref);
        await s.load();
        const r = a.get("Font");
        if (!(r instanceof Dict)) return;
        const n = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions);
        n.useSystemFonts = !1;
        const g = new PartialEvaluator({
            xref: this.xref,
            handler: e1,
            pageIndex: -1,
            idFactory: this._globalIdFactory,
            fontCache: this.catalog.fontCache,
            builtInCMapCache: this.catalog.builtInCMapCache,
            standardFontDataCache: this.catalog.standardFontDataCache,
            options: n
        }), o = new OperatorList, c = [], C = {
            get font () {
                return c.at(-1);
            },
            set font (e){
                c.push(e);
            },
            clone () {
                return this;
            }
        }, h = [];
        for (const [e1, i] of r){
            const s = i.get("FontDescriptor");
            if (!(s instanceof Dict)) continue;
            let r = s.get("FontFamily");
            r = r.replaceAll(/[ ]+(\d)/g, "$1");
            const n = {
                fontFamily: r,
                fontWeight: s.get("FontWeight"),
                italicAngle: -s.get("ItalicAngle")
            };
            validateCSSFont(n) && h.push(g.handleSetFont(a, [
                Name.get(e1),
                1
            ], null, o, t, C, null, n).catch(function(e1) {
                warn(`loadXfaFonts: "${e1}".`);
                return null;
            }));
        }
        await Promise.all(h);
        const l = this.xfaFactory.setFonts(c);
        if (!l) return;
        n.ignoreErrors = !0;
        h.length = 0;
        c.length = 0;
        const Q = new Set;
        for (const e1 of l)getXfaFontName(`${e1}-Regular`) || Q.add(e1);
        Q.size && l.push("PdfJS-Fallback");
        for (const e1 of l)if (!Q.has(e1)) for (const i of [
            {
                name: "Regular",
                fontWeight: 400,
                italicAngle: 0
            },
            {
                name: "Bold",
                fontWeight: 700,
                italicAngle: 0
            },
            {
                name: "Italic",
                fontWeight: 400,
                italicAngle: 12
            },
            {
                name: "BoldItalic",
                fontWeight: 700,
                italicAngle: 12
            }
        ]){
            const s = `${e1}-${i.name}`, r = getXfaFontDict(s);
            h.push(g.handleSetFont(a, [
                Name.get(s),
                1
            ], null, o, t, C, r, {
                fontFamily: e1,
                fontWeight: i.fontWeight,
                italicAngle: i.italicAngle
            }).catch(function(e1) {
                warn(`loadXfaFonts: "${e1}".`);
                return null;
            }));
        }
        await Promise.all(h);
        this.xfaFactory.appendFonts(c, Q);
    }
    async serializeXfaData(e1) {
        return this.xfaFactory ? this.xfaFactory.serializeData(e1) : null;
    }
    get version() {
        return this.catalog.version || this._version;
    }
    get formInfo() {
        const e1 = {
            hasFields: !1,
            hasAcroForm: !1,
            hasXfa: !1,
            hasSignatures: !1
        }, t = this.catalog.acroForm;
        if (!t) return shadow(this, "formInfo", e1);
        try {
            const i = t.get("Fields"), a = Array.isArray(i) && i.length > 0;
            e1.hasFields = a;
            const s = t.get("XFA");
            e1.hasXfa = Array.isArray(s) && s.length > 0 || s instanceof BaseStream && !s.isEmpty;
            const r = !!(1 & t.get("SigFlags")), n = r && this._hasOnlyDocumentSignatures(i);
            e1.hasAcroForm = a && !n;
            e1.hasSignatures = r;
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`Cannot fetch form information: "${e1}".`);
        }
        return shadow(this, "formInfo", e1);
    }
    get documentInfo() {
        const e1 = {
            PDFFormatVersion: this.version,
            Language: this.catalog.lang,
            EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
            IsLinearized: !!this.linearization,
            IsAcroFormPresent: this.formInfo.hasAcroForm,
            IsXFAPresent: this.formInfo.hasXfa,
            IsCollectionPresent: !!this.catalog.collection,
            IsSignaturesPresent: this.formInfo.hasSignatures
        };
        let t;
        try {
            t = this.xref.trailer.get("Info");
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info("The document information dictionary is invalid.");
        }
        if (!(t instanceof Dict)) return shadow(this, "documentInfo", e1);
        for (const i of t.getKeys()){
            const a = t.get(i);
            switch(i){
                case "Title":
                case "Author":
                case "Subject":
                case "Keywords":
                case "Creator":
                case "Producer":
                case "CreationDate":
                case "ModDate":
                    if ("string" == typeof a) {
                        e1[i] = stringToPDFString(a);
                        continue;
                    }
                    break;
                case "Trapped":
                    if (a instanceof Name) {
                        e1[i] = a;
                        continue;
                    }
                    break;
                default:
                    let t1;
                    switch(typeof a){
                        case "string":
                            t1 = stringToPDFString(a);
                            break;
                        case "number":
                        case "boolean":
                            t1 = a;
                            break;
                        default:
                            a instanceof Name && (t1 = a);
                    }
                    if (void 0 === t1) {
                        warn(`Bad value, for custom key "${i}", in Info: ${a}.`);
                        continue;
                    }
                    e1.Custom || (e1.Custom = Object.create(null));
                    e1.Custom[i] = t1;
                    continue;
            }
            warn(`Bad value, for key "${i}", in Info: ${a}.`);
        }
        return shadow(this, "documentInfo", e1);
    }
    get fingerprints() {
        const e1 = "\0".repeat(16);
        function validate(t) {
            return "string" == typeof t && 16 === t.length && t !== e1;
        }
        const t = this.xref.trailer.get("ID");
        let i, a;
        if (Array.isArray(t) && validate(t[0])) {
            i = stringToBytes(t[0]);
            t[1] !== t[0] && validate(t[1]) && (a = stringToBytes(t[1]));
        } else i = $n(this.stream.getByteRange(0, 1024), 0, 1024);
        return shadow(this, "fingerprints", [
            toHexUtil(i),
            a ? toHexUtil(a) : null
        ]);
    }
    async _getLinearizationPage(e1) {
        const { catalog: t, linearization: i, xref: a } = this, s = Ref.get(i.objectNumberFirst, 0);
        try {
            const e1 = await a.fetchAsync(s);
            if (e1 instanceof Dict) {
                let i = e1.getRaw("Type");
                i instanceof Ref && (i = await a.fetchAsync(i));
                if (isName(i, "Page") || !e1.has("Type") && !e1.has("Kids") && e1.has("Contents")) {
                    t.pageKidsCountCache.has(s) || t.pageKidsCountCache.put(s, 1);
                    t.pageIndexCache.has(s) || t.pageIndexCache.put(s, 0);
                    return [
                        e1,
                        s
                    ];
                }
            }
            throw new FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
        } catch (i) {
            warn(`_getLinearizationPage: "${i.message}".`);
            return t.getPageDict(e1);
        }
    }
    getPage(e1) {
        const t = this._pagePromises.get(e1);
        if (t) return t;
        const { catalog: i, linearization: a, xfaFactory: s } = this;
        let r;
        r = s ? Promise.resolve([
            Dict.empty,
            null
        ]) : a?.pageFirst === e1 ? this._getLinearizationPage(e1) : i.getPageDict(e1);
        r = r.then(([t, a])=>new Page({
                pdfManager: this.pdfManager,
                xref: this.xref,
                pageIndex: e1,
                pageDict: t,
                ref: a,
                globalIdFactory: this._globalIdFactory,
                fontCache: i.fontCache,
                builtInCMapCache: i.builtInCMapCache,
                standardFontDataCache: i.standardFontDataCache,
                globalImageCache: i.globalImageCache,
                systemFontCache: i.systemFontCache,
                nonBlendModesSet: i.nonBlendModesSet,
                xfaFactory: s
            }));
        this._pagePromises.set(e1, r);
        return r;
    }
    async checkFirstPage(e1 = !1) {
        if (!e1) try {
            await this.getPage(0);
        } catch (e1) {
            if (e1 instanceof XRefEntryException) {
                this._pagePromises.delete(0);
                await this.cleanup();
                throw new XRefParseException;
            }
        }
    }
    async checkLastPage(e1 = !1) {
        const { catalog: t, pdfManager: i } = this;
        t.setActualNumPages();
        let a;
        try {
            await Promise.all([
                i.ensureDoc("xfaFactory"),
                i.ensureDoc("linearization"),
                i.ensureCatalog("numPages")
            ]);
            if (this.xfaFactory) return;
            a = this.linearization ? this.linearization.numPages : t.numPages;
            if (!Number.isInteger(a)) throw new FormatError("Page count is not an integer.");
            if (a <= 1) return;
            await this.getPage(a - 1);
        } catch (s) {
            this._pagePromises.delete(a - 1);
            await this.cleanup();
            if (s instanceof XRefEntryException && !e1) throw new XRefParseException;
            warn(`checkLastPage - invalid /Pages tree /Count: ${a}.`);
            let r;
            try {
                r = await t.getAllPageDicts(e1);
            } catch (i) {
                if (i instanceof XRefEntryException && !e1) throw new XRefParseException;
                t.setActualNumPages(1);
                return;
            }
            for (const [e1, [a, s]] of r){
                let r;
                if (a instanceof Error) {
                    r = Promise.reject(a);
                    r.catch(()=>{});
                } else r = Promise.resolve(new Page({
                    pdfManager: i,
                    xref: this.xref,
                    pageIndex: e1,
                    pageDict: a,
                    ref: s,
                    globalIdFactory: this._globalIdFactory,
                    fontCache: t.fontCache,
                    builtInCMapCache: t.builtInCMapCache,
                    standardFontDataCache: t.standardFontDataCache,
                    globalImageCache: t.globalImageCache,
                    systemFontCache: t.systemFontCache,
                    nonBlendModesSet: t.nonBlendModesSet,
                    xfaFactory: null
                }));
                this._pagePromises.set(e1, r);
            }
            t.setActualNumPages(r.size);
        }
    }
    fontFallback(e1, t) {
        return this.catalog.fontFallback(e1, t);
    }
    async cleanup(e1 = !1) {
        return this.catalog ? this.catalog.cleanup(e1) : clearGlobalCaches();
    }
    async #z(e1, t, i, a, s, r, n) {
        const { xref: g } = this;
        if (!(i instanceof Ref) || r.has(i)) return;
        r.put(i);
        const o = await g.fetchAsync(i);
        if (!(o instanceof Dict)) return;
        if (o.has("T")) {
            const t = stringToPDFString(await o.getAsync("T"));
            e1 = "" === e1 ? t : `${e1}.${t}`;
        } else {
            let i = o;
            for(;;){
                i = i.getRaw("Parent") || t;
                if (i instanceof Ref) {
                    if (r.has(i)) break;
                    i = await g.fetchAsync(i);
                }
                if (!(i instanceof Dict)) break;
                if (i.has("T")) {
                    const t = stringToPDFString(await i.getAsync("T"));
                    e1 = "" === e1 ? t : `${e1}.${t}`;
                    break;
                }
            }
        }
        t && !o.has("Parent") && isName(o.get("Subtype"), "Widget") && n.put(i, t);
        a.has(e1) || a.set(e1, []);
        a.get(e1).push(AnnotationFactory.create(g, i, s, null, !0, n, null).then((e1)=>e1?.getFieldObject()).catch(function(e1) {
            warn(`#collectFieldObjects: "${e1}".`);
            return null;
        }));
        if (!o.has("Kids")) return;
        const c = await o.getAsync("Kids");
        if (Array.isArray(c)) for (const t of c)await this.#z(e1, i, t, a, s, r, n);
    }
    get fieldObjects() {
        return shadow(this, "fieldObjects", this.pdfManager.ensureDoc("formInfo").then(async (e1)=>{
            if (!e1.hasFields) return null;
            const [t, i] = await Promise.all([
                this.pdfManager.ensureDoc("annotationGlobals"),
                this.pdfManager.ensureCatalog("acroForm")
            ]);
            if (!t) return null;
            const a = new RefSet, s = Object.create(null), r = new Map, n = new RefSetCache;
            for (const e1 of (await i.getAsync("Fields")))await this.#z("", null, e1, r, t, a, n);
            const g = [];
            for (const [e1, t] of r)g.push(Promise.all(t).then((t)=>{
                (t = t.filter((e1)=>!!e1)).length > 0 && (s[e1] = t);
            }));
            await Promise.all(g);
            return {
                allFields: s,
                orphanFields: n
            };
        }));
    }
    get hasJSActions() {
        return shadow(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
    }
    async _parseHasJSActions() {
        const [e1, t] = await Promise.all([
            this.pdfManager.ensureCatalog("jsActions"),
            this.pdfManager.ensureDoc("fieldObjects")
        ]);
        return !!e1 || !!t && Object.values(t.allFields).some((e1)=>e1.some((e1)=>null !== e1.actions));
    }
    get calculationOrderIds() {
        const e1 = this.catalog.acroForm?.get("CO");
        if (!Array.isArray(e1) || 0 === e1.length) return shadow(this, "calculationOrderIds", null);
        const t = [];
        for (const i of e1)i instanceof Ref && t.push(i.toString());
        return shadow(this, "calculationOrderIds", t.length ? t : null);
    }
    get annotationGlobals() {
        return shadow(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
    }
}
class BasePdfManager {
    constructor(e1){
        this._docBaseUrl = function parseDocBaseUrl(e1) {
            if (e1) {
                const t = createValidAbsoluteUrl(e1);
                if (t) return t.href;
                warn(`Invalid absolute docBaseUrl: "${e1}".`);
            }
            return null;
        }(e1.docBaseUrl);
        this._docId = e1.docId;
        this._password = e1.password;
        this.enableXfa = e1.enableXfa;
        e1.evaluatorOptions.isOffscreenCanvasSupported &&= FeatureTest.isOffscreenCanvasSupported;
        e1.evaluatorOptions.isImageDecoderSupported &&= FeatureTest.isImageDecoderSupported;
        this.evaluatorOptions = Object.freeze(e1.evaluatorOptions);
    }
    get docId() {
        return this._docId;
    }
    get password() {
        return this._password;
    }
    get docBaseUrl() {
        return this._docBaseUrl;
    }
    get catalog() {
        return this.pdfDocument.catalog;
    }
    ensureDoc(e1, t) {
        return this.ensure(this.pdfDocument, e1, t);
    }
    ensureXRef(e1, t) {
        return this.ensure(this.pdfDocument.xref, e1, t);
    }
    ensureCatalog(e1, t) {
        return this.ensure(this.pdfDocument.catalog, e1, t);
    }
    getPage(e1) {
        return this.pdfDocument.getPage(e1);
    }
    fontFallback(e1, t) {
        return this.pdfDocument.fontFallback(e1, t);
    }
    loadXfaFonts(e1, t) {
        return this.pdfDocument.loadXfaFonts(e1, t);
    }
    loadXfaImages() {
        return this.pdfDocument.loadXfaImages();
    }
    serializeXfaData(e1) {
        return this.pdfDocument.serializeXfaData(e1);
    }
    cleanup(e1 = !1) {
        return this.pdfDocument.cleanup(e1);
    }
    async ensure(e1, t, i) {
        unreachable("Abstract method `ensure` called");
    }
    requestRange(e1, t) {
        unreachable("Abstract method `requestRange` called");
    }
    requestLoadedStream(e1 = !1) {
        unreachable("Abstract method `requestLoadedStream` called");
    }
    sendProgressiveData(e1) {
        unreachable("Abstract method `sendProgressiveData` called");
    }
    updatePassword(e1) {
        this._password = e1;
    }
    terminate(e1) {
        unreachable("Abstract method `terminate` called");
    }
}
class LocalPdfManager extends BasePdfManager {
    constructor(e1){
        super(e1);
        const t = new Stream(e1.source);
        this.pdfDocument = new PDFDocument(this, t);
        this._loadedStreamPromise = Promise.resolve(t);
    }
    async ensure(e1, t, i) {
        const a = e1[t];
        return "function" == typeof a ? a.apply(e1, i) : a;
    }
    requestRange(e1, t) {
        return Promise.resolve();
    }
    requestLoadedStream(e1 = !1) {
        return this._loadedStreamPromise;
    }
    terminate(e1) {}
}
class NetworkPdfManager extends BasePdfManager {
    constructor(e1){
        super(e1);
        this.streamManager = new ChunkedStreamManager(e1.source, {
            msgHandler: e1.handler,
            length: e1.length,
            disableAutoFetch: e1.disableAutoFetch,
            rangeChunkSize: e1.rangeChunkSize
        });
        this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
    }
    async ensure(e1, t, i) {
        try {
            const a = e1[t];
            return "function" == typeof a ? a.apply(e1, i) : a;
        } catch (a) {
            if (!(a instanceof MissingDataException)) throw a;
            await this.requestRange(a.begin, a.end);
            return this.ensure(e1, t, i);
        }
    }
    requestRange(e1, t) {
        return this.streamManager.requestRange(e1, t);
    }
    requestLoadedStream(e1 = !1) {
        return this.streamManager.requestAllChunks(e1);
    }
    sendProgressiveData(e1) {
        this.streamManager.onReceiveData({
            chunk: e1
        });
    }
    terminate(e1) {
        this.streamManager.abort(e1);
    }
}
const rg = 1, ng = 2, gg = 1, og = 2, Ig = 3, cg = 4, Cg = 5, hg = 6, lg = 7, Bg = 8;
function onFn() {}
function wrapReason(e1) {
    if (e1 instanceof AbortException || e1 instanceof InvalidPDFException || e1 instanceof MissingPDFException || e1 instanceof PasswordException || e1 instanceof UnexpectedResponseException || e1 instanceof UnknownErrorException) return e1;
    e1 instanceof Error || "object" == typeof e1 && null !== e1 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
    switch(e1.name){
        case "AbortException":
            return new AbortException(e1.message);
        case "InvalidPDFException":
            return new InvalidPDFException(e1.message);
        case "MissingPDFException":
            return new MissingPDFException(e1.message);
        case "PasswordException":
            return new PasswordException(e1.message, e1.code);
        case "UnexpectedResponseException":
            return new UnexpectedResponseException(e1.message, e1.status);
        case "UnknownErrorException":
            return new UnknownErrorException(e1.message, e1.details);
    }
    return new UnknownErrorException(e1.message, e1.toString());
}
class MessageHandler {
    #_ = new AbortController;
    constructor(e1, t, i){
        this.sourceName = e1;
        this.targetName = t;
        this.comObj = i;
        this.callbackId = 1;
        this.streamId = 1;
        this.streamSinks = Object.create(null);
        this.streamControllers = Object.create(null);
        this.callbackCapabilities = Object.create(null);
        this.actionHandler = Object.create(null);
        i.addEventListener("message", this.#$.bind(this), {
            signal: this.#_.signal
        });
    }
    #$({ data: e1 }) {
        if (e1.targetName !== this.sourceName) return;
        if (e1.stream) {
            this.#AA(e1);
            return;
        }
        if (e1.callback) {
            const t = e1.callbackId, i = this.callbackCapabilities[t];
            if (!i) throw new Error(`Cannot resolve callback ${t}`);
            delete this.callbackCapabilities[t];
            if (e1.callback === rg) i.resolve(e1.data);
            else {
                if (e1.callback !== ng) throw new Error("Unexpected callback case");
                i.reject(wrapReason(e1.reason));
            }
            return;
        }
        const t = this.actionHandler[e1.action];
        if (!t) throw new Error(`Unknown action from worker: ${e1.action}`);
        if (e1.callbackId) {
            const i = this.sourceName, a = e1.sourceName, s = this.comObj;
            Promise.try(t, e1.data).then(function(t) {
                s.postMessage({
                    sourceName: i,
                    targetName: a,
                    callback: rg,
                    callbackId: e1.callbackId,
                    data: t
                });
            }, function(t) {
                s.postMessage({
                    sourceName: i,
                    targetName: a,
                    callback: ng,
                    callbackId: e1.callbackId,
                    reason: wrapReason(t)
                });
            });
        } else e1.streamId ? this.#eA(e1) : t(e1.data);
    }
    on(e1, t) {
        const i = this.actionHandler;
        if (i[e1]) throw new Error(`There is already an actionName called "${e1}"`);
        i[e1] = t;
    }
    send(e1, t, i) {
        this.comObj.postMessage({
            sourceName: this.sourceName,
            targetName: this.targetName,
            action: e1,
            data: t
        }, i);
    }
    sendWithPromise(e1, t, i) {
        const a = this.callbackId++, s = Promise.withResolvers();
        this.callbackCapabilities[a] = s;
        try {
            this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: e1,
                callbackId: a,
                data: t
            }, i);
        } catch (e1) {
            s.reject(e1);
        }
        return s.promise;
    }
    sendWithStream(e1, t, i, a) {
        const s = this.streamId++, r = this.sourceName, n = this.targetName, g = this.comObj;
        return new ReadableStream({
            start: (i)=>{
                const o = Promise.withResolvers();
                this.streamControllers[s] = {
                    controller: i,
                    startCall: o,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                };
                g.postMessage({
                    sourceName: r,
                    targetName: n,
                    action: e1,
                    streamId: s,
                    data: t,
                    desiredSize: i.desiredSize
                }, a);
                return o.promise;
            },
            pull: (e1)=>{
                const t = Promise.withResolvers();
                this.streamControllers[s].pullCall = t;
                g.postMessage({
                    sourceName: r,
                    targetName: n,
                    stream: hg,
                    streamId: s,
                    desiredSize: e1.desiredSize
                });
                return t.promise;
            },
            cancel: (e1)=>{
                assert(e1 instanceof Error, "cancel must have a valid reason");
                const t = Promise.withResolvers();
                this.streamControllers[s].cancelCall = t;
                this.streamControllers[s].isClosed = !0;
                g.postMessage({
                    sourceName: r,
                    targetName: n,
                    stream: gg,
                    streamId: s,
                    reason: wrapReason(e1)
                });
                return t.promise;
            }
        }, i);
    }
    #eA(e1) {
        const t = e1.streamId, i = this.sourceName, a = e1.sourceName, s = this.comObj, r = this, n = this.actionHandler[e1.action], g = {
            enqueue (e1, r = 1, n) {
                if (this.isCancelled) return;
                const g = this.desiredSize;
                this.desiredSize -= r;
                if (g > 0 && this.desiredSize <= 0) {
                    this.sinkCapability = Promise.withResolvers();
                    this.ready = this.sinkCapability.promise;
                }
                s.postMessage({
                    sourceName: i,
                    targetName: a,
                    stream: cg,
                    streamId: t,
                    chunk: e1
                }, n);
            },
            close () {
                if (!this.isCancelled) {
                    this.isCancelled = !0;
                    s.postMessage({
                        sourceName: i,
                        targetName: a,
                        stream: Ig,
                        streamId: t
                    });
                    delete r.streamSinks[t];
                }
            },
            error (e1) {
                assert(e1 instanceof Error, "error must have a valid reason");
                if (!this.isCancelled) {
                    this.isCancelled = !0;
                    s.postMessage({
                        sourceName: i,
                        targetName: a,
                        stream: Cg,
                        streamId: t,
                        reason: wrapReason(e1)
                    });
                }
            },
            sinkCapability: Promise.withResolvers(),
            onPull: null,
            onCancel: null,
            isCancelled: !1,
            desiredSize: e1.desiredSize,
            ready: null
        };
        g.sinkCapability.resolve();
        g.ready = g.sinkCapability.promise;
        this.streamSinks[t] = g;
        Promise.try(n, e1.data, g).then(function() {
            s.postMessage({
                sourceName: i,
                targetName: a,
                stream: Bg,
                streamId: t,
                success: !0
            });
        }, function(e1) {
            s.postMessage({
                sourceName: i,
                targetName: a,
                stream: Bg,
                streamId: t,
                reason: wrapReason(e1)
            });
        });
    }
    #AA(e1) {
        const t = e1.streamId, i = this.sourceName, a = e1.sourceName, s = this.comObj, r = this.streamControllers[t], n = this.streamSinks[t];
        switch(e1.stream){
            case Bg:
                e1.success ? r.startCall.resolve() : r.startCall.reject(wrapReason(e1.reason));
                break;
            case lg:
                e1.success ? r.pullCall.resolve() : r.pullCall.reject(wrapReason(e1.reason));
                break;
            case hg:
                if (!n) {
                    s.postMessage({
                        sourceName: i,
                        targetName: a,
                        stream: lg,
                        streamId: t,
                        success: !0
                    });
                    break;
                }
                n.desiredSize <= 0 && e1.desiredSize > 0 && n.sinkCapability.resolve();
                n.desiredSize = e1.desiredSize;
                Promise.try(n.onPull || onFn).then(function() {
                    s.postMessage({
                        sourceName: i,
                        targetName: a,
                        stream: lg,
                        streamId: t,
                        success: !0
                    });
                }, function(e1) {
                    s.postMessage({
                        sourceName: i,
                        targetName: a,
                        stream: lg,
                        streamId: t,
                        reason: wrapReason(e1)
                    });
                });
                break;
            case cg:
                assert(r, "enqueue should have stream controller");
                if (r.isClosed) break;
                r.controller.enqueue(e1.chunk);
                break;
            case Ig:
                assert(r, "close should have stream controller");
                if (r.isClosed) break;
                r.isClosed = !0;
                r.controller.close();
                this.#tA(r, t);
                break;
            case Cg:
                assert(r, "error should have stream controller");
                r.controller.error(wrapReason(e1.reason));
                this.#tA(r, t);
                break;
            case og:
                e1.success ? r.cancelCall.resolve() : r.cancelCall.reject(wrapReason(e1.reason));
                this.#tA(r, t);
                break;
            case gg:
                if (!n) break;
                const g = wrapReason(e1.reason);
                Promise.try(n.onCancel || onFn, g).then(function() {
                    s.postMessage({
                        sourceName: i,
                        targetName: a,
                        stream: og,
                        streamId: t,
                        success: !0
                    });
                }, function(e1) {
                    s.postMessage({
                        sourceName: i,
                        targetName: a,
                        stream: og,
                        streamId: t,
                        reason: wrapReason(e1)
                    });
                });
                n.sinkCapability.reject(g);
                n.isCancelled = !0;
                delete this.streamSinks[t];
                break;
            default:
                throw new Error("Unexpected stream case");
        }
    }
    async #tA(e1, t) {
        await Promise.allSettled([
            e1.startCall?.promise,
            e1.pullCall?.promise,
            e1.cancelCall?.promise
        ]);
        delete this.streamControllers[t];
    }
    destroy() {
        this.#_?.abort();
        this.#_ = null;
    }
}
async function writeObject(e1, t, i, { encrypt: a = null }) {
    const s = a?.createCipherTransform(e1.num, e1.gen);
    i.push(`${e1.num} ${e1.gen} obj\n`);
    t instanceof Dict ? await writeDict(t, i, s) : t instanceof BaseStream ? await writeStream(t, i, s) : (Array.isArray(t) || ArrayBuffer.isView(t)) && await writeArray(t, i, s);
    i.push("\nendobj\n");
}
async function writeDict(e1, t, i) {
    t.push("<<");
    for (const a of e1.getKeys()){
        t.push(` /${escapePDFName(a)} `);
        await writeValue(e1.getRaw(a), t, i);
    }
    t.push(">>");
}
async function writeStream(e1, t, i) {
    let a = e1.getBytes();
    const { dict: s } = e1, [r, n] = await Promise.all([
        s.getAsync("Filter"),
        s.getAsync("DecodeParms")
    ]), g = isName(Array.isArray(r) ? await s.xref.fetchIfRefAsync(r[0]) : r, "FlateDecode");
    if (a.length >= 256 || g) try {
        const e1 = new CompressionStream("deflate"), t = e1.writable.getWriter();
        await t.ready;
        t.write(a).then(async ()=>{
            await t.ready;
            await t.close();
        }).catch(()=>{});
        const i = await new Response(e1.readable).arrayBuffer();
        a = new Uint8Array(i);
        let o, c;
        if (r) {
            if (!g) {
                o = Array.isArray(r) ? [
                    Name.get("FlateDecode"),
                    ...r
                ] : [
                    Name.get("FlateDecode"),
                    r
                ];
                n && (c = Array.isArray(n) ? [
                    null,
                    ...n
                ] : [
                    null,
                    n
                ]);
            }
        } else o = Name.get("FlateDecode");
        o && s.set("Filter", o);
        c && s.set("DecodeParms", c);
    } catch (e1) {
        info(`writeStream - cannot compress data: "${e1}".`);
    }
    let o = bytesToString(a);
    i && (o = i.encryptString(o));
    s.set("Length", o.length);
    await writeDict(s, t, i);
    t.push(" stream\n", o, "\nendstream");
}
async function writeArray(e1, t, i) {
    t.push("[");
    let a = !0;
    for (const s of e1){
        a ? a = !1 : t.push(" ");
        await writeValue(s, t, i);
    }
    t.push("]");
}
async function writeValue(e1, t, i) {
    if (e1 instanceof Name) t.push(`/${escapePDFName(e1.name)}`);
    else if (e1 instanceof Ref) t.push(`${e1.num} ${e1.gen} R`);
    else if (Array.isArray(e1) || ArrayBuffer.isView(e1)) await writeArray(e1, t, i);
    else if ("string" == typeof e1) {
        i && (e1 = i.encryptString(e1));
        t.push(`(${escapeString(e1)})`);
    } else "number" == typeof e1 ? t.push(numberToString(e1)) : "boolean" == typeof e1 ? t.push(e1.toString()) : e1 instanceof Dict ? await writeDict(e1, t, i) : e1 instanceof BaseStream ? await writeStream(e1, t, i) : null === e1 ? t.push("null") : warn(`Unhandled value in writer: ${typeof e1}, please file a bug.`);
}
function writeInt(e1, t, i, a) {
    for(let s = t + i - 1; s > i - 1; s--){
        a[s] = 255 & e1;
        e1 >>= 8;
    }
    return i + t;
}
function writeString(e1, t, i) {
    for(let a = 0, s = e1.length; a < s; a++)i[t + a] = 255 & e1.charCodeAt(a);
}
function updateXFA({ xfaData: e1, xfaDatasetsRef: t, changes: i, xref: a }) {
    if (null === e1) {
        e1 = function writeXFADataForAcroform(e1, t) {
            const i = new SimpleXMLParser({
                hasAttributes: !0
            }).parseFromString(e1);
            for (const { xfa: e1 } of t){
                if (!e1) continue;
                const { path: t, value: a } = e1;
                if (!t) continue;
                const s = parseXFAPath(t);
                let r = i.documentElement.searchNode(s, 0);
                !r && s.length > 1 && (r = i.documentElement.searchNode([
                    s.at(-1)
                ], 0));
                r ? r.childNodes = Array.isArray(a) ? a.map((e1)=>new SimpleDOMNode("value", e1)) : [
                    new SimpleDOMNode("#text", a)
                ] : warn(`Node not found for path: ${t}`);
            }
            const a = [];
            i.documentElement.dump(a);
            return a.join("");
        }(a.fetchIfRef(t).getString(), i);
    }
    const s = new StringStream(e1);
    s.dict = new Dict(a);
    s.dict.set("Type", Name.get("EmbeddedFile"));
    i.put(t, {
        data: s
    });
}
function getIndexes(e1) {
    const t = [];
    for (const { ref: i } of e1)i.num === t.at(-2) + t.at(-1) ? t[t.length - 1] += 1 : t.push(i.num, 1);
    return t;
}
function computeIDs(e1, t, i) {
    if (Array.isArray(t.fileIds) && t.fileIds.length > 0) {
        const a = function computeMD5(e1, t) {
            const i = Math.floor(Date.now() / 1e3), a = t.filename || "", s = [
                i.toString(),
                a,
                e1.toString()
            ];
            let r = s.reduce((e1, t)=>e1 + t.length, 0);
            for (const e1 of Object.values(t.info)){
                s.push(e1);
                r += e1.length;
            }
            const n = new Uint8Array(r);
            let g = 0;
            for (const e1 of s){
                writeString(e1, g, n);
                g += e1.length;
            }
            return bytesToString($n(n));
        }(e1, t);
        i.set("ID", [
            t.fileIds[0],
            a
        ]);
    }
}
async function incrementalUpdate({ originalData: e1, xrefInfo: t, changes: i, xref: a = null, hasXfa: s = !1, xfaDatasetsRef: r = null, hasXfaDatasetsEntry: n = !1, needAppearances: g, acroFormRef: o = null, acroForm: c = null, xfaData: C = null, useXrefStream: h = !1 }) {
    await async function updateAcroform({ xref: e1, acroForm: t, acroFormRef: i, hasXfa: a, hasXfaDatasetsEntry: s, xfaDatasetsRef: r, needAppearances: n, changes: g }) {
        !a || s || r || warn("XFA - Cannot save it");
        if (!n && (!a || !r || s)) return;
        const o = t.clone();
        if (a && !s) {
            const e1 = t.get("XFA").slice();
            e1.splice(2, 0, "datasets");
            e1.splice(3, 0, r);
            o.set("XFA", e1);
        }
        n && o.set("NeedAppearances", !0);
        g.put(i, {
            data: o
        });
    }({
        xref: a,
        acroForm: c,
        acroFormRef: o,
        hasXfa: s,
        hasXfaDatasetsEntry: n,
        xfaDatasetsRef: r,
        needAppearances: g,
        changes: i
    });
    s && updateXFA({
        xfaData: C,
        xfaDatasetsRef: r,
        changes: i,
        xref: a
    });
    const l = function getTrailerDict(e1, t, i) {
        const a = new Dict(null);
        a.set("Prev", e1.startXRef);
        const s = e1.newRef;
        if (i) {
            t.put(s, {
                data: ""
            });
            a.set("Size", s.num + 1);
            a.set("Type", Name.get("XRef"));
        } else a.set("Size", s.num);
        null !== e1.rootRef && a.set("Root", e1.rootRef);
        null !== e1.infoRef && a.set("Info", e1.infoRef);
        null !== e1.encryptRef && a.set("Encrypt", e1.encryptRef);
        return a;
    }(t, i, h), Q = [], E = await async function writeChanges(e1, t, i = []) {
        const a = [];
        for (const [s, { data: r }] of e1.items())if (null !== r && "string" != typeof r) {
            await writeObject(s, r, i, t);
            a.push({
                ref: s,
                data: i.join("")
            });
            i.length = 0;
        } else a.push({
            ref: s,
            data: r
        });
        return a.sort((e1, t)=>e1.ref.num - t.ref.num);
    }(i, a, Q);
    let u = e1.length;
    const d = e1.at(-1);
    if (10 !== d && 13 !== d) {
        Q.push("\n");
        u += 1;
    }
    for (const { data: e1 } of E)null !== e1 && Q.push(e1);
    await (h ? async function getXRefStreamTable(e1, t, i, a, s) {
        const r = [];
        let n = 0, g = 0;
        for (const { ref: e1, data: a } of i){
            let i;
            n = Math.max(n, t);
            if (null !== a) {
                i = Math.min(e1.gen, 65535);
                r.push([
                    1,
                    t,
                    i
                ]);
                t += a.length;
            } else {
                i = Math.min(e1.gen + 1, 65535);
                r.push([
                    0,
                    0,
                    i
                ]);
            }
            g = Math.max(g, i);
        }
        a.set("Index", getIndexes(i));
        const o = [
            1,
            getSizeInBytes(n),
            getSizeInBytes(g)
        ];
        a.set("W", o);
        computeIDs(t, e1, a);
        const c = o.reduce((e1, t)=>e1 + t, 0), C = new Uint8Array(c * r.length), h = new Stream(C);
        h.dict = a;
        let l = 0;
        for (const [e1, t, i] of r){
            l = writeInt(e1, o[0], l, C);
            l = writeInt(t, o[1], l, C);
            l = writeInt(i, o[2], l, C);
        }
        await writeObject(e1.newRef, h, s, {});
        s.push("startxref\n", t.toString(), "\n%%EOF\n");
    }(t, u, E, l, Q) : async function getXRefTable(e1, t, i, a, s) {
        s.push("xref\n");
        const r = getIndexes(i);
        let n = 0;
        for (const { ref: e1, data: a } of i){
            if (e1.num === r[n]) {
                s.push(`${r[n]} ${r[n + 1]}\n`);
                n += 2;
            }
            if (null !== a) {
                s.push(`${t.toString().padStart(10, "0")} ${Math.min(e1.gen, 65535).toString().padStart(5, "0")} n\r\n`);
                t += a.length;
            } else s.push(`0000000000 ${Math.min(e1.gen + 1, 65535).toString().padStart(5, "0")} f\r\n`);
        }
        computeIDs(t, e1, a);
        s.push("trailer\n");
        await writeDict(a, s);
        s.push("\nstartxref\n", t.toString(), "\n%%EOF\n");
    }(t, u, E, l, Q));
    const f = Q.reduce((e1, t)=>e1 + t.length, e1.length), p = new Uint8Array(f);
    p.set(e1);
    let m = e1.length;
    for (const e1 of Q){
        writeString(e1, m, p);
        m += e1.length;
    }
    return p;
}
class PDFWorkerStream {
    constructor(e1){
        this._msgHandler = e1;
        this._contentLength = null;
        this._fullRequestReader = null;
        this._rangeRequestReaders = [];
    }
    getFullReader() {
        assert(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
        this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
        return this._fullRequestReader;
    }
    getRangeReader(e1, t) {
        const i = new PDFWorkerStreamRangeReader(e1, t, this._msgHandler);
        this._rangeRequestReaders.push(i);
        return i;
    }
    cancelAllRequests(e1) {
        this._fullRequestReader?.cancel(e1);
        for (const t of this._rangeRequestReaders.slice(0))t.cancel(e1);
    }
}
class PDFWorkerStreamReader {
    constructor(e1){
        this._msgHandler = e1;
        this.onProgress = null;
        this._contentLength = null;
        this._isRangeSupported = !1;
        this._isStreamingSupported = !1;
        const t = this._msgHandler.sendWithStream("GetReader");
        this._reader = t.getReader();
        this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e1)=>{
            this._isStreamingSupported = e1.isStreamingSupported;
            this._isRangeSupported = e1.isRangeSupported;
            this._contentLength = e1.contentLength;
        });
    }
    get headersReady() {
        return this._headersReady;
    }
    get contentLength() {
        return this._contentLength;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    get isRangeSupported() {
        return this._isRangeSupported;
    }
    async read() {
        const { value: e1, done: t } = await this._reader.read();
        return t ? {
            value: void 0,
            done: !0
        } : {
            value: e1.buffer,
            done: !1
        };
    }
    cancel(e1) {
        this._reader.cancel(e1);
    }
}
class PDFWorkerStreamRangeReader {
    constructor(e1, t, i){
        this._msgHandler = i;
        this.onProgress = null;
        const a = this._msgHandler.sendWithStream("GetRangeReader", {
            begin: e1,
            end: t
        });
        this._reader = a.getReader();
    }
    get isStreamingSupported() {
        return !1;
    }
    async read() {
        const { value: e1, done: t } = await this._reader.read();
        return t ? {
            value: void 0,
            done: !0
        } : {
            value: e1.buffer,
            done: !1
        };
    }
    cancel(e1) {
        this._reader.cancel(e1);
    }
}
class WorkerTask {
    constructor(e1){
        this.name = e1;
        this.terminated = !1;
        this._capability = Promise.withResolvers();
    }
    get finished() {
        return this._capability.promise;
    }
    finish() {
        this._capability.resolve();
    }
    terminate() {
        this.terminated = !0;
    }
    ensureNotTerminated() {
        if (this.terminated) throw new Error("Worker task was terminated");
    }
}
class WorkerMessageHandler {
    static{
        "undefined" == typeof window && !t && "undefined" != typeof self && "function" == typeof self.postMessage && "onmessage" in self && this.initializeFromPort(self);
    }
    static setup(e1, t) {
        let i = !1;
        e1.on("test", (t)=>{
            if (!i) {
                i = !0;
                e1.send("test", t instanceof Uint8Array);
            }
        });
        e1.on("configure", (e1)=>{
            !function setVerbosityLevel(e1) {
                Number.isInteger(e1) && (gt = e1);
            }(e1.verbosity);
        });
        e1.on("GetDocRequest", (e1)=>this.createDocumentHandler(e1, t));
    }
    static createDocumentHandler(e1, t) {
        let i, a = !1, s = null;
        const r = new Set, n = getVerbosityLevel(), { docId: g, apiVersion: o } = e1, c = "4.10.38";
        if (o !== c) throw new Error(`The API version "${o}" does not match the Worker version "${c}".`);
        const C = [];
        for(const e1 in [])C.push(e1);
        if (C.length) throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + C.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
        const h = g + "_worker";
        let l = new MessageHandler(h, g, t);
        function ensureNotTerminated() {
            if (a) throw new Error("Worker was terminated");
        }
        function startWorkerTask(e1) {
            r.add(e1);
        }
        function finishWorkerTask(e1) {
            e1.finish();
            r.delete(e1);
        }
        async function loadDocument(e1) {
            await i.ensureDoc("checkHeader");
            await i.ensureDoc("parseStartXRef");
            await i.ensureDoc("parse", [
                e1
            ]);
            await i.ensureDoc("checkFirstPage", [
                e1
            ]);
            await i.ensureDoc("checkLastPage", [
                e1
            ]);
            const t = await i.ensureDoc("isPureXfa");
            if (t) {
                const e1 = new WorkerTask("loadXfaFonts");
                startWorkerTask(e1);
                await Promise.all([
                    i.loadXfaFonts(l, e1).catch((e1)=>{}).then(()=>finishWorkerTask(e1)),
                    i.loadXfaImages()
                ]);
            }
            const [a, s] = await Promise.all([
                i.ensureDoc("numPages"),
                i.ensureDoc("fingerprints")
            ]);
            return {
                numPages: a,
                fingerprints: s,
                htmlForXfa: t ? await i.ensureDoc("htmlForXfa") : null
            };
        }
        function setupDoc(e1) {
            function onSuccess(e1) {
                ensureNotTerminated();
                l.send("GetDoc", {
                    pdfInfo: e1
                });
            }
            function onFailure(e1) {
                ensureNotTerminated();
                if (e1 instanceof PasswordException) {
                    const t = new WorkerTask(`PasswordException: response ${e1.code}`);
                    startWorkerTask(t);
                    l.sendWithPromise("PasswordRequest", e1).then(function({ password: e1 }) {
                        finishWorkerTask(t);
                        i.updatePassword(e1);
                        pdfManagerReady();
                    }).catch(function() {
                        finishWorkerTask(t);
                        l.send("DocException", e1);
                    });
                } else l.send("DocException", wrapReason(e1));
            }
            function pdfManagerReady() {
                ensureNotTerminated();
                loadDocument(!1).then(onSuccess, function(e1) {
                    ensureNotTerminated();
                    e1 instanceof XRefParseException ? i.requestLoadedStream().then(function() {
                        ensureNotTerminated();
                        loadDocument(!0).then(onSuccess, onFailure);
                    }) : onFailure(e1);
                });
            }
            ensureNotTerminated();
            (async function getPdfManager({ data: e1, password: t, disableAutoFetch: i, rangeChunkSize: a, length: r, docBaseUrl: n, enableXfa: o, evaluatorOptions: c }) {
                const C = {
                    source: null,
                    disableAutoFetch: i,
                    docBaseUrl: n,
                    docId: g,
                    enableXfa: o,
                    evaluatorOptions: c,
                    handler: l,
                    length: r,
                    password: t,
                    rangeChunkSize: a
                };
                if (e1) {
                    C.source = e1;
                    return new LocalPdfManager(C);
                }
                const h = new PDFWorkerStream(l), Q = h.getFullReader(), E = Promise.withResolvers();
                let u, d = [], f = 0;
                Q.headersReady.then(function() {
                    if (Q.isRangeSupported) {
                        C.source = h;
                        C.length = Q.contentLength;
                        C.disableAutoFetch ||= Q.isStreamingSupported;
                        u = new NetworkPdfManager(C);
                        for (const e1 of d)u.sendProgressiveData(e1);
                        d = [];
                        E.resolve(u);
                        s = null;
                    }
                }).catch(function(e1) {
                    E.reject(e1);
                    s = null;
                });
                new Promise(function(e1, t) {
                    const readChunk = function({ value: e1, done: i }) {
                        try {
                            ensureNotTerminated();
                            if (i) {
                                if (!u) {
                                    const e1 = arrayBuffersToBytes(d);
                                    d = [];
                                    r && e1.length !== r && warn("reported HTTP length is different from actual");
                                    C.source = e1;
                                    u = new LocalPdfManager(C);
                                    E.resolve(u);
                                }
                                s = null;
                                return;
                            }
                            f += e1.byteLength;
                            Q.isStreamingSupported || l.send("DocProgress", {
                                loaded: f,
                                total: Math.max(f, Q.contentLength || 0)
                            });
                            u ? u.sendProgressiveData(e1) : d.push(e1);
                            Q.read().then(readChunk, t);
                        } catch (e1) {
                            t(e1);
                        }
                    };
                    Q.read().then(readChunk, t);
                }).catch(function(e1) {
                    E.reject(e1);
                    s = null;
                });
                s = (e1)=>{
                    h.cancelAllRequests(e1);
                };
                return E.promise;
            })(e1).then(function(e1) {
                if (a) {
                    e1.terminate(new AbortException("Worker was terminated."));
                    throw new Error("Worker was terminated");
                }
                i = e1;
                i.requestLoadedStream(!0).then((e1)=>{
                    l.send("DataLoaded", {
                        length: e1.bytes.byteLength
                    });
                });
            }).then(pdfManagerReady, onFailure);
        }
        l.on("GetPage", function(e1) {
            return i.getPage(e1.pageIndex).then(function(e1) {
                return Promise.all([
                    i.ensure(e1, "rotate"),
                    i.ensure(e1, "ref"),
                    i.ensure(e1, "userUnit"),
                    i.ensure(e1, "view")
                ]).then(function([e1, t, i, a]) {
                    return {
                        rotate: e1,
                        ref: t,
                        refStr: t?.toString() ?? null,
                        userUnit: i,
                        view: a
                    };
                });
            });
        });
        l.on("GetPageIndex", function(e1) {
            const t = Ref.get(e1.num, e1.gen);
            return i.ensureCatalog("getPageIndex", [
                t
            ]);
        });
        l.on("GetDestinations", function(e1) {
            return i.ensureCatalog("destinations");
        });
        l.on("GetDestination", function(e1) {
            return i.ensureCatalog("getDestination", [
                e1.id
            ]);
        });
        l.on("GetPageLabels", function(e1) {
            return i.ensureCatalog("pageLabels");
        });
        l.on("GetPageLayout", function(e1) {
            return i.ensureCatalog("pageLayout");
        });
        l.on("GetPageMode", function(e1) {
            return i.ensureCatalog("pageMode");
        });
        l.on("GetViewerPreferences", function(e1) {
            return i.ensureCatalog("viewerPreferences");
        });
        l.on("GetOpenAction", function(e1) {
            return i.ensureCatalog("openAction");
        });
        l.on("GetAttachments", function(e1) {
            return i.ensureCatalog("attachments");
        });
        l.on("GetDocJSActions", function(e1) {
            return i.ensureCatalog("jsActions");
        });
        l.on("GetPageJSActions", function({ pageIndex: e1 }) {
            return i.getPage(e1).then(function(e1) {
                return i.ensure(e1, "jsActions");
            });
        });
        l.on("GetOutline", function(e1) {
            return i.ensureCatalog("documentOutline");
        });
        l.on("GetOptionalContentConfig", function(e1) {
            return i.ensureCatalog("optionalContentConfig");
        });
        l.on("GetPermissions", function(e1) {
            return i.ensureCatalog("permissions");
        });
        l.on("GetMetadata", function(e1) {
            return Promise.all([
                i.ensureDoc("documentInfo"),
                i.ensureCatalog("metadata")
            ]);
        });
        l.on("GetMarkInfo", function(e1) {
            return i.ensureCatalog("markInfo");
        });
        l.on("GetData", function(e1) {
            return i.requestLoadedStream().then(function(e1) {
                return e1.bytes;
            });
        });
        l.on("GetAnnotations", function({ pageIndex: e1, intent: t }) {
            return i.getPage(e1).then(function(i) {
                const a = new WorkerTask(`GetAnnotations: page ${e1}`);
                startWorkerTask(a);
                return i.getAnnotationsData(l, a, t).then((e1)=>{
                    finishWorkerTask(a);
                    return e1;
                }, (e1)=>{
                    finishWorkerTask(a);
                    throw e1;
                });
            });
        });
        l.on("GetFieldObjects", function(e1) {
            return i.ensureDoc("fieldObjects").then((e1)=>e1?.allFields || null);
        });
        l.on("HasJSActions", function(e1) {
            return i.ensureDoc("hasJSActions");
        });
        l.on("GetCalculationOrderIds", function(e1) {
            return i.ensureDoc("calculationOrderIds");
        });
        l.on("SaveDocument", async function({ isPureXfa: e1, numPages: t, annotationStorage: a, filename: s }) {
            const r = [
                i.requestLoadedStream(),
                i.ensureCatalog("acroForm"),
                i.ensureCatalog("acroFormRef"),
                i.ensureDoc("startXRef"),
                i.ensureDoc("xref"),
                i.ensureDoc("linearization"),
                i.ensureCatalog("structTreeRoot")
            ], n = new RefSetCache, g = [], o = e1 ? null : getNewAnnotationsMap(a), [c, C, h, Q, E, u, d] = await Promise.all(r), f = E.trailer.getRaw("Root") || null;
            let p;
            if (o) {
                d ? await d.canUpdateStructTree({
                    pdfManager: i,
                    xref: E,
                    newAnnotationsByPage: o
                }) && (p = d) : await StructTreeRoot.canCreateStructureTree({
                    catalogRef: f,
                    pdfManager: i,
                    newAnnotationsByPage: o
                }) && (p = null);
                const e1 = AnnotationFactory.generateImages(a.values(), E, i.evaluatorOptions.isOffscreenCanvasSupported), t = void 0 === p ? g : [];
                for (const [a, s] of o)t.push(i.getPage(a).then((t)=>{
                    const i = new WorkerTask(`Save (editor): page ${a}`);
                    startWorkerTask(i);
                    return t.saveNewAnnotations(l, i, s, e1, n).finally(function() {
                        finishWorkerTask(i);
                    });
                }));
                null === p ? g.push(Promise.all(t).then(async ()=>{
                    await StructTreeRoot.createStructureTree({
                        newAnnotationsByPage: o,
                        xref: E,
                        catalogRef: f,
                        pdfManager: i,
                        changes: n
                    });
                })) : p && g.push(Promise.all(t).then(async ()=>{
                    await p.updateStructureTree({
                        newAnnotationsByPage: o,
                        pdfManager: i,
                        changes: n
                    });
                }));
            }
            if (e1) g.push(i.serializeXfaData(a));
            else for(let e1 = 0; e1 < t; e1++)g.push(i.getPage(e1).then(function(t) {
                const i = new WorkerTask(`Save: page ${e1}`);
                startWorkerTask(i);
                return t.save(l, i, a, n).finally(function() {
                    finishWorkerTask(i);
                });
            }));
            const m = await Promise.all(g);
            let y = null;
            if (e1) {
                y = m[0];
                if (!y) return c.bytes;
            } else if (0 === n.size) return c.bytes;
            const w = h && C instanceof Dict && n.values().some((e1)=>e1.needAppearances), D = C instanceof Dict && C.get("XFA") || null;
            let b = null, F = !1;
            if (Array.isArray(D)) {
                for(let e1 = 0, t = D.length; e1 < t; e1 += 2)if ("datasets" === D[e1]) {
                    b = D[e1 + 1];
                    F = !0;
                }
                null === b && (b = E.getNewTemporaryRef());
            } else D && warn("Unsupported XFA type.");
            let S = Object.create(null);
            if (E.trailer) {
                const e1 = Object.create(null), t = E.trailer.get("Info") || null;
                if (t instanceof Dict) for (const [i, a] of t)"string" == typeof a && (e1[i] = stringToPDFString(a));
                S = {
                    rootRef: f,
                    encryptRef: E.trailer.getRaw("Encrypt") || null,
                    newRef: E.getNewTemporaryRef(),
                    infoRef: E.trailer.getRaw("Info") || null,
                    info: e1,
                    fileIds: E.trailer.get("ID") || null,
                    startXRef: u ? Q : E.lastXRefStreamPos ?? Q,
                    filename: s
                };
            }
            return incrementalUpdate({
                originalData: c.bytes,
                xrefInfo: S,
                changes: n,
                xref: E,
                hasXfa: !!D,
                xfaDatasetsRef: b,
                hasXfaDatasetsEntry: F,
                needAppearances: w,
                acroFormRef: h,
                acroForm: C,
                xfaData: y,
                useXrefStream: isDict(E.topDict, "XRef")
            }).finally(()=>{
                E.resetNewTemporaryRef();
            });
        });
        l.on("GetOperatorList", function(e1, t) {
            const a = e1.pageIndex;
            i.getPage(a).then(function(i) {
                const s = new WorkerTask(`GetOperatorList: page ${a}`);
                startWorkerTask(s);
                const r = n >= yA ? Date.now() : 0;
                i.getOperatorList({
                    handler: l,
                    sink: t,
                    task: s,
                    intent: e1.intent,
                    cacheKey: e1.cacheKey,
                    annotationStorage: e1.annotationStorage,
                    modifiedIds: e1.modifiedIds
                }).then(function(e1) {
                    finishWorkerTask(s);
                    r && info(`page=${a + 1} - getOperatorList: time=${Date.now() - r}ms, len=${e1.length}`);
                    t.close();
                }, function(e1) {
                    finishWorkerTask(s);
                    s.terminated || t.error(e1);
                });
            });
        });
        l.on("GetTextContent", function(e1, t) {
            const { pageIndex: a, includeMarkedContent: s, disableNormalization: r } = e1;
            i.getPage(a).then(function(e1) {
                const i = new WorkerTask("GetTextContent: page " + a);
                startWorkerTask(i);
                const g = n >= yA ? Date.now() : 0;
                e1.extractTextContent({
                    handler: l,
                    task: i,
                    sink: t,
                    includeMarkedContent: s,
                    disableNormalization: r
                }).then(function() {
                    finishWorkerTask(i);
                    g && info(`page=${a + 1} - getTextContent: time=` + (Date.now() - g) + "ms");
                    t.close();
                }, function(e1) {
                    finishWorkerTask(i);
                    i.terminated || t.error(e1);
                });
            });
        });
        l.on("GetStructTree", function(e1) {
            return i.getPage(e1.pageIndex).then(function(e1) {
                return i.ensure(e1, "getStructTree");
            });
        });
        l.on("FontFallback", function(e1) {
            return i.fontFallback(e1.id, l);
        });
        l.on("Cleanup", function(e1) {
            return i.cleanup(!0);
        });
        l.on("Terminate", function(e1) {
            a = !0;
            const t = [];
            if (i) {
                i.terminate(new AbortException("Worker was terminated."));
                const e1 = i.cleanup();
                t.push(e1);
                i = null;
            } else clearGlobalCaches();
            s?.(new AbortException("Worker was terminated."));
            for (const e1 of r){
                t.push(e1.finished);
                e1.terminate();
            }
            return Promise.all(t).then(function() {
                l.destroy();
                l = null;
            });
        });
        l.on("Ready", function(t) {
            setupDoc(e1);
            e1 = null;
        });
        return h;
    }
    static initializeFromPort(e1) {
        const t = new MessageHandler("worker", "main", e1);
        this.setup(t, e1);
        t.send("ready", null);
    }
}
var Qg = __webpack_exports__.WorkerMessageHandler;
;
}}),

};

//# sourceMappingURL=node_modules_pdfjs-dist_build_pdf_worker_min_mjs_344e14b9._.js.map